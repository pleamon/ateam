
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model AgentTask
 * 
 */
export type AgentTask = $Result.DefaultSelection<Prisma.$AgentTaskPayload>
/**
 * Model AgentActivity
 * 
 */
export type AgentActivity = $Result.DefaultSelection<Prisma.$AgentActivityPayload>
/**
 * Model AgentWorklog
 * 
 */
export type AgentWorklog = $Result.DefaultSelection<Prisma.$AgentWorklogPayload>
/**
 * Model AgentPromptTemplate
 * 
 */
export type AgentPromptTemplate = $Result.DefaultSelection<Prisma.$AgentPromptTemplatePayload>
/**
 * Model ApiDesign
 * 
 */
export type ApiDesign = $Result.DefaultSelection<Prisma.$ApiDesignPayload>
/**
 * Model ApiExample
 * 
 */
export type ApiExample = $Result.DefaultSelection<Prisma.$ApiExamplePayload>
/**
 * Model ApiErrorCode
 * 
 */
export type ApiErrorCode = $Result.DefaultSelection<Prisma.$ApiErrorCodePayload>
/**
 * Model SystemArchitecture
 * 
 */
export type SystemArchitecture = $Result.DefaultSelection<Prisma.$SystemArchitecturePayload>
/**
 * Model PlatformArchitecture
 * 
 */
export type PlatformArchitecture = $Result.DefaultSelection<Prisma.$PlatformArchitecturePayload>
/**
 * Model ArchitectureChangeHistory
 * 
 */
export type ArchitectureChangeHistory = $Result.DefaultSelection<Prisma.$ArchitectureChangeHistoryPayload>
/**
 * Model DatabaseSchema
 * 
 */
export type DatabaseSchema = $Result.DefaultSelection<Prisma.$DatabaseSchemaPayload>
/**
 * Model DatabaseTable
 * 
 */
export type DatabaseTable = $Result.DefaultSelection<Prisma.$DatabaseTablePayload>
/**
 * Model TableColumn
 * 
 */
export type TableColumn = $Result.DefaultSelection<Prisma.$TableColumnPayload>
/**
 * Model DatabaseIndex
 * 
 */
export type DatabaseIndex = $Result.DefaultSelection<Prisma.$DatabaseIndexPayload>
/**
 * Model DatabaseRelation
 * 
 */
export type DatabaseRelation = $Result.DefaultSelection<Prisma.$DatabaseRelationPayload>
/**
 * Model Documentation
 * 
 */
export type Documentation = $Result.DefaultSelection<Prisma.$DocumentationPayload>
/**
 * Model DocumentVersion
 * 
 */
export type DocumentVersion = $Result.DefaultSelection<Prisma.$DocumentVersionPayload>
/**
 * Model DocumentTag
 * 
 */
export type DocumentTag = $Result.DefaultSelection<Prisma.$DocumentTagPayload>
/**
 * Model DocumentComment
 * 
 */
export type DocumentComment = $Result.DefaultSelection<Prisma.$DocumentCommentPayload>
/**
 * Model DocumentAttachment
 * 
 */
export type DocumentAttachment = $Result.DefaultSelection<Prisma.$DocumentAttachmentPayload>
/**
 * Model MindMap
 * 
 */
export type MindMap = $Result.DefaultSelection<Prisma.$MindMapPayload>
/**
 * Model MindMapNode
 * 
 */
export type MindMapNode = $Result.DefaultSelection<Prisma.$MindMapNodePayload>
/**
 * Model DomainKnowledge
 * 
 */
export type DomainKnowledge = $Result.DefaultSelection<Prisma.$DomainKnowledgePayload>
/**
 * Model DomainConcept
 * 
 */
export type DomainConcept = $Result.DefaultSelection<Prisma.$DomainConceptPayload>
/**
 * Model DomainPattern
 * 
 */
export type DomainPattern = $Result.DefaultSelection<Prisma.$DomainPatternPayload>
/**
 * Model DomainBestPractice
 * 
 */
export type DomainBestPractice = $Result.DefaultSelection<Prisma.$DomainBestPracticePayload>
/**
 * Model DomainAntiPattern
 * 
 */
export type DomainAntiPattern = $Result.DefaultSelection<Prisma.$DomainAntiPatternPayload>
/**
 * Model DomainReference
 * 
 */
export type DomainReference = $Result.DefaultSelection<Prisma.$DomainReferencePayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Requirement
 * 
 */
export type Requirement = $Result.DefaultSelection<Prisma.$RequirementPayload>
/**
 * Model RequirementQuestion
 * 
 */
export type RequirementQuestion = $Result.DefaultSelection<Prisma.$RequirementQuestionPayload>
/**
 * Model RequirementAttachment
 * 
 */
export type RequirementAttachment = $Result.DefaultSelection<Prisma.$RequirementAttachmentPayload>
/**
 * Model Roadmap
 * 
 */
export type Roadmap = $Result.DefaultSelection<Prisma.$RoadmapPayload>
/**
 * Model Milestone
 * 
 */
export type Milestone = $Result.DefaultSelection<Prisma.$MilestonePayload>
/**
 * Model Version
 * 
 */
export type Version = $Result.DefaultSelection<Prisma.$VersionPayload>
/**
 * Model Feature
 * 
 */
export type Feature = $Result.DefaultSelection<Prisma.$FeaturePayload>
/**
 * Model Sprint
 * 
 */
export type Sprint = $Result.DefaultSelection<Prisma.$SprintPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ApiMethod: {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE',
  PATCH: 'PATCH',
  OPTIONS: 'OPTIONS',
  HEAD: 'HEAD'
};

export type ApiMethod = (typeof ApiMethod)[keyof typeof ApiMethod]


export const ApiContentType: {
  APPLICATION_JSON: 'APPLICATION_JSON',
  APPLICATION_XML: 'APPLICATION_XML',
  APPLICATION_FORM_URLENCODED: 'APPLICATION_FORM_URLENCODED',
  MULTIPART_FORM_DATA: 'MULTIPART_FORM_DATA',
  TEXT_PLAIN: 'TEXT_PLAIN'
};

export type ApiContentType = (typeof ApiContentType)[keyof typeof ApiContentType]


export const ApiAuthType: {
  NONE: 'NONE',
  BASIC: 'BASIC',
  BEARER: 'BEARER',
  API_KEY: 'API_KEY',
  OAUTH2: 'OAUTH2',
  CUSTOM: 'CUSTOM'
};

export type ApiAuthType = (typeof ApiAuthType)[keyof typeof ApiAuthType]


export const ApiStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  DEPRECATED: 'DEPRECATED',
  RETIRED: 'RETIRED'
};

export type ApiStatus = (typeof ApiStatus)[keyof typeof ApiStatus]


export const ArchitectureStatus: {
  DRAFT: 'DRAFT',
  REVIEWING: 'REVIEWING',
  APPROVED: 'APPROVED',
  DEPRECATED: 'DEPRECATED'
};

export type ArchitectureStatus = (typeof ArchitectureStatus)[keyof typeof ArchitectureStatus]


export const DatabaseEngine: {
  MYSQL: 'MYSQL',
  POSTGRESQL: 'POSTGRESQL',
  SQLITE: 'SQLITE',
  MONGODB: 'MONGODB',
  REDIS: 'REDIS',
  ELASTICSEARCH: 'ELASTICSEARCH'
};

export type DatabaseEngine = (typeof DatabaseEngine)[keyof typeof DatabaseEngine]


export const ColumnType: {
  INT: 'INT',
  BIGINT: 'BIGINT',
  DECIMAL: 'DECIMAL',
  FLOAT: 'FLOAT',
  DOUBLE: 'DOUBLE',
  VARCHAR: 'VARCHAR',
  CHAR: 'CHAR',
  TEXT: 'TEXT',
  LONGTEXT: 'LONGTEXT',
  DATE: 'DATE',
  TIME: 'TIME',
  DATETIME: 'DATETIME',
  TIMESTAMP: 'TIMESTAMP',
  BINARY: 'BINARY',
  VARBINARY: 'VARBINARY',
  BLOB: 'BLOB',
  BOOLEAN: 'BOOLEAN',
  JSON: 'JSON',
  UUID: 'UUID',
  ENUM: 'ENUM'
};

export type ColumnType = (typeof ColumnType)[keyof typeof ColumnType]


export const IndexType: {
  PRIMARY: 'PRIMARY',
  UNIQUE: 'UNIQUE',
  INDEX: 'INDEX',
  FULLTEXT: 'FULLTEXT',
  SPATIAL: 'SPATIAL'
};

export type IndexType = (typeof IndexType)[keyof typeof IndexType]


export const RelationType: {
  ONE_TO_ONE: 'ONE_TO_ONE',
  ONE_TO_MANY: 'ONE_TO_MANY',
  MANY_TO_ONE: 'MANY_TO_ONE',
  MANY_TO_MANY: 'MANY_TO_MANY'
};

export type RelationType = (typeof RelationType)[keyof typeof RelationType]


export const DocumentType: {
  OVERVIEW: 'OVERVIEW',
  TECHNICAL: 'TECHNICAL',
  DESIGN: 'DESIGN',
  RESEARCH: 'RESEARCH',
  USER_GUIDE: 'USER_GUIDE',
  API_DOC: 'API_DOC',
  OTHER: 'OTHER'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const DocumentStatus: {
  DRAFT: 'DRAFT',
  REVIEWING: 'REVIEWING',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]


export const DocumentVisibility: {
  PUBLIC: 'PUBLIC',
  INTERNAL: 'INTERNAL',
  PRIVATE: 'PRIVATE'
};

export type DocumentVisibility = (typeof DocumentVisibility)[keyof typeof DocumentVisibility]


export const NodeType: {
  ROOT: 'ROOT',
  TOPIC: 'TOPIC',
  SUBTOPIC: 'SUBTOPIC',
  DETAIL: 'DETAIL',
  REFERENCE: 'REFERENCE'
};

export type NodeType = (typeof NodeType)[keyof typeof NodeType]


export const KnowledgeCategory: {
  BUSINESS: 'BUSINESS',
  TECHNICAL: 'TECHNICAL',
  DOMAIN_SPECIFIC: 'DOMAIN_SPECIFIC',
  GENERAL: 'GENERAL'
};

export type KnowledgeCategory = (typeof KnowledgeCategory)[keyof typeof KnowledgeCategory]


export const RequirementType: {
  FUNCTIONAL: 'FUNCTIONAL',
  NON_FUNCTIONAL: 'NON_FUNCTIONAL',
  BUSINESS: 'BUSINESS',
  TECHNICAL: 'TECHNICAL'
};

export type RequirementType = (typeof RequirementType)[keyof typeof RequirementType]


export const RequirementPriority: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type RequirementPriority = (typeof RequirementPriority)[keyof typeof RequirementPriority]


export const RequirementStatus: {
  DRAFT: 'DRAFT',
  REVIEWING: 'REVIEWING',
  CONFIRMED: 'CONFIRMED',
  IMPLEMENTED: 'IMPLEMENTED',
  DEPRECATED: 'DEPRECATED'
};

export type RequirementStatus = (typeof RequirementStatus)[keyof typeof RequirementStatus]


export const RequirementSource: {
  CUSTOMER: 'CUSTOMER',
  PRODUCT: 'PRODUCT',
  TECHNICAL: 'TECHNICAL',
  INTERNAL: 'INTERNAL'
};

export type RequirementSource = (typeof RequirementSource)[keyof typeof RequirementSource]


export const QuestionStatus: {
  TODO: 'TODO',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE'
};

export type QuestionStatus = (typeof QuestionStatus)[keyof typeof QuestionStatus]


export const QuestionPriority: {
  URGENT: 'URGENT',
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type QuestionPriority = (typeof QuestionPriority)[keyof typeof QuestionPriority]


export const UserRole: {
  ADMIN: 'ADMIN',
  USER: 'USER',
  GUEST: 'GUEST'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ProjectRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER',
  VIEWER: 'VIEWER'
};

export type ProjectRole = (typeof ProjectRole)[keyof typeof ProjectRole]

}

export type ApiMethod = $Enums.ApiMethod

export const ApiMethod: typeof $Enums.ApiMethod

export type ApiContentType = $Enums.ApiContentType

export const ApiContentType: typeof $Enums.ApiContentType

export type ApiAuthType = $Enums.ApiAuthType

export const ApiAuthType: typeof $Enums.ApiAuthType

export type ApiStatus = $Enums.ApiStatus

export const ApiStatus: typeof $Enums.ApiStatus

export type ArchitectureStatus = $Enums.ArchitectureStatus

export const ArchitectureStatus: typeof $Enums.ArchitectureStatus

export type DatabaseEngine = $Enums.DatabaseEngine

export const DatabaseEngine: typeof $Enums.DatabaseEngine

export type ColumnType = $Enums.ColumnType

export const ColumnType: typeof $Enums.ColumnType

export type IndexType = $Enums.IndexType

export const IndexType: typeof $Enums.IndexType

export type RelationType = $Enums.RelationType

export const RelationType: typeof $Enums.RelationType

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

export type DocumentVisibility = $Enums.DocumentVisibility

export const DocumentVisibility: typeof $Enums.DocumentVisibility

export type NodeType = $Enums.NodeType

export const NodeType: typeof $Enums.NodeType

export type KnowledgeCategory = $Enums.KnowledgeCategory

export const KnowledgeCategory: typeof $Enums.KnowledgeCategory

export type RequirementType = $Enums.RequirementType

export const RequirementType: typeof $Enums.RequirementType

export type RequirementPriority = $Enums.RequirementPriority

export const RequirementPriority: typeof $Enums.RequirementPriority

export type RequirementStatus = $Enums.RequirementStatus

export const RequirementStatus: typeof $Enums.RequirementStatus

export type RequirementSource = $Enums.RequirementSource

export const RequirementSource: typeof $Enums.RequirementSource

export type QuestionStatus = $Enums.QuestionStatus

export const QuestionStatus: typeof $Enums.QuestionStatus

export type QuestionPriority = $Enums.QuestionPriority

export const QuestionPriority: typeof $Enums.QuestionPriority

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ProjectRole = $Enums.ProjectRole

export const ProjectRole: typeof $Enums.ProjectRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Agents
 * const agents = await prisma.agent.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Agents
   * const agents = await prisma.agent.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentTask`: Exposes CRUD operations for the **AgentTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentTasks
    * const agentTasks = await prisma.agentTask.findMany()
    * ```
    */
  get agentTask(): Prisma.AgentTaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentActivity`: Exposes CRUD operations for the **AgentActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentActivities
    * const agentActivities = await prisma.agentActivity.findMany()
    * ```
    */
  get agentActivity(): Prisma.AgentActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentWorklog`: Exposes CRUD operations for the **AgentWorklog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentWorklogs
    * const agentWorklogs = await prisma.agentWorklog.findMany()
    * ```
    */
  get agentWorklog(): Prisma.AgentWorklogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agentPromptTemplate`: Exposes CRUD operations for the **AgentPromptTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AgentPromptTemplates
    * const agentPromptTemplates = await prisma.agentPromptTemplate.findMany()
    * ```
    */
  get agentPromptTemplate(): Prisma.AgentPromptTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiDesign`: Exposes CRUD operations for the **ApiDesign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiDesigns
    * const apiDesigns = await prisma.apiDesign.findMany()
    * ```
    */
  get apiDesign(): Prisma.ApiDesignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiExample`: Exposes CRUD operations for the **ApiExample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiExamples
    * const apiExamples = await prisma.apiExample.findMany()
    * ```
    */
  get apiExample(): Prisma.ApiExampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiErrorCode`: Exposes CRUD operations for the **ApiErrorCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiErrorCodes
    * const apiErrorCodes = await prisma.apiErrorCode.findMany()
    * ```
    */
  get apiErrorCode(): Prisma.ApiErrorCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemArchitecture`: Exposes CRUD operations for the **SystemArchitecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemArchitectures
    * const systemArchitectures = await prisma.systemArchitecture.findMany()
    * ```
    */
  get systemArchitecture(): Prisma.SystemArchitectureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformArchitecture`: Exposes CRUD operations for the **PlatformArchitecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformArchitectures
    * const platformArchitectures = await prisma.platformArchitecture.findMany()
    * ```
    */
  get platformArchitecture(): Prisma.PlatformArchitectureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.architectureChangeHistory`: Exposes CRUD operations for the **ArchitectureChangeHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArchitectureChangeHistories
    * const architectureChangeHistories = await prisma.architectureChangeHistory.findMany()
    * ```
    */
  get architectureChangeHistory(): Prisma.ArchitectureChangeHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.databaseSchema`: Exposes CRUD operations for the **DatabaseSchema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatabaseSchemas
    * const databaseSchemas = await prisma.databaseSchema.findMany()
    * ```
    */
  get databaseSchema(): Prisma.DatabaseSchemaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.databaseTable`: Exposes CRUD operations for the **DatabaseTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatabaseTables
    * const databaseTables = await prisma.databaseTable.findMany()
    * ```
    */
  get databaseTable(): Prisma.DatabaseTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tableColumn`: Exposes CRUD operations for the **TableColumn** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TableColumns
    * const tableColumns = await prisma.tableColumn.findMany()
    * ```
    */
  get tableColumn(): Prisma.TableColumnDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.databaseIndex`: Exposes CRUD operations for the **DatabaseIndex** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatabaseIndices
    * const databaseIndices = await prisma.databaseIndex.findMany()
    * ```
    */
  get databaseIndex(): Prisma.DatabaseIndexDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.databaseRelation`: Exposes CRUD operations for the **DatabaseRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DatabaseRelations
    * const databaseRelations = await prisma.databaseRelation.findMany()
    * ```
    */
  get databaseRelation(): Prisma.DatabaseRelationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentation`: Exposes CRUD operations for the **Documentation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documentations
    * const documentations = await prisma.documentation.findMany()
    * ```
    */
  get documentation(): Prisma.DocumentationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentVersion`: Exposes CRUD operations for the **DocumentVersion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentVersions
    * const documentVersions = await prisma.documentVersion.findMany()
    * ```
    */
  get documentVersion(): Prisma.DocumentVersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentTag`: Exposes CRUD operations for the **DocumentTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentTags
    * const documentTags = await prisma.documentTag.findMany()
    * ```
    */
  get documentTag(): Prisma.DocumentTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentComment`: Exposes CRUD operations for the **DocumentComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentComments
    * const documentComments = await prisma.documentComment.findMany()
    * ```
    */
  get documentComment(): Prisma.DocumentCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentAttachment`: Exposes CRUD operations for the **DocumentAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentAttachments
    * const documentAttachments = await prisma.documentAttachment.findMany()
    * ```
    */
  get documentAttachment(): Prisma.DocumentAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mindMap`: Exposes CRUD operations for the **MindMap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MindMaps
    * const mindMaps = await prisma.mindMap.findMany()
    * ```
    */
  get mindMap(): Prisma.MindMapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mindMapNode`: Exposes CRUD operations for the **MindMapNode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MindMapNodes
    * const mindMapNodes = await prisma.mindMapNode.findMany()
    * ```
    */
  get mindMapNode(): Prisma.MindMapNodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainKnowledge`: Exposes CRUD operations for the **DomainKnowledge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainKnowledges
    * const domainKnowledges = await prisma.domainKnowledge.findMany()
    * ```
    */
  get domainKnowledge(): Prisma.DomainKnowledgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainConcept`: Exposes CRUD operations for the **DomainConcept** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainConcepts
    * const domainConcepts = await prisma.domainConcept.findMany()
    * ```
    */
  get domainConcept(): Prisma.DomainConceptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainPattern`: Exposes CRUD operations for the **DomainPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainPatterns
    * const domainPatterns = await prisma.domainPattern.findMany()
    * ```
    */
  get domainPattern(): Prisma.DomainPatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainBestPractice`: Exposes CRUD operations for the **DomainBestPractice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainBestPractices
    * const domainBestPractices = await prisma.domainBestPractice.findMany()
    * ```
    */
  get domainBestPractice(): Prisma.DomainBestPracticeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainAntiPattern`: Exposes CRUD operations for the **DomainAntiPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainAntiPatterns
    * const domainAntiPatterns = await prisma.domainAntiPattern.findMany()
    * ```
    */
  get domainAntiPattern(): Prisma.DomainAntiPatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.domainReference`: Exposes CRUD operations for the **DomainReference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DomainReferences
    * const domainReferences = await prisma.domainReference.findMany()
    * ```
    */
  get domainReference(): Prisma.DomainReferenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirement`: Exposes CRUD operations for the **Requirement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requirements
    * const requirements = await prisma.requirement.findMany()
    * ```
    */
  get requirement(): Prisma.RequirementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirementQuestion`: Exposes CRUD operations for the **RequirementQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequirementQuestions
    * const requirementQuestions = await prisma.requirementQuestion.findMany()
    * ```
    */
  get requirementQuestion(): Prisma.RequirementQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requirementAttachment`: Exposes CRUD operations for the **RequirementAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RequirementAttachments
    * const requirementAttachments = await prisma.requirementAttachment.findMany()
    * ```
    */
  get requirementAttachment(): Prisma.RequirementAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmap`: Exposes CRUD operations for the **Roadmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roadmaps
    * const roadmaps = await prisma.roadmap.findMany()
    * ```
    */
  get roadmap(): Prisma.RoadmapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.milestone`: Exposes CRUD operations for the **Milestone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Milestones
    * const milestones = await prisma.milestone.findMany()
    * ```
    */
  get milestone(): Prisma.MilestoneDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.version`: Exposes CRUD operations for the **Version** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Versions
    * const versions = await prisma.version.findMany()
    * ```
    */
  get version(): Prisma.VersionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feature`: Exposes CRUD operations for the **Feature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.feature.findMany()
    * ```
    */
  get feature(): Prisma.FeatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sprint`: Exposes CRUD operations for the **Sprint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sprints
    * const sprints = await prisma.sprint.findMany()
    * ```
    */
  get sprint(): Prisma.SprintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Agent: 'Agent',
    AgentTask: 'AgentTask',
    AgentActivity: 'AgentActivity',
    AgentWorklog: 'AgentWorklog',
    AgentPromptTemplate: 'AgentPromptTemplate',
    ApiDesign: 'ApiDesign',
    ApiExample: 'ApiExample',
    ApiErrorCode: 'ApiErrorCode',
    SystemArchitecture: 'SystemArchitecture',
    PlatformArchitecture: 'PlatformArchitecture',
    ArchitectureChangeHistory: 'ArchitectureChangeHistory',
    DatabaseSchema: 'DatabaseSchema',
    DatabaseTable: 'DatabaseTable',
    TableColumn: 'TableColumn',
    DatabaseIndex: 'DatabaseIndex',
    DatabaseRelation: 'DatabaseRelation',
    Documentation: 'Documentation',
    DocumentVersion: 'DocumentVersion',
    DocumentTag: 'DocumentTag',
    DocumentComment: 'DocumentComment',
    DocumentAttachment: 'DocumentAttachment',
    MindMap: 'MindMap',
    MindMapNode: 'MindMapNode',
    DomainKnowledge: 'DomainKnowledge',
    DomainConcept: 'DomainConcept',
    DomainPattern: 'DomainPattern',
    DomainBestPractice: 'DomainBestPractice',
    DomainAntiPattern: 'DomainAntiPattern',
    DomainReference: 'DomainReference',
    Project: 'Project',
    Requirement: 'Requirement',
    RequirementQuestion: 'RequirementQuestion',
    RequirementAttachment: 'RequirementAttachment',
    Roadmap: 'Roadmap',
    Milestone: 'Milestone',
    Version: 'Version',
    Feature: 'Feature',
    Sprint: 'Sprint',
    Task: 'Task',
    Team: 'Team',
    User: 'User',
    Session: 'Session',
    ProjectMember: 'ProjectMember',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "agent" | "agentTask" | "agentActivity" | "agentWorklog" | "agentPromptTemplate" | "apiDesign" | "apiExample" | "apiErrorCode" | "systemArchitecture" | "platformArchitecture" | "architectureChangeHistory" | "databaseSchema" | "databaseTable" | "tableColumn" | "databaseIndex" | "databaseRelation" | "documentation" | "documentVersion" | "documentTag" | "documentComment" | "documentAttachment" | "mindMap" | "mindMapNode" | "domainKnowledge" | "domainConcept" | "domainPattern" | "domainBestPractice" | "domainAntiPattern" | "domainReference" | "project" | "requirement" | "requirementQuestion" | "requirementAttachment" | "roadmap" | "milestone" | "version" | "feature" | "sprint" | "task" | "team" | "user" | "session" | "projectMember" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      AgentTask: {
        payload: Prisma.$AgentTaskPayload<ExtArgs>
        fields: Prisma.AgentTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          findFirst: {
            args: Prisma.AgentTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          findMany: {
            args: Prisma.AgentTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>[]
          }
          create: {
            args: Prisma.AgentTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          createMany: {
            args: Prisma.AgentTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentTaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>[]
          }
          delete: {
            args: Prisma.AgentTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          update: {
            args: Prisma.AgentTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          deleteMany: {
            args: Prisma.AgentTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentTaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>[]
          }
          upsert: {
            args: Prisma.AgentTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentTaskPayload>
          }
          aggregate: {
            args: Prisma.AgentTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentTask>
          }
          groupBy: {
            args: Prisma.AgentTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentTaskCountArgs<ExtArgs>
            result: $Utils.Optional<AgentTaskCountAggregateOutputType> | number
          }
        }
      }
      AgentActivity: {
        payload: Prisma.$AgentActivityPayload<ExtArgs>
        fields: Prisma.AgentActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload>
          }
          findFirst: {
            args: Prisma.AgentActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload>
          }
          findMany: {
            args: Prisma.AgentActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload>[]
          }
          create: {
            args: Prisma.AgentActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload>
          }
          createMany: {
            args: Prisma.AgentActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload>[]
          }
          delete: {
            args: Prisma.AgentActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload>
          }
          update: {
            args: Prisma.AgentActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload>
          }
          deleteMany: {
            args: Prisma.AgentActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload>[]
          }
          upsert: {
            args: Prisma.AgentActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentActivityPayload>
          }
          aggregate: {
            args: Prisma.AgentActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentActivity>
          }
          groupBy: {
            args: Prisma.AgentActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentActivityCountArgs<ExtArgs>
            result: $Utils.Optional<AgentActivityCountAggregateOutputType> | number
          }
        }
      }
      AgentWorklog: {
        payload: Prisma.$AgentWorklogPayload<ExtArgs>
        fields: Prisma.AgentWorklogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentWorklogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentWorklogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload>
          }
          findFirst: {
            args: Prisma.AgentWorklogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentWorklogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload>
          }
          findMany: {
            args: Prisma.AgentWorklogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload>[]
          }
          create: {
            args: Prisma.AgentWorklogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload>
          }
          createMany: {
            args: Prisma.AgentWorklogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentWorklogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload>[]
          }
          delete: {
            args: Prisma.AgentWorklogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload>
          }
          update: {
            args: Prisma.AgentWorklogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload>
          }
          deleteMany: {
            args: Prisma.AgentWorklogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentWorklogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentWorklogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload>[]
          }
          upsert: {
            args: Prisma.AgentWorklogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentWorklogPayload>
          }
          aggregate: {
            args: Prisma.AgentWorklogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentWorklog>
          }
          groupBy: {
            args: Prisma.AgentWorklogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentWorklogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentWorklogCountArgs<ExtArgs>
            result: $Utils.Optional<AgentWorklogCountAggregateOutputType> | number
          }
        }
      }
      AgentPromptTemplate: {
        payload: Prisma.$AgentPromptTemplatePayload<ExtArgs>
        fields: Prisma.AgentPromptTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentPromptTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentPromptTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload>
          }
          findFirst: {
            args: Prisma.AgentPromptTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentPromptTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload>
          }
          findMany: {
            args: Prisma.AgentPromptTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload>[]
          }
          create: {
            args: Prisma.AgentPromptTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload>
          }
          createMany: {
            args: Prisma.AgentPromptTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentPromptTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload>[]
          }
          delete: {
            args: Prisma.AgentPromptTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload>
          }
          update: {
            args: Prisma.AgentPromptTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload>
          }
          deleteMany: {
            args: Prisma.AgentPromptTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentPromptTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentPromptTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload>[]
          }
          upsert: {
            args: Prisma.AgentPromptTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPromptTemplatePayload>
          }
          aggregate: {
            args: Prisma.AgentPromptTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgentPromptTemplate>
          }
          groupBy: {
            args: Prisma.AgentPromptTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentPromptTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentPromptTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<AgentPromptTemplateCountAggregateOutputType> | number
          }
        }
      }
      ApiDesign: {
        payload: Prisma.$ApiDesignPayload<ExtArgs>
        fields: Prisma.ApiDesignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiDesignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiDesignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload>
          }
          findFirst: {
            args: Prisma.ApiDesignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiDesignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload>
          }
          findMany: {
            args: Prisma.ApiDesignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload>[]
          }
          create: {
            args: Prisma.ApiDesignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload>
          }
          createMany: {
            args: Prisma.ApiDesignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiDesignCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload>[]
          }
          delete: {
            args: Prisma.ApiDesignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload>
          }
          update: {
            args: Prisma.ApiDesignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload>
          }
          deleteMany: {
            args: Prisma.ApiDesignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiDesignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiDesignUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload>[]
          }
          upsert: {
            args: Prisma.ApiDesignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiDesignPayload>
          }
          aggregate: {
            args: Prisma.ApiDesignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiDesign>
          }
          groupBy: {
            args: Prisma.ApiDesignGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiDesignGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiDesignCountArgs<ExtArgs>
            result: $Utils.Optional<ApiDesignCountAggregateOutputType> | number
          }
        }
      }
      ApiExample: {
        payload: Prisma.$ApiExamplePayload<ExtArgs>
        fields: Prisma.ApiExampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiExampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiExampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload>
          }
          findFirst: {
            args: Prisma.ApiExampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiExampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload>
          }
          findMany: {
            args: Prisma.ApiExampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload>[]
          }
          create: {
            args: Prisma.ApiExampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload>
          }
          createMany: {
            args: Prisma.ApiExampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiExampleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload>[]
          }
          delete: {
            args: Prisma.ApiExampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload>
          }
          update: {
            args: Prisma.ApiExampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload>
          }
          deleteMany: {
            args: Prisma.ApiExampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiExampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiExampleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload>[]
          }
          upsert: {
            args: Prisma.ApiExampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiExamplePayload>
          }
          aggregate: {
            args: Prisma.ApiExampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiExample>
          }
          groupBy: {
            args: Prisma.ApiExampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiExampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiExampleCountArgs<ExtArgs>
            result: $Utils.Optional<ApiExampleCountAggregateOutputType> | number
          }
        }
      }
      ApiErrorCode: {
        payload: Prisma.$ApiErrorCodePayload<ExtArgs>
        fields: Prisma.ApiErrorCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiErrorCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiErrorCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload>
          }
          findFirst: {
            args: Prisma.ApiErrorCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiErrorCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload>
          }
          findMany: {
            args: Prisma.ApiErrorCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload>[]
          }
          create: {
            args: Prisma.ApiErrorCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload>
          }
          createMany: {
            args: Prisma.ApiErrorCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiErrorCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload>[]
          }
          delete: {
            args: Prisma.ApiErrorCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload>
          }
          update: {
            args: Prisma.ApiErrorCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload>
          }
          deleteMany: {
            args: Prisma.ApiErrorCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiErrorCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiErrorCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload>[]
          }
          upsert: {
            args: Prisma.ApiErrorCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiErrorCodePayload>
          }
          aggregate: {
            args: Prisma.ApiErrorCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiErrorCode>
          }
          groupBy: {
            args: Prisma.ApiErrorCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiErrorCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiErrorCodeCountArgs<ExtArgs>
            result: $Utils.Optional<ApiErrorCodeCountAggregateOutputType> | number
          }
        }
      }
      SystemArchitecture: {
        payload: Prisma.$SystemArchitecturePayload<ExtArgs>
        fields: Prisma.SystemArchitectureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemArchitectureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemArchitectureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload>
          }
          findFirst: {
            args: Prisma.SystemArchitectureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemArchitectureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload>
          }
          findMany: {
            args: Prisma.SystemArchitectureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload>[]
          }
          create: {
            args: Prisma.SystemArchitectureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload>
          }
          createMany: {
            args: Prisma.SystemArchitectureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemArchitectureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload>[]
          }
          delete: {
            args: Prisma.SystemArchitectureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload>
          }
          update: {
            args: Prisma.SystemArchitectureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload>
          }
          deleteMany: {
            args: Prisma.SystemArchitectureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemArchitectureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemArchitectureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload>[]
          }
          upsert: {
            args: Prisma.SystemArchitectureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemArchitecturePayload>
          }
          aggregate: {
            args: Prisma.SystemArchitectureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemArchitecture>
          }
          groupBy: {
            args: Prisma.SystemArchitectureGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemArchitectureGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemArchitectureCountArgs<ExtArgs>
            result: $Utils.Optional<SystemArchitectureCountAggregateOutputType> | number
          }
        }
      }
      PlatformArchitecture: {
        payload: Prisma.$PlatformArchitecturePayload<ExtArgs>
        fields: Prisma.PlatformArchitectureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformArchitectureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformArchitectureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload>
          }
          findFirst: {
            args: Prisma.PlatformArchitectureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformArchitectureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload>
          }
          findMany: {
            args: Prisma.PlatformArchitectureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload>[]
          }
          create: {
            args: Prisma.PlatformArchitectureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload>
          }
          createMany: {
            args: Prisma.PlatformArchitectureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformArchitectureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload>[]
          }
          delete: {
            args: Prisma.PlatformArchitectureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload>
          }
          update: {
            args: Prisma.PlatformArchitectureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload>
          }
          deleteMany: {
            args: Prisma.PlatformArchitectureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformArchitectureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformArchitectureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload>[]
          }
          upsert: {
            args: Prisma.PlatformArchitectureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformArchitecturePayload>
          }
          aggregate: {
            args: Prisma.PlatformArchitectureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformArchitecture>
          }
          groupBy: {
            args: Prisma.PlatformArchitectureGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformArchitectureGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformArchitectureCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformArchitectureCountAggregateOutputType> | number
          }
        }
      }
      ArchitectureChangeHistory: {
        payload: Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>
        fields: Prisma.ArchitectureChangeHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArchitectureChangeHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArchitectureChangeHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload>
          }
          findFirst: {
            args: Prisma.ArchitectureChangeHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArchitectureChangeHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload>
          }
          findMany: {
            args: Prisma.ArchitectureChangeHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload>[]
          }
          create: {
            args: Prisma.ArchitectureChangeHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload>
          }
          createMany: {
            args: Prisma.ArchitectureChangeHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArchitectureChangeHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload>[]
          }
          delete: {
            args: Prisma.ArchitectureChangeHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload>
          }
          update: {
            args: Prisma.ArchitectureChangeHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload>
          }
          deleteMany: {
            args: Prisma.ArchitectureChangeHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArchitectureChangeHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArchitectureChangeHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload>[]
          }
          upsert: {
            args: Prisma.ArchitectureChangeHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArchitectureChangeHistoryPayload>
          }
          aggregate: {
            args: Prisma.ArchitectureChangeHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArchitectureChangeHistory>
          }
          groupBy: {
            args: Prisma.ArchitectureChangeHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArchitectureChangeHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArchitectureChangeHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<ArchitectureChangeHistoryCountAggregateOutputType> | number
          }
        }
      }
      DatabaseSchema: {
        payload: Prisma.$DatabaseSchemaPayload<ExtArgs>
        fields: Prisma.DatabaseSchemaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatabaseSchemaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatabaseSchemaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload>
          }
          findFirst: {
            args: Prisma.DatabaseSchemaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatabaseSchemaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload>
          }
          findMany: {
            args: Prisma.DatabaseSchemaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload>[]
          }
          create: {
            args: Prisma.DatabaseSchemaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload>
          }
          createMany: {
            args: Prisma.DatabaseSchemaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatabaseSchemaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload>[]
          }
          delete: {
            args: Prisma.DatabaseSchemaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload>
          }
          update: {
            args: Prisma.DatabaseSchemaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload>
          }
          deleteMany: {
            args: Prisma.DatabaseSchemaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatabaseSchemaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DatabaseSchemaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload>[]
          }
          upsert: {
            args: Prisma.DatabaseSchemaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseSchemaPayload>
          }
          aggregate: {
            args: Prisma.DatabaseSchemaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatabaseSchema>
          }
          groupBy: {
            args: Prisma.DatabaseSchemaGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatabaseSchemaGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatabaseSchemaCountArgs<ExtArgs>
            result: $Utils.Optional<DatabaseSchemaCountAggregateOutputType> | number
          }
        }
      }
      DatabaseTable: {
        payload: Prisma.$DatabaseTablePayload<ExtArgs>
        fields: Prisma.DatabaseTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatabaseTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatabaseTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload>
          }
          findFirst: {
            args: Prisma.DatabaseTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatabaseTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload>
          }
          findMany: {
            args: Prisma.DatabaseTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload>[]
          }
          create: {
            args: Prisma.DatabaseTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload>
          }
          createMany: {
            args: Prisma.DatabaseTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatabaseTableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload>[]
          }
          delete: {
            args: Prisma.DatabaseTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload>
          }
          update: {
            args: Prisma.DatabaseTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload>
          }
          deleteMany: {
            args: Prisma.DatabaseTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatabaseTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DatabaseTableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload>[]
          }
          upsert: {
            args: Prisma.DatabaseTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseTablePayload>
          }
          aggregate: {
            args: Prisma.DatabaseTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatabaseTable>
          }
          groupBy: {
            args: Prisma.DatabaseTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatabaseTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatabaseTableCountArgs<ExtArgs>
            result: $Utils.Optional<DatabaseTableCountAggregateOutputType> | number
          }
        }
      }
      TableColumn: {
        payload: Prisma.$TableColumnPayload<ExtArgs>
        fields: Prisma.TableColumnFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableColumnFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableColumnFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload>
          }
          findFirst: {
            args: Prisma.TableColumnFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableColumnFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload>
          }
          findMany: {
            args: Prisma.TableColumnFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload>[]
          }
          create: {
            args: Prisma.TableColumnCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload>
          }
          createMany: {
            args: Prisma.TableColumnCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TableColumnCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload>[]
          }
          delete: {
            args: Prisma.TableColumnDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload>
          }
          update: {
            args: Prisma.TableColumnUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload>
          }
          deleteMany: {
            args: Prisma.TableColumnDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableColumnUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TableColumnUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload>[]
          }
          upsert: {
            args: Prisma.TableColumnUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TableColumnPayload>
          }
          aggregate: {
            args: Prisma.TableColumnAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTableColumn>
          }
          groupBy: {
            args: Prisma.TableColumnGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableColumnGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableColumnCountArgs<ExtArgs>
            result: $Utils.Optional<TableColumnCountAggregateOutputType> | number
          }
        }
      }
      DatabaseIndex: {
        payload: Prisma.$DatabaseIndexPayload<ExtArgs>
        fields: Prisma.DatabaseIndexFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatabaseIndexFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatabaseIndexFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload>
          }
          findFirst: {
            args: Prisma.DatabaseIndexFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatabaseIndexFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload>
          }
          findMany: {
            args: Prisma.DatabaseIndexFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload>[]
          }
          create: {
            args: Prisma.DatabaseIndexCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload>
          }
          createMany: {
            args: Prisma.DatabaseIndexCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatabaseIndexCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload>[]
          }
          delete: {
            args: Prisma.DatabaseIndexDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload>
          }
          update: {
            args: Prisma.DatabaseIndexUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload>
          }
          deleteMany: {
            args: Prisma.DatabaseIndexDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatabaseIndexUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DatabaseIndexUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload>[]
          }
          upsert: {
            args: Prisma.DatabaseIndexUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseIndexPayload>
          }
          aggregate: {
            args: Prisma.DatabaseIndexAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatabaseIndex>
          }
          groupBy: {
            args: Prisma.DatabaseIndexGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatabaseIndexGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatabaseIndexCountArgs<ExtArgs>
            result: $Utils.Optional<DatabaseIndexCountAggregateOutputType> | number
          }
        }
      }
      DatabaseRelation: {
        payload: Prisma.$DatabaseRelationPayload<ExtArgs>
        fields: Prisma.DatabaseRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DatabaseRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DatabaseRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload>
          }
          findFirst: {
            args: Prisma.DatabaseRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DatabaseRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload>
          }
          findMany: {
            args: Prisma.DatabaseRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload>[]
          }
          create: {
            args: Prisma.DatabaseRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload>
          }
          createMany: {
            args: Prisma.DatabaseRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DatabaseRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload>[]
          }
          delete: {
            args: Prisma.DatabaseRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload>
          }
          update: {
            args: Prisma.DatabaseRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload>
          }
          deleteMany: {
            args: Prisma.DatabaseRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DatabaseRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DatabaseRelationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload>[]
          }
          upsert: {
            args: Prisma.DatabaseRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DatabaseRelationPayload>
          }
          aggregate: {
            args: Prisma.DatabaseRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDatabaseRelation>
          }
          groupBy: {
            args: Prisma.DatabaseRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DatabaseRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DatabaseRelationCountArgs<ExtArgs>
            result: $Utils.Optional<DatabaseRelationCountAggregateOutputType> | number
          }
        }
      }
      Documentation: {
        payload: Prisma.$DocumentationPayload<ExtArgs>
        fields: Prisma.DocumentationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload>
          }
          findFirst: {
            args: Prisma.DocumentationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload>
          }
          findMany: {
            args: Prisma.DocumentationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload>[]
          }
          create: {
            args: Prisma.DocumentationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload>
          }
          createMany: {
            args: Prisma.DocumentationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload>[]
          }
          delete: {
            args: Prisma.DocumentationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload>
          }
          update: {
            args: Prisma.DocumentationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload>
          }
          deleteMany: {
            args: Prisma.DocumentationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload>[]
          }
          upsert: {
            args: Prisma.DocumentationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentationPayload>
          }
          aggregate: {
            args: Prisma.DocumentationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentation>
          }
          groupBy: {
            args: Prisma.DocumentationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentationCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentationCountAggregateOutputType> | number
          }
        }
      }
      DocumentVersion: {
        payload: Prisma.$DocumentVersionPayload<ExtArgs>
        fields: Prisma.DocumentVersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentVersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentVersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          findFirst: {
            args: Prisma.DocumentVersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentVersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          findMany: {
            args: Prisma.DocumentVersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>[]
          }
          create: {
            args: Prisma.DocumentVersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          createMany: {
            args: Prisma.DocumentVersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentVersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>[]
          }
          delete: {
            args: Prisma.DocumentVersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          update: {
            args: Prisma.DocumentVersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          deleteMany: {
            args: Prisma.DocumentVersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentVersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentVersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>[]
          }
          upsert: {
            args: Prisma.DocumentVersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentVersionPayload>
          }
          aggregate: {
            args: Prisma.DocumentVersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentVersion>
          }
          groupBy: {
            args: Prisma.DocumentVersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentVersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentVersionCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentVersionCountAggregateOutputType> | number
          }
        }
      }
      DocumentTag: {
        payload: Prisma.$DocumentTagPayload<ExtArgs>
        fields: Prisma.DocumentTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          findFirst: {
            args: Prisma.DocumentTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          findMany: {
            args: Prisma.DocumentTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>[]
          }
          create: {
            args: Prisma.DocumentTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          createMany: {
            args: Prisma.DocumentTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>[]
          }
          delete: {
            args: Prisma.DocumentTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          update: {
            args: Prisma.DocumentTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          deleteMany: {
            args: Prisma.DocumentTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>[]
          }
          upsert: {
            args: Prisma.DocumentTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentTagPayload>
          }
          aggregate: {
            args: Prisma.DocumentTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentTag>
          }
          groupBy: {
            args: Prisma.DocumentTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentTagCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentTagCountAggregateOutputType> | number
          }
        }
      }
      DocumentComment: {
        payload: Prisma.$DocumentCommentPayload<ExtArgs>
        fields: Prisma.DocumentCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          findFirst: {
            args: Prisma.DocumentCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          findMany: {
            args: Prisma.DocumentCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>[]
          }
          create: {
            args: Prisma.DocumentCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          createMany: {
            args: Prisma.DocumentCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>[]
          }
          delete: {
            args: Prisma.DocumentCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          update: {
            args: Prisma.DocumentCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentCommentPayload>
          }
          aggregate: {
            args: Prisma.DocumentCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentComment>
          }
          groupBy: {
            args: Prisma.DocumentCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCommentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCommentCountAggregateOutputType> | number
          }
        }
      }
      DocumentAttachment: {
        payload: Prisma.$DocumentAttachmentPayload<ExtArgs>
        fields: Prisma.DocumentAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          findFirst: {
            args: Prisma.DocumentAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          findMany: {
            args: Prisma.DocumentAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>[]
          }
          create: {
            args: Prisma.DocumentAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          createMany: {
            args: Prisma.DocumentAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>[]
          }
          delete: {
            args: Prisma.DocumentAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          update: {
            args: Prisma.DocumentAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentAttachmentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentAttachment>
          }
          groupBy: {
            args: Prisma.DocumentAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentAttachmentCountAggregateOutputType> | number
          }
        }
      }
      MindMap: {
        payload: Prisma.$MindMapPayload<ExtArgs>
        fields: Prisma.MindMapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MindMapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MindMapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload>
          }
          findFirst: {
            args: Prisma.MindMapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MindMapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload>
          }
          findMany: {
            args: Prisma.MindMapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload>[]
          }
          create: {
            args: Prisma.MindMapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload>
          }
          createMany: {
            args: Prisma.MindMapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MindMapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload>[]
          }
          delete: {
            args: Prisma.MindMapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload>
          }
          update: {
            args: Prisma.MindMapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload>
          }
          deleteMany: {
            args: Prisma.MindMapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MindMapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MindMapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload>[]
          }
          upsert: {
            args: Prisma.MindMapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapPayload>
          }
          aggregate: {
            args: Prisma.MindMapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMindMap>
          }
          groupBy: {
            args: Prisma.MindMapGroupByArgs<ExtArgs>
            result: $Utils.Optional<MindMapGroupByOutputType>[]
          }
          count: {
            args: Prisma.MindMapCountArgs<ExtArgs>
            result: $Utils.Optional<MindMapCountAggregateOutputType> | number
          }
        }
      }
      MindMapNode: {
        payload: Prisma.$MindMapNodePayload<ExtArgs>
        fields: Prisma.MindMapNodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MindMapNodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MindMapNodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload>
          }
          findFirst: {
            args: Prisma.MindMapNodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MindMapNodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload>
          }
          findMany: {
            args: Prisma.MindMapNodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload>[]
          }
          create: {
            args: Prisma.MindMapNodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload>
          }
          createMany: {
            args: Prisma.MindMapNodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MindMapNodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload>[]
          }
          delete: {
            args: Prisma.MindMapNodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload>
          }
          update: {
            args: Prisma.MindMapNodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload>
          }
          deleteMany: {
            args: Prisma.MindMapNodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MindMapNodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MindMapNodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload>[]
          }
          upsert: {
            args: Prisma.MindMapNodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MindMapNodePayload>
          }
          aggregate: {
            args: Prisma.MindMapNodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMindMapNode>
          }
          groupBy: {
            args: Prisma.MindMapNodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MindMapNodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MindMapNodeCountArgs<ExtArgs>
            result: $Utils.Optional<MindMapNodeCountAggregateOutputType> | number
          }
        }
      }
      DomainKnowledge: {
        payload: Prisma.$DomainKnowledgePayload<ExtArgs>
        fields: Prisma.DomainKnowledgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainKnowledgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainKnowledgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload>
          }
          findFirst: {
            args: Prisma.DomainKnowledgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainKnowledgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload>
          }
          findMany: {
            args: Prisma.DomainKnowledgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload>[]
          }
          create: {
            args: Prisma.DomainKnowledgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload>
          }
          createMany: {
            args: Prisma.DomainKnowledgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainKnowledgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload>[]
          }
          delete: {
            args: Prisma.DomainKnowledgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload>
          }
          update: {
            args: Prisma.DomainKnowledgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload>
          }
          deleteMany: {
            args: Prisma.DomainKnowledgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainKnowledgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainKnowledgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload>[]
          }
          upsert: {
            args: Prisma.DomainKnowledgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainKnowledgePayload>
          }
          aggregate: {
            args: Prisma.DomainKnowledgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainKnowledge>
          }
          groupBy: {
            args: Prisma.DomainKnowledgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainKnowledgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainKnowledgeCountArgs<ExtArgs>
            result: $Utils.Optional<DomainKnowledgeCountAggregateOutputType> | number
          }
        }
      }
      DomainConcept: {
        payload: Prisma.$DomainConceptPayload<ExtArgs>
        fields: Prisma.DomainConceptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainConceptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainConceptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload>
          }
          findFirst: {
            args: Prisma.DomainConceptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainConceptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload>
          }
          findMany: {
            args: Prisma.DomainConceptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload>[]
          }
          create: {
            args: Prisma.DomainConceptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload>
          }
          createMany: {
            args: Prisma.DomainConceptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainConceptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload>[]
          }
          delete: {
            args: Prisma.DomainConceptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload>
          }
          update: {
            args: Prisma.DomainConceptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload>
          }
          deleteMany: {
            args: Prisma.DomainConceptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainConceptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainConceptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload>[]
          }
          upsert: {
            args: Prisma.DomainConceptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainConceptPayload>
          }
          aggregate: {
            args: Prisma.DomainConceptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainConcept>
          }
          groupBy: {
            args: Prisma.DomainConceptGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainConceptGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainConceptCountArgs<ExtArgs>
            result: $Utils.Optional<DomainConceptCountAggregateOutputType> | number
          }
        }
      }
      DomainPattern: {
        payload: Prisma.$DomainPatternPayload<ExtArgs>
        fields: Prisma.DomainPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload>
          }
          findFirst: {
            args: Prisma.DomainPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload>
          }
          findMany: {
            args: Prisma.DomainPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload>[]
          }
          create: {
            args: Prisma.DomainPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload>
          }
          createMany: {
            args: Prisma.DomainPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload>[]
          }
          delete: {
            args: Prisma.DomainPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload>
          }
          update: {
            args: Prisma.DomainPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload>
          }
          deleteMany: {
            args: Prisma.DomainPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainPatternUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload>[]
          }
          upsert: {
            args: Prisma.DomainPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainPatternPayload>
          }
          aggregate: {
            args: Prisma.DomainPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainPattern>
          }
          groupBy: {
            args: Prisma.DomainPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainPatternCountArgs<ExtArgs>
            result: $Utils.Optional<DomainPatternCountAggregateOutputType> | number
          }
        }
      }
      DomainBestPractice: {
        payload: Prisma.$DomainBestPracticePayload<ExtArgs>
        fields: Prisma.DomainBestPracticeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainBestPracticeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainBestPracticeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload>
          }
          findFirst: {
            args: Prisma.DomainBestPracticeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainBestPracticeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload>
          }
          findMany: {
            args: Prisma.DomainBestPracticeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload>[]
          }
          create: {
            args: Prisma.DomainBestPracticeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload>
          }
          createMany: {
            args: Prisma.DomainBestPracticeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainBestPracticeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload>[]
          }
          delete: {
            args: Prisma.DomainBestPracticeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload>
          }
          update: {
            args: Prisma.DomainBestPracticeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload>
          }
          deleteMany: {
            args: Prisma.DomainBestPracticeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainBestPracticeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainBestPracticeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload>[]
          }
          upsert: {
            args: Prisma.DomainBestPracticeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainBestPracticePayload>
          }
          aggregate: {
            args: Prisma.DomainBestPracticeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainBestPractice>
          }
          groupBy: {
            args: Prisma.DomainBestPracticeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainBestPracticeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainBestPracticeCountArgs<ExtArgs>
            result: $Utils.Optional<DomainBestPracticeCountAggregateOutputType> | number
          }
        }
      }
      DomainAntiPattern: {
        payload: Prisma.$DomainAntiPatternPayload<ExtArgs>
        fields: Prisma.DomainAntiPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainAntiPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainAntiPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload>
          }
          findFirst: {
            args: Prisma.DomainAntiPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainAntiPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload>
          }
          findMany: {
            args: Prisma.DomainAntiPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload>[]
          }
          create: {
            args: Prisma.DomainAntiPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload>
          }
          createMany: {
            args: Prisma.DomainAntiPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainAntiPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload>[]
          }
          delete: {
            args: Prisma.DomainAntiPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload>
          }
          update: {
            args: Prisma.DomainAntiPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload>
          }
          deleteMany: {
            args: Prisma.DomainAntiPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainAntiPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainAntiPatternUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload>[]
          }
          upsert: {
            args: Prisma.DomainAntiPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainAntiPatternPayload>
          }
          aggregate: {
            args: Prisma.DomainAntiPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainAntiPattern>
          }
          groupBy: {
            args: Prisma.DomainAntiPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainAntiPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainAntiPatternCountArgs<ExtArgs>
            result: $Utils.Optional<DomainAntiPatternCountAggregateOutputType> | number
          }
        }
      }
      DomainReference: {
        payload: Prisma.$DomainReferencePayload<ExtArgs>
        fields: Prisma.DomainReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DomainReferenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DomainReferenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload>
          }
          findFirst: {
            args: Prisma.DomainReferenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DomainReferenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload>
          }
          findMany: {
            args: Prisma.DomainReferenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload>[]
          }
          create: {
            args: Prisma.DomainReferenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload>
          }
          createMany: {
            args: Prisma.DomainReferenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DomainReferenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload>[]
          }
          delete: {
            args: Prisma.DomainReferenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload>
          }
          update: {
            args: Prisma.DomainReferenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload>
          }
          deleteMany: {
            args: Prisma.DomainReferenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DomainReferenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DomainReferenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload>[]
          }
          upsert: {
            args: Prisma.DomainReferenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DomainReferencePayload>
          }
          aggregate: {
            args: Prisma.DomainReferenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDomainReference>
          }
          groupBy: {
            args: Prisma.DomainReferenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DomainReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DomainReferenceCountArgs<ExtArgs>
            result: $Utils.Optional<DomainReferenceCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Requirement: {
        payload: Prisma.$RequirementPayload<ExtArgs>
        fields: Prisma.RequirementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequirementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequirementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          findFirst: {
            args: Prisma.RequirementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequirementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          findMany: {
            args: Prisma.RequirementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          create: {
            args: Prisma.RequirementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          createMany: {
            args: Prisma.RequirementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequirementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          delete: {
            args: Prisma.RequirementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          update: {
            args: Prisma.RequirementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          deleteMany: {
            args: Prisma.RequirementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequirementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequirementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>[]
          }
          upsert: {
            args: Prisma.RequirementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementPayload>
          }
          aggregate: {
            args: Prisma.RequirementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequirement>
          }
          groupBy: {
            args: Prisma.RequirementGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequirementGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequirementCountArgs<ExtArgs>
            result: $Utils.Optional<RequirementCountAggregateOutputType> | number
          }
        }
      }
      RequirementQuestion: {
        payload: Prisma.$RequirementQuestionPayload<ExtArgs>
        fields: Prisma.RequirementQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequirementQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequirementQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload>
          }
          findFirst: {
            args: Prisma.RequirementQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequirementQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload>
          }
          findMany: {
            args: Prisma.RequirementQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload>[]
          }
          create: {
            args: Prisma.RequirementQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload>
          }
          createMany: {
            args: Prisma.RequirementQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequirementQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload>[]
          }
          delete: {
            args: Prisma.RequirementQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload>
          }
          update: {
            args: Prisma.RequirementQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload>
          }
          deleteMany: {
            args: Prisma.RequirementQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequirementQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequirementQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload>[]
          }
          upsert: {
            args: Prisma.RequirementQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementQuestionPayload>
          }
          aggregate: {
            args: Prisma.RequirementQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequirementQuestion>
          }
          groupBy: {
            args: Prisma.RequirementQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequirementQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequirementQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<RequirementQuestionCountAggregateOutputType> | number
          }
        }
      }
      RequirementAttachment: {
        payload: Prisma.$RequirementAttachmentPayload<ExtArgs>
        fields: Prisma.RequirementAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequirementAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequirementAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload>
          }
          findFirst: {
            args: Prisma.RequirementAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequirementAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload>
          }
          findMany: {
            args: Prisma.RequirementAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload>[]
          }
          create: {
            args: Prisma.RequirementAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload>
          }
          createMany: {
            args: Prisma.RequirementAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequirementAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload>[]
          }
          delete: {
            args: Prisma.RequirementAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload>
          }
          update: {
            args: Prisma.RequirementAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.RequirementAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequirementAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequirementAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.RequirementAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequirementAttachmentPayload>
          }
          aggregate: {
            args: Prisma.RequirementAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequirementAttachment>
          }
          groupBy: {
            args: Prisma.RequirementAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequirementAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequirementAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<RequirementAttachmentCountAggregateOutputType> | number
          }
        }
      }
      Roadmap: {
        payload: Prisma.$RoadmapPayload<ExtArgs>
        fields: Prisma.RoadmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findFirst: {
            args: Prisma.RoadmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findMany: {
            args: Prisma.RoadmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          create: {
            args: Prisma.RoadmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          createMany: {
            args: Prisma.RoadmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          delete: {
            args: Prisma.RoadmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          update: {
            args: Prisma.RoadmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoadmapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          upsert: {
            args: Prisma.RoadmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          aggregate: {
            args: Prisma.RoadmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmap>
          }
          groupBy: {
            args: Prisma.RoadmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapCountAggregateOutputType> | number
          }
        }
      }
      Milestone: {
        payload: Prisma.$MilestonePayload<ExtArgs>
        fields: Prisma.MilestoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MilestoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MilestoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findFirst: {
            args: Prisma.MilestoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MilestoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          findMany: {
            args: Prisma.MilestoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          create: {
            args: Prisma.MilestoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          createMany: {
            args: Prisma.MilestoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MilestoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          delete: {
            args: Prisma.MilestoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          update: {
            args: Prisma.MilestoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          deleteMany: {
            args: Prisma.MilestoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MilestoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MilestoneUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>[]
          }
          upsert: {
            args: Prisma.MilestoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MilestonePayload>
          }
          aggregate: {
            args: Prisma.MilestoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMilestone>
          }
          groupBy: {
            args: Prisma.MilestoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<MilestoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.MilestoneCountArgs<ExtArgs>
            result: $Utils.Optional<MilestoneCountAggregateOutputType> | number
          }
        }
      }
      Version: {
        payload: Prisma.$VersionPayload<ExtArgs>
        fields: Prisma.VersionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VersionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VersionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findFirst: {
            args: Prisma.VersionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VersionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          findMany: {
            args: Prisma.VersionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          create: {
            args: Prisma.VersionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          createMany: {
            args: Prisma.VersionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VersionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          delete: {
            args: Prisma.VersionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          update: {
            args: Prisma.VersionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          deleteMany: {
            args: Prisma.VersionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VersionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VersionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>[]
          }
          upsert: {
            args: Prisma.VersionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VersionPayload>
          }
          aggregate: {
            args: Prisma.VersionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVersion>
          }
          groupBy: {
            args: Prisma.VersionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VersionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VersionCountArgs<ExtArgs>
            result: $Utils.Optional<VersionCountAggregateOutputType> | number
          }
        }
      }
      Feature: {
        payload: Prisma.$FeaturePayload<ExtArgs>
        fields: Prisma.FeatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findFirst: {
            args: Prisma.FeatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          findMany: {
            args: Prisma.FeatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          create: {
            args: Prisma.FeatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          createMany: {
            args: Prisma.FeatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          delete: {
            args: Prisma.FeatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          update: {
            args: Prisma.FeatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          deleteMany: {
            args: Prisma.FeatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FeatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>[]
          }
          upsert: {
            args: Prisma.FeatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeaturePayload>
          }
          aggregate: {
            args: Prisma.FeatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeature>
          }
          groupBy: {
            args: Prisma.FeatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeatureCountArgs<ExtArgs>
            result: $Utils.Optional<FeatureCountAggregateOutputType> | number
          }
        }
      }
      Sprint: {
        payload: Prisma.$SprintPayload<ExtArgs>
        fields: Prisma.SprintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SprintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SprintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findFirst: {
            args: Prisma.SprintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SprintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          findMany: {
            args: Prisma.SprintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          create: {
            args: Prisma.SprintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          createMany: {
            args: Prisma.SprintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SprintCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          delete: {
            args: Prisma.SprintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          update: {
            args: Prisma.SprintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          deleteMany: {
            args: Prisma.SprintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SprintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SprintUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>[]
          }
          upsert: {
            args: Prisma.SprintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SprintPayload>
          }
          aggregate: {
            args: Prisma.SprintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSprint>
          }
          groupBy: {
            args: Prisma.SprintGroupByArgs<ExtArgs>
            result: $Utils.Optional<SprintGroupByOutputType>[]
          }
          count: {
            args: Prisma.SprintCountArgs<ExtArgs>
            result: $Utils.Optional<SprintCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    agent?: AgentOmit
    agentTask?: AgentTaskOmit
    agentActivity?: AgentActivityOmit
    agentWorklog?: AgentWorklogOmit
    agentPromptTemplate?: AgentPromptTemplateOmit
    apiDesign?: ApiDesignOmit
    apiExample?: ApiExampleOmit
    apiErrorCode?: ApiErrorCodeOmit
    systemArchitecture?: SystemArchitectureOmit
    platformArchitecture?: PlatformArchitectureOmit
    architectureChangeHistory?: ArchitectureChangeHistoryOmit
    databaseSchema?: DatabaseSchemaOmit
    databaseTable?: DatabaseTableOmit
    tableColumn?: TableColumnOmit
    databaseIndex?: DatabaseIndexOmit
    databaseRelation?: DatabaseRelationOmit
    documentation?: DocumentationOmit
    documentVersion?: DocumentVersionOmit
    documentTag?: DocumentTagOmit
    documentComment?: DocumentCommentOmit
    documentAttachment?: DocumentAttachmentOmit
    mindMap?: MindMapOmit
    mindMapNode?: MindMapNodeOmit
    domainKnowledge?: DomainKnowledgeOmit
    domainConcept?: DomainConceptOmit
    domainPattern?: DomainPatternOmit
    domainBestPractice?: DomainBestPracticeOmit
    domainAntiPattern?: DomainAntiPatternOmit
    domainReference?: DomainReferenceOmit
    project?: ProjectOmit
    requirement?: RequirementOmit
    requirementQuestion?: RequirementQuestionOmit
    requirementAttachment?: RequirementAttachmentOmit
    roadmap?: RoadmapOmit
    milestone?: MilestoneOmit
    version?: VersionOmit
    feature?: FeatureOmit
    sprint?: SprintOmit
    task?: TaskOmit
    team?: TeamOmit
    user?: UserOmit
    session?: SessionOmit
    projectMember?: ProjectMemberOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    AgentActivity: number
    AgentTask: number
    AgentWorklog: number
    RequirementQuestion: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AgentActivity?: boolean | AgentCountOutputTypeCountAgentActivityArgs
    AgentTask?: boolean | AgentCountOutputTypeCountAgentTaskArgs
    AgentWorklog?: boolean | AgentCountOutputTypeCountAgentWorklogArgs
    RequirementQuestion?: boolean | AgentCountOutputTypeCountRequirementQuestionArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAgentActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentActivityWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAgentTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTaskWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountAgentWorklogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWorklogWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountRequirementQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementQuestionWhereInput
  }


  /**
   * Count Type ApiDesignCountOutputType
   */

  export type ApiDesignCountOutputType = {
    examples: number
    errorCodes: number
  }

  export type ApiDesignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examples?: boolean | ApiDesignCountOutputTypeCountExamplesArgs
    errorCodes?: boolean | ApiDesignCountOutputTypeCountErrorCodesArgs
  }

  // Custom InputTypes
  /**
   * ApiDesignCountOutputType without action
   */
  export type ApiDesignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesignCountOutputType
     */
    select?: ApiDesignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApiDesignCountOutputType without action
   */
  export type ApiDesignCountOutputTypeCountExamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiExampleWhereInput
  }

  /**
   * ApiDesignCountOutputType without action
   */
  export type ApiDesignCountOutputTypeCountErrorCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiErrorCodeWhereInput
  }


  /**
   * Count Type SystemArchitectureCountOutputType
   */

  export type SystemArchitectureCountOutputType = {
    platformArchitectures: number
    changeHistories: number
    nextVersions: number
  }

  export type SystemArchitectureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platformArchitectures?: boolean | SystemArchitectureCountOutputTypeCountPlatformArchitecturesArgs
    changeHistories?: boolean | SystemArchitectureCountOutputTypeCountChangeHistoriesArgs
    nextVersions?: boolean | SystemArchitectureCountOutputTypeCountNextVersionsArgs
  }

  // Custom InputTypes
  /**
   * SystemArchitectureCountOutputType without action
   */
  export type SystemArchitectureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitectureCountOutputType
     */
    select?: SystemArchitectureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SystemArchitectureCountOutputType without action
   */
  export type SystemArchitectureCountOutputTypeCountPlatformArchitecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformArchitectureWhereInput
  }

  /**
   * SystemArchitectureCountOutputType without action
   */
  export type SystemArchitectureCountOutputTypeCountChangeHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchitectureChangeHistoryWhereInput
  }

  /**
   * SystemArchitectureCountOutputType without action
   */
  export type SystemArchitectureCountOutputTypeCountNextVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemArchitectureWhereInput
  }


  /**
   * Count Type DatabaseSchemaCountOutputType
   */

  export type DatabaseSchemaCountOutputType = {
    tables: number
  }

  export type DatabaseSchemaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tables?: boolean | DatabaseSchemaCountOutputTypeCountTablesArgs
  }

  // Custom InputTypes
  /**
   * DatabaseSchemaCountOutputType without action
   */
  export type DatabaseSchemaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchemaCountOutputType
     */
    select?: DatabaseSchemaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DatabaseSchemaCountOutputType without action
   */
  export type DatabaseSchemaCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseTableWhereInput
  }


  /**
   * Count Type DatabaseTableCountOutputType
   */

  export type DatabaseTableCountOutputType = {
    columns: number
    indexes: number
    sourceRelations: number
    targetRelations: number
  }

  export type DatabaseTableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    columns?: boolean | DatabaseTableCountOutputTypeCountColumnsArgs
    indexes?: boolean | DatabaseTableCountOutputTypeCountIndexesArgs
    sourceRelations?: boolean | DatabaseTableCountOutputTypeCountSourceRelationsArgs
    targetRelations?: boolean | DatabaseTableCountOutputTypeCountTargetRelationsArgs
  }

  // Custom InputTypes
  /**
   * DatabaseTableCountOutputType without action
   */
  export type DatabaseTableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTableCountOutputType
     */
    select?: DatabaseTableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DatabaseTableCountOutputType without action
   */
  export type DatabaseTableCountOutputTypeCountColumnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableColumnWhereInput
  }

  /**
   * DatabaseTableCountOutputType without action
   */
  export type DatabaseTableCountOutputTypeCountIndexesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseIndexWhereInput
  }

  /**
   * DatabaseTableCountOutputType without action
   */
  export type DatabaseTableCountOutputTypeCountSourceRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseRelationWhereInput
  }

  /**
   * DatabaseTableCountOutputType without action
   */
  export type DatabaseTableCountOutputTypeCountTargetRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseRelationWhereInput
  }


  /**
   * Count Type DocumentationCountOutputType
   */

  export type DocumentationCountOutputType = {
    tags: number
    versions: number
    comments: number
    attachments: number
  }

  export type DocumentationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | DocumentationCountOutputTypeCountTagsArgs
    versions?: boolean | DocumentationCountOutputTypeCountVersionsArgs
    comments?: boolean | DocumentationCountOutputTypeCountCommentsArgs
    attachments?: boolean | DocumentationCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * DocumentationCountOutputType without action
   */
  export type DocumentationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentationCountOutputType
     */
    select?: DocumentationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentationCountOutputType without action
   */
  export type DocumentationCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTagWhereInput
  }

  /**
   * DocumentationCountOutputType without action
   */
  export type DocumentationCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionWhereInput
  }

  /**
   * DocumentationCountOutputType without action
   */
  export type DocumentationCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentWhereInput
  }

  /**
   * DocumentationCountOutputType without action
   */
  export type DocumentationCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAttachmentWhereInput
  }


  /**
   * Count Type DocumentTagCountOutputType
   */

  export type DocumentTagCountOutputType = {
    documentations: number
  }

  export type DocumentTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentations?: boolean | DocumentTagCountOutputTypeCountDocumentationsArgs
  }

  // Custom InputTypes
  /**
   * DocumentTagCountOutputType without action
   */
  export type DocumentTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTagCountOutputType
     */
    select?: DocumentTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentTagCountOutputType without action
   */
  export type DocumentTagCountOutputTypeCountDocumentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentationWhereInput
  }


  /**
   * Count Type DocumentCommentCountOutputType
   */

  export type DocumentCommentCountOutputType = {
    replies: number
  }

  export type DocumentCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | DocumentCommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * DocumentCommentCountOutputType without action
   */
  export type DocumentCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCommentCountOutputType
     */
    select?: DocumentCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCommentCountOutputType without action
   */
  export type DocumentCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentWhereInput
  }


  /**
   * Count Type MindMapCountOutputType
   */

  export type MindMapCountOutputType = {
    nodes: number
  }

  export type MindMapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nodes?: boolean | MindMapCountOutputTypeCountNodesArgs
  }

  // Custom InputTypes
  /**
   * MindMapCountOutputType without action
   */
  export type MindMapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapCountOutputType
     */
    select?: MindMapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MindMapCountOutputType without action
   */
  export type MindMapCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MindMapNodeWhereInput
  }


  /**
   * Count Type MindMapNodeCountOutputType
   */

  export type MindMapNodeCountOutputType = {
    children: number
  }

  export type MindMapNodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | MindMapNodeCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * MindMapNodeCountOutputType without action
   */
  export type MindMapNodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNodeCountOutputType
     */
    select?: MindMapNodeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MindMapNodeCountOutputType without action
   */
  export type MindMapNodeCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MindMapNodeWhereInput
  }


  /**
   * Count Type DomainKnowledgeCountOutputType
   */

  export type DomainKnowledgeCountOutputType = {
    concepts: number
    patterns: number
    bestPractices: number
    antiPatterns: number
    references: number
  }

  export type DomainKnowledgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    concepts?: boolean | DomainKnowledgeCountOutputTypeCountConceptsArgs
    patterns?: boolean | DomainKnowledgeCountOutputTypeCountPatternsArgs
    bestPractices?: boolean | DomainKnowledgeCountOutputTypeCountBestPracticesArgs
    antiPatterns?: boolean | DomainKnowledgeCountOutputTypeCountAntiPatternsArgs
    references?: boolean | DomainKnowledgeCountOutputTypeCountReferencesArgs
  }

  // Custom InputTypes
  /**
   * DomainKnowledgeCountOutputType without action
   */
  export type DomainKnowledgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledgeCountOutputType
     */
    select?: DomainKnowledgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DomainKnowledgeCountOutputType without action
   */
  export type DomainKnowledgeCountOutputTypeCountConceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainConceptWhereInput
  }

  /**
   * DomainKnowledgeCountOutputType without action
   */
  export type DomainKnowledgeCountOutputTypeCountPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainPatternWhereInput
  }

  /**
   * DomainKnowledgeCountOutputType without action
   */
  export type DomainKnowledgeCountOutputTypeCountBestPracticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainBestPracticeWhereInput
  }

  /**
   * DomainKnowledgeCountOutputType without action
   */
  export type DomainKnowledgeCountOutputTypeCountAntiPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainAntiPatternWhereInput
  }

  /**
   * DomainKnowledgeCountOutputType without action
   */
  export type DomainKnowledgeCountOutputTypeCountReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainReferenceWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
    tasks: number
    documentation: number
    MindMap: number
    Sprint: number
    Requirement: number
    DomainKnowledge: number
    SystemArchitecture: number
    roadmaps: number
    ApiDesign: number
    team: number
    Agent: number
    AgentWorklog: number
    DatabaseSchema: number
    RequirementQuestion: number
    RequirementAttachment: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
    documentation?: boolean | ProjectCountOutputTypeCountDocumentationArgs
    MindMap?: boolean | ProjectCountOutputTypeCountMindMapArgs
    Sprint?: boolean | ProjectCountOutputTypeCountSprintArgs
    Requirement?: boolean | ProjectCountOutputTypeCountRequirementArgs
    DomainKnowledge?: boolean | ProjectCountOutputTypeCountDomainKnowledgeArgs
    SystemArchitecture?: boolean | ProjectCountOutputTypeCountSystemArchitectureArgs
    roadmaps?: boolean | ProjectCountOutputTypeCountRoadmapsArgs
    ApiDesign?: boolean | ProjectCountOutputTypeCountApiDesignArgs
    team?: boolean | ProjectCountOutputTypeCountTeamArgs
    Agent?: boolean | ProjectCountOutputTypeCountAgentArgs
    AgentWorklog?: boolean | ProjectCountOutputTypeCountAgentWorklogArgs
    DatabaseSchema?: boolean | ProjectCountOutputTypeCountDatabaseSchemaArgs
    RequirementQuestion?: boolean | ProjectCountOutputTypeCountRequirementQuestionArgs
    RequirementAttachment?: boolean | ProjectCountOutputTypeCountRequirementAttachmentArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDocumentationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentationWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMindMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MindMapWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDomainKnowledgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainKnowledgeWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSystemArchitectureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemArchitectureWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRoadmapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountApiDesignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiDesignWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAgentWorklogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWorklogWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDatabaseSchemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseSchemaWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRequirementQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementQuestionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountRequirementAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementAttachmentWhereInput
  }


  /**
   * Count Type RequirementCountOutputType
   */

  export type RequirementCountOutputType = {
    children: number
    questions: number
    attachments: number
  }

  export type RequirementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | RequirementCountOutputTypeCountChildrenArgs
    questions?: boolean | RequirementCountOutputTypeCountQuestionsArgs
    attachments?: boolean | RequirementCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementCountOutputType
     */
    select?: RequirementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementQuestionWhereInput
  }

  /**
   * RequirementCountOutputType without action
   */
  export type RequirementCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementAttachmentWhereInput
  }


  /**
   * Count Type RoadmapCountOutputType
   */

  export type RoadmapCountOutputType = {
    milestones: number
    versions: number
  }

  export type RoadmapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestones?: boolean | RoadmapCountOutputTypeCountMilestonesArgs
    versions?: boolean | RoadmapCountOutputTypeCountVersionsArgs
  }

  // Custom InputTypes
  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapCountOutputType
     */
    select?: RoadmapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountMilestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionWhereInput
  }


  /**
   * Count Type MilestoneCountOutputType
   */

  export type MilestoneCountOutputType = {
    features: number
  }

  export type MilestoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | MilestoneCountOutputTypeCountFeaturesArgs
  }

  // Custom InputTypes
  /**
   * MilestoneCountOutputType without action
   */
  export type MilestoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MilestoneCountOutputType
     */
    select?: MilestoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MilestoneCountOutputType without action
   */
  export type MilestoneCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
  }


  /**
   * Count Type VersionCountOutputType
   */

  export type VersionCountOutputType = {
    features: number
  }

  export type VersionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | VersionCountOutputTypeCountFeaturesArgs
  }

  // Custom InputTypes
  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VersionCountOutputType
     */
    select?: VersionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VersionCountOutputType without action
   */
  export type VersionCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
  }


  /**
   * Count Type FeatureCountOutputType
   */

  export type FeatureCountOutputType = {
    tasks: number
  }

  export type FeatureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | FeatureCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeatureCountOutputType
     */
    select?: FeatureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeatureCountOutputType without action
   */
  export type FeatureCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type SprintCountOutputType
   */

  export type SprintCountOutputType = {
    Task: number
  }

  export type SprintCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Task?: boolean | SprintCountOutputTypeCountTaskArgs
  }

  // Custom InputTypes
  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SprintCountOutputType
     */
    select?: SprintCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SprintCountOutputType without action
   */
  export type SprintCountOutputTypeCountTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    AgentTask: number
    AgentWorklog: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AgentTask?: boolean | TaskCountOutputTypeCountAgentTaskArgs
    AgentWorklog?: boolean | TaskCountOutputTypeCountAgentWorklogArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAgentTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTaskWhereInput
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountAgentWorklogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWorklogWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    tasks: number
    agents: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | TeamCountOutputTypeCountTasksArgs
    agents?: boolean | TeamCountOutputTypeCountAgentsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    projects: number
    projectMembers: number
    sessions: number
    auditLogs: number
    DomainKnowledge: number
    DatabaseSchema: number
    Requirement: number
    RequirementAttachment: number
    Documentation: number
    DocumentVersion: number
    DocumentComment: number
    DocumentAttachment: number
    MindMap: number
    ArchitectureChangeHistory: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    projectMembers?: boolean | UserCountOutputTypeCountProjectMembersArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    DomainKnowledge?: boolean | UserCountOutputTypeCountDomainKnowledgeArgs
    DatabaseSchema?: boolean | UserCountOutputTypeCountDatabaseSchemaArgs
    Requirement?: boolean | UserCountOutputTypeCountRequirementArgs
    RequirementAttachment?: boolean | UserCountOutputTypeCountRequirementAttachmentArgs
    Documentation?: boolean | UserCountOutputTypeCountDocumentationArgs
    DocumentVersion?: boolean | UserCountOutputTypeCountDocumentVersionArgs
    DocumentComment?: boolean | UserCountOutputTypeCountDocumentCommentArgs
    DocumentAttachment?: boolean | UserCountOutputTypeCountDocumentAttachmentArgs
    MindMap?: boolean | UserCountOutputTypeCountMindMapArgs
    ArchitectureChangeHistory?: boolean | UserCountOutputTypeCountArchitectureChangeHistoryArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDomainKnowledgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainKnowledgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDatabaseSchemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseSchemaWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequirementAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementAttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAttachmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMindMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MindMapWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArchitectureChangeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchitectureChangeHistoryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    teamId: string | null
    name: string | null
    description: string | null
    workPrompt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    teamId: string | null
    name: string | null
    description: string | null
    workPrompt: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    projectId: number
    teamId: number
    name: number
    description: number
    workPrompt: number
    responsibilities: number
    skills: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentMinAggregateInputType = {
    id?: true
    projectId?: true
    teamId?: true
    name?: true
    description?: true
    workPrompt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    projectId?: true
    teamId?: true
    name?: true
    description?: true
    workPrompt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    projectId?: true
    teamId?: true
    name?: true
    description?: true
    workPrompt?: true
    responsibilities?: true
    skills?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    projectId: string
    teamId: string
    name: string
    description: string | null
    workPrompt: string | null
    responsibilities: string[]
    skills: string[]
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    teamId?: boolean
    name?: boolean
    description?: boolean
    workPrompt?: boolean
    responsibilities?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    AgentActivity?: boolean | Agent$AgentActivityArgs<ExtArgs>
    AgentTask?: boolean | Agent$AgentTaskArgs<ExtArgs>
    AgentWorklog?: boolean | Agent$AgentWorklogArgs<ExtArgs>
    RequirementQuestion?: boolean | Agent$RequirementQuestionArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    teamId?: boolean
    name?: boolean
    description?: boolean
    workPrompt?: boolean
    responsibilities?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    teamId?: boolean
    name?: boolean
    description?: boolean
    workPrompt?: boolean
    responsibilities?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    projectId?: boolean
    teamId?: boolean
    name?: boolean
    description?: boolean
    workPrompt?: boolean
    responsibilities?: boolean
    skills?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "teamId" | "name" | "description" | "workPrompt" | "responsibilities" | "skills" | "createdAt" | "updatedAt", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    AgentActivity?: boolean | Agent$AgentActivityArgs<ExtArgs>
    AgentTask?: boolean | Agent$AgentTaskArgs<ExtArgs>
    AgentWorklog?: boolean | Agent$AgentWorklogArgs<ExtArgs>
    RequirementQuestion?: boolean | Agent$RequirementQuestionArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      AgentActivity: Prisma.$AgentActivityPayload<ExtArgs>[]
      AgentTask: Prisma.$AgentTaskPayload<ExtArgs>[]
      AgentWorklog: Prisma.$AgentWorklogPayload<ExtArgs>[]
      RequirementQuestion: Prisma.$RequirementQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      teamId: string
      name: string
      description: string | null
      workPrompt: string | null
      responsibilities: string[]
      skills: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    AgentActivity<T extends Agent$AgentActivityArgs<ExtArgs> = {}>(args?: Subset<T, Agent$AgentActivityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AgentTask<T extends Agent$AgentTaskArgs<ExtArgs> = {}>(args?: Subset<T, Agent$AgentTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AgentWorklog<T extends Agent$AgentWorklogArgs<ExtArgs> = {}>(args?: Subset<T, Agent$AgentWorklogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RequirementQuestion<T extends Agent$RequirementQuestionArgs<ExtArgs> = {}>(args?: Subset<T, Agent$RequirementQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly projectId: FieldRef<"Agent", 'String'>
    readonly teamId: FieldRef<"Agent", 'String'>
    readonly name: FieldRef<"Agent", 'String'>
    readonly description: FieldRef<"Agent", 'String'>
    readonly workPrompt: FieldRef<"Agent", 'String'>
    readonly responsibilities: FieldRef<"Agent", 'String[]'>
    readonly skills: FieldRef<"Agent", 'String[]'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.AgentActivity
   */
  export type Agent$AgentActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    where?: AgentActivityWhereInput
    orderBy?: AgentActivityOrderByWithRelationInput | AgentActivityOrderByWithRelationInput[]
    cursor?: AgentActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentActivityScalarFieldEnum | AgentActivityScalarFieldEnum[]
  }

  /**
   * Agent.AgentTask
   */
  export type Agent$AgentTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    where?: AgentTaskWhereInput
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    cursor?: AgentTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentTaskScalarFieldEnum | AgentTaskScalarFieldEnum[]
  }

  /**
   * Agent.AgentWorklog
   */
  export type Agent$AgentWorklogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    where?: AgentWorklogWhereInput
    orderBy?: AgentWorklogOrderByWithRelationInput | AgentWorklogOrderByWithRelationInput[]
    cursor?: AgentWorklogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentWorklogScalarFieldEnum | AgentWorklogScalarFieldEnum[]
  }

  /**
   * Agent.RequirementQuestion
   */
  export type Agent$RequirementQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    where?: RequirementQuestionWhereInput
    orderBy?: RequirementQuestionOrderByWithRelationInput | RequirementQuestionOrderByWithRelationInput[]
    cursor?: RequirementQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementQuestionScalarFieldEnum | RequirementQuestionScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model AgentTask
   */

  export type AggregateAgentTask = {
    _count: AgentTaskCountAggregateOutputType | null
    _min: AgentTaskMinAggregateOutputType | null
    _max: AgentTaskMaxAggregateOutputType | null
  }

  export type AgentTaskMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    taskId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentTaskMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    taskId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentTaskCountAggregateOutputType = {
    id: number
    agentId: number
    taskId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentTaskMinAggregateInputType = {
    id?: true
    agentId?: true
    taskId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentTaskMaxAggregateInputType = {
    id?: true
    agentId?: true
    taskId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentTaskCountAggregateInputType = {
    id?: true
    agentId?: true
    taskId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTask to aggregate.
     */
    where?: AgentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTasks to fetch.
     */
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentTasks
    **/
    _count?: true | AgentTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentTaskMaxAggregateInputType
  }

  export type GetAgentTaskAggregateType<T extends AgentTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentTask[P]>
      : GetScalarType<T[P], AggregateAgentTask[P]>
  }




  export type AgentTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentTaskWhereInput
    orderBy?: AgentTaskOrderByWithAggregationInput | AgentTaskOrderByWithAggregationInput[]
    by: AgentTaskScalarFieldEnum[] | AgentTaskScalarFieldEnum
    having?: AgentTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentTaskCountAggregateInputType | true
    _min?: AgentTaskMinAggregateInputType
    _max?: AgentTaskMaxAggregateInputType
  }

  export type AgentTaskGroupByOutputType = {
    id: string
    agentId: string
    taskId: string
    createdAt: Date
    updatedAt: Date
    _count: AgentTaskCountAggregateOutputType | null
    _min: AgentTaskMinAggregateOutputType | null
    _max: AgentTaskMaxAggregateOutputType | null
  }

  type GetAgentTaskGroupByPayload<T extends AgentTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentTaskGroupByOutputType[P]>
            : GetScalarType<T[P], AgentTaskGroupByOutputType[P]>
        }
      >
    >


  export type AgentTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    taskId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTask"]>

  export type AgentTaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    taskId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTask"]>

  export type AgentTaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    taskId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentTask"]>

  export type AgentTaskSelectScalar = {
    id?: boolean
    agentId?: boolean
    taskId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentTaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "taskId" | "createdAt" | "updatedAt", ExtArgs["result"]["agentTask"]>
  export type AgentTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type AgentTaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type AgentTaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $AgentTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentTask"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      taskId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentTask"]>
    composites: {}
  }

  type AgentTaskGetPayload<S extends boolean | null | undefined | AgentTaskDefaultArgs> = $Result.GetResult<Prisma.$AgentTaskPayload, S>

  type AgentTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentTaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentTaskCountAggregateInputType | true
    }

  export interface AgentTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentTask'], meta: { name: 'AgentTask' } }
    /**
     * Find zero or one AgentTask that matches the filter.
     * @param {AgentTaskFindUniqueArgs} args - Arguments to find a AgentTask
     * @example
     * // Get one AgentTask
     * const agentTask = await prisma.agentTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentTaskFindUniqueArgs>(args: SelectSubset<T, AgentTaskFindUniqueArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentTask that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentTaskFindUniqueOrThrowArgs} args - Arguments to find a AgentTask
     * @example
     * // Get one AgentTask
     * const agentTask = await prisma.agentTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskFindFirstArgs} args - Arguments to find a AgentTask
     * @example
     * // Get one AgentTask
     * const agentTask = await prisma.agentTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentTaskFindFirstArgs>(args?: SelectSubset<T, AgentTaskFindFirstArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskFindFirstOrThrowArgs} args - Arguments to find a AgentTask
     * @example
     * // Get one AgentTask
     * const agentTask = await prisma.agentTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentTasks
     * const agentTasks = await prisma.agentTask.findMany()
     * 
     * // Get first 10 AgentTasks
     * const agentTasks = await prisma.agentTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentTaskWithIdOnly = await prisma.agentTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentTaskFindManyArgs>(args?: SelectSubset<T, AgentTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentTask.
     * @param {AgentTaskCreateArgs} args - Arguments to create a AgentTask.
     * @example
     * // Create one AgentTask
     * const AgentTask = await prisma.agentTask.create({
     *   data: {
     *     // ... data to create a AgentTask
     *   }
     * })
     * 
     */
    create<T extends AgentTaskCreateArgs>(args: SelectSubset<T, AgentTaskCreateArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentTasks.
     * @param {AgentTaskCreateManyArgs} args - Arguments to create many AgentTasks.
     * @example
     * // Create many AgentTasks
     * const agentTask = await prisma.agentTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentTaskCreateManyArgs>(args?: SelectSubset<T, AgentTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentTasks and returns the data saved in the database.
     * @param {AgentTaskCreateManyAndReturnArgs} args - Arguments to create many AgentTasks.
     * @example
     * // Create many AgentTasks
     * const agentTask = await prisma.agentTask.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentTasks and only return the `id`
     * const agentTaskWithIdOnly = await prisma.agentTask.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentTaskCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentTaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentTask.
     * @param {AgentTaskDeleteArgs} args - Arguments to delete one AgentTask.
     * @example
     * // Delete one AgentTask
     * const AgentTask = await prisma.agentTask.delete({
     *   where: {
     *     // ... filter to delete one AgentTask
     *   }
     * })
     * 
     */
    delete<T extends AgentTaskDeleteArgs>(args: SelectSubset<T, AgentTaskDeleteArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentTask.
     * @param {AgentTaskUpdateArgs} args - Arguments to update one AgentTask.
     * @example
     * // Update one AgentTask
     * const agentTask = await prisma.agentTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentTaskUpdateArgs>(args: SelectSubset<T, AgentTaskUpdateArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentTasks.
     * @param {AgentTaskDeleteManyArgs} args - Arguments to filter AgentTasks to delete.
     * @example
     * // Delete a few AgentTasks
     * const { count } = await prisma.agentTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentTaskDeleteManyArgs>(args?: SelectSubset<T, AgentTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentTasks
     * const agentTask = await prisma.agentTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentTaskUpdateManyArgs>(args: SelectSubset<T, AgentTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentTasks and returns the data updated in the database.
     * @param {AgentTaskUpdateManyAndReturnArgs} args - Arguments to update many AgentTasks.
     * @example
     * // Update many AgentTasks
     * const agentTask = await prisma.agentTask.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentTasks and only return the `id`
     * const agentTaskWithIdOnly = await prisma.agentTask.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentTaskUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentTaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentTask.
     * @param {AgentTaskUpsertArgs} args - Arguments to update or create a AgentTask.
     * @example
     * // Update or create a AgentTask
     * const agentTask = await prisma.agentTask.upsert({
     *   create: {
     *     // ... data to create a AgentTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentTask we want to update
     *   }
     * })
     */
    upsert<T extends AgentTaskUpsertArgs>(args: SelectSubset<T, AgentTaskUpsertArgs<ExtArgs>>): Prisma__AgentTaskClient<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskCountArgs} args - Arguments to filter AgentTasks to count.
     * @example
     * // Count the number of AgentTasks
     * const count = await prisma.agentTask.count({
     *   where: {
     *     // ... the filter for the AgentTasks we want to count
     *   }
     * })
    **/
    count<T extends AgentTaskCountArgs>(
      args?: Subset<T, AgentTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentTaskAggregateArgs>(args: Subset<T, AgentTaskAggregateArgs>): Prisma.PrismaPromise<GetAgentTaskAggregateType<T>>

    /**
     * Group by AgentTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentTaskGroupByArgs['orderBy'] }
        : { orderBy?: AgentTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentTask model
   */
  readonly fields: AgentTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentTask model
   */
  interface AgentTaskFieldRefs {
    readonly id: FieldRef<"AgentTask", 'String'>
    readonly agentId: FieldRef<"AgentTask", 'String'>
    readonly taskId: FieldRef<"AgentTask", 'String'>
    readonly createdAt: FieldRef<"AgentTask", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentTask findUnique
   */
  export type AgentTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTask to fetch.
     */
    where: AgentTaskWhereUniqueInput
  }

  /**
   * AgentTask findUniqueOrThrow
   */
  export type AgentTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTask to fetch.
     */
    where: AgentTaskWhereUniqueInput
  }

  /**
   * AgentTask findFirst
   */
  export type AgentTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTask to fetch.
     */
    where?: AgentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTasks to fetch.
     */
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTasks.
     */
    cursor?: AgentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTasks.
     */
    distinct?: AgentTaskScalarFieldEnum | AgentTaskScalarFieldEnum[]
  }

  /**
   * AgentTask findFirstOrThrow
   */
  export type AgentTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTask to fetch.
     */
    where?: AgentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTasks to fetch.
     */
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentTasks.
     */
    cursor?: AgentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentTasks.
     */
    distinct?: AgentTaskScalarFieldEnum | AgentTaskScalarFieldEnum[]
  }

  /**
   * AgentTask findMany
   */
  export type AgentTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter, which AgentTasks to fetch.
     */
    where?: AgentTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentTasks to fetch.
     */
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentTasks.
     */
    cursor?: AgentTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentTasks.
     */
    skip?: number
    distinct?: AgentTaskScalarFieldEnum | AgentTaskScalarFieldEnum[]
  }

  /**
   * AgentTask create
   */
  export type AgentTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentTask.
     */
    data: XOR<AgentTaskCreateInput, AgentTaskUncheckedCreateInput>
  }

  /**
   * AgentTask createMany
   */
  export type AgentTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentTasks.
     */
    data: AgentTaskCreateManyInput | AgentTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentTask createManyAndReturn
   */
  export type AgentTaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * The data used to create many AgentTasks.
     */
    data: AgentTaskCreateManyInput | AgentTaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTask update
   */
  export type AgentTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentTask.
     */
    data: XOR<AgentTaskUpdateInput, AgentTaskUncheckedUpdateInput>
    /**
     * Choose, which AgentTask to update.
     */
    where: AgentTaskWhereUniqueInput
  }

  /**
   * AgentTask updateMany
   */
  export type AgentTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentTasks.
     */
    data: XOR<AgentTaskUpdateManyMutationInput, AgentTaskUncheckedUpdateManyInput>
    /**
     * Filter which AgentTasks to update
     */
    where?: AgentTaskWhereInput
    /**
     * Limit how many AgentTasks to update.
     */
    limit?: number
  }

  /**
   * AgentTask updateManyAndReturn
   */
  export type AgentTaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * The data used to update AgentTasks.
     */
    data: XOR<AgentTaskUpdateManyMutationInput, AgentTaskUncheckedUpdateManyInput>
    /**
     * Filter which AgentTasks to update
     */
    where?: AgentTaskWhereInput
    /**
     * Limit how many AgentTasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentTask upsert
   */
  export type AgentTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentTask to update in case it exists.
     */
    where: AgentTaskWhereUniqueInput
    /**
     * In case the AgentTask found by the `where` argument doesn't exist, create a new AgentTask with this data.
     */
    create: XOR<AgentTaskCreateInput, AgentTaskUncheckedCreateInput>
    /**
     * In case the AgentTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentTaskUpdateInput, AgentTaskUncheckedUpdateInput>
  }

  /**
   * AgentTask delete
   */
  export type AgentTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    /**
     * Filter which AgentTask to delete.
     */
    where: AgentTaskWhereUniqueInput
  }

  /**
   * AgentTask deleteMany
   */
  export type AgentTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentTasks to delete
     */
    where?: AgentTaskWhereInput
    /**
     * Limit how many AgentTasks to delete.
     */
    limit?: number
  }

  /**
   * AgentTask without action
   */
  export type AgentTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
  }


  /**
   * Model AgentActivity
   */

  export type AggregateAgentActivity = {
    _count: AgentActivityCountAggregateOutputType | null
    _min: AgentActivityMinAggregateOutputType | null
    _max: AgentActivityMaxAggregateOutputType | null
  }

  export type AgentActivityMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    body: string | null
    action: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentActivityMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    body: string | null
    action: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentActivityCountAggregateOutputType = {
    id: number
    agentId: number
    body: number
    action: number
    details: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentActivityMinAggregateInputType = {
    id?: true
    agentId?: true
    body?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentActivityMaxAggregateInputType = {
    id?: true
    agentId?: true
    body?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentActivityCountAggregateInputType = {
    id?: true
    agentId?: true
    body?: true
    action?: true
    details?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentActivity to aggregate.
     */
    where?: AgentActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentActivities to fetch.
     */
    orderBy?: AgentActivityOrderByWithRelationInput | AgentActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentActivities
    **/
    _count?: true | AgentActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentActivityMaxAggregateInputType
  }

  export type GetAgentActivityAggregateType<T extends AgentActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentActivity[P]>
      : GetScalarType<T[P], AggregateAgentActivity[P]>
  }




  export type AgentActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentActivityWhereInput
    orderBy?: AgentActivityOrderByWithAggregationInput | AgentActivityOrderByWithAggregationInput[]
    by: AgentActivityScalarFieldEnum[] | AgentActivityScalarFieldEnum
    having?: AgentActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentActivityCountAggregateInputType | true
    _min?: AgentActivityMinAggregateInputType
    _max?: AgentActivityMaxAggregateInputType
  }

  export type AgentActivityGroupByOutputType = {
    id: string
    agentId: string
    body: string
    action: string
    details: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AgentActivityCountAggregateOutputType | null
    _min: AgentActivityMinAggregateOutputType | null
    _max: AgentActivityMaxAggregateOutputType | null
  }

  type GetAgentActivityGroupByPayload<T extends AgentActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentActivityGroupByOutputType[P]>
            : GetScalarType<T[P], AgentActivityGroupByOutputType[P]>
        }
      >
    >


  export type AgentActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    body?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentActivity"]>

  export type AgentActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    body?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentActivity"]>

  export type AgentActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    body?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentActivity"]>

  export type AgentActivitySelectScalar = {
    id?: boolean
    agentId?: boolean
    body?: boolean
    action?: boolean
    details?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "body" | "action" | "details" | "createdAt" | "updatedAt", ExtArgs["result"]["agentActivity"]>
  export type AgentActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type AgentActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $AgentActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentActivity"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      body: string
      action: string
      details: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentActivity"]>
    composites: {}
  }

  type AgentActivityGetPayload<S extends boolean | null | undefined | AgentActivityDefaultArgs> = $Result.GetResult<Prisma.$AgentActivityPayload, S>

  type AgentActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentActivityCountAggregateInputType | true
    }

  export interface AgentActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentActivity'], meta: { name: 'AgentActivity' } }
    /**
     * Find zero or one AgentActivity that matches the filter.
     * @param {AgentActivityFindUniqueArgs} args - Arguments to find a AgentActivity
     * @example
     * // Get one AgentActivity
     * const agentActivity = await prisma.agentActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentActivityFindUniqueArgs>(args: SelectSubset<T, AgentActivityFindUniqueArgs<ExtArgs>>): Prisma__AgentActivityClient<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentActivityFindUniqueOrThrowArgs} args - Arguments to find a AgentActivity
     * @example
     * // Get one AgentActivity
     * const agentActivity = await prisma.agentActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentActivityClient<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentActivityFindFirstArgs} args - Arguments to find a AgentActivity
     * @example
     * // Get one AgentActivity
     * const agentActivity = await prisma.agentActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentActivityFindFirstArgs>(args?: SelectSubset<T, AgentActivityFindFirstArgs<ExtArgs>>): Prisma__AgentActivityClient<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentActivityFindFirstOrThrowArgs} args - Arguments to find a AgentActivity
     * @example
     * // Get one AgentActivity
     * const agentActivity = await prisma.agentActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentActivityClient<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentActivities
     * const agentActivities = await prisma.agentActivity.findMany()
     * 
     * // Get first 10 AgentActivities
     * const agentActivities = await prisma.agentActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentActivityWithIdOnly = await prisma.agentActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentActivityFindManyArgs>(args?: SelectSubset<T, AgentActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentActivity.
     * @param {AgentActivityCreateArgs} args - Arguments to create a AgentActivity.
     * @example
     * // Create one AgentActivity
     * const AgentActivity = await prisma.agentActivity.create({
     *   data: {
     *     // ... data to create a AgentActivity
     *   }
     * })
     * 
     */
    create<T extends AgentActivityCreateArgs>(args: SelectSubset<T, AgentActivityCreateArgs<ExtArgs>>): Prisma__AgentActivityClient<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentActivities.
     * @param {AgentActivityCreateManyArgs} args - Arguments to create many AgentActivities.
     * @example
     * // Create many AgentActivities
     * const agentActivity = await prisma.agentActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentActivityCreateManyArgs>(args?: SelectSubset<T, AgentActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentActivities and returns the data saved in the database.
     * @param {AgentActivityCreateManyAndReturnArgs} args - Arguments to create many AgentActivities.
     * @example
     * // Create many AgentActivities
     * const agentActivity = await prisma.agentActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentActivities and only return the `id`
     * const agentActivityWithIdOnly = await prisma.agentActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentActivity.
     * @param {AgentActivityDeleteArgs} args - Arguments to delete one AgentActivity.
     * @example
     * // Delete one AgentActivity
     * const AgentActivity = await prisma.agentActivity.delete({
     *   where: {
     *     // ... filter to delete one AgentActivity
     *   }
     * })
     * 
     */
    delete<T extends AgentActivityDeleteArgs>(args: SelectSubset<T, AgentActivityDeleteArgs<ExtArgs>>): Prisma__AgentActivityClient<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentActivity.
     * @param {AgentActivityUpdateArgs} args - Arguments to update one AgentActivity.
     * @example
     * // Update one AgentActivity
     * const agentActivity = await prisma.agentActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentActivityUpdateArgs>(args: SelectSubset<T, AgentActivityUpdateArgs<ExtArgs>>): Prisma__AgentActivityClient<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentActivities.
     * @param {AgentActivityDeleteManyArgs} args - Arguments to filter AgentActivities to delete.
     * @example
     * // Delete a few AgentActivities
     * const { count } = await prisma.agentActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentActivityDeleteManyArgs>(args?: SelectSubset<T, AgentActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentActivities
     * const agentActivity = await prisma.agentActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentActivityUpdateManyArgs>(args: SelectSubset<T, AgentActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentActivities and returns the data updated in the database.
     * @param {AgentActivityUpdateManyAndReturnArgs} args - Arguments to update many AgentActivities.
     * @example
     * // Update many AgentActivities
     * const agentActivity = await prisma.agentActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentActivities and only return the `id`
     * const agentActivityWithIdOnly = await prisma.agentActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentActivity.
     * @param {AgentActivityUpsertArgs} args - Arguments to update or create a AgentActivity.
     * @example
     * // Update or create a AgentActivity
     * const agentActivity = await prisma.agentActivity.upsert({
     *   create: {
     *     // ... data to create a AgentActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentActivity we want to update
     *   }
     * })
     */
    upsert<T extends AgentActivityUpsertArgs>(args: SelectSubset<T, AgentActivityUpsertArgs<ExtArgs>>): Prisma__AgentActivityClient<$Result.GetResult<Prisma.$AgentActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentActivityCountArgs} args - Arguments to filter AgentActivities to count.
     * @example
     * // Count the number of AgentActivities
     * const count = await prisma.agentActivity.count({
     *   where: {
     *     // ... the filter for the AgentActivities we want to count
     *   }
     * })
    **/
    count<T extends AgentActivityCountArgs>(
      args?: Subset<T, AgentActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentActivityAggregateArgs>(args: Subset<T, AgentActivityAggregateArgs>): Prisma.PrismaPromise<GetAgentActivityAggregateType<T>>

    /**
     * Group by AgentActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentActivityGroupByArgs['orderBy'] }
        : { orderBy?: AgentActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentActivity model
   */
  readonly fields: AgentActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentActivity model
   */
  interface AgentActivityFieldRefs {
    readonly id: FieldRef<"AgentActivity", 'String'>
    readonly agentId: FieldRef<"AgentActivity", 'String'>
    readonly body: FieldRef<"AgentActivity", 'String'>
    readonly action: FieldRef<"AgentActivity", 'String'>
    readonly details: FieldRef<"AgentActivity", 'Json'>
    readonly createdAt: FieldRef<"AgentActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentActivity findUnique
   */
  export type AgentActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    /**
     * Filter, which AgentActivity to fetch.
     */
    where: AgentActivityWhereUniqueInput
  }

  /**
   * AgentActivity findUniqueOrThrow
   */
  export type AgentActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    /**
     * Filter, which AgentActivity to fetch.
     */
    where: AgentActivityWhereUniqueInput
  }

  /**
   * AgentActivity findFirst
   */
  export type AgentActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    /**
     * Filter, which AgentActivity to fetch.
     */
    where?: AgentActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentActivities to fetch.
     */
    orderBy?: AgentActivityOrderByWithRelationInput | AgentActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentActivities.
     */
    cursor?: AgentActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentActivities.
     */
    distinct?: AgentActivityScalarFieldEnum | AgentActivityScalarFieldEnum[]
  }

  /**
   * AgentActivity findFirstOrThrow
   */
  export type AgentActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    /**
     * Filter, which AgentActivity to fetch.
     */
    where?: AgentActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentActivities to fetch.
     */
    orderBy?: AgentActivityOrderByWithRelationInput | AgentActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentActivities.
     */
    cursor?: AgentActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentActivities.
     */
    distinct?: AgentActivityScalarFieldEnum | AgentActivityScalarFieldEnum[]
  }

  /**
   * AgentActivity findMany
   */
  export type AgentActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    /**
     * Filter, which AgentActivities to fetch.
     */
    where?: AgentActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentActivities to fetch.
     */
    orderBy?: AgentActivityOrderByWithRelationInput | AgentActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentActivities.
     */
    cursor?: AgentActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentActivities.
     */
    skip?: number
    distinct?: AgentActivityScalarFieldEnum | AgentActivityScalarFieldEnum[]
  }

  /**
   * AgentActivity create
   */
  export type AgentActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentActivity.
     */
    data: XOR<AgentActivityCreateInput, AgentActivityUncheckedCreateInput>
  }

  /**
   * AgentActivity createMany
   */
  export type AgentActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentActivities.
     */
    data: AgentActivityCreateManyInput | AgentActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentActivity createManyAndReturn
   */
  export type AgentActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * The data used to create many AgentActivities.
     */
    data: AgentActivityCreateManyInput | AgentActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentActivity update
   */
  export type AgentActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentActivity.
     */
    data: XOR<AgentActivityUpdateInput, AgentActivityUncheckedUpdateInput>
    /**
     * Choose, which AgentActivity to update.
     */
    where: AgentActivityWhereUniqueInput
  }

  /**
   * AgentActivity updateMany
   */
  export type AgentActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentActivities.
     */
    data: XOR<AgentActivityUpdateManyMutationInput, AgentActivityUncheckedUpdateManyInput>
    /**
     * Filter which AgentActivities to update
     */
    where?: AgentActivityWhereInput
    /**
     * Limit how many AgentActivities to update.
     */
    limit?: number
  }

  /**
   * AgentActivity updateManyAndReturn
   */
  export type AgentActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * The data used to update AgentActivities.
     */
    data: XOR<AgentActivityUpdateManyMutationInput, AgentActivityUncheckedUpdateManyInput>
    /**
     * Filter which AgentActivities to update
     */
    where?: AgentActivityWhereInput
    /**
     * Limit how many AgentActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentActivity upsert
   */
  export type AgentActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentActivity to update in case it exists.
     */
    where: AgentActivityWhereUniqueInput
    /**
     * In case the AgentActivity found by the `where` argument doesn't exist, create a new AgentActivity with this data.
     */
    create: XOR<AgentActivityCreateInput, AgentActivityUncheckedCreateInput>
    /**
     * In case the AgentActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentActivityUpdateInput, AgentActivityUncheckedUpdateInput>
  }

  /**
   * AgentActivity delete
   */
  export type AgentActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
    /**
     * Filter which AgentActivity to delete.
     */
    where: AgentActivityWhereUniqueInput
  }

  /**
   * AgentActivity deleteMany
   */
  export type AgentActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentActivities to delete
     */
    where?: AgentActivityWhereInput
    /**
     * Limit how many AgentActivities to delete.
     */
    limit?: number
  }

  /**
   * AgentActivity without action
   */
  export type AgentActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentActivity
     */
    select?: AgentActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentActivity
     */
    omit?: AgentActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentActivityInclude<ExtArgs> | null
  }


  /**
   * Model AgentWorklog
   */

  export type AggregateAgentWorklog = {
    _count: AgentWorklogCountAggregateOutputType | null
    _min: AgentWorklogMinAggregateOutputType | null
    _max: AgentWorklogMaxAggregateOutputType | null
  }

  export type AgentWorklogMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    agentId: string | null
    taskId: string | null
    workType: string | null
    summarize: string | null
    nextPlan: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentWorklogMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    agentId: string | null
    taskId: string | null
    workType: string | null
    summarize: string | null
    nextPlan: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentWorklogCountAggregateOutputType = {
    id: number
    projectId: number
    agentId: number
    taskId: number
    workType: number
    summarize: number
    nextPlan: number
    content: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentWorklogMinAggregateInputType = {
    id?: true
    projectId?: true
    agentId?: true
    taskId?: true
    workType?: true
    summarize?: true
    nextPlan?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentWorklogMaxAggregateInputType = {
    id?: true
    projectId?: true
    agentId?: true
    taskId?: true
    workType?: true
    summarize?: true
    nextPlan?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentWorklogCountAggregateInputType = {
    id?: true
    projectId?: true
    agentId?: true
    taskId?: true
    workType?: true
    summarize?: true
    nextPlan?: true
    content?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentWorklogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentWorklog to aggregate.
     */
    where?: AgentWorklogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentWorklogs to fetch.
     */
    orderBy?: AgentWorklogOrderByWithRelationInput | AgentWorklogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWorklogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentWorklogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentWorklogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentWorklogs
    **/
    _count?: true | AgentWorklogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentWorklogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentWorklogMaxAggregateInputType
  }

  export type GetAgentWorklogAggregateType<T extends AgentWorklogAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentWorklog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentWorklog[P]>
      : GetScalarType<T[P], AggregateAgentWorklog[P]>
  }




  export type AgentWorklogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWorklogWhereInput
    orderBy?: AgentWorklogOrderByWithAggregationInput | AgentWorklogOrderByWithAggregationInput[]
    by: AgentWorklogScalarFieldEnum[] | AgentWorklogScalarFieldEnum
    having?: AgentWorklogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentWorklogCountAggregateInputType | true
    _min?: AgentWorklogMinAggregateInputType
    _max?: AgentWorklogMaxAggregateInputType
  }

  export type AgentWorklogGroupByOutputType = {
    id: string
    projectId: string
    agentId: string
    taskId: string
    workType: string
    summarize: string | null
    nextPlan: string | null
    content: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AgentWorklogCountAggregateOutputType | null
    _min: AgentWorklogMinAggregateOutputType | null
    _max: AgentWorklogMaxAggregateOutputType | null
  }

  type GetAgentWorklogGroupByPayload<T extends AgentWorklogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentWorklogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentWorklogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentWorklogGroupByOutputType[P]>
            : GetScalarType<T[P], AgentWorklogGroupByOutputType[P]>
        }
      >
    >


  export type AgentWorklogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    agentId?: boolean
    taskId?: boolean
    workType?: boolean
    summarize?: boolean
    nextPlan?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentWorklog"]>

  export type AgentWorklogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    agentId?: boolean
    taskId?: boolean
    workType?: boolean
    summarize?: boolean
    nextPlan?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentWorklog"]>

  export type AgentWorklogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    agentId?: boolean
    taskId?: boolean
    workType?: boolean
    summarize?: boolean
    nextPlan?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agentWorklog"]>

  export type AgentWorklogSelectScalar = {
    id?: boolean
    projectId?: boolean
    agentId?: boolean
    taskId?: boolean
    workType?: boolean
    summarize?: boolean
    nextPlan?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentWorklogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "agentId" | "taskId" | "workType" | "summarize" | "nextPlan" | "content" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["agentWorklog"]>
  export type AgentWorklogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type AgentWorklogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type AgentWorklogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $AgentWorklogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentWorklog"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      agentId: string
      taskId: string
      workType: string
      summarize: string | null
      nextPlan: string | null
      content: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentWorklog"]>
    composites: {}
  }

  type AgentWorklogGetPayload<S extends boolean | null | undefined | AgentWorklogDefaultArgs> = $Result.GetResult<Prisma.$AgentWorklogPayload, S>

  type AgentWorklogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentWorklogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentWorklogCountAggregateInputType | true
    }

  export interface AgentWorklogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentWorklog'], meta: { name: 'AgentWorklog' } }
    /**
     * Find zero or one AgentWorklog that matches the filter.
     * @param {AgentWorklogFindUniqueArgs} args - Arguments to find a AgentWorklog
     * @example
     * // Get one AgentWorklog
     * const agentWorklog = await prisma.agentWorklog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentWorklogFindUniqueArgs>(args: SelectSubset<T, AgentWorklogFindUniqueArgs<ExtArgs>>): Prisma__AgentWorklogClient<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentWorklog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentWorklogFindUniqueOrThrowArgs} args - Arguments to find a AgentWorklog
     * @example
     * // Get one AgentWorklog
     * const agentWorklog = await prisma.agentWorklog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentWorklogFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentWorklogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentWorklogClient<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentWorklog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWorklogFindFirstArgs} args - Arguments to find a AgentWorklog
     * @example
     * // Get one AgentWorklog
     * const agentWorklog = await prisma.agentWorklog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentWorklogFindFirstArgs>(args?: SelectSubset<T, AgentWorklogFindFirstArgs<ExtArgs>>): Prisma__AgentWorklogClient<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentWorklog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWorklogFindFirstOrThrowArgs} args - Arguments to find a AgentWorklog
     * @example
     * // Get one AgentWorklog
     * const agentWorklog = await prisma.agentWorklog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentWorklogFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentWorklogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentWorklogClient<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentWorklogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWorklogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentWorklogs
     * const agentWorklogs = await prisma.agentWorklog.findMany()
     * 
     * // Get first 10 AgentWorklogs
     * const agentWorklogs = await prisma.agentWorklog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWorklogWithIdOnly = await prisma.agentWorklog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentWorklogFindManyArgs>(args?: SelectSubset<T, AgentWorklogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentWorklog.
     * @param {AgentWorklogCreateArgs} args - Arguments to create a AgentWorklog.
     * @example
     * // Create one AgentWorklog
     * const AgentWorklog = await prisma.agentWorklog.create({
     *   data: {
     *     // ... data to create a AgentWorklog
     *   }
     * })
     * 
     */
    create<T extends AgentWorklogCreateArgs>(args: SelectSubset<T, AgentWorklogCreateArgs<ExtArgs>>): Prisma__AgentWorklogClient<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentWorklogs.
     * @param {AgentWorklogCreateManyArgs} args - Arguments to create many AgentWorklogs.
     * @example
     * // Create many AgentWorklogs
     * const agentWorklog = await prisma.agentWorklog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentWorklogCreateManyArgs>(args?: SelectSubset<T, AgentWorklogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentWorklogs and returns the data saved in the database.
     * @param {AgentWorklogCreateManyAndReturnArgs} args - Arguments to create many AgentWorklogs.
     * @example
     * // Create many AgentWorklogs
     * const agentWorklog = await prisma.agentWorklog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentWorklogs and only return the `id`
     * const agentWorklogWithIdOnly = await prisma.agentWorklog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentWorklogCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentWorklogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentWorklog.
     * @param {AgentWorklogDeleteArgs} args - Arguments to delete one AgentWorklog.
     * @example
     * // Delete one AgentWorklog
     * const AgentWorklog = await prisma.agentWorklog.delete({
     *   where: {
     *     // ... filter to delete one AgentWorklog
     *   }
     * })
     * 
     */
    delete<T extends AgentWorklogDeleteArgs>(args: SelectSubset<T, AgentWorklogDeleteArgs<ExtArgs>>): Prisma__AgentWorklogClient<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentWorklog.
     * @param {AgentWorklogUpdateArgs} args - Arguments to update one AgentWorklog.
     * @example
     * // Update one AgentWorklog
     * const agentWorklog = await prisma.agentWorklog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentWorklogUpdateArgs>(args: SelectSubset<T, AgentWorklogUpdateArgs<ExtArgs>>): Prisma__AgentWorklogClient<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentWorklogs.
     * @param {AgentWorklogDeleteManyArgs} args - Arguments to filter AgentWorklogs to delete.
     * @example
     * // Delete a few AgentWorklogs
     * const { count } = await prisma.agentWorklog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentWorklogDeleteManyArgs>(args?: SelectSubset<T, AgentWorklogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentWorklogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWorklogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentWorklogs
     * const agentWorklog = await prisma.agentWorklog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentWorklogUpdateManyArgs>(args: SelectSubset<T, AgentWorklogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentWorklogs and returns the data updated in the database.
     * @param {AgentWorklogUpdateManyAndReturnArgs} args - Arguments to update many AgentWorklogs.
     * @example
     * // Update many AgentWorklogs
     * const agentWorklog = await prisma.agentWorklog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentWorklogs and only return the `id`
     * const agentWorklogWithIdOnly = await prisma.agentWorklog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentWorklogUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentWorklogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentWorklog.
     * @param {AgentWorklogUpsertArgs} args - Arguments to update or create a AgentWorklog.
     * @example
     * // Update or create a AgentWorklog
     * const agentWorklog = await prisma.agentWorklog.upsert({
     *   create: {
     *     // ... data to create a AgentWorklog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentWorklog we want to update
     *   }
     * })
     */
    upsert<T extends AgentWorklogUpsertArgs>(args: SelectSubset<T, AgentWorklogUpsertArgs<ExtArgs>>): Prisma__AgentWorklogClient<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentWorklogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWorklogCountArgs} args - Arguments to filter AgentWorklogs to count.
     * @example
     * // Count the number of AgentWorklogs
     * const count = await prisma.agentWorklog.count({
     *   where: {
     *     // ... the filter for the AgentWorklogs we want to count
     *   }
     * })
    **/
    count<T extends AgentWorklogCountArgs>(
      args?: Subset<T, AgentWorklogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentWorklogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentWorklog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWorklogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentWorklogAggregateArgs>(args: Subset<T, AgentWorklogAggregateArgs>): Prisma.PrismaPromise<GetAgentWorklogAggregateType<T>>

    /**
     * Group by AgentWorklog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentWorklogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentWorklogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentWorklogGroupByArgs['orderBy'] }
        : { orderBy?: AgentWorklogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentWorklogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentWorklogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentWorklog model
   */
  readonly fields: AgentWorklogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentWorklog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentWorklogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentWorklog model
   */
  interface AgentWorklogFieldRefs {
    readonly id: FieldRef<"AgentWorklog", 'String'>
    readonly projectId: FieldRef<"AgentWorklog", 'String'>
    readonly agentId: FieldRef<"AgentWorklog", 'String'>
    readonly taskId: FieldRef<"AgentWorklog", 'String'>
    readonly workType: FieldRef<"AgentWorklog", 'String'>
    readonly summarize: FieldRef<"AgentWorklog", 'String'>
    readonly nextPlan: FieldRef<"AgentWorklog", 'String'>
    readonly content: FieldRef<"AgentWorklog", 'String'>
    readonly metadata: FieldRef<"AgentWorklog", 'Json'>
    readonly createdAt: FieldRef<"AgentWorklog", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentWorklog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentWorklog findUnique
   */
  export type AgentWorklogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    /**
     * Filter, which AgentWorklog to fetch.
     */
    where: AgentWorklogWhereUniqueInput
  }

  /**
   * AgentWorklog findUniqueOrThrow
   */
  export type AgentWorklogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    /**
     * Filter, which AgentWorklog to fetch.
     */
    where: AgentWorklogWhereUniqueInput
  }

  /**
   * AgentWorklog findFirst
   */
  export type AgentWorklogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    /**
     * Filter, which AgentWorklog to fetch.
     */
    where?: AgentWorklogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentWorklogs to fetch.
     */
    orderBy?: AgentWorklogOrderByWithRelationInput | AgentWorklogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentWorklogs.
     */
    cursor?: AgentWorklogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentWorklogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentWorklogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentWorklogs.
     */
    distinct?: AgentWorklogScalarFieldEnum | AgentWorklogScalarFieldEnum[]
  }

  /**
   * AgentWorklog findFirstOrThrow
   */
  export type AgentWorklogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    /**
     * Filter, which AgentWorklog to fetch.
     */
    where?: AgentWorklogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentWorklogs to fetch.
     */
    orderBy?: AgentWorklogOrderByWithRelationInput | AgentWorklogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentWorklogs.
     */
    cursor?: AgentWorklogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentWorklogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentWorklogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentWorklogs.
     */
    distinct?: AgentWorklogScalarFieldEnum | AgentWorklogScalarFieldEnum[]
  }

  /**
   * AgentWorklog findMany
   */
  export type AgentWorklogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    /**
     * Filter, which AgentWorklogs to fetch.
     */
    where?: AgentWorklogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentWorklogs to fetch.
     */
    orderBy?: AgentWorklogOrderByWithRelationInput | AgentWorklogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentWorklogs.
     */
    cursor?: AgentWorklogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentWorklogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentWorklogs.
     */
    skip?: number
    distinct?: AgentWorklogScalarFieldEnum | AgentWorklogScalarFieldEnum[]
  }

  /**
   * AgentWorklog create
   */
  export type AgentWorklogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    /**
     * The data needed to create a AgentWorklog.
     */
    data: XOR<AgentWorklogCreateInput, AgentWorklogUncheckedCreateInput>
  }

  /**
   * AgentWorklog createMany
   */
  export type AgentWorklogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentWorklogs.
     */
    data: AgentWorklogCreateManyInput | AgentWorklogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentWorklog createManyAndReturn
   */
  export type AgentWorklogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * The data used to create many AgentWorklogs.
     */
    data: AgentWorklogCreateManyInput | AgentWorklogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentWorklog update
   */
  export type AgentWorklogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    /**
     * The data needed to update a AgentWorklog.
     */
    data: XOR<AgentWorklogUpdateInput, AgentWorklogUncheckedUpdateInput>
    /**
     * Choose, which AgentWorklog to update.
     */
    where: AgentWorklogWhereUniqueInput
  }

  /**
   * AgentWorklog updateMany
   */
  export type AgentWorklogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentWorklogs.
     */
    data: XOR<AgentWorklogUpdateManyMutationInput, AgentWorklogUncheckedUpdateManyInput>
    /**
     * Filter which AgentWorklogs to update
     */
    where?: AgentWorklogWhereInput
    /**
     * Limit how many AgentWorklogs to update.
     */
    limit?: number
  }

  /**
   * AgentWorklog updateManyAndReturn
   */
  export type AgentWorklogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * The data used to update AgentWorklogs.
     */
    data: XOR<AgentWorklogUpdateManyMutationInput, AgentWorklogUncheckedUpdateManyInput>
    /**
     * Filter which AgentWorklogs to update
     */
    where?: AgentWorklogWhereInput
    /**
     * Limit how many AgentWorklogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AgentWorklog upsert
   */
  export type AgentWorklogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    /**
     * The filter to search for the AgentWorklog to update in case it exists.
     */
    where: AgentWorklogWhereUniqueInput
    /**
     * In case the AgentWorklog found by the `where` argument doesn't exist, create a new AgentWorklog with this data.
     */
    create: XOR<AgentWorklogCreateInput, AgentWorklogUncheckedCreateInput>
    /**
     * In case the AgentWorklog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentWorklogUpdateInput, AgentWorklogUncheckedUpdateInput>
  }

  /**
   * AgentWorklog delete
   */
  export type AgentWorklogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    /**
     * Filter which AgentWorklog to delete.
     */
    where: AgentWorklogWhereUniqueInput
  }

  /**
   * AgentWorklog deleteMany
   */
  export type AgentWorklogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentWorklogs to delete
     */
    where?: AgentWorklogWhereInput
    /**
     * Limit how many AgentWorklogs to delete.
     */
    limit?: number
  }

  /**
   * AgentWorklog without action
   */
  export type AgentWorklogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
  }


  /**
   * Model AgentPromptTemplate
   */

  export type AggregateAgentPromptTemplate = {
    _count: AgentPromptTemplateCountAggregateOutputType | null
    _min: AgentPromptTemplateMinAggregateOutputType | null
    _max: AgentPromptTemplateMaxAggregateOutputType | null
  }

  export type AgentPromptTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    responsibility: string | null
    prompt: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentPromptTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    responsibility: string | null
    prompt: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentPromptTemplateCountAggregateOutputType = {
    id: number
    name: number
    responsibility: number
    prompt: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentPromptTemplateMinAggregateInputType = {
    id?: true
    name?: true
    responsibility?: true
    prompt?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentPromptTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    responsibility?: true
    prompt?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentPromptTemplateCountAggregateInputType = {
    id?: true
    name?: true
    responsibility?: true
    prompt?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentPromptTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentPromptTemplate to aggregate.
     */
    where?: AgentPromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentPromptTemplates to fetch.
     */
    orderBy?: AgentPromptTemplateOrderByWithRelationInput | AgentPromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentPromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentPromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentPromptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AgentPromptTemplates
    **/
    _count?: true | AgentPromptTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentPromptTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentPromptTemplateMaxAggregateInputType
  }

  export type GetAgentPromptTemplateAggregateType<T extends AgentPromptTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateAgentPromptTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgentPromptTemplate[P]>
      : GetScalarType<T[P], AggregateAgentPromptTemplate[P]>
  }




  export type AgentPromptTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentPromptTemplateWhereInput
    orderBy?: AgentPromptTemplateOrderByWithAggregationInput | AgentPromptTemplateOrderByWithAggregationInput[]
    by: AgentPromptTemplateScalarFieldEnum[] | AgentPromptTemplateScalarFieldEnum
    having?: AgentPromptTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentPromptTemplateCountAggregateInputType | true
    _min?: AgentPromptTemplateMinAggregateInputType
    _max?: AgentPromptTemplateMaxAggregateInputType
  }

  export type AgentPromptTemplateGroupByOutputType = {
    id: string
    name: string
    responsibility: string
    prompt: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AgentPromptTemplateCountAggregateOutputType | null
    _min: AgentPromptTemplateMinAggregateOutputType | null
    _max: AgentPromptTemplateMaxAggregateOutputType | null
  }

  type GetAgentPromptTemplateGroupByPayload<T extends AgentPromptTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentPromptTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentPromptTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentPromptTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], AgentPromptTemplateGroupByOutputType[P]>
        }
      >
    >


  export type AgentPromptTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    responsibility?: boolean
    prompt?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentPromptTemplate"]>

  export type AgentPromptTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    responsibility?: boolean
    prompt?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentPromptTemplate"]>

  export type AgentPromptTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    responsibility?: boolean
    prompt?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agentPromptTemplate"]>

  export type AgentPromptTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    responsibility?: boolean
    prompt?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentPromptTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "responsibility" | "prompt" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["agentPromptTemplate"]>

  export type $AgentPromptTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AgentPromptTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      responsibility: string
      prompt: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agentPromptTemplate"]>
    composites: {}
  }

  type AgentPromptTemplateGetPayload<S extends boolean | null | undefined | AgentPromptTemplateDefaultArgs> = $Result.GetResult<Prisma.$AgentPromptTemplatePayload, S>

  type AgentPromptTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentPromptTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentPromptTemplateCountAggregateInputType | true
    }

  export interface AgentPromptTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AgentPromptTemplate'], meta: { name: 'AgentPromptTemplate' } }
    /**
     * Find zero or one AgentPromptTemplate that matches the filter.
     * @param {AgentPromptTemplateFindUniqueArgs} args - Arguments to find a AgentPromptTemplate
     * @example
     * // Get one AgentPromptTemplate
     * const agentPromptTemplate = await prisma.agentPromptTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentPromptTemplateFindUniqueArgs>(args: SelectSubset<T, AgentPromptTemplateFindUniqueArgs<ExtArgs>>): Prisma__AgentPromptTemplateClient<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AgentPromptTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentPromptTemplateFindUniqueOrThrowArgs} args - Arguments to find a AgentPromptTemplate
     * @example
     * // Get one AgentPromptTemplate
     * const agentPromptTemplate = await prisma.agentPromptTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentPromptTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentPromptTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentPromptTemplateClient<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentPromptTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPromptTemplateFindFirstArgs} args - Arguments to find a AgentPromptTemplate
     * @example
     * // Get one AgentPromptTemplate
     * const agentPromptTemplate = await prisma.agentPromptTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentPromptTemplateFindFirstArgs>(args?: SelectSubset<T, AgentPromptTemplateFindFirstArgs<ExtArgs>>): Prisma__AgentPromptTemplateClient<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AgentPromptTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPromptTemplateFindFirstOrThrowArgs} args - Arguments to find a AgentPromptTemplate
     * @example
     * // Get one AgentPromptTemplate
     * const agentPromptTemplate = await prisma.agentPromptTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentPromptTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentPromptTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentPromptTemplateClient<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AgentPromptTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPromptTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AgentPromptTemplates
     * const agentPromptTemplates = await prisma.agentPromptTemplate.findMany()
     * 
     * // Get first 10 AgentPromptTemplates
     * const agentPromptTemplates = await prisma.agentPromptTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentPromptTemplateWithIdOnly = await prisma.agentPromptTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentPromptTemplateFindManyArgs>(args?: SelectSubset<T, AgentPromptTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AgentPromptTemplate.
     * @param {AgentPromptTemplateCreateArgs} args - Arguments to create a AgentPromptTemplate.
     * @example
     * // Create one AgentPromptTemplate
     * const AgentPromptTemplate = await prisma.agentPromptTemplate.create({
     *   data: {
     *     // ... data to create a AgentPromptTemplate
     *   }
     * })
     * 
     */
    create<T extends AgentPromptTemplateCreateArgs>(args: SelectSubset<T, AgentPromptTemplateCreateArgs<ExtArgs>>): Prisma__AgentPromptTemplateClient<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AgentPromptTemplates.
     * @param {AgentPromptTemplateCreateManyArgs} args - Arguments to create many AgentPromptTemplates.
     * @example
     * // Create many AgentPromptTemplates
     * const agentPromptTemplate = await prisma.agentPromptTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentPromptTemplateCreateManyArgs>(args?: SelectSubset<T, AgentPromptTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AgentPromptTemplates and returns the data saved in the database.
     * @param {AgentPromptTemplateCreateManyAndReturnArgs} args - Arguments to create many AgentPromptTemplates.
     * @example
     * // Create many AgentPromptTemplates
     * const agentPromptTemplate = await prisma.agentPromptTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AgentPromptTemplates and only return the `id`
     * const agentPromptTemplateWithIdOnly = await prisma.agentPromptTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentPromptTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentPromptTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AgentPromptTemplate.
     * @param {AgentPromptTemplateDeleteArgs} args - Arguments to delete one AgentPromptTemplate.
     * @example
     * // Delete one AgentPromptTemplate
     * const AgentPromptTemplate = await prisma.agentPromptTemplate.delete({
     *   where: {
     *     // ... filter to delete one AgentPromptTemplate
     *   }
     * })
     * 
     */
    delete<T extends AgentPromptTemplateDeleteArgs>(args: SelectSubset<T, AgentPromptTemplateDeleteArgs<ExtArgs>>): Prisma__AgentPromptTemplateClient<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AgentPromptTemplate.
     * @param {AgentPromptTemplateUpdateArgs} args - Arguments to update one AgentPromptTemplate.
     * @example
     * // Update one AgentPromptTemplate
     * const agentPromptTemplate = await prisma.agentPromptTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentPromptTemplateUpdateArgs>(args: SelectSubset<T, AgentPromptTemplateUpdateArgs<ExtArgs>>): Prisma__AgentPromptTemplateClient<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AgentPromptTemplates.
     * @param {AgentPromptTemplateDeleteManyArgs} args - Arguments to filter AgentPromptTemplates to delete.
     * @example
     * // Delete a few AgentPromptTemplates
     * const { count } = await prisma.agentPromptTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentPromptTemplateDeleteManyArgs>(args?: SelectSubset<T, AgentPromptTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentPromptTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPromptTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AgentPromptTemplates
     * const agentPromptTemplate = await prisma.agentPromptTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentPromptTemplateUpdateManyArgs>(args: SelectSubset<T, AgentPromptTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AgentPromptTemplates and returns the data updated in the database.
     * @param {AgentPromptTemplateUpdateManyAndReturnArgs} args - Arguments to update many AgentPromptTemplates.
     * @example
     * // Update many AgentPromptTemplates
     * const agentPromptTemplate = await prisma.agentPromptTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AgentPromptTemplates and only return the `id`
     * const agentPromptTemplateWithIdOnly = await prisma.agentPromptTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentPromptTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentPromptTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AgentPromptTemplate.
     * @param {AgentPromptTemplateUpsertArgs} args - Arguments to update or create a AgentPromptTemplate.
     * @example
     * // Update or create a AgentPromptTemplate
     * const agentPromptTemplate = await prisma.agentPromptTemplate.upsert({
     *   create: {
     *     // ... data to create a AgentPromptTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AgentPromptTemplate we want to update
     *   }
     * })
     */
    upsert<T extends AgentPromptTemplateUpsertArgs>(args: SelectSubset<T, AgentPromptTemplateUpsertArgs<ExtArgs>>): Prisma__AgentPromptTemplateClient<$Result.GetResult<Prisma.$AgentPromptTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AgentPromptTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPromptTemplateCountArgs} args - Arguments to filter AgentPromptTemplates to count.
     * @example
     * // Count the number of AgentPromptTemplates
     * const count = await prisma.agentPromptTemplate.count({
     *   where: {
     *     // ... the filter for the AgentPromptTemplates we want to count
     *   }
     * })
    **/
    count<T extends AgentPromptTemplateCountArgs>(
      args?: Subset<T, AgentPromptTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentPromptTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AgentPromptTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPromptTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentPromptTemplateAggregateArgs>(args: Subset<T, AgentPromptTemplateAggregateArgs>): Prisma.PrismaPromise<GetAgentPromptTemplateAggregateType<T>>

    /**
     * Group by AgentPromptTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentPromptTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentPromptTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentPromptTemplateGroupByArgs['orderBy'] }
        : { orderBy?: AgentPromptTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentPromptTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentPromptTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AgentPromptTemplate model
   */
  readonly fields: AgentPromptTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AgentPromptTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentPromptTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AgentPromptTemplate model
   */
  interface AgentPromptTemplateFieldRefs {
    readonly id: FieldRef<"AgentPromptTemplate", 'String'>
    readonly name: FieldRef<"AgentPromptTemplate", 'String'>
    readonly responsibility: FieldRef<"AgentPromptTemplate", 'String'>
    readonly prompt: FieldRef<"AgentPromptTemplate", 'String'>
    readonly description: FieldRef<"AgentPromptTemplate", 'String'>
    readonly isActive: FieldRef<"AgentPromptTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"AgentPromptTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"AgentPromptTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AgentPromptTemplate findUnique
   */
  export type AgentPromptTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AgentPromptTemplate to fetch.
     */
    where: AgentPromptTemplateWhereUniqueInput
  }

  /**
   * AgentPromptTemplate findUniqueOrThrow
   */
  export type AgentPromptTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AgentPromptTemplate to fetch.
     */
    where: AgentPromptTemplateWhereUniqueInput
  }

  /**
   * AgentPromptTemplate findFirst
   */
  export type AgentPromptTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AgentPromptTemplate to fetch.
     */
    where?: AgentPromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentPromptTemplates to fetch.
     */
    orderBy?: AgentPromptTemplateOrderByWithRelationInput | AgentPromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentPromptTemplates.
     */
    cursor?: AgentPromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentPromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentPromptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentPromptTemplates.
     */
    distinct?: AgentPromptTemplateScalarFieldEnum | AgentPromptTemplateScalarFieldEnum[]
  }

  /**
   * AgentPromptTemplate findFirstOrThrow
   */
  export type AgentPromptTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AgentPromptTemplate to fetch.
     */
    where?: AgentPromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentPromptTemplates to fetch.
     */
    orderBy?: AgentPromptTemplateOrderByWithRelationInput | AgentPromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AgentPromptTemplates.
     */
    cursor?: AgentPromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentPromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentPromptTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AgentPromptTemplates.
     */
    distinct?: AgentPromptTemplateScalarFieldEnum | AgentPromptTemplateScalarFieldEnum[]
  }

  /**
   * AgentPromptTemplate findMany
   */
  export type AgentPromptTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter, which AgentPromptTemplates to fetch.
     */
    where?: AgentPromptTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AgentPromptTemplates to fetch.
     */
    orderBy?: AgentPromptTemplateOrderByWithRelationInput | AgentPromptTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AgentPromptTemplates.
     */
    cursor?: AgentPromptTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AgentPromptTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AgentPromptTemplates.
     */
    skip?: number
    distinct?: AgentPromptTemplateScalarFieldEnum | AgentPromptTemplateScalarFieldEnum[]
  }

  /**
   * AgentPromptTemplate create
   */
  export type AgentPromptTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * The data needed to create a AgentPromptTemplate.
     */
    data: XOR<AgentPromptTemplateCreateInput, AgentPromptTemplateUncheckedCreateInput>
  }

  /**
   * AgentPromptTemplate createMany
   */
  export type AgentPromptTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AgentPromptTemplates.
     */
    data: AgentPromptTemplateCreateManyInput | AgentPromptTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentPromptTemplate createManyAndReturn
   */
  export type AgentPromptTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many AgentPromptTemplates.
     */
    data: AgentPromptTemplateCreateManyInput | AgentPromptTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AgentPromptTemplate update
   */
  export type AgentPromptTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * The data needed to update a AgentPromptTemplate.
     */
    data: XOR<AgentPromptTemplateUpdateInput, AgentPromptTemplateUncheckedUpdateInput>
    /**
     * Choose, which AgentPromptTemplate to update.
     */
    where: AgentPromptTemplateWhereUniqueInput
  }

  /**
   * AgentPromptTemplate updateMany
   */
  export type AgentPromptTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AgentPromptTemplates.
     */
    data: XOR<AgentPromptTemplateUpdateManyMutationInput, AgentPromptTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AgentPromptTemplates to update
     */
    where?: AgentPromptTemplateWhereInput
    /**
     * Limit how many AgentPromptTemplates to update.
     */
    limit?: number
  }

  /**
   * AgentPromptTemplate updateManyAndReturn
   */
  export type AgentPromptTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * The data used to update AgentPromptTemplates.
     */
    data: XOR<AgentPromptTemplateUpdateManyMutationInput, AgentPromptTemplateUncheckedUpdateManyInput>
    /**
     * Filter which AgentPromptTemplates to update
     */
    where?: AgentPromptTemplateWhereInput
    /**
     * Limit how many AgentPromptTemplates to update.
     */
    limit?: number
  }

  /**
   * AgentPromptTemplate upsert
   */
  export type AgentPromptTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * The filter to search for the AgentPromptTemplate to update in case it exists.
     */
    where: AgentPromptTemplateWhereUniqueInput
    /**
     * In case the AgentPromptTemplate found by the `where` argument doesn't exist, create a new AgentPromptTemplate with this data.
     */
    create: XOR<AgentPromptTemplateCreateInput, AgentPromptTemplateUncheckedCreateInput>
    /**
     * In case the AgentPromptTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentPromptTemplateUpdateInput, AgentPromptTemplateUncheckedUpdateInput>
  }

  /**
   * AgentPromptTemplate delete
   */
  export type AgentPromptTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
    /**
     * Filter which AgentPromptTemplate to delete.
     */
    where: AgentPromptTemplateWhereUniqueInput
  }

  /**
   * AgentPromptTemplate deleteMany
   */
  export type AgentPromptTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AgentPromptTemplates to delete
     */
    where?: AgentPromptTemplateWhereInput
    /**
     * Limit how many AgentPromptTemplates to delete.
     */
    limit?: number
  }

  /**
   * AgentPromptTemplate without action
   */
  export type AgentPromptTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentPromptTemplate
     */
    select?: AgentPromptTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentPromptTemplate
     */
    omit?: AgentPromptTemplateOmit<ExtArgs> | null
  }


  /**
   * Model ApiDesign
   */

  export type AggregateApiDesign = {
    _count: ApiDesignCountAggregateOutputType | null
    _avg: ApiDesignAvgAggregateOutputType | null
    _sum: ApiDesignSumAggregateOutputType | null
    _min: ApiDesignMinAggregateOutputType | null
    _max: ApiDesignMaxAggregateOutputType | null
  }

  export type ApiDesignAvgAggregateOutputType = {
    rateLimit: number | null
    timeout: number | null
    maxPayloadSize: number | null
    version: number | null
  }

  export type ApiDesignSumAggregateOutputType = {
    rateLimit: number | null
    timeout: number | null
    maxPayloadSize: number | null
    version: number | null
  }

  export type ApiDesignMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    apiName: string | null
    apiPath: string | null
    apiMethod: $Enums.ApiMethod | null
    apiVersion: string | null
    platform: string | null
    module: string | null
    apiDescription: string | null
    businessLogic: string | null
    apiContentType: $Enums.ApiContentType | null
    authentication: $Enums.ApiAuthType | null
    rateLimit: number | null
    timeout: number | null
    maxPayloadSize: number | null
    status: $Enums.ApiStatus | null
    deprecated: boolean | null
    deprecationDate: Date | null
    sunsetDate: Date | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ApiDesignMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    apiName: string | null
    apiPath: string | null
    apiMethod: $Enums.ApiMethod | null
    apiVersion: string | null
    platform: string | null
    module: string | null
    apiDescription: string | null
    businessLogic: string | null
    apiContentType: $Enums.ApiContentType | null
    authentication: $Enums.ApiAuthType | null
    rateLimit: number | null
    timeout: number | null
    maxPayloadSize: number | null
    status: $Enums.ApiStatus | null
    deprecated: boolean | null
    deprecationDate: Date | null
    sunsetDate: Date | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ApiDesignCountAggregateOutputType = {
    id: number
    projectId: number
    apiName: number
    apiPath: number
    apiMethod: number
    apiVersion: number
    platform: number
    module: number
    apiDescription: number
    businessLogic: number
    apiContentType: number
    requestHeaders: number
    requestParams: number
    requestBody: number
    responseHeaders: number
    responseBody: number
    authentication: number
    authDetails: number
    permissions: number
    rateLimit: number
    timeout: number
    maxPayloadSize: number
    status: number
    deprecated: number
    deprecationDate: number
    sunsetDate: number
    version: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ApiDesignAvgAggregateInputType = {
    rateLimit?: true
    timeout?: true
    maxPayloadSize?: true
    version?: true
  }

  export type ApiDesignSumAggregateInputType = {
    rateLimit?: true
    timeout?: true
    maxPayloadSize?: true
    version?: true
  }

  export type ApiDesignMinAggregateInputType = {
    id?: true
    projectId?: true
    apiName?: true
    apiPath?: true
    apiMethod?: true
    apiVersion?: true
    platform?: true
    module?: true
    apiDescription?: true
    businessLogic?: true
    apiContentType?: true
    authentication?: true
    rateLimit?: true
    timeout?: true
    maxPayloadSize?: true
    status?: true
    deprecated?: true
    deprecationDate?: true
    sunsetDate?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ApiDesignMaxAggregateInputType = {
    id?: true
    projectId?: true
    apiName?: true
    apiPath?: true
    apiMethod?: true
    apiVersion?: true
    platform?: true
    module?: true
    apiDescription?: true
    businessLogic?: true
    apiContentType?: true
    authentication?: true
    rateLimit?: true
    timeout?: true
    maxPayloadSize?: true
    status?: true
    deprecated?: true
    deprecationDate?: true
    sunsetDate?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ApiDesignCountAggregateInputType = {
    id?: true
    projectId?: true
    apiName?: true
    apiPath?: true
    apiMethod?: true
    apiVersion?: true
    platform?: true
    module?: true
    apiDescription?: true
    businessLogic?: true
    apiContentType?: true
    requestHeaders?: true
    requestParams?: true
    requestBody?: true
    responseHeaders?: true
    responseBody?: true
    authentication?: true
    authDetails?: true
    permissions?: true
    rateLimit?: true
    timeout?: true
    maxPayloadSize?: true
    status?: true
    deprecated?: true
    deprecationDate?: true
    sunsetDate?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ApiDesignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiDesign to aggregate.
     */
    where?: ApiDesignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiDesigns to fetch.
     */
    orderBy?: ApiDesignOrderByWithRelationInput | ApiDesignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiDesignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiDesigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiDesigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiDesigns
    **/
    _count?: true | ApiDesignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiDesignAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiDesignSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiDesignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiDesignMaxAggregateInputType
  }

  export type GetApiDesignAggregateType<T extends ApiDesignAggregateArgs> = {
        [P in keyof T & keyof AggregateApiDesign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiDesign[P]>
      : GetScalarType<T[P], AggregateApiDesign[P]>
  }




  export type ApiDesignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiDesignWhereInput
    orderBy?: ApiDesignOrderByWithAggregationInput | ApiDesignOrderByWithAggregationInput[]
    by: ApiDesignScalarFieldEnum[] | ApiDesignScalarFieldEnum
    having?: ApiDesignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiDesignCountAggregateInputType | true
    _avg?: ApiDesignAvgAggregateInputType
    _sum?: ApiDesignSumAggregateInputType
    _min?: ApiDesignMinAggregateInputType
    _max?: ApiDesignMaxAggregateInputType
  }

  export type ApiDesignGroupByOutputType = {
    id: string
    projectId: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion: string
    platform: string
    module: string | null
    apiDescription: string
    businessLogic: string | null
    apiContentType: $Enums.ApiContentType
    requestHeaders: JsonValue | null
    requestParams: JsonValue | null
    requestBody: JsonValue | null
    responseHeaders: JsonValue | null
    responseBody: JsonValue | null
    authentication: $Enums.ApiAuthType
    authDetails: JsonValue | null
    permissions: string[]
    rateLimit: number | null
    timeout: number | null
    maxPayloadSize: number | null
    status: $Enums.ApiStatus
    deprecated: boolean
    deprecationDate: Date | null
    sunsetDate: Date | null
    version: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ApiDesignCountAggregateOutputType | null
    _avg: ApiDesignAvgAggregateOutputType | null
    _sum: ApiDesignSumAggregateOutputType | null
    _min: ApiDesignMinAggregateOutputType | null
    _max: ApiDesignMaxAggregateOutputType | null
  }

  type GetApiDesignGroupByPayload<T extends ApiDesignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiDesignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiDesignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiDesignGroupByOutputType[P]>
            : GetScalarType<T[P], ApiDesignGroupByOutputType[P]>
        }
      >
    >


  export type ApiDesignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    apiName?: boolean
    apiPath?: boolean
    apiMethod?: boolean
    apiVersion?: boolean
    platform?: boolean
    module?: boolean
    apiDescription?: boolean
    businessLogic?: boolean
    apiContentType?: boolean
    requestHeaders?: boolean
    requestParams?: boolean
    requestBody?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    authentication?: boolean
    authDetails?: boolean
    permissions?: boolean
    rateLimit?: boolean
    timeout?: boolean
    maxPayloadSize?: boolean
    status?: boolean
    deprecated?: boolean
    deprecationDate?: boolean
    sunsetDate?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    examples?: boolean | ApiDesign$examplesArgs<ExtArgs>
    errorCodes?: boolean | ApiDesign$errorCodesArgs<ExtArgs>
    _count?: boolean | ApiDesignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiDesign"]>

  export type ApiDesignSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    apiName?: boolean
    apiPath?: boolean
    apiMethod?: boolean
    apiVersion?: boolean
    platform?: boolean
    module?: boolean
    apiDescription?: boolean
    businessLogic?: boolean
    apiContentType?: boolean
    requestHeaders?: boolean
    requestParams?: boolean
    requestBody?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    authentication?: boolean
    authDetails?: boolean
    permissions?: boolean
    rateLimit?: boolean
    timeout?: boolean
    maxPayloadSize?: boolean
    status?: boolean
    deprecated?: boolean
    deprecationDate?: boolean
    sunsetDate?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiDesign"]>

  export type ApiDesignSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    apiName?: boolean
    apiPath?: boolean
    apiMethod?: boolean
    apiVersion?: boolean
    platform?: boolean
    module?: boolean
    apiDescription?: boolean
    businessLogic?: boolean
    apiContentType?: boolean
    requestHeaders?: boolean
    requestParams?: boolean
    requestBody?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    authentication?: boolean
    authDetails?: boolean
    permissions?: boolean
    rateLimit?: boolean
    timeout?: boolean
    maxPayloadSize?: boolean
    status?: boolean
    deprecated?: boolean
    deprecationDate?: boolean
    sunsetDate?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiDesign"]>

  export type ApiDesignSelectScalar = {
    id?: boolean
    projectId?: boolean
    apiName?: boolean
    apiPath?: boolean
    apiMethod?: boolean
    apiVersion?: boolean
    platform?: boolean
    module?: boolean
    apiDescription?: boolean
    businessLogic?: boolean
    apiContentType?: boolean
    requestHeaders?: boolean
    requestParams?: boolean
    requestBody?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    authentication?: boolean
    authDetails?: boolean
    permissions?: boolean
    rateLimit?: boolean
    timeout?: boolean
    maxPayloadSize?: boolean
    status?: boolean
    deprecated?: boolean
    deprecationDate?: boolean
    sunsetDate?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ApiDesignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "apiName" | "apiPath" | "apiMethod" | "apiVersion" | "platform" | "module" | "apiDescription" | "businessLogic" | "apiContentType" | "requestHeaders" | "requestParams" | "requestBody" | "responseHeaders" | "responseBody" | "authentication" | "authDetails" | "permissions" | "rateLimit" | "timeout" | "maxPayloadSize" | "status" | "deprecated" | "deprecationDate" | "sunsetDate" | "version" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["apiDesign"]>
  export type ApiDesignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    examples?: boolean | ApiDesign$examplesArgs<ExtArgs>
    errorCodes?: boolean | ApiDesign$errorCodesArgs<ExtArgs>
    _count?: boolean | ApiDesignCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApiDesignIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ApiDesignIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ApiDesignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiDesign"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      examples: Prisma.$ApiExamplePayload<ExtArgs>[]
      errorCodes: Prisma.$ApiErrorCodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      apiName: string
      apiPath: string
      apiMethod: $Enums.ApiMethod
      apiVersion: string
      platform: string
      module: string | null
      apiDescription: string
      businessLogic: string | null
      apiContentType: $Enums.ApiContentType
      requestHeaders: Prisma.JsonValue | null
      requestParams: Prisma.JsonValue | null
      requestBody: Prisma.JsonValue | null
      responseHeaders: Prisma.JsonValue | null
      responseBody: Prisma.JsonValue | null
      authentication: $Enums.ApiAuthType
      authDetails: Prisma.JsonValue | null
      permissions: string[]
      rateLimit: number | null
      timeout: number | null
      maxPayloadSize: number | null
      status: $Enums.ApiStatus
      deprecated: boolean
      deprecationDate: Date | null
      sunsetDate: Date | null
      version: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["apiDesign"]>
    composites: {}
  }

  type ApiDesignGetPayload<S extends boolean | null | undefined | ApiDesignDefaultArgs> = $Result.GetResult<Prisma.$ApiDesignPayload, S>

  type ApiDesignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiDesignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiDesignCountAggregateInputType | true
    }

  export interface ApiDesignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiDesign'], meta: { name: 'ApiDesign' } }
    /**
     * Find zero or one ApiDesign that matches the filter.
     * @param {ApiDesignFindUniqueArgs} args - Arguments to find a ApiDesign
     * @example
     * // Get one ApiDesign
     * const apiDesign = await prisma.apiDesign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiDesignFindUniqueArgs>(args: SelectSubset<T, ApiDesignFindUniqueArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiDesign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiDesignFindUniqueOrThrowArgs} args - Arguments to find a ApiDesign
     * @example
     * // Get one ApiDesign
     * const apiDesign = await prisma.apiDesign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiDesignFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiDesignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiDesign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiDesignFindFirstArgs} args - Arguments to find a ApiDesign
     * @example
     * // Get one ApiDesign
     * const apiDesign = await prisma.apiDesign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiDesignFindFirstArgs>(args?: SelectSubset<T, ApiDesignFindFirstArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiDesign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiDesignFindFirstOrThrowArgs} args - Arguments to find a ApiDesign
     * @example
     * // Get one ApiDesign
     * const apiDesign = await prisma.apiDesign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiDesignFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiDesignFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiDesigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiDesignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiDesigns
     * const apiDesigns = await prisma.apiDesign.findMany()
     * 
     * // Get first 10 ApiDesigns
     * const apiDesigns = await prisma.apiDesign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiDesignWithIdOnly = await prisma.apiDesign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiDesignFindManyArgs>(args?: SelectSubset<T, ApiDesignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiDesign.
     * @param {ApiDesignCreateArgs} args - Arguments to create a ApiDesign.
     * @example
     * // Create one ApiDesign
     * const ApiDesign = await prisma.apiDesign.create({
     *   data: {
     *     // ... data to create a ApiDesign
     *   }
     * })
     * 
     */
    create<T extends ApiDesignCreateArgs>(args: SelectSubset<T, ApiDesignCreateArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiDesigns.
     * @param {ApiDesignCreateManyArgs} args - Arguments to create many ApiDesigns.
     * @example
     * // Create many ApiDesigns
     * const apiDesign = await prisma.apiDesign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiDesignCreateManyArgs>(args?: SelectSubset<T, ApiDesignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiDesigns and returns the data saved in the database.
     * @param {ApiDesignCreateManyAndReturnArgs} args - Arguments to create many ApiDesigns.
     * @example
     * // Create many ApiDesigns
     * const apiDesign = await prisma.apiDesign.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiDesigns and only return the `id`
     * const apiDesignWithIdOnly = await prisma.apiDesign.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiDesignCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiDesignCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiDesign.
     * @param {ApiDesignDeleteArgs} args - Arguments to delete one ApiDesign.
     * @example
     * // Delete one ApiDesign
     * const ApiDesign = await prisma.apiDesign.delete({
     *   where: {
     *     // ... filter to delete one ApiDesign
     *   }
     * })
     * 
     */
    delete<T extends ApiDesignDeleteArgs>(args: SelectSubset<T, ApiDesignDeleteArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiDesign.
     * @param {ApiDesignUpdateArgs} args - Arguments to update one ApiDesign.
     * @example
     * // Update one ApiDesign
     * const apiDesign = await prisma.apiDesign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiDesignUpdateArgs>(args: SelectSubset<T, ApiDesignUpdateArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiDesigns.
     * @param {ApiDesignDeleteManyArgs} args - Arguments to filter ApiDesigns to delete.
     * @example
     * // Delete a few ApiDesigns
     * const { count } = await prisma.apiDesign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiDesignDeleteManyArgs>(args?: SelectSubset<T, ApiDesignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiDesigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiDesignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiDesigns
     * const apiDesign = await prisma.apiDesign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiDesignUpdateManyArgs>(args: SelectSubset<T, ApiDesignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiDesigns and returns the data updated in the database.
     * @param {ApiDesignUpdateManyAndReturnArgs} args - Arguments to update many ApiDesigns.
     * @example
     * // Update many ApiDesigns
     * const apiDesign = await prisma.apiDesign.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiDesigns and only return the `id`
     * const apiDesignWithIdOnly = await prisma.apiDesign.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiDesignUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiDesignUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiDesign.
     * @param {ApiDesignUpsertArgs} args - Arguments to update or create a ApiDesign.
     * @example
     * // Update or create a ApiDesign
     * const apiDesign = await prisma.apiDesign.upsert({
     *   create: {
     *     // ... data to create a ApiDesign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiDesign we want to update
     *   }
     * })
     */
    upsert<T extends ApiDesignUpsertArgs>(args: SelectSubset<T, ApiDesignUpsertArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiDesigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiDesignCountArgs} args - Arguments to filter ApiDesigns to count.
     * @example
     * // Count the number of ApiDesigns
     * const count = await prisma.apiDesign.count({
     *   where: {
     *     // ... the filter for the ApiDesigns we want to count
     *   }
     * })
    **/
    count<T extends ApiDesignCountArgs>(
      args?: Subset<T, ApiDesignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiDesignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiDesign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiDesignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiDesignAggregateArgs>(args: Subset<T, ApiDesignAggregateArgs>): Prisma.PrismaPromise<GetApiDesignAggregateType<T>>

    /**
     * Group by ApiDesign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiDesignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiDesignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiDesignGroupByArgs['orderBy'] }
        : { orderBy?: ApiDesignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiDesignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiDesignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiDesign model
   */
  readonly fields: ApiDesignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiDesign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiDesignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    examples<T extends ApiDesign$examplesArgs<ExtArgs> = {}>(args?: Subset<T, ApiDesign$examplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    errorCodes<T extends ApiDesign$errorCodesArgs<ExtArgs> = {}>(args?: Subset<T, ApiDesign$errorCodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiDesign model
   */
  interface ApiDesignFieldRefs {
    readonly id: FieldRef<"ApiDesign", 'String'>
    readonly projectId: FieldRef<"ApiDesign", 'String'>
    readonly apiName: FieldRef<"ApiDesign", 'String'>
    readonly apiPath: FieldRef<"ApiDesign", 'String'>
    readonly apiMethod: FieldRef<"ApiDesign", 'ApiMethod'>
    readonly apiVersion: FieldRef<"ApiDesign", 'String'>
    readonly platform: FieldRef<"ApiDesign", 'String'>
    readonly module: FieldRef<"ApiDesign", 'String'>
    readonly apiDescription: FieldRef<"ApiDesign", 'String'>
    readonly businessLogic: FieldRef<"ApiDesign", 'String'>
    readonly apiContentType: FieldRef<"ApiDesign", 'ApiContentType'>
    readonly requestHeaders: FieldRef<"ApiDesign", 'Json'>
    readonly requestParams: FieldRef<"ApiDesign", 'Json'>
    readonly requestBody: FieldRef<"ApiDesign", 'Json'>
    readonly responseHeaders: FieldRef<"ApiDesign", 'Json'>
    readonly responseBody: FieldRef<"ApiDesign", 'Json'>
    readonly authentication: FieldRef<"ApiDesign", 'ApiAuthType'>
    readonly authDetails: FieldRef<"ApiDesign", 'Json'>
    readonly permissions: FieldRef<"ApiDesign", 'String[]'>
    readonly rateLimit: FieldRef<"ApiDesign", 'Int'>
    readonly timeout: FieldRef<"ApiDesign", 'Int'>
    readonly maxPayloadSize: FieldRef<"ApiDesign", 'Int'>
    readonly status: FieldRef<"ApiDesign", 'ApiStatus'>
    readonly deprecated: FieldRef<"ApiDesign", 'Boolean'>
    readonly deprecationDate: FieldRef<"ApiDesign", 'DateTime'>
    readonly sunsetDate: FieldRef<"ApiDesign", 'DateTime'>
    readonly version: FieldRef<"ApiDesign", 'Int'>
    readonly createdAt: FieldRef<"ApiDesign", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiDesign", 'DateTime'>
    readonly deletedAt: FieldRef<"ApiDesign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiDesign findUnique
   */
  export type ApiDesignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    /**
     * Filter, which ApiDesign to fetch.
     */
    where: ApiDesignWhereUniqueInput
  }

  /**
   * ApiDesign findUniqueOrThrow
   */
  export type ApiDesignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    /**
     * Filter, which ApiDesign to fetch.
     */
    where: ApiDesignWhereUniqueInput
  }

  /**
   * ApiDesign findFirst
   */
  export type ApiDesignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    /**
     * Filter, which ApiDesign to fetch.
     */
    where?: ApiDesignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiDesigns to fetch.
     */
    orderBy?: ApiDesignOrderByWithRelationInput | ApiDesignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiDesigns.
     */
    cursor?: ApiDesignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiDesigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiDesigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiDesigns.
     */
    distinct?: ApiDesignScalarFieldEnum | ApiDesignScalarFieldEnum[]
  }

  /**
   * ApiDesign findFirstOrThrow
   */
  export type ApiDesignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    /**
     * Filter, which ApiDesign to fetch.
     */
    where?: ApiDesignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiDesigns to fetch.
     */
    orderBy?: ApiDesignOrderByWithRelationInput | ApiDesignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiDesigns.
     */
    cursor?: ApiDesignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiDesigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiDesigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiDesigns.
     */
    distinct?: ApiDesignScalarFieldEnum | ApiDesignScalarFieldEnum[]
  }

  /**
   * ApiDesign findMany
   */
  export type ApiDesignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    /**
     * Filter, which ApiDesigns to fetch.
     */
    where?: ApiDesignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiDesigns to fetch.
     */
    orderBy?: ApiDesignOrderByWithRelationInput | ApiDesignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiDesigns.
     */
    cursor?: ApiDesignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiDesigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiDesigns.
     */
    skip?: number
    distinct?: ApiDesignScalarFieldEnum | ApiDesignScalarFieldEnum[]
  }

  /**
   * ApiDesign create
   */
  export type ApiDesignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiDesign.
     */
    data: XOR<ApiDesignCreateInput, ApiDesignUncheckedCreateInput>
  }

  /**
   * ApiDesign createMany
   */
  export type ApiDesignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiDesigns.
     */
    data: ApiDesignCreateManyInput | ApiDesignCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiDesign createManyAndReturn
   */
  export type ApiDesignCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * The data used to create many ApiDesigns.
     */
    data: ApiDesignCreateManyInput | ApiDesignCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiDesign update
   */
  export type ApiDesignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiDesign.
     */
    data: XOR<ApiDesignUpdateInput, ApiDesignUncheckedUpdateInput>
    /**
     * Choose, which ApiDesign to update.
     */
    where: ApiDesignWhereUniqueInput
  }

  /**
   * ApiDesign updateMany
   */
  export type ApiDesignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiDesigns.
     */
    data: XOR<ApiDesignUpdateManyMutationInput, ApiDesignUncheckedUpdateManyInput>
    /**
     * Filter which ApiDesigns to update
     */
    where?: ApiDesignWhereInput
    /**
     * Limit how many ApiDesigns to update.
     */
    limit?: number
  }

  /**
   * ApiDesign updateManyAndReturn
   */
  export type ApiDesignUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * The data used to update ApiDesigns.
     */
    data: XOR<ApiDesignUpdateManyMutationInput, ApiDesignUncheckedUpdateManyInput>
    /**
     * Filter which ApiDesigns to update
     */
    where?: ApiDesignWhereInput
    /**
     * Limit how many ApiDesigns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiDesign upsert
   */
  export type ApiDesignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiDesign to update in case it exists.
     */
    where: ApiDesignWhereUniqueInput
    /**
     * In case the ApiDesign found by the `where` argument doesn't exist, create a new ApiDesign with this data.
     */
    create: XOR<ApiDesignCreateInput, ApiDesignUncheckedCreateInput>
    /**
     * In case the ApiDesign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiDesignUpdateInput, ApiDesignUncheckedUpdateInput>
  }

  /**
   * ApiDesign delete
   */
  export type ApiDesignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    /**
     * Filter which ApiDesign to delete.
     */
    where: ApiDesignWhereUniqueInput
  }

  /**
   * ApiDesign deleteMany
   */
  export type ApiDesignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiDesigns to delete
     */
    where?: ApiDesignWhereInput
    /**
     * Limit how many ApiDesigns to delete.
     */
    limit?: number
  }

  /**
   * ApiDesign.examples
   */
  export type ApiDesign$examplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    where?: ApiExampleWhereInput
    orderBy?: ApiExampleOrderByWithRelationInput | ApiExampleOrderByWithRelationInput[]
    cursor?: ApiExampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiExampleScalarFieldEnum | ApiExampleScalarFieldEnum[]
  }

  /**
   * ApiDesign.errorCodes
   */
  export type ApiDesign$errorCodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    where?: ApiErrorCodeWhereInput
    orderBy?: ApiErrorCodeOrderByWithRelationInput | ApiErrorCodeOrderByWithRelationInput[]
    cursor?: ApiErrorCodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiErrorCodeScalarFieldEnum | ApiErrorCodeScalarFieldEnum[]
  }

  /**
   * ApiDesign without action
   */
  export type ApiDesignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
  }


  /**
   * Model ApiExample
   */

  export type AggregateApiExample = {
    _count: ApiExampleCountAggregateOutputType | null
    _avg: ApiExampleAvgAggregateOutputType | null
    _sum: ApiExampleSumAggregateOutputType | null
    _min: ApiExampleMinAggregateOutputType | null
    _max: ApiExampleMaxAggregateOutputType | null
  }

  export type ApiExampleAvgAggregateOutputType = {
    responseStatus: number | null
  }

  export type ApiExampleSumAggregateOutputType = {
    responseStatus: number | null
  }

  export type ApiExampleMinAggregateOutputType = {
    id: string | null
    apiDesignId: string | null
    name: string | null
    description: string | null
    requestUrl: string | null
    responseStatus: number | null
    notes: string | null
    isSuccess: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiExampleMaxAggregateOutputType = {
    id: string | null
    apiDesignId: string | null
    name: string | null
    description: string | null
    requestUrl: string | null
    responseStatus: number | null
    notes: string | null
    isSuccess: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiExampleCountAggregateOutputType = {
    id: number
    apiDesignId: number
    name: number
    description: number
    requestUrl: number
    requestHeaders: number
    requestParams: number
    requestBody: number
    responseStatus: number
    responseHeaders: number
    responseBody: number
    notes: number
    isSuccess: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiExampleAvgAggregateInputType = {
    responseStatus?: true
  }

  export type ApiExampleSumAggregateInputType = {
    responseStatus?: true
  }

  export type ApiExampleMinAggregateInputType = {
    id?: true
    apiDesignId?: true
    name?: true
    description?: true
    requestUrl?: true
    responseStatus?: true
    notes?: true
    isSuccess?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiExampleMaxAggregateInputType = {
    id?: true
    apiDesignId?: true
    name?: true
    description?: true
    requestUrl?: true
    responseStatus?: true
    notes?: true
    isSuccess?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiExampleCountAggregateInputType = {
    id?: true
    apiDesignId?: true
    name?: true
    description?: true
    requestUrl?: true
    requestHeaders?: true
    requestParams?: true
    requestBody?: true
    responseStatus?: true
    responseHeaders?: true
    responseBody?: true
    notes?: true
    isSuccess?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiExampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiExample to aggregate.
     */
    where?: ApiExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiExamples to fetch.
     */
    orderBy?: ApiExampleOrderByWithRelationInput | ApiExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiExamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiExamples
    **/
    _count?: true | ApiExampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiExampleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiExampleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiExampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiExampleMaxAggregateInputType
  }

  export type GetApiExampleAggregateType<T extends ApiExampleAggregateArgs> = {
        [P in keyof T & keyof AggregateApiExample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiExample[P]>
      : GetScalarType<T[P], AggregateApiExample[P]>
  }




  export type ApiExampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiExampleWhereInput
    orderBy?: ApiExampleOrderByWithAggregationInput | ApiExampleOrderByWithAggregationInput[]
    by: ApiExampleScalarFieldEnum[] | ApiExampleScalarFieldEnum
    having?: ApiExampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiExampleCountAggregateInputType | true
    _avg?: ApiExampleAvgAggregateInputType
    _sum?: ApiExampleSumAggregateInputType
    _min?: ApiExampleMinAggregateInputType
    _max?: ApiExampleMaxAggregateInputType
  }

  export type ApiExampleGroupByOutputType = {
    id: string
    apiDesignId: string
    name: string
    description: string
    requestUrl: string
    requestHeaders: JsonValue | null
    requestParams: JsonValue | null
    requestBody: JsonValue | null
    responseStatus: number
    responseHeaders: JsonValue | null
    responseBody: JsonValue | null
    notes: string | null
    isSuccess: boolean
    createdAt: Date
    updatedAt: Date
    _count: ApiExampleCountAggregateOutputType | null
    _avg: ApiExampleAvgAggregateOutputType | null
    _sum: ApiExampleSumAggregateOutputType | null
    _min: ApiExampleMinAggregateOutputType | null
    _max: ApiExampleMaxAggregateOutputType | null
  }

  type GetApiExampleGroupByPayload<T extends ApiExampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiExampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiExampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiExampleGroupByOutputType[P]>
            : GetScalarType<T[P], ApiExampleGroupByOutputType[P]>
        }
      >
    >


  export type ApiExampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiDesignId?: boolean
    name?: boolean
    description?: boolean
    requestUrl?: boolean
    requestHeaders?: boolean
    requestParams?: boolean
    requestBody?: boolean
    responseStatus?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    notes?: boolean
    isSuccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiExample"]>

  export type ApiExampleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiDesignId?: boolean
    name?: boolean
    description?: boolean
    requestUrl?: boolean
    requestHeaders?: boolean
    requestParams?: boolean
    requestBody?: boolean
    responseStatus?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    notes?: boolean
    isSuccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiExample"]>

  export type ApiExampleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiDesignId?: boolean
    name?: boolean
    description?: boolean
    requestUrl?: boolean
    requestHeaders?: boolean
    requestParams?: boolean
    requestBody?: boolean
    responseStatus?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    notes?: boolean
    isSuccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiExample"]>

  export type ApiExampleSelectScalar = {
    id?: boolean
    apiDesignId?: boolean
    name?: boolean
    description?: boolean
    requestUrl?: boolean
    requestHeaders?: boolean
    requestParams?: boolean
    requestBody?: boolean
    responseStatus?: boolean
    responseHeaders?: boolean
    responseBody?: boolean
    notes?: boolean
    isSuccess?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiExampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apiDesignId" | "name" | "description" | "requestUrl" | "requestHeaders" | "requestParams" | "requestBody" | "responseStatus" | "responseHeaders" | "responseBody" | "notes" | "isSuccess" | "createdAt" | "updatedAt", ExtArgs["result"]["apiExample"]>
  export type ApiExampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }
  export type ApiExampleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }
  export type ApiExampleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }

  export type $ApiExamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiExample"
    objects: {
      apiDesign: Prisma.$ApiDesignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apiDesignId: string
      name: string
      description: string
      requestUrl: string
      requestHeaders: Prisma.JsonValue | null
      requestParams: Prisma.JsonValue | null
      requestBody: Prisma.JsonValue | null
      responseStatus: number
      responseHeaders: Prisma.JsonValue | null
      responseBody: Prisma.JsonValue | null
      notes: string | null
      isSuccess: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiExample"]>
    composites: {}
  }

  type ApiExampleGetPayload<S extends boolean | null | undefined | ApiExampleDefaultArgs> = $Result.GetResult<Prisma.$ApiExamplePayload, S>

  type ApiExampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiExampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiExampleCountAggregateInputType | true
    }

  export interface ApiExampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiExample'], meta: { name: 'ApiExample' } }
    /**
     * Find zero or one ApiExample that matches the filter.
     * @param {ApiExampleFindUniqueArgs} args - Arguments to find a ApiExample
     * @example
     * // Get one ApiExample
     * const apiExample = await prisma.apiExample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiExampleFindUniqueArgs>(args: SelectSubset<T, ApiExampleFindUniqueArgs<ExtArgs>>): Prisma__ApiExampleClient<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiExample that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiExampleFindUniqueOrThrowArgs} args - Arguments to find a ApiExample
     * @example
     * // Get one ApiExample
     * const apiExample = await prisma.apiExample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiExampleFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiExampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiExampleClient<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiExample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiExampleFindFirstArgs} args - Arguments to find a ApiExample
     * @example
     * // Get one ApiExample
     * const apiExample = await prisma.apiExample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiExampleFindFirstArgs>(args?: SelectSubset<T, ApiExampleFindFirstArgs<ExtArgs>>): Prisma__ApiExampleClient<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiExample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiExampleFindFirstOrThrowArgs} args - Arguments to find a ApiExample
     * @example
     * // Get one ApiExample
     * const apiExample = await prisma.apiExample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiExampleFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiExampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiExampleClient<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiExamples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiExampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiExamples
     * const apiExamples = await prisma.apiExample.findMany()
     * 
     * // Get first 10 ApiExamples
     * const apiExamples = await prisma.apiExample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiExampleWithIdOnly = await prisma.apiExample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiExampleFindManyArgs>(args?: SelectSubset<T, ApiExampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiExample.
     * @param {ApiExampleCreateArgs} args - Arguments to create a ApiExample.
     * @example
     * // Create one ApiExample
     * const ApiExample = await prisma.apiExample.create({
     *   data: {
     *     // ... data to create a ApiExample
     *   }
     * })
     * 
     */
    create<T extends ApiExampleCreateArgs>(args: SelectSubset<T, ApiExampleCreateArgs<ExtArgs>>): Prisma__ApiExampleClient<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiExamples.
     * @param {ApiExampleCreateManyArgs} args - Arguments to create many ApiExamples.
     * @example
     * // Create many ApiExamples
     * const apiExample = await prisma.apiExample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiExampleCreateManyArgs>(args?: SelectSubset<T, ApiExampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiExamples and returns the data saved in the database.
     * @param {ApiExampleCreateManyAndReturnArgs} args - Arguments to create many ApiExamples.
     * @example
     * // Create many ApiExamples
     * const apiExample = await prisma.apiExample.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiExamples and only return the `id`
     * const apiExampleWithIdOnly = await prisma.apiExample.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiExampleCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiExampleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiExample.
     * @param {ApiExampleDeleteArgs} args - Arguments to delete one ApiExample.
     * @example
     * // Delete one ApiExample
     * const ApiExample = await prisma.apiExample.delete({
     *   where: {
     *     // ... filter to delete one ApiExample
     *   }
     * })
     * 
     */
    delete<T extends ApiExampleDeleteArgs>(args: SelectSubset<T, ApiExampleDeleteArgs<ExtArgs>>): Prisma__ApiExampleClient<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiExample.
     * @param {ApiExampleUpdateArgs} args - Arguments to update one ApiExample.
     * @example
     * // Update one ApiExample
     * const apiExample = await prisma.apiExample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiExampleUpdateArgs>(args: SelectSubset<T, ApiExampleUpdateArgs<ExtArgs>>): Prisma__ApiExampleClient<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiExamples.
     * @param {ApiExampleDeleteManyArgs} args - Arguments to filter ApiExamples to delete.
     * @example
     * // Delete a few ApiExamples
     * const { count } = await prisma.apiExample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiExampleDeleteManyArgs>(args?: SelectSubset<T, ApiExampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiExamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiExampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiExamples
     * const apiExample = await prisma.apiExample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiExampleUpdateManyArgs>(args: SelectSubset<T, ApiExampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiExamples and returns the data updated in the database.
     * @param {ApiExampleUpdateManyAndReturnArgs} args - Arguments to update many ApiExamples.
     * @example
     * // Update many ApiExamples
     * const apiExample = await prisma.apiExample.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiExamples and only return the `id`
     * const apiExampleWithIdOnly = await prisma.apiExample.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiExampleUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiExampleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiExample.
     * @param {ApiExampleUpsertArgs} args - Arguments to update or create a ApiExample.
     * @example
     * // Update or create a ApiExample
     * const apiExample = await prisma.apiExample.upsert({
     *   create: {
     *     // ... data to create a ApiExample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiExample we want to update
     *   }
     * })
     */
    upsert<T extends ApiExampleUpsertArgs>(args: SelectSubset<T, ApiExampleUpsertArgs<ExtArgs>>): Prisma__ApiExampleClient<$Result.GetResult<Prisma.$ApiExamplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiExamples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiExampleCountArgs} args - Arguments to filter ApiExamples to count.
     * @example
     * // Count the number of ApiExamples
     * const count = await prisma.apiExample.count({
     *   where: {
     *     // ... the filter for the ApiExamples we want to count
     *   }
     * })
    **/
    count<T extends ApiExampleCountArgs>(
      args?: Subset<T, ApiExampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiExampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiExample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiExampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiExampleAggregateArgs>(args: Subset<T, ApiExampleAggregateArgs>): Prisma.PrismaPromise<GetApiExampleAggregateType<T>>

    /**
     * Group by ApiExample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiExampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiExampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiExampleGroupByArgs['orderBy'] }
        : { orderBy?: ApiExampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiExampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiExampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiExample model
   */
  readonly fields: ApiExampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiExample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiExampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiDesign<T extends ApiDesignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApiDesignDefaultArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiExample model
   */
  interface ApiExampleFieldRefs {
    readonly id: FieldRef<"ApiExample", 'String'>
    readonly apiDesignId: FieldRef<"ApiExample", 'String'>
    readonly name: FieldRef<"ApiExample", 'String'>
    readonly description: FieldRef<"ApiExample", 'String'>
    readonly requestUrl: FieldRef<"ApiExample", 'String'>
    readonly requestHeaders: FieldRef<"ApiExample", 'Json'>
    readonly requestParams: FieldRef<"ApiExample", 'Json'>
    readonly requestBody: FieldRef<"ApiExample", 'Json'>
    readonly responseStatus: FieldRef<"ApiExample", 'Int'>
    readonly responseHeaders: FieldRef<"ApiExample", 'Json'>
    readonly responseBody: FieldRef<"ApiExample", 'Json'>
    readonly notes: FieldRef<"ApiExample", 'String'>
    readonly isSuccess: FieldRef<"ApiExample", 'Boolean'>
    readonly createdAt: FieldRef<"ApiExample", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiExample", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiExample findUnique
   */
  export type ApiExampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    /**
     * Filter, which ApiExample to fetch.
     */
    where: ApiExampleWhereUniqueInput
  }

  /**
   * ApiExample findUniqueOrThrow
   */
  export type ApiExampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    /**
     * Filter, which ApiExample to fetch.
     */
    where: ApiExampleWhereUniqueInput
  }

  /**
   * ApiExample findFirst
   */
  export type ApiExampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    /**
     * Filter, which ApiExample to fetch.
     */
    where?: ApiExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiExamples to fetch.
     */
    orderBy?: ApiExampleOrderByWithRelationInput | ApiExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiExamples.
     */
    cursor?: ApiExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiExamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiExamples.
     */
    distinct?: ApiExampleScalarFieldEnum | ApiExampleScalarFieldEnum[]
  }

  /**
   * ApiExample findFirstOrThrow
   */
  export type ApiExampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    /**
     * Filter, which ApiExample to fetch.
     */
    where?: ApiExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiExamples to fetch.
     */
    orderBy?: ApiExampleOrderByWithRelationInput | ApiExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiExamples.
     */
    cursor?: ApiExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiExamples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiExamples.
     */
    distinct?: ApiExampleScalarFieldEnum | ApiExampleScalarFieldEnum[]
  }

  /**
   * ApiExample findMany
   */
  export type ApiExampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    /**
     * Filter, which ApiExamples to fetch.
     */
    where?: ApiExampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiExamples to fetch.
     */
    orderBy?: ApiExampleOrderByWithRelationInput | ApiExampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiExamples.
     */
    cursor?: ApiExampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiExamples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiExamples.
     */
    skip?: number
    distinct?: ApiExampleScalarFieldEnum | ApiExampleScalarFieldEnum[]
  }

  /**
   * ApiExample create
   */
  export type ApiExampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiExample.
     */
    data: XOR<ApiExampleCreateInput, ApiExampleUncheckedCreateInput>
  }

  /**
   * ApiExample createMany
   */
  export type ApiExampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiExamples.
     */
    data: ApiExampleCreateManyInput | ApiExampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiExample createManyAndReturn
   */
  export type ApiExampleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * The data used to create many ApiExamples.
     */
    data: ApiExampleCreateManyInput | ApiExampleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiExample update
   */
  export type ApiExampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiExample.
     */
    data: XOR<ApiExampleUpdateInput, ApiExampleUncheckedUpdateInput>
    /**
     * Choose, which ApiExample to update.
     */
    where: ApiExampleWhereUniqueInput
  }

  /**
   * ApiExample updateMany
   */
  export type ApiExampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiExamples.
     */
    data: XOR<ApiExampleUpdateManyMutationInput, ApiExampleUncheckedUpdateManyInput>
    /**
     * Filter which ApiExamples to update
     */
    where?: ApiExampleWhereInput
    /**
     * Limit how many ApiExamples to update.
     */
    limit?: number
  }

  /**
   * ApiExample updateManyAndReturn
   */
  export type ApiExampleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * The data used to update ApiExamples.
     */
    data: XOR<ApiExampleUpdateManyMutationInput, ApiExampleUncheckedUpdateManyInput>
    /**
     * Filter which ApiExamples to update
     */
    where?: ApiExampleWhereInput
    /**
     * Limit how many ApiExamples to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiExample upsert
   */
  export type ApiExampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiExample to update in case it exists.
     */
    where: ApiExampleWhereUniqueInput
    /**
     * In case the ApiExample found by the `where` argument doesn't exist, create a new ApiExample with this data.
     */
    create: XOR<ApiExampleCreateInput, ApiExampleUncheckedCreateInput>
    /**
     * In case the ApiExample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiExampleUpdateInput, ApiExampleUncheckedUpdateInput>
  }

  /**
   * ApiExample delete
   */
  export type ApiExampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
    /**
     * Filter which ApiExample to delete.
     */
    where: ApiExampleWhereUniqueInput
  }

  /**
   * ApiExample deleteMany
   */
  export type ApiExampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiExamples to delete
     */
    where?: ApiExampleWhereInput
    /**
     * Limit how many ApiExamples to delete.
     */
    limit?: number
  }

  /**
   * ApiExample without action
   */
  export type ApiExampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiExample
     */
    select?: ApiExampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiExample
     */
    omit?: ApiExampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiExampleInclude<ExtArgs> | null
  }


  /**
   * Model ApiErrorCode
   */

  export type AggregateApiErrorCode = {
    _count: ApiErrorCodeCountAggregateOutputType | null
    _avg: ApiErrorCodeAvgAggregateOutputType | null
    _sum: ApiErrorCodeSumAggregateOutputType | null
    _min: ApiErrorCodeMinAggregateOutputType | null
    _max: ApiErrorCodeMaxAggregateOutputType | null
  }

  export type ApiErrorCodeAvgAggregateOutputType = {
    httpStatus: number | null
  }

  export type ApiErrorCodeSumAggregateOutputType = {
    httpStatus: number | null
  }

  export type ApiErrorCodeMinAggregateOutputType = {
    id: string | null
    apiDesignId: string | null
    code: string | null
    httpStatus: number | null
    message: string | null
    description: string | null
    solution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiErrorCodeMaxAggregateOutputType = {
    id: string | null
    apiDesignId: string | null
    code: string | null
    httpStatus: number | null
    message: string | null
    description: string | null
    solution: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiErrorCodeCountAggregateOutputType = {
    id: number
    apiDesignId: number
    code: number
    httpStatus: number
    message: number
    description: number
    solution: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiErrorCodeAvgAggregateInputType = {
    httpStatus?: true
  }

  export type ApiErrorCodeSumAggregateInputType = {
    httpStatus?: true
  }

  export type ApiErrorCodeMinAggregateInputType = {
    id?: true
    apiDesignId?: true
    code?: true
    httpStatus?: true
    message?: true
    description?: true
    solution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiErrorCodeMaxAggregateInputType = {
    id?: true
    apiDesignId?: true
    code?: true
    httpStatus?: true
    message?: true
    description?: true
    solution?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiErrorCodeCountAggregateInputType = {
    id?: true
    apiDesignId?: true
    code?: true
    httpStatus?: true
    message?: true
    description?: true
    solution?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiErrorCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiErrorCode to aggregate.
     */
    where?: ApiErrorCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorCodes to fetch.
     */
    orderBy?: ApiErrorCodeOrderByWithRelationInput | ApiErrorCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiErrorCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiErrorCodes
    **/
    _count?: true | ApiErrorCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiErrorCodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiErrorCodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiErrorCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiErrorCodeMaxAggregateInputType
  }

  export type GetApiErrorCodeAggregateType<T extends ApiErrorCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateApiErrorCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiErrorCode[P]>
      : GetScalarType<T[P], AggregateApiErrorCode[P]>
  }




  export type ApiErrorCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiErrorCodeWhereInput
    orderBy?: ApiErrorCodeOrderByWithAggregationInput | ApiErrorCodeOrderByWithAggregationInput[]
    by: ApiErrorCodeScalarFieldEnum[] | ApiErrorCodeScalarFieldEnum
    having?: ApiErrorCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiErrorCodeCountAggregateInputType | true
    _avg?: ApiErrorCodeAvgAggregateInputType
    _sum?: ApiErrorCodeSumAggregateInputType
    _min?: ApiErrorCodeMinAggregateInputType
    _max?: ApiErrorCodeMaxAggregateInputType
  }

  export type ApiErrorCodeGroupByOutputType = {
    id: string
    apiDesignId: string
    code: string
    httpStatus: number
    message: string
    description: string
    solution: string | null
    createdAt: Date
    updatedAt: Date
    _count: ApiErrorCodeCountAggregateOutputType | null
    _avg: ApiErrorCodeAvgAggregateOutputType | null
    _sum: ApiErrorCodeSumAggregateOutputType | null
    _min: ApiErrorCodeMinAggregateOutputType | null
    _max: ApiErrorCodeMaxAggregateOutputType | null
  }

  type GetApiErrorCodeGroupByPayload<T extends ApiErrorCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiErrorCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiErrorCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiErrorCodeGroupByOutputType[P]>
            : GetScalarType<T[P], ApiErrorCodeGroupByOutputType[P]>
        }
      >
    >


  export type ApiErrorCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiDesignId?: boolean
    code?: boolean
    httpStatus?: boolean
    message?: boolean
    description?: boolean
    solution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiErrorCode"]>

  export type ApiErrorCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiDesignId?: boolean
    code?: boolean
    httpStatus?: boolean
    message?: boolean
    description?: boolean
    solution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiErrorCode"]>

  export type ApiErrorCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apiDesignId?: boolean
    code?: boolean
    httpStatus?: boolean
    message?: boolean
    description?: boolean
    solution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiErrorCode"]>

  export type ApiErrorCodeSelectScalar = {
    id?: boolean
    apiDesignId?: boolean
    code?: boolean
    httpStatus?: boolean
    message?: boolean
    description?: boolean
    solution?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiErrorCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apiDesignId" | "code" | "httpStatus" | "message" | "description" | "solution" | "createdAt" | "updatedAt", ExtArgs["result"]["apiErrorCode"]>
  export type ApiErrorCodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }
  export type ApiErrorCodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }
  export type ApiErrorCodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apiDesign?: boolean | ApiDesignDefaultArgs<ExtArgs>
  }

  export type $ApiErrorCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiErrorCode"
    objects: {
      apiDesign: Prisma.$ApiDesignPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apiDesignId: string
      code: string
      httpStatus: number
      message: string
      description: string
      solution: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiErrorCode"]>
    composites: {}
  }

  type ApiErrorCodeGetPayload<S extends boolean | null | undefined | ApiErrorCodeDefaultArgs> = $Result.GetResult<Prisma.$ApiErrorCodePayload, S>

  type ApiErrorCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiErrorCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiErrorCodeCountAggregateInputType | true
    }

  export interface ApiErrorCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiErrorCode'], meta: { name: 'ApiErrorCode' } }
    /**
     * Find zero or one ApiErrorCode that matches the filter.
     * @param {ApiErrorCodeFindUniqueArgs} args - Arguments to find a ApiErrorCode
     * @example
     * // Get one ApiErrorCode
     * const apiErrorCode = await prisma.apiErrorCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiErrorCodeFindUniqueArgs>(args: SelectSubset<T, ApiErrorCodeFindUniqueArgs<ExtArgs>>): Prisma__ApiErrorCodeClient<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApiErrorCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiErrorCodeFindUniqueOrThrowArgs} args - Arguments to find a ApiErrorCode
     * @example
     * // Get one ApiErrorCode
     * const apiErrorCode = await prisma.apiErrorCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiErrorCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiErrorCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiErrorCodeClient<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiErrorCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorCodeFindFirstArgs} args - Arguments to find a ApiErrorCode
     * @example
     * // Get one ApiErrorCode
     * const apiErrorCode = await prisma.apiErrorCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiErrorCodeFindFirstArgs>(args?: SelectSubset<T, ApiErrorCodeFindFirstArgs<ExtArgs>>): Prisma__ApiErrorCodeClient<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApiErrorCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorCodeFindFirstOrThrowArgs} args - Arguments to find a ApiErrorCode
     * @example
     * // Get one ApiErrorCode
     * const apiErrorCode = await prisma.apiErrorCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiErrorCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiErrorCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiErrorCodeClient<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApiErrorCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiErrorCodes
     * const apiErrorCodes = await prisma.apiErrorCode.findMany()
     * 
     * // Get first 10 ApiErrorCodes
     * const apiErrorCodes = await prisma.apiErrorCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiErrorCodeWithIdOnly = await prisma.apiErrorCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiErrorCodeFindManyArgs>(args?: SelectSubset<T, ApiErrorCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApiErrorCode.
     * @param {ApiErrorCodeCreateArgs} args - Arguments to create a ApiErrorCode.
     * @example
     * // Create one ApiErrorCode
     * const ApiErrorCode = await prisma.apiErrorCode.create({
     *   data: {
     *     // ... data to create a ApiErrorCode
     *   }
     * })
     * 
     */
    create<T extends ApiErrorCodeCreateArgs>(args: SelectSubset<T, ApiErrorCodeCreateArgs<ExtArgs>>): Prisma__ApiErrorCodeClient<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApiErrorCodes.
     * @param {ApiErrorCodeCreateManyArgs} args - Arguments to create many ApiErrorCodes.
     * @example
     * // Create many ApiErrorCodes
     * const apiErrorCode = await prisma.apiErrorCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiErrorCodeCreateManyArgs>(args?: SelectSubset<T, ApiErrorCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiErrorCodes and returns the data saved in the database.
     * @param {ApiErrorCodeCreateManyAndReturnArgs} args - Arguments to create many ApiErrorCodes.
     * @example
     * // Create many ApiErrorCodes
     * const apiErrorCode = await prisma.apiErrorCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiErrorCodes and only return the `id`
     * const apiErrorCodeWithIdOnly = await prisma.apiErrorCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiErrorCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiErrorCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApiErrorCode.
     * @param {ApiErrorCodeDeleteArgs} args - Arguments to delete one ApiErrorCode.
     * @example
     * // Delete one ApiErrorCode
     * const ApiErrorCode = await prisma.apiErrorCode.delete({
     *   where: {
     *     // ... filter to delete one ApiErrorCode
     *   }
     * })
     * 
     */
    delete<T extends ApiErrorCodeDeleteArgs>(args: SelectSubset<T, ApiErrorCodeDeleteArgs<ExtArgs>>): Prisma__ApiErrorCodeClient<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApiErrorCode.
     * @param {ApiErrorCodeUpdateArgs} args - Arguments to update one ApiErrorCode.
     * @example
     * // Update one ApiErrorCode
     * const apiErrorCode = await prisma.apiErrorCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiErrorCodeUpdateArgs>(args: SelectSubset<T, ApiErrorCodeUpdateArgs<ExtArgs>>): Prisma__ApiErrorCodeClient<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApiErrorCodes.
     * @param {ApiErrorCodeDeleteManyArgs} args - Arguments to filter ApiErrorCodes to delete.
     * @example
     * // Delete a few ApiErrorCodes
     * const { count } = await prisma.apiErrorCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiErrorCodeDeleteManyArgs>(args?: SelectSubset<T, ApiErrorCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiErrorCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiErrorCodes
     * const apiErrorCode = await prisma.apiErrorCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiErrorCodeUpdateManyArgs>(args: SelectSubset<T, ApiErrorCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiErrorCodes and returns the data updated in the database.
     * @param {ApiErrorCodeUpdateManyAndReturnArgs} args - Arguments to update many ApiErrorCodes.
     * @example
     * // Update many ApiErrorCodes
     * const apiErrorCode = await prisma.apiErrorCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiErrorCodes and only return the `id`
     * const apiErrorCodeWithIdOnly = await prisma.apiErrorCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiErrorCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiErrorCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApiErrorCode.
     * @param {ApiErrorCodeUpsertArgs} args - Arguments to update or create a ApiErrorCode.
     * @example
     * // Update or create a ApiErrorCode
     * const apiErrorCode = await prisma.apiErrorCode.upsert({
     *   create: {
     *     // ... data to create a ApiErrorCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiErrorCode we want to update
     *   }
     * })
     */
    upsert<T extends ApiErrorCodeUpsertArgs>(args: SelectSubset<T, ApiErrorCodeUpsertArgs<ExtArgs>>): Prisma__ApiErrorCodeClient<$Result.GetResult<Prisma.$ApiErrorCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApiErrorCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorCodeCountArgs} args - Arguments to filter ApiErrorCodes to count.
     * @example
     * // Count the number of ApiErrorCodes
     * const count = await prisma.apiErrorCode.count({
     *   where: {
     *     // ... the filter for the ApiErrorCodes we want to count
     *   }
     * })
    **/
    count<T extends ApiErrorCodeCountArgs>(
      args?: Subset<T, ApiErrorCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiErrorCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiErrorCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiErrorCodeAggregateArgs>(args: Subset<T, ApiErrorCodeAggregateArgs>): Prisma.PrismaPromise<GetApiErrorCodeAggregateType<T>>

    /**
     * Group by ApiErrorCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiErrorCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiErrorCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiErrorCodeGroupByArgs['orderBy'] }
        : { orderBy?: ApiErrorCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiErrorCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiErrorCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiErrorCode model
   */
  readonly fields: ApiErrorCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiErrorCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiErrorCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apiDesign<T extends ApiDesignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApiDesignDefaultArgs<ExtArgs>>): Prisma__ApiDesignClient<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiErrorCode model
   */
  interface ApiErrorCodeFieldRefs {
    readonly id: FieldRef<"ApiErrorCode", 'String'>
    readonly apiDesignId: FieldRef<"ApiErrorCode", 'String'>
    readonly code: FieldRef<"ApiErrorCode", 'String'>
    readonly httpStatus: FieldRef<"ApiErrorCode", 'Int'>
    readonly message: FieldRef<"ApiErrorCode", 'String'>
    readonly description: FieldRef<"ApiErrorCode", 'String'>
    readonly solution: FieldRef<"ApiErrorCode", 'String'>
    readonly createdAt: FieldRef<"ApiErrorCode", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiErrorCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiErrorCode findUnique
   */
  export type ApiErrorCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    /**
     * Filter, which ApiErrorCode to fetch.
     */
    where: ApiErrorCodeWhereUniqueInput
  }

  /**
   * ApiErrorCode findUniqueOrThrow
   */
  export type ApiErrorCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    /**
     * Filter, which ApiErrorCode to fetch.
     */
    where: ApiErrorCodeWhereUniqueInput
  }

  /**
   * ApiErrorCode findFirst
   */
  export type ApiErrorCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    /**
     * Filter, which ApiErrorCode to fetch.
     */
    where?: ApiErrorCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorCodes to fetch.
     */
    orderBy?: ApiErrorCodeOrderByWithRelationInput | ApiErrorCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiErrorCodes.
     */
    cursor?: ApiErrorCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiErrorCodes.
     */
    distinct?: ApiErrorCodeScalarFieldEnum | ApiErrorCodeScalarFieldEnum[]
  }

  /**
   * ApiErrorCode findFirstOrThrow
   */
  export type ApiErrorCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    /**
     * Filter, which ApiErrorCode to fetch.
     */
    where?: ApiErrorCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorCodes to fetch.
     */
    orderBy?: ApiErrorCodeOrderByWithRelationInput | ApiErrorCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiErrorCodes.
     */
    cursor?: ApiErrorCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiErrorCodes.
     */
    distinct?: ApiErrorCodeScalarFieldEnum | ApiErrorCodeScalarFieldEnum[]
  }

  /**
   * ApiErrorCode findMany
   */
  export type ApiErrorCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    /**
     * Filter, which ApiErrorCodes to fetch.
     */
    where?: ApiErrorCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiErrorCodes to fetch.
     */
    orderBy?: ApiErrorCodeOrderByWithRelationInput | ApiErrorCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiErrorCodes.
     */
    cursor?: ApiErrorCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiErrorCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiErrorCodes.
     */
    skip?: number
    distinct?: ApiErrorCodeScalarFieldEnum | ApiErrorCodeScalarFieldEnum[]
  }

  /**
   * ApiErrorCode create
   */
  export type ApiErrorCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiErrorCode.
     */
    data: XOR<ApiErrorCodeCreateInput, ApiErrorCodeUncheckedCreateInput>
  }

  /**
   * ApiErrorCode createMany
   */
  export type ApiErrorCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiErrorCodes.
     */
    data: ApiErrorCodeCreateManyInput | ApiErrorCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiErrorCode createManyAndReturn
   */
  export type ApiErrorCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * The data used to create many ApiErrorCodes.
     */
    data: ApiErrorCodeCreateManyInput | ApiErrorCodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiErrorCode update
   */
  export type ApiErrorCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiErrorCode.
     */
    data: XOR<ApiErrorCodeUpdateInput, ApiErrorCodeUncheckedUpdateInput>
    /**
     * Choose, which ApiErrorCode to update.
     */
    where: ApiErrorCodeWhereUniqueInput
  }

  /**
   * ApiErrorCode updateMany
   */
  export type ApiErrorCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiErrorCodes.
     */
    data: XOR<ApiErrorCodeUpdateManyMutationInput, ApiErrorCodeUncheckedUpdateManyInput>
    /**
     * Filter which ApiErrorCodes to update
     */
    where?: ApiErrorCodeWhereInput
    /**
     * Limit how many ApiErrorCodes to update.
     */
    limit?: number
  }

  /**
   * ApiErrorCode updateManyAndReturn
   */
  export type ApiErrorCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * The data used to update ApiErrorCodes.
     */
    data: XOR<ApiErrorCodeUpdateManyMutationInput, ApiErrorCodeUncheckedUpdateManyInput>
    /**
     * Filter which ApiErrorCodes to update
     */
    where?: ApiErrorCodeWhereInput
    /**
     * Limit how many ApiErrorCodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiErrorCode upsert
   */
  export type ApiErrorCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiErrorCode to update in case it exists.
     */
    where: ApiErrorCodeWhereUniqueInput
    /**
     * In case the ApiErrorCode found by the `where` argument doesn't exist, create a new ApiErrorCode with this data.
     */
    create: XOR<ApiErrorCodeCreateInput, ApiErrorCodeUncheckedCreateInput>
    /**
     * In case the ApiErrorCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiErrorCodeUpdateInput, ApiErrorCodeUncheckedUpdateInput>
  }

  /**
   * ApiErrorCode delete
   */
  export type ApiErrorCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
    /**
     * Filter which ApiErrorCode to delete.
     */
    where: ApiErrorCodeWhereUniqueInput
  }

  /**
   * ApiErrorCode deleteMany
   */
  export type ApiErrorCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiErrorCodes to delete
     */
    where?: ApiErrorCodeWhereInput
    /**
     * Limit how many ApiErrorCodes to delete.
     */
    limit?: number
  }

  /**
   * ApiErrorCode without action
   */
  export type ApiErrorCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiErrorCode
     */
    select?: ApiErrorCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiErrorCode
     */
    omit?: ApiErrorCodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiErrorCodeInclude<ExtArgs> | null
  }


  /**
   * Model SystemArchitecture
   */

  export type AggregateSystemArchitecture = {
    _count: SystemArchitectureCountAggregateOutputType | null
    _avg: SystemArchitectureAvgAggregateOutputType | null
    _sum: SystemArchitectureSumAggregateOutputType | null
    _min: SystemArchitectureMinAggregateOutputType | null
    _max: SystemArchitectureMaxAggregateOutputType | null
  }

  export type SystemArchitectureAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type SystemArchitectureSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type SystemArchitectureMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    overview: string | null
    version: string | null
    status: $Enums.ArchitectureStatus | null
    diagrams: string | null
    notes: string | null
    versionNumber: number | null
    previousVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SystemArchitectureMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    overview: string | null
    version: string | null
    status: $Enums.ArchitectureStatus | null
    diagrams: string | null
    notes: string | null
    versionNumber: number | null
    previousVersionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SystemArchitectureCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    overview: number
    version: number
    status: number
    platforms: number
    components: number
    technologies: number
    diagrams: number
    notes: number
    versionNumber: number
    previousVersionId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SystemArchitectureAvgAggregateInputType = {
    versionNumber?: true
  }

  export type SystemArchitectureSumAggregateInputType = {
    versionNumber?: true
  }

  export type SystemArchitectureMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    overview?: true
    version?: true
    status?: true
    diagrams?: true
    notes?: true
    versionNumber?: true
    previousVersionId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SystemArchitectureMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    overview?: true
    version?: true
    status?: true
    diagrams?: true
    notes?: true
    versionNumber?: true
    previousVersionId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SystemArchitectureCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    overview?: true
    version?: true
    status?: true
    platforms?: true
    components?: true
    technologies?: true
    diagrams?: true
    notes?: true
    versionNumber?: true
    previousVersionId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SystemArchitectureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemArchitecture to aggregate.
     */
    where?: SystemArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemArchitectures to fetch.
     */
    orderBy?: SystemArchitectureOrderByWithRelationInput | SystemArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemArchitectures
    **/
    _count?: true | SystemArchitectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemArchitectureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemArchitectureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemArchitectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemArchitectureMaxAggregateInputType
  }

  export type GetSystemArchitectureAggregateType<T extends SystemArchitectureAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemArchitecture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemArchitecture[P]>
      : GetScalarType<T[P], AggregateSystemArchitecture[P]>
  }




  export type SystemArchitectureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemArchitectureWhereInput
    orderBy?: SystemArchitectureOrderByWithAggregationInput | SystemArchitectureOrderByWithAggregationInput[]
    by: SystemArchitectureScalarFieldEnum[] | SystemArchitectureScalarFieldEnum
    having?: SystemArchitectureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemArchitectureCountAggregateInputType | true
    _avg?: SystemArchitectureAvgAggregateInputType
    _sum?: SystemArchitectureSumAggregateInputType
    _min?: SystemArchitectureMinAggregateInputType
    _max?: SystemArchitectureMaxAggregateInputType
  }

  export type SystemArchitectureGroupByOutputType = {
    id: string
    projectId: string
    name: string
    overview: string
    version: string
    status: $Enums.ArchitectureStatus
    platforms: string[]
    components: string[]
    technologies: string[]
    diagrams: string | null
    notes: string | null
    versionNumber: number
    previousVersionId: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SystemArchitectureCountAggregateOutputType | null
    _avg: SystemArchitectureAvgAggregateOutputType | null
    _sum: SystemArchitectureSumAggregateOutputType | null
    _min: SystemArchitectureMinAggregateOutputType | null
    _max: SystemArchitectureMaxAggregateOutputType | null
  }

  type GetSystemArchitectureGroupByPayload<T extends SystemArchitectureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemArchitectureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemArchitectureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemArchitectureGroupByOutputType[P]>
            : GetScalarType<T[P], SystemArchitectureGroupByOutputType[P]>
        }
      >
    >


  export type SystemArchitectureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    overview?: boolean
    version?: boolean
    status?: boolean
    platforms?: boolean
    components?: boolean
    technologies?: boolean
    diagrams?: boolean
    notes?: boolean
    versionNumber?: boolean
    previousVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    platformArchitectures?: boolean | SystemArchitecture$platformArchitecturesArgs<ExtArgs>
    changeHistories?: boolean | SystemArchitecture$changeHistoriesArgs<ExtArgs>
    previousVersion?: boolean | SystemArchitecture$previousVersionArgs<ExtArgs>
    nextVersions?: boolean | SystemArchitecture$nextVersionsArgs<ExtArgs>
    _count?: boolean | SystemArchitectureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemArchitecture"]>

  export type SystemArchitectureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    overview?: boolean
    version?: boolean
    status?: boolean
    platforms?: boolean
    components?: boolean
    technologies?: boolean
    diagrams?: boolean
    notes?: boolean
    versionNumber?: boolean
    previousVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    previousVersion?: boolean | SystemArchitecture$previousVersionArgs<ExtArgs>
  }, ExtArgs["result"]["systemArchitecture"]>

  export type SystemArchitectureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    overview?: boolean
    version?: boolean
    status?: boolean
    platforms?: boolean
    components?: boolean
    technologies?: boolean
    diagrams?: boolean
    notes?: boolean
    versionNumber?: boolean
    previousVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    previousVersion?: boolean | SystemArchitecture$previousVersionArgs<ExtArgs>
  }, ExtArgs["result"]["systemArchitecture"]>

  export type SystemArchitectureSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    overview?: boolean
    version?: boolean
    status?: boolean
    platforms?: boolean
    components?: boolean
    technologies?: boolean
    diagrams?: boolean
    notes?: boolean
    versionNumber?: boolean
    previousVersionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SystemArchitectureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "overview" | "version" | "status" | "platforms" | "components" | "technologies" | "diagrams" | "notes" | "versionNumber" | "previousVersionId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["systemArchitecture"]>
  export type SystemArchitectureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    platformArchitectures?: boolean | SystemArchitecture$platformArchitecturesArgs<ExtArgs>
    changeHistories?: boolean | SystemArchitecture$changeHistoriesArgs<ExtArgs>
    previousVersion?: boolean | SystemArchitecture$previousVersionArgs<ExtArgs>
    nextVersions?: boolean | SystemArchitecture$nextVersionsArgs<ExtArgs>
    _count?: boolean | SystemArchitectureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SystemArchitectureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    previousVersion?: boolean | SystemArchitecture$previousVersionArgs<ExtArgs>
  }
  export type SystemArchitectureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    previousVersion?: boolean | SystemArchitecture$previousVersionArgs<ExtArgs>
  }

  export type $SystemArchitecturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemArchitecture"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      platformArchitectures: Prisma.$PlatformArchitecturePayload<ExtArgs>[]
      changeHistories: Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>[]
      previousVersion: Prisma.$SystemArchitecturePayload<ExtArgs> | null
      nextVersions: Prisma.$SystemArchitecturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      overview: string
      version: string
      status: $Enums.ArchitectureStatus
      platforms: string[]
      components: string[]
      technologies: string[]
      diagrams: string | null
      notes: string | null
      versionNumber: number
      previousVersionId: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["systemArchitecture"]>
    composites: {}
  }

  type SystemArchitectureGetPayload<S extends boolean | null | undefined | SystemArchitectureDefaultArgs> = $Result.GetResult<Prisma.$SystemArchitecturePayload, S>

  type SystemArchitectureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemArchitectureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemArchitectureCountAggregateInputType | true
    }

  export interface SystemArchitectureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemArchitecture'], meta: { name: 'SystemArchitecture' } }
    /**
     * Find zero or one SystemArchitecture that matches the filter.
     * @param {SystemArchitectureFindUniqueArgs} args - Arguments to find a SystemArchitecture
     * @example
     * // Get one SystemArchitecture
     * const systemArchitecture = await prisma.systemArchitecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemArchitectureFindUniqueArgs>(args: SelectSubset<T, SystemArchitectureFindUniqueArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemArchitecture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemArchitectureFindUniqueOrThrowArgs} args - Arguments to find a SystemArchitecture
     * @example
     * // Get one SystemArchitecture
     * const systemArchitecture = await prisma.systemArchitecture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemArchitectureFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemArchitectureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemArchitecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemArchitectureFindFirstArgs} args - Arguments to find a SystemArchitecture
     * @example
     * // Get one SystemArchitecture
     * const systemArchitecture = await prisma.systemArchitecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemArchitectureFindFirstArgs>(args?: SelectSubset<T, SystemArchitectureFindFirstArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemArchitecture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemArchitectureFindFirstOrThrowArgs} args - Arguments to find a SystemArchitecture
     * @example
     * // Get one SystemArchitecture
     * const systemArchitecture = await prisma.systemArchitecture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemArchitectureFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemArchitectureFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemArchitectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemArchitectureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemArchitectures
     * const systemArchitectures = await prisma.systemArchitecture.findMany()
     * 
     * // Get first 10 SystemArchitectures
     * const systemArchitectures = await prisma.systemArchitecture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemArchitectureWithIdOnly = await prisma.systemArchitecture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemArchitectureFindManyArgs>(args?: SelectSubset<T, SystemArchitectureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemArchitecture.
     * @param {SystemArchitectureCreateArgs} args - Arguments to create a SystemArchitecture.
     * @example
     * // Create one SystemArchitecture
     * const SystemArchitecture = await prisma.systemArchitecture.create({
     *   data: {
     *     // ... data to create a SystemArchitecture
     *   }
     * })
     * 
     */
    create<T extends SystemArchitectureCreateArgs>(args: SelectSubset<T, SystemArchitectureCreateArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemArchitectures.
     * @param {SystemArchitectureCreateManyArgs} args - Arguments to create many SystemArchitectures.
     * @example
     * // Create many SystemArchitectures
     * const systemArchitecture = await prisma.systemArchitecture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemArchitectureCreateManyArgs>(args?: SelectSubset<T, SystemArchitectureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemArchitectures and returns the data saved in the database.
     * @param {SystemArchitectureCreateManyAndReturnArgs} args - Arguments to create many SystemArchitectures.
     * @example
     * // Create many SystemArchitectures
     * const systemArchitecture = await prisma.systemArchitecture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemArchitectures and only return the `id`
     * const systemArchitectureWithIdOnly = await prisma.systemArchitecture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemArchitectureCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemArchitectureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemArchitecture.
     * @param {SystemArchitectureDeleteArgs} args - Arguments to delete one SystemArchitecture.
     * @example
     * // Delete one SystemArchitecture
     * const SystemArchitecture = await prisma.systemArchitecture.delete({
     *   where: {
     *     // ... filter to delete one SystemArchitecture
     *   }
     * })
     * 
     */
    delete<T extends SystemArchitectureDeleteArgs>(args: SelectSubset<T, SystemArchitectureDeleteArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemArchitecture.
     * @param {SystemArchitectureUpdateArgs} args - Arguments to update one SystemArchitecture.
     * @example
     * // Update one SystemArchitecture
     * const systemArchitecture = await prisma.systemArchitecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemArchitectureUpdateArgs>(args: SelectSubset<T, SystemArchitectureUpdateArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemArchitectures.
     * @param {SystemArchitectureDeleteManyArgs} args - Arguments to filter SystemArchitectures to delete.
     * @example
     * // Delete a few SystemArchitectures
     * const { count } = await prisma.systemArchitecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemArchitectureDeleteManyArgs>(args?: SelectSubset<T, SystemArchitectureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemArchitectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemArchitectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemArchitectures
     * const systemArchitecture = await prisma.systemArchitecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemArchitectureUpdateManyArgs>(args: SelectSubset<T, SystemArchitectureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemArchitectures and returns the data updated in the database.
     * @param {SystemArchitectureUpdateManyAndReturnArgs} args - Arguments to update many SystemArchitectures.
     * @example
     * // Update many SystemArchitectures
     * const systemArchitecture = await prisma.systemArchitecture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemArchitectures and only return the `id`
     * const systemArchitectureWithIdOnly = await prisma.systemArchitecture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemArchitectureUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemArchitectureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemArchitecture.
     * @param {SystemArchitectureUpsertArgs} args - Arguments to update or create a SystemArchitecture.
     * @example
     * // Update or create a SystemArchitecture
     * const systemArchitecture = await prisma.systemArchitecture.upsert({
     *   create: {
     *     // ... data to create a SystemArchitecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemArchitecture we want to update
     *   }
     * })
     */
    upsert<T extends SystemArchitectureUpsertArgs>(args: SelectSubset<T, SystemArchitectureUpsertArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemArchitectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemArchitectureCountArgs} args - Arguments to filter SystemArchitectures to count.
     * @example
     * // Count the number of SystemArchitectures
     * const count = await prisma.systemArchitecture.count({
     *   where: {
     *     // ... the filter for the SystemArchitectures we want to count
     *   }
     * })
    **/
    count<T extends SystemArchitectureCountArgs>(
      args?: Subset<T, SystemArchitectureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemArchitectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemArchitecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemArchitectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemArchitectureAggregateArgs>(args: Subset<T, SystemArchitectureAggregateArgs>): Prisma.PrismaPromise<GetSystemArchitectureAggregateType<T>>

    /**
     * Group by SystemArchitecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemArchitectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemArchitectureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemArchitectureGroupByArgs['orderBy'] }
        : { orderBy?: SystemArchitectureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemArchitectureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemArchitectureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemArchitecture model
   */
  readonly fields: SystemArchitectureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemArchitecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemArchitectureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    platformArchitectures<T extends SystemArchitecture$platformArchitecturesArgs<ExtArgs> = {}>(args?: Subset<T, SystemArchitecture$platformArchitecturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    changeHistories<T extends SystemArchitecture$changeHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, SystemArchitecture$changeHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    previousVersion<T extends SystemArchitecture$previousVersionArgs<ExtArgs> = {}>(args?: Subset<T, SystemArchitecture$previousVersionArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nextVersions<T extends SystemArchitecture$nextVersionsArgs<ExtArgs> = {}>(args?: Subset<T, SystemArchitecture$nextVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemArchitecture model
   */
  interface SystemArchitectureFieldRefs {
    readonly id: FieldRef<"SystemArchitecture", 'String'>
    readonly projectId: FieldRef<"SystemArchitecture", 'String'>
    readonly name: FieldRef<"SystemArchitecture", 'String'>
    readonly overview: FieldRef<"SystemArchitecture", 'String'>
    readonly version: FieldRef<"SystemArchitecture", 'String'>
    readonly status: FieldRef<"SystemArchitecture", 'ArchitectureStatus'>
    readonly platforms: FieldRef<"SystemArchitecture", 'String[]'>
    readonly components: FieldRef<"SystemArchitecture", 'String[]'>
    readonly technologies: FieldRef<"SystemArchitecture", 'String[]'>
    readonly diagrams: FieldRef<"SystemArchitecture", 'String'>
    readonly notes: FieldRef<"SystemArchitecture", 'String'>
    readonly versionNumber: FieldRef<"SystemArchitecture", 'Int'>
    readonly previousVersionId: FieldRef<"SystemArchitecture", 'String'>
    readonly createdAt: FieldRef<"SystemArchitecture", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemArchitecture", 'DateTime'>
    readonly deletedAt: FieldRef<"SystemArchitecture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemArchitecture findUnique
   */
  export type SystemArchitectureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which SystemArchitecture to fetch.
     */
    where: SystemArchitectureWhereUniqueInput
  }

  /**
   * SystemArchitecture findUniqueOrThrow
   */
  export type SystemArchitectureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which SystemArchitecture to fetch.
     */
    where: SystemArchitectureWhereUniqueInput
  }

  /**
   * SystemArchitecture findFirst
   */
  export type SystemArchitectureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which SystemArchitecture to fetch.
     */
    where?: SystemArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemArchitectures to fetch.
     */
    orderBy?: SystemArchitectureOrderByWithRelationInput | SystemArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemArchitectures.
     */
    cursor?: SystemArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemArchitectures.
     */
    distinct?: SystemArchitectureScalarFieldEnum | SystemArchitectureScalarFieldEnum[]
  }

  /**
   * SystemArchitecture findFirstOrThrow
   */
  export type SystemArchitectureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which SystemArchitecture to fetch.
     */
    where?: SystemArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemArchitectures to fetch.
     */
    orderBy?: SystemArchitectureOrderByWithRelationInput | SystemArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemArchitectures.
     */
    cursor?: SystemArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemArchitectures.
     */
    distinct?: SystemArchitectureScalarFieldEnum | SystemArchitectureScalarFieldEnum[]
  }

  /**
   * SystemArchitecture findMany
   */
  export type SystemArchitectureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which SystemArchitectures to fetch.
     */
    where?: SystemArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemArchitectures to fetch.
     */
    orderBy?: SystemArchitectureOrderByWithRelationInput | SystemArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemArchitectures.
     */
    cursor?: SystemArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemArchitectures.
     */
    skip?: number
    distinct?: SystemArchitectureScalarFieldEnum | SystemArchitectureScalarFieldEnum[]
  }

  /**
   * SystemArchitecture create
   */
  export type SystemArchitectureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemArchitecture.
     */
    data: XOR<SystemArchitectureCreateInput, SystemArchitectureUncheckedCreateInput>
  }

  /**
   * SystemArchitecture createMany
   */
  export type SystemArchitectureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemArchitectures.
     */
    data: SystemArchitectureCreateManyInput | SystemArchitectureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemArchitecture createManyAndReturn
   */
  export type SystemArchitectureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * The data used to create many SystemArchitectures.
     */
    data: SystemArchitectureCreateManyInput | SystemArchitectureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemArchitecture update
   */
  export type SystemArchitectureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemArchitecture.
     */
    data: XOR<SystemArchitectureUpdateInput, SystemArchitectureUncheckedUpdateInput>
    /**
     * Choose, which SystemArchitecture to update.
     */
    where: SystemArchitectureWhereUniqueInput
  }

  /**
   * SystemArchitecture updateMany
   */
  export type SystemArchitectureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemArchitectures.
     */
    data: XOR<SystemArchitectureUpdateManyMutationInput, SystemArchitectureUncheckedUpdateManyInput>
    /**
     * Filter which SystemArchitectures to update
     */
    where?: SystemArchitectureWhereInput
    /**
     * Limit how many SystemArchitectures to update.
     */
    limit?: number
  }

  /**
   * SystemArchitecture updateManyAndReturn
   */
  export type SystemArchitectureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * The data used to update SystemArchitectures.
     */
    data: XOR<SystemArchitectureUpdateManyMutationInput, SystemArchitectureUncheckedUpdateManyInput>
    /**
     * Filter which SystemArchitectures to update
     */
    where?: SystemArchitectureWhereInput
    /**
     * Limit how many SystemArchitectures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemArchitecture upsert
   */
  export type SystemArchitectureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemArchitecture to update in case it exists.
     */
    where: SystemArchitectureWhereUniqueInput
    /**
     * In case the SystemArchitecture found by the `where` argument doesn't exist, create a new SystemArchitecture with this data.
     */
    create: XOR<SystemArchitectureCreateInput, SystemArchitectureUncheckedCreateInput>
    /**
     * In case the SystemArchitecture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemArchitectureUpdateInput, SystemArchitectureUncheckedUpdateInput>
  }

  /**
   * SystemArchitecture delete
   */
  export type SystemArchitectureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    /**
     * Filter which SystemArchitecture to delete.
     */
    where: SystemArchitectureWhereUniqueInput
  }

  /**
   * SystemArchitecture deleteMany
   */
  export type SystemArchitectureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemArchitectures to delete
     */
    where?: SystemArchitectureWhereInput
    /**
     * Limit how many SystemArchitectures to delete.
     */
    limit?: number
  }

  /**
   * SystemArchitecture.platformArchitectures
   */
  export type SystemArchitecture$platformArchitecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    where?: PlatformArchitectureWhereInput
    orderBy?: PlatformArchitectureOrderByWithRelationInput | PlatformArchitectureOrderByWithRelationInput[]
    cursor?: PlatformArchitectureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformArchitectureScalarFieldEnum | PlatformArchitectureScalarFieldEnum[]
  }

  /**
   * SystemArchitecture.changeHistories
   */
  export type SystemArchitecture$changeHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    where?: ArchitectureChangeHistoryWhereInput
    orderBy?: ArchitectureChangeHistoryOrderByWithRelationInput | ArchitectureChangeHistoryOrderByWithRelationInput[]
    cursor?: ArchitectureChangeHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchitectureChangeHistoryScalarFieldEnum | ArchitectureChangeHistoryScalarFieldEnum[]
  }

  /**
   * SystemArchitecture.previousVersion
   */
  export type SystemArchitecture$previousVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    where?: SystemArchitectureWhereInput
  }

  /**
   * SystemArchitecture.nextVersions
   */
  export type SystemArchitecture$nextVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    where?: SystemArchitectureWhereInput
    orderBy?: SystemArchitectureOrderByWithRelationInput | SystemArchitectureOrderByWithRelationInput[]
    cursor?: SystemArchitectureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemArchitectureScalarFieldEnum | SystemArchitectureScalarFieldEnum[]
  }

  /**
   * SystemArchitecture without action
   */
  export type SystemArchitectureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
  }


  /**
   * Model PlatformArchitecture
   */

  export type AggregatePlatformArchitecture = {
    _count: PlatformArchitectureCountAggregateOutputType | null
    _min: PlatformArchitectureMinAggregateOutputType | null
    _max: PlatformArchitectureMaxAggregateOutputType | null
  }

  export type PlatformArchitectureMinAggregateOutputType = {
    id: string | null
    systemArchitectureId: string | null
    platform: string | null
    displayName: string | null
    description: string | null
    deploymentStrategy: string | null
    scalingStrategy: string | null
    diagrams: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformArchitectureMaxAggregateOutputType = {
    id: string | null
    systemArchitectureId: string | null
    platform: string | null
    displayName: string | null
    description: string | null
    deploymentStrategy: string | null
    scalingStrategy: string | null
    diagrams: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformArchitectureCountAggregateOutputType = {
    id: number
    systemArchitectureId: number
    platform: number
    displayName: number
    description: number
    frontend: number
    backend: number
    infrastructure: number
    technologies: number
    components: number
    dependencies: number
    deploymentStrategy: number
    scalingStrategy: number
    diagrams: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformArchitectureMinAggregateInputType = {
    id?: true
    systemArchitectureId?: true
    platform?: true
    displayName?: true
    description?: true
    deploymentStrategy?: true
    scalingStrategy?: true
    diagrams?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformArchitectureMaxAggregateInputType = {
    id?: true
    systemArchitectureId?: true
    platform?: true
    displayName?: true
    description?: true
    deploymentStrategy?: true
    scalingStrategy?: true
    diagrams?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformArchitectureCountAggregateInputType = {
    id?: true
    systemArchitectureId?: true
    platform?: true
    displayName?: true
    description?: true
    frontend?: true
    backend?: true
    infrastructure?: true
    technologies?: true
    components?: true
    dependencies?: true
    deploymentStrategy?: true
    scalingStrategy?: true
    diagrams?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformArchitectureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformArchitecture to aggregate.
     */
    where?: PlatformArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformArchitectures to fetch.
     */
    orderBy?: PlatformArchitectureOrderByWithRelationInput | PlatformArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformArchitectures
    **/
    _count?: true | PlatformArchitectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformArchitectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformArchitectureMaxAggregateInputType
  }

  export type GetPlatformArchitectureAggregateType<T extends PlatformArchitectureAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformArchitecture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformArchitecture[P]>
      : GetScalarType<T[P], AggregatePlatformArchitecture[P]>
  }




  export type PlatformArchitectureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformArchitectureWhereInput
    orderBy?: PlatformArchitectureOrderByWithAggregationInput | PlatformArchitectureOrderByWithAggregationInput[]
    by: PlatformArchitectureScalarFieldEnum[] | PlatformArchitectureScalarFieldEnum
    having?: PlatformArchitectureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformArchitectureCountAggregateInputType | true
    _min?: PlatformArchitectureMinAggregateInputType
    _max?: PlatformArchitectureMaxAggregateInputType
  }

  export type PlatformArchitectureGroupByOutputType = {
    id: string
    systemArchitectureId: string
    platform: string
    displayName: string
    description: string
    frontend: JsonValue | null
    backend: JsonValue | null
    infrastructure: JsonValue | null
    technologies: string[]
    components: string[]
    dependencies: JsonValue | null
    deploymentStrategy: string | null
    scalingStrategy: string | null
    diagrams: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PlatformArchitectureCountAggregateOutputType | null
    _min: PlatformArchitectureMinAggregateOutputType | null
    _max: PlatformArchitectureMaxAggregateOutputType | null
  }

  type GetPlatformArchitectureGroupByPayload<T extends PlatformArchitectureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformArchitectureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformArchitectureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformArchitectureGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformArchitectureGroupByOutputType[P]>
        }
      >
    >


  export type PlatformArchitectureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemArchitectureId?: boolean
    platform?: boolean
    displayName?: boolean
    description?: boolean
    frontend?: boolean
    backend?: boolean
    infrastructure?: boolean
    technologies?: boolean
    components?: boolean
    dependencies?: boolean
    deploymentStrategy?: boolean
    scalingStrategy?: boolean
    diagrams?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    systemArchitecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformArchitecture"]>

  export type PlatformArchitectureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemArchitectureId?: boolean
    platform?: boolean
    displayName?: boolean
    description?: boolean
    frontend?: boolean
    backend?: boolean
    infrastructure?: boolean
    technologies?: boolean
    components?: boolean
    dependencies?: boolean
    deploymentStrategy?: boolean
    scalingStrategy?: boolean
    diagrams?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    systemArchitecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformArchitecture"]>

  export type PlatformArchitectureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    systemArchitectureId?: boolean
    platform?: boolean
    displayName?: boolean
    description?: boolean
    frontend?: boolean
    backend?: boolean
    infrastructure?: boolean
    technologies?: boolean
    components?: boolean
    dependencies?: boolean
    deploymentStrategy?: boolean
    scalingStrategy?: boolean
    diagrams?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    systemArchitecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformArchitecture"]>

  export type PlatformArchitectureSelectScalar = {
    id?: boolean
    systemArchitectureId?: boolean
    platform?: boolean
    displayName?: boolean
    description?: boolean
    frontend?: boolean
    backend?: boolean
    infrastructure?: boolean
    technologies?: boolean
    components?: boolean
    dependencies?: boolean
    deploymentStrategy?: boolean
    scalingStrategy?: boolean
    diagrams?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformArchitectureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "systemArchitectureId" | "platform" | "displayName" | "description" | "frontend" | "backend" | "infrastructure" | "technologies" | "components" | "dependencies" | "deploymentStrategy" | "scalingStrategy" | "diagrams" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["platformArchitecture"]>
  export type PlatformArchitectureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    systemArchitecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
  }
  export type PlatformArchitectureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    systemArchitecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
  }
  export type PlatformArchitectureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    systemArchitecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
  }

  export type $PlatformArchitecturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformArchitecture"
    objects: {
      systemArchitecture: Prisma.$SystemArchitecturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      systemArchitectureId: string
      platform: string
      displayName: string
      description: string
      frontend: Prisma.JsonValue | null
      backend: Prisma.JsonValue | null
      infrastructure: Prisma.JsonValue | null
      technologies: string[]
      components: string[]
      dependencies: Prisma.JsonValue | null
      deploymentStrategy: string | null
      scalingStrategy: string | null
      diagrams: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platformArchitecture"]>
    composites: {}
  }

  type PlatformArchitectureGetPayload<S extends boolean | null | undefined | PlatformArchitectureDefaultArgs> = $Result.GetResult<Prisma.$PlatformArchitecturePayload, S>

  type PlatformArchitectureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformArchitectureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformArchitectureCountAggregateInputType | true
    }

  export interface PlatformArchitectureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformArchitecture'], meta: { name: 'PlatformArchitecture' } }
    /**
     * Find zero or one PlatformArchitecture that matches the filter.
     * @param {PlatformArchitectureFindUniqueArgs} args - Arguments to find a PlatformArchitecture
     * @example
     * // Get one PlatformArchitecture
     * const platformArchitecture = await prisma.platformArchitecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformArchitectureFindUniqueArgs>(args: SelectSubset<T, PlatformArchitectureFindUniqueArgs<ExtArgs>>): Prisma__PlatformArchitectureClient<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformArchitecture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformArchitectureFindUniqueOrThrowArgs} args - Arguments to find a PlatformArchitecture
     * @example
     * // Get one PlatformArchitecture
     * const platformArchitecture = await prisma.platformArchitecture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformArchitectureFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformArchitectureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformArchitectureClient<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformArchitecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformArchitectureFindFirstArgs} args - Arguments to find a PlatformArchitecture
     * @example
     * // Get one PlatformArchitecture
     * const platformArchitecture = await prisma.platformArchitecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformArchitectureFindFirstArgs>(args?: SelectSubset<T, PlatformArchitectureFindFirstArgs<ExtArgs>>): Prisma__PlatformArchitectureClient<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformArchitecture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformArchitectureFindFirstOrThrowArgs} args - Arguments to find a PlatformArchitecture
     * @example
     * // Get one PlatformArchitecture
     * const platformArchitecture = await prisma.platformArchitecture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformArchitectureFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformArchitectureFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformArchitectureClient<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformArchitectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformArchitectureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformArchitectures
     * const platformArchitectures = await prisma.platformArchitecture.findMany()
     * 
     * // Get first 10 PlatformArchitectures
     * const platformArchitectures = await prisma.platformArchitecture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformArchitectureWithIdOnly = await prisma.platformArchitecture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformArchitectureFindManyArgs>(args?: SelectSubset<T, PlatformArchitectureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformArchitecture.
     * @param {PlatformArchitectureCreateArgs} args - Arguments to create a PlatformArchitecture.
     * @example
     * // Create one PlatformArchitecture
     * const PlatformArchitecture = await prisma.platformArchitecture.create({
     *   data: {
     *     // ... data to create a PlatformArchitecture
     *   }
     * })
     * 
     */
    create<T extends PlatformArchitectureCreateArgs>(args: SelectSubset<T, PlatformArchitectureCreateArgs<ExtArgs>>): Prisma__PlatformArchitectureClient<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformArchitectures.
     * @param {PlatformArchitectureCreateManyArgs} args - Arguments to create many PlatformArchitectures.
     * @example
     * // Create many PlatformArchitectures
     * const platformArchitecture = await prisma.platformArchitecture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformArchitectureCreateManyArgs>(args?: SelectSubset<T, PlatformArchitectureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformArchitectures and returns the data saved in the database.
     * @param {PlatformArchitectureCreateManyAndReturnArgs} args - Arguments to create many PlatformArchitectures.
     * @example
     * // Create many PlatformArchitectures
     * const platformArchitecture = await prisma.platformArchitecture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformArchitectures and only return the `id`
     * const platformArchitectureWithIdOnly = await prisma.platformArchitecture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformArchitectureCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformArchitectureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlatformArchitecture.
     * @param {PlatformArchitectureDeleteArgs} args - Arguments to delete one PlatformArchitecture.
     * @example
     * // Delete one PlatformArchitecture
     * const PlatformArchitecture = await prisma.platformArchitecture.delete({
     *   where: {
     *     // ... filter to delete one PlatformArchitecture
     *   }
     * })
     * 
     */
    delete<T extends PlatformArchitectureDeleteArgs>(args: SelectSubset<T, PlatformArchitectureDeleteArgs<ExtArgs>>): Prisma__PlatformArchitectureClient<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformArchitecture.
     * @param {PlatformArchitectureUpdateArgs} args - Arguments to update one PlatformArchitecture.
     * @example
     * // Update one PlatformArchitecture
     * const platformArchitecture = await prisma.platformArchitecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformArchitectureUpdateArgs>(args: SelectSubset<T, PlatformArchitectureUpdateArgs<ExtArgs>>): Prisma__PlatformArchitectureClient<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformArchitectures.
     * @param {PlatformArchitectureDeleteManyArgs} args - Arguments to filter PlatformArchitectures to delete.
     * @example
     * // Delete a few PlatformArchitectures
     * const { count } = await prisma.platformArchitecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformArchitectureDeleteManyArgs>(args?: SelectSubset<T, PlatformArchitectureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformArchitectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformArchitectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformArchitectures
     * const platformArchitecture = await prisma.platformArchitecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformArchitectureUpdateManyArgs>(args: SelectSubset<T, PlatformArchitectureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformArchitectures and returns the data updated in the database.
     * @param {PlatformArchitectureUpdateManyAndReturnArgs} args - Arguments to update many PlatformArchitectures.
     * @example
     * // Update many PlatformArchitectures
     * const platformArchitecture = await prisma.platformArchitecture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlatformArchitectures and only return the `id`
     * const platformArchitectureWithIdOnly = await prisma.platformArchitecture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformArchitectureUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformArchitectureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlatformArchitecture.
     * @param {PlatformArchitectureUpsertArgs} args - Arguments to update or create a PlatformArchitecture.
     * @example
     * // Update or create a PlatformArchitecture
     * const platformArchitecture = await prisma.platformArchitecture.upsert({
     *   create: {
     *     // ... data to create a PlatformArchitecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformArchitecture we want to update
     *   }
     * })
     */
    upsert<T extends PlatformArchitectureUpsertArgs>(args: SelectSubset<T, PlatformArchitectureUpsertArgs<ExtArgs>>): Prisma__PlatformArchitectureClient<$Result.GetResult<Prisma.$PlatformArchitecturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformArchitectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformArchitectureCountArgs} args - Arguments to filter PlatformArchitectures to count.
     * @example
     * // Count the number of PlatformArchitectures
     * const count = await prisma.platformArchitecture.count({
     *   where: {
     *     // ... the filter for the PlatformArchitectures we want to count
     *   }
     * })
    **/
    count<T extends PlatformArchitectureCountArgs>(
      args?: Subset<T, PlatformArchitectureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformArchitectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformArchitecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformArchitectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformArchitectureAggregateArgs>(args: Subset<T, PlatformArchitectureAggregateArgs>): Prisma.PrismaPromise<GetPlatformArchitectureAggregateType<T>>

    /**
     * Group by PlatformArchitecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformArchitectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformArchitectureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformArchitectureGroupByArgs['orderBy'] }
        : { orderBy?: PlatformArchitectureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformArchitectureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformArchitectureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformArchitecture model
   */
  readonly fields: PlatformArchitectureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformArchitecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformArchitectureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    systemArchitecture<T extends SystemArchitectureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SystemArchitectureDefaultArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformArchitecture model
   */
  interface PlatformArchitectureFieldRefs {
    readonly id: FieldRef<"PlatformArchitecture", 'String'>
    readonly systemArchitectureId: FieldRef<"PlatformArchitecture", 'String'>
    readonly platform: FieldRef<"PlatformArchitecture", 'String'>
    readonly displayName: FieldRef<"PlatformArchitecture", 'String'>
    readonly description: FieldRef<"PlatformArchitecture", 'String'>
    readonly frontend: FieldRef<"PlatformArchitecture", 'Json'>
    readonly backend: FieldRef<"PlatformArchitecture", 'Json'>
    readonly infrastructure: FieldRef<"PlatformArchitecture", 'Json'>
    readonly technologies: FieldRef<"PlatformArchitecture", 'String[]'>
    readonly components: FieldRef<"PlatformArchitecture", 'String[]'>
    readonly dependencies: FieldRef<"PlatformArchitecture", 'Json'>
    readonly deploymentStrategy: FieldRef<"PlatformArchitecture", 'String'>
    readonly scalingStrategy: FieldRef<"PlatformArchitecture", 'String'>
    readonly diagrams: FieldRef<"PlatformArchitecture", 'String'>
    readonly notes: FieldRef<"PlatformArchitecture", 'String'>
    readonly createdAt: FieldRef<"PlatformArchitecture", 'DateTime'>
    readonly updatedAt: FieldRef<"PlatformArchitecture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformArchitecture findUnique
   */
  export type PlatformArchitectureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which PlatformArchitecture to fetch.
     */
    where: PlatformArchitectureWhereUniqueInput
  }

  /**
   * PlatformArchitecture findUniqueOrThrow
   */
  export type PlatformArchitectureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which PlatformArchitecture to fetch.
     */
    where: PlatformArchitectureWhereUniqueInput
  }

  /**
   * PlatformArchitecture findFirst
   */
  export type PlatformArchitectureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which PlatformArchitecture to fetch.
     */
    where?: PlatformArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformArchitectures to fetch.
     */
    orderBy?: PlatformArchitectureOrderByWithRelationInput | PlatformArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformArchitectures.
     */
    cursor?: PlatformArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformArchitectures.
     */
    distinct?: PlatformArchitectureScalarFieldEnum | PlatformArchitectureScalarFieldEnum[]
  }

  /**
   * PlatformArchitecture findFirstOrThrow
   */
  export type PlatformArchitectureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which PlatformArchitecture to fetch.
     */
    where?: PlatformArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformArchitectures to fetch.
     */
    orderBy?: PlatformArchitectureOrderByWithRelationInput | PlatformArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformArchitectures.
     */
    cursor?: PlatformArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformArchitectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformArchitectures.
     */
    distinct?: PlatformArchitectureScalarFieldEnum | PlatformArchitectureScalarFieldEnum[]
  }

  /**
   * PlatformArchitecture findMany
   */
  export type PlatformArchitectureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    /**
     * Filter, which PlatformArchitectures to fetch.
     */
    where?: PlatformArchitectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformArchitectures to fetch.
     */
    orderBy?: PlatformArchitectureOrderByWithRelationInput | PlatformArchitectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformArchitectures.
     */
    cursor?: PlatformArchitectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformArchitectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformArchitectures.
     */
    skip?: number
    distinct?: PlatformArchitectureScalarFieldEnum | PlatformArchitectureScalarFieldEnum[]
  }

  /**
   * PlatformArchitecture create
   */
  export type PlatformArchitectureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformArchitecture.
     */
    data: XOR<PlatformArchitectureCreateInput, PlatformArchitectureUncheckedCreateInput>
  }

  /**
   * PlatformArchitecture createMany
   */
  export type PlatformArchitectureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformArchitectures.
     */
    data: PlatformArchitectureCreateManyInput | PlatformArchitectureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformArchitecture createManyAndReturn
   */
  export type PlatformArchitectureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * The data used to create many PlatformArchitectures.
     */
    data: PlatformArchitectureCreateManyInput | PlatformArchitectureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformArchitecture update
   */
  export type PlatformArchitectureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformArchitecture.
     */
    data: XOR<PlatformArchitectureUpdateInput, PlatformArchitectureUncheckedUpdateInput>
    /**
     * Choose, which PlatformArchitecture to update.
     */
    where: PlatformArchitectureWhereUniqueInput
  }

  /**
   * PlatformArchitecture updateMany
   */
  export type PlatformArchitectureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformArchitectures.
     */
    data: XOR<PlatformArchitectureUpdateManyMutationInput, PlatformArchitectureUncheckedUpdateManyInput>
    /**
     * Filter which PlatformArchitectures to update
     */
    where?: PlatformArchitectureWhereInput
    /**
     * Limit how many PlatformArchitectures to update.
     */
    limit?: number
  }

  /**
   * PlatformArchitecture updateManyAndReturn
   */
  export type PlatformArchitectureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * The data used to update PlatformArchitectures.
     */
    data: XOR<PlatformArchitectureUpdateManyMutationInput, PlatformArchitectureUncheckedUpdateManyInput>
    /**
     * Filter which PlatformArchitectures to update
     */
    where?: PlatformArchitectureWhereInput
    /**
     * Limit how many PlatformArchitectures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformArchitecture upsert
   */
  export type PlatformArchitectureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformArchitecture to update in case it exists.
     */
    where: PlatformArchitectureWhereUniqueInput
    /**
     * In case the PlatformArchitecture found by the `where` argument doesn't exist, create a new PlatformArchitecture with this data.
     */
    create: XOR<PlatformArchitectureCreateInput, PlatformArchitectureUncheckedCreateInput>
    /**
     * In case the PlatformArchitecture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformArchitectureUpdateInput, PlatformArchitectureUncheckedUpdateInput>
  }

  /**
   * PlatformArchitecture delete
   */
  export type PlatformArchitectureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
    /**
     * Filter which PlatformArchitecture to delete.
     */
    where: PlatformArchitectureWhereUniqueInput
  }

  /**
   * PlatformArchitecture deleteMany
   */
  export type PlatformArchitectureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformArchitectures to delete
     */
    where?: PlatformArchitectureWhereInput
    /**
     * Limit how many PlatformArchitectures to delete.
     */
    limit?: number
  }

  /**
   * PlatformArchitecture without action
   */
  export type PlatformArchitectureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformArchitecture
     */
    select?: PlatformArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformArchitecture
     */
    omit?: PlatformArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformArchitectureInclude<ExtArgs> | null
  }


  /**
   * Model ArchitectureChangeHistory
   */

  export type AggregateArchitectureChangeHistory = {
    _count: ArchitectureChangeHistoryCountAggregateOutputType | null
    _min: ArchitectureChangeHistoryMinAggregateOutputType | null
    _max: ArchitectureChangeHistoryMaxAggregateOutputType | null
  }

  export type ArchitectureChangeHistoryMinAggregateOutputType = {
    id: string | null
    architectureId: string | null
    changeType: string | null
    changeDescription: string | null
    changeReason: string | null
    impact: string | null
    changedAt: Date | null
    userId: string | null
  }

  export type ArchitectureChangeHistoryMaxAggregateOutputType = {
    id: string | null
    architectureId: string | null
    changeType: string | null
    changeDescription: string | null
    changeReason: string | null
    impact: string | null
    changedAt: Date | null
    userId: string | null
  }

  export type ArchitectureChangeHistoryCountAggregateOutputType = {
    id: number
    architectureId: number
    changeType: number
    changeDescription: number
    changeReason: number
    impact: number
    beforeChange: number
    afterChange: number
    changedAt: number
    userId: number
    _all: number
  }


  export type ArchitectureChangeHistoryMinAggregateInputType = {
    id?: true
    architectureId?: true
    changeType?: true
    changeDescription?: true
    changeReason?: true
    impact?: true
    changedAt?: true
    userId?: true
  }

  export type ArchitectureChangeHistoryMaxAggregateInputType = {
    id?: true
    architectureId?: true
    changeType?: true
    changeDescription?: true
    changeReason?: true
    impact?: true
    changedAt?: true
    userId?: true
  }

  export type ArchitectureChangeHistoryCountAggregateInputType = {
    id?: true
    architectureId?: true
    changeType?: true
    changeDescription?: true
    changeReason?: true
    impact?: true
    beforeChange?: true
    afterChange?: true
    changedAt?: true
    userId?: true
    _all?: true
  }

  export type ArchitectureChangeHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArchitectureChangeHistory to aggregate.
     */
    where?: ArchitectureChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchitectureChangeHistories to fetch.
     */
    orderBy?: ArchitectureChangeHistoryOrderByWithRelationInput | ArchitectureChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArchitectureChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchitectureChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchitectureChangeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArchitectureChangeHistories
    **/
    _count?: true | ArchitectureChangeHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArchitectureChangeHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArchitectureChangeHistoryMaxAggregateInputType
  }

  export type GetArchitectureChangeHistoryAggregateType<T extends ArchitectureChangeHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateArchitectureChangeHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArchitectureChangeHistory[P]>
      : GetScalarType<T[P], AggregateArchitectureChangeHistory[P]>
  }




  export type ArchitectureChangeHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArchitectureChangeHistoryWhereInput
    orderBy?: ArchitectureChangeHistoryOrderByWithAggregationInput | ArchitectureChangeHistoryOrderByWithAggregationInput[]
    by: ArchitectureChangeHistoryScalarFieldEnum[] | ArchitectureChangeHistoryScalarFieldEnum
    having?: ArchitectureChangeHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArchitectureChangeHistoryCountAggregateInputType | true
    _min?: ArchitectureChangeHistoryMinAggregateInputType
    _max?: ArchitectureChangeHistoryMaxAggregateInputType
  }

  export type ArchitectureChangeHistoryGroupByOutputType = {
    id: string
    architectureId: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact: string | null
    beforeChange: JsonValue | null
    afterChange: JsonValue | null
    changedAt: Date
    userId: string | null
    _count: ArchitectureChangeHistoryCountAggregateOutputType | null
    _min: ArchitectureChangeHistoryMinAggregateOutputType | null
    _max: ArchitectureChangeHistoryMaxAggregateOutputType | null
  }

  type GetArchitectureChangeHistoryGroupByPayload<T extends ArchitectureChangeHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArchitectureChangeHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArchitectureChangeHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArchitectureChangeHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], ArchitectureChangeHistoryGroupByOutputType[P]>
        }
      >
    >


  export type ArchitectureChangeHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    architectureId?: boolean
    changeType?: boolean
    changeDescription?: boolean
    changeReason?: boolean
    impact?: boolean
    beforeChange?: boolean
    afterChange?: boolean
    changedAt?: boolean
    userId?: boolean
    architecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
    User?: boolean | ArchitectureChangeHistory$UserArgs<ExtArgs>
  }, ExtArgs["result"]["architectureChangeHistory"]>

  export type ArchitectureChangeHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    architectureId?: boolean
    changeType?: boolean
    changeDescription?: boolean
    changeReason?: boolean
    impact?: boolean
    beforeChange?: boolean
    afterChange?: boolean
    changedAt?: boolean
    userId?: boolean
    architecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
    User?: boolean | ArchitectureChangeHistory$UserArgs<ExtArgs>
  }, ExtArgs["result"]["architectureChangeHistory"]>

  export type ArchitectureChangeHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    architectureId?: boolean
    changeType?: boolean
    changeDescription?: boolean
    changeReason?: boolean
    impact?: boolean
    beforeChange?: boolean
    afterChange?: boolean
    changedAt?: boolean
    userId?: boolean
    architecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
    User?: boolean | ArchitectureChangeHistory$UserArgs<ExtArgs>
  }, ExtArgs["result"]["architectureChangeHistory"]>

  export type ArchitectureChangeHistorySelectScalar = {
    id?: boolean
    architectureId?: boolean
    changeType?: boolean
    changeDescription?: boolean
    changeReason?: boolean
    impact?: boolean
    beforeChange?: boolean
    afterChange?: boolean
    changedAt?: boolean
    userId?: boolean
  }

  export type ArchitectureChangeHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "architectureId" | "changeType" | "changeDescription" | "changeReason" | "impact" | "beforeChange" | "afterChange" | "changedAt" | "userId", ExtArgs["result"]["architectureChangeHistory"]>
  export type ArchitectureChangeHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    architecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
    User?: boolean | ArchitectureChangeHistory$UserArgs<ExtArgs>
  }
  export type ArchitectureChangeHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    architecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
    User?: boolean | ArchitectureChangeHistory$UserArgs<ExtArgs>
  }
  export type ArchitectureChangeHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    architecture?: boolean | SystemArchitectureDefaultArgs<ExtArgs>
    User?: boolean | ArchitectureChangeHistory$UserArgs<ExtArgs>
  }

  export type $ArchitectureChangeHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArchitectureChangeHistory"
    objects: {
      architecture: Prisma.$SystemArchitecturePayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      architectureId: string
      changeType: string
      changeDescription: string
      changeReason: string
      impact: string | null
      beforeChange: Prisma.JsonValue | null
      afterChange: Prisma.JsonValue | null
      changedAt: Date
      userId: string | null
    }, ExtArgs["result"]["architectureChangeHistory"]>
    composites: {}
  }

  type ArchitectureChangeHistoryGetPayload<S extends boolean | null | undefined | ArchitectureChangeHistoryDefaultArgs> = $Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload, S>

  type ArchitectureChangeHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArchitectureChangeHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArchitectureChangeHistoryCountAggregateInputType | true
    }

  export interface ArchitectureChangeHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArchitectureChangeHistory'], meta: { name: 'ArchitectureChangeHistory' } }
    /**
     * Find zero or one ArchitectureChangeHistory that matches the filter.
     * @param {ArchitectureChangeHistoryFindUniqueArgs} args - Arguments to find a ArchitectureChangeHistory
     * @example
     * // Get one ArchitectureChangeHistory
     * const architectureChangeHistory = await prisma.architectureChangeHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArchitectureChangeHistoryFindUniqueArgs>(args: SelectSubset<T, ArchitectureChangeHistoryFindUniqueArgs<ExtArgs>>): Prisma__ArchitectureChangeHistoryClient<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArchitectureChangeHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArchitectureChangeHistoryFindUniqueOrThrowArgs} args - Arguments to find a ArchitectureChangeHistory
     * @example
     * // Get one ArchitectureChangeHistory
     * const architectureChangeHistory = await prisma.architectureChangeHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArchitectureChangeHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ArchitectureChangeHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArchitectureChangeHistoryClient<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArchitectureChangeHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchitectureChangeHistoryFindFirstArgs} args - Arguments to find a ArchitectureChangeHistory
     * @example
     * // Get one ArchitectureChangeHistory
     * const architectureChangeHistory = await prisma.architectureChangeHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArchitectureChangeHistoryFindFirstArgs>(args?: SelectSubset<T, ArchitectureChangeHistoryFindFirstArgs<ExtArgs>>): Prisma__ArchitectureChangeHistoryClient<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArchitectureChangeHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchitectureChangeHistoryFindFirstOrThrowArgs} args - Arguments to find a ArchitectureChangeHistory
     * @example
     * // Get one ArchitectureChangeHistory
     * const architectureChangeHistory = await prisma.architectureChangeHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArchitectureChangeHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ArchitectureChangeHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArchitectureChangeHistoryClient<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArchitectureChangeHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchitectureChangeHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArchitectureChangeHistories
     * const architectureChangeHistories = await prisma.architectureChangeHistory.findMany()
     * 
     * // Get first 10 ArchitectureChangeHistories
     * const architectureChangeHistories = await prisma.architectureChangeHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const architectureChangeHistoryWithIdOnly = await prisma.architectureChangeHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArchitectureChangeHistoryFindManyArgs>(args?: SelectSubset<T, ArchitectureChangeHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArchitectureChangeHistory.
     * @param {ArchitectureChangeHistoryCreateArgs} args - Arguments to create a ArchitectureChangeHistory.
     * @example
     * // Create one ArchitectureChangeHistory
     * const ArchitectureChangeHistory = await prisma.architectureChangeHistory.create({
     *   data: {
     *     // ... data to create a ArchitectureChangeHistory
     *   }
     * })
     * 
     */
    create<T extends ArchitectureChangeHistoryCreateArgs>(args: SelectSubset<T, ArchitectureChangeHistoryCreateArgs<ExtArgs>>): Prisma__ArchitectureChangeHistoryClient<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArchitectureChangeHistories.
     * @param {ArchitectureChangeHistoryCreateManyArgs} args - Arguments to create many ArchitectureChangeHistories.
     * @example
     * // Create many ArchitectureChangeHistories
     * const architectureChangeHistory = await prisma.architectureChangeHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArchitectureChangeHistoryCreateManyArgs>(args?: SelectSubset<T, ArchitectureChangeHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArchitectureChangeHistories and returns the data saved in the database.
     * @param {ArchitectureChangeHistoryCreateManyAndReturnArgs} args - Arguments to create many ArchitectureChangeHistories.
     * @example
     * // Create many ArchitectureChangeHistories
     * const architectureChangeHistory = await prisma.architectureChangeHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArchitectureChangeHistories and only return the `id`
     * const architectureChangeHistoryWithIdOnly = await prisma.architectureChangeHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArchitectureChangeHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ArchitectureChangeHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArchitectureChangeHistory.
     * @param {ArchitectureChangeHistoryDeleteArgs} args - Arguments to delete one ArchitectureChangeHistory.
     * @example
     * // Delete one ArchitectureChangeHistory
     * const ArchitectureChangeHistory = await prisma.architectureChangeHistory.delete({
     *   where: {
     *     // ... filter to delete one ArchitectureChangeHistory
     *   }
     * })
     * 
     */
    delete<T extends ArchitectureChangeHistoryDeleteArgs>(args: SelectSubset<T, ArchitectureChangeHistoryDeleteArgs<ExtArgs>>): Prisma__ArchitectureChangeHistoryClient<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArchitectureChangeHistory.
     * @param {ArchitectureChangeHistoryUpdateArgs} args - Arguments to update one ArchitectureChangeHistory.
     * @example
     * // Update one ArchitectureChangeHistory
     * const architectureChangeHistory = await prisma.architectureChangeHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArchitectureChangeHistoryUpdateArgs>(args: SelectSubset<T, ArchitectureChangeHistoryUpdateArgs<ExtArgs>>): Prisma__ArchitectureChangeHistoryClient<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArchitectureChangeHistories.
     * @param {ArchitectureChangeHistoryDeleteManyArgs} args - Arguments to filter ArchitectureChangeHistories to delete.
     * @example
     * // Delete a few ArchitectureChangeHistories
     * const { count } = await prisma.architectureChangeHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArchitectureChangeHistoryDeleteManyArgs>(args?: SelectSubset<T, ArchitectureChangeHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArchitectureChangeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchitectureChangeHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArchitectureChangeHistories
     * const architectureChangeHistory = await prisma.architectureChangeHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArchitectureChangeHistoryUpdateManyArgs>(args: SelectSubset<T, ArchitectureChangeHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArchitectureChangeHistories and returns the data updated in the database.
     * @param {ArchitectureChangeHistoryUpdateManyAndReturnArgs} args - Arguments to update many ArchitectureChangeHistories.
     * @example
     * // Update many ArchitectureChangeHistories
     * const architectureChangeHistory = await prisma.architectureChangeHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArchitectureChangeHistories and only return the `id`
     * const architectureChangeHistoryWithIdOnly = await prisma.architectureChangeHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArchitectureChangeHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ArchitectureChangeHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArchitectureChangeHistory.
     * @param {ArchitectureChangeHistoryUpsertArgs} args - Arguments to update or create a ArchitectureChangeHistory.
     * @example
     * // Update or create a ArchitectureChangeHistory
     * const architectureChangeHistory = await prisma.architectureChangeHistory.upsert({
     *   create: {
     *     // ... data to create a ArchitectureChangeHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArchitectureChangeHistory we want to update
     *   }
     * })
     */
    upsert<T extends ArchitectureChangeHistoryUpsertArgs>(args: SelectSubset<T, ArchitectureChangeHistoryUpsertArgs<ExtArgs>>): Prisma__ArchitectureChangeHistoryClient<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArchitectureChangeHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchitectureChangeHistoryCountArgs} args - Arguments to filter ArchitectureChangeHistories to count.
     * @example
     * // Count the number of ArchitectureChangeHistories
     * const count = await prisma.architectureChangeHistory.count({
     *   where: {
     *     // ... the filter for the ArchitectureChangeHistories we want to count
     *   }
     * })
    **/
    count<T extends ArchitectureChangeHistoryCountArgs>(
      args?: Subset<T, ArchitectureChangeHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArchitectureChangeHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArchitectureChangeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchitectureChangeHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArchitectureChangeHistoryAggregateArgs>(args: Subset<T, ArchitectureChangeHistoryAggregateArgs>): Prisma.PrismaPromise<GetArchitectureChangeHistoryAggregateType<T>>

    /**
     * Group by ArchitectureChangeHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArchitectureChangeHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArchitectureChangeHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArchitectureChangeHistoryGroupByArgs['orderBy'] }
        : { orderBy?: ArchitectureChangeHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArchitectureChangeHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArchitectureChangeHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArchitectureChangeHistory model
   */
  readonly fields: ArchitectureChangeHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArchitectureChangeHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArchitectureChangeHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    architecture<T extends SystemArchitectureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SystemArchitectureDefaultArgs<ExtArgs>>): Prisma__SystemArchitectureClient<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends ArchitectureChangeHistory$UserArgs<ExtArgs> = {}>(args?: Subset<T, ArchitectureChangeHistory$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArchitectureChangeHistory model
   */
  interface ArchitectureChangeHistoryFieldRefs {
    readonly id: FieldRef<"ArchitectureChangeHistory", 'String'>
    readonly architectureId: FieldRef<"ArchitectureChangeHistory", 'String'>
    readonly changeType: FieldRef<"ArchitectureChangeHistory", 'String'>
    readonly changeDescription: FieldRef<"ArchitectureChangeHistory", 'String'>
    readonly changeReason: FieldRef<"ArchitectureChangeHistory", 'String'>
    readonly impact: FieldRef<"ArchitectureChangeHistory", 'String'>
    readonly beforeChange: FieldRef<"ArchitectureChangeHistory", 'Json'>
    readonly afterChange: FieldRef<"ArchitectureChangeHistory", 'Json'>
    readonly changedAt: FieldRef<"ArchitectureChangeHistory", 'DateTime'>
    readonly userId: FieldRef<"ArchitectureChangeHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ArchitectureChangeHistory findUnique
   */
  export type ArchitectureChangeHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ArchitectureChangeHistory to fetch.
     */
    where: ArchitectureChangeHistoryWhereUniqueInput
  }

  /**
   * ArchitectureChangeHistory findUniqueOrThrow
   */
  export type ArchitectureChangeHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ArchitectureChangeHistory to fetch.
     */
    where: ArchitectureChangeHistoryWhereUniqueInput
  }

  /**
   * ArchitectureChangeHistory findFirst
   */
  export type ArchitectureChangeHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ArchitectureChangeHistory to fetch.
     */
    where?: ArchitectureChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchitectureChangeHistories to fetch.
     */
    orderBy?: ArchitectureChangeHistoryOrderByWithRelationInput | ArchitectureChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArchitectureChangeHistories.
     */
    cursor?: ArchitectureChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchitectureChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchitectureChangeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArchitectureChangeHistories.
     */
    distinct?: ArchitectureChangeHistoryScalarFieldEnum | ArchitectureChangeHistoryScalarFieldEnum[]
  }

  /**
   * ArchitectureChangeHistory findFirstOrThrow
   */
  export type ArchitectureChangeHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ArchitectureChangeHistory to fetch.
     */
    where?: ArchitectureChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchitectureChangeHistories to fetch.
     */
    orderBy?: ArchitectureChangeHistoryOrderByWithRelationInput | ArchitectureChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArchitectureChangeHistories.
     */
    cursor?: ArchitectureChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchitectureChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchitectureChangeHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArchitectureChangeHistories.
     */
    distinct?: ArchitectureChangeHistoryScalarFieldEnum | ArchitectureChangeHistoryScalarFieldEnum[]
  }

  /**
   * ArchitectureChangeHistory findMany
   */
  export type ArchitectureChangeHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter, which ArchitectureChangeHistories to fetch.
     */
    where?: ArchitectureChangeHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArchitectureChangeHistories to fetch.
     */
    orderBy?: ArchitectureChangeHistoryOrderByWithRelationInput | ArchitectureChangeHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArchitectureChangeHistories.
     */
    cursor?: ArchitectureChangeHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArchitectureChangeHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArchitectureChangeHistories.
     */
    skip?: number
    distinct?: ArchitectureChangeHistoryScalarFieldEnum | ArchitectureChangeHistoryScalarFieldEnum[]
  }

  /**
   * ArchitectureChangeHistory create
   */
  export type ArchitectureChangeHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ArchitectureChangeHistory.
     */
    data: XOR<ArchitectureChangeHistoryCreateInput, ArchitectureChangeHistoryUncheckedCreateInput>
  }

  /**
   * ArchitectureChangeHistory createMany
   */
  export type ArchitectureChangeHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArchitectureChangeHistories.
     */
    data: ArchitectureChangeHistoryCreateManyInput | ArchitectureChangeHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArchitectureChangeHistory createManyAndReturn
   */
  export type ArchitectureChangeHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many ArchitectureChangeHistories.
     */
    data: ArchitectureChangeHistoryCreateManyInput | ArchitectureChangeHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArchitectureChangeHistory update
   */
  export type ArchitectureChangeHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ArchitectureChangeHistory.
     */
    data: XOR<ArchitectureChangeHistoryUpdateInput, ArchitectureChangeHistoryUncheckedUpdateInput>
    /**
     * Choose, which ArchitectureChangeHistory to update.
     */
    where: ArchitectureChangeHistoryWhereUniqueInput
  }

  /**
   * ArchitectureChangeHistory updateMany
   */
  export type ArchitectureChangeHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArchitectureChangeHistories.
     */
    data: XOR<ArchitectureChangeHistoryUpdateManyMutationInput, ArchitectureChangeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ArchitectureChangeHistories to update
     */
    where?: ArchitectureChangeHistoryWhereInput
    /**
     * Limit how many ArchitectureChangeHistories to update.
     */
    limit?: number
  }

  /**
   * ArchitectureChangeHistory updateManyAndReturn
   */
  export type ArchitectureChangeHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * The data used to update ArchitectureChangeHistories.
     */
    data: XOR<ArchitectureChangeHistoryUpdateManyMutationInput, ArchitectureChangeHistoryUncheckedUpdateManyInput>
    /**
     * Filter which ArchitectureChangeHistories to update
     */
    where?: ArchitectureChangeHistoryWhereInput
    /**
     * Limit how many ArchitectureChangeHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArchitectureChangeHistory upsert
   */
  export type ArchitectureChangeHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ArchitectureChangeHistory to update in case it exists.
     */
    where: ArchitectureChangeHistoryWhereUniqueInput
    /**
     * In case the ArchitectureChangeHistory found by the `where` argument doesn't exist, create a new ArchitectureChangeHistory with this data.
     */
    create: XOR<ArchitectureChangeHistoryCreateInput, ArchitectureChangeHistoryUncheckedCreateInput>
    /**
     * In case the ArchitectureChangeHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArchitectureChangeHistoryUpdateInput, ArchitectureChangeHistoryUncheckedUpdateInput>
  }

  /**
   * ArchitectureChangeHistory delete
   */
  export type ArchitectureChangeHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    /**
     * Filter which ArchitectureChangeHistory to delete.
     */
    where: ArchitectureChangeHistoryWhereUniqueInput
  }

  /**
   * ArchitectureChangeHistory deleteMany
   */
  export type ArchitectureChangeHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArchitectureChangeHistories to delete
     */
    where?: ArchitectureChangeHistoryWhereInput
    /**
     * Limit how many ArchitectureChangeHistories to delete.
     */
    limit?: number
  }

  /**
   * ArchitectureChangeHistory.User
   */
  export type ArchitectureChangeHistory$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ArchitectureChangeHistory without action
   */
  export type ArchitectureChangeHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
  }


  /**
   * Model DatabaseSchema
   */

  export type AggregateDatabaseSchema = {
    _count: DatabaseSchemaCountAggregateOutputType | null
    _avg: DatabaseSchemaAvgAggregateOutputType | null
    _sum: DatabaseSchemaSumAggregateOutputType | null
    _min: DatabaseSchemaMinAggregateOutputType | null
    _max: DatabaseSchemaMaxAggregateOutputType | null
  }

  export type DatabaseSchemaAvgAggregateOutputType = {
    version: number | null
  }

  export type DatabaseSchemaSumAggregateOutputType = {
    version: number | null
  }

  export type DatabaseSchemaMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    schemaName: string | null
    engine: $Enums.DatabaseEngine | null
    charset: string | null
    collation: string | null
    description: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type DatabaseSchemaMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    schemaName: string | null
    engine: $Enums.DatabaseEngine | null
    charset: string | null
    collation: string | null
    description: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type DatabaseSchemaCountAggregateOutputType = {
    id: number
    projectId: number
    schemaName: number
    engine: number
    charset: number
    collation: number
    description: number
    version: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    userId: number
    _all: number
  }


  export type DatabaseSchemaAvgAggregateInputType = {
    version?: true
  }

  export type DatabaseSchemaSumAggregateInputType = {
    version?: true
  }

  export type DatabaseSchemaMinAggregateInputType = {
    id?: true
    projectId?: true
    schemaName?: true
    engine?: true
    charset?: true
    collation?: true
    description?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type DatabaseSchemaMaxAggregateInputType = {
    id?: true
    projectId?: true
    schemaName?: true
    engine?: true
    charset?: true
    collation?: true
    description?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type DatabaseSchemaCountAggregateInputType = {
    id?: true
    projectId?: true
    schemaName?: true
    engine?: true
    charset?: true
    collation?: true
    description?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
    _all?: true
  }

  export type DatabaseSchemaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseSchema to aggregate.
     */
    where?: DatabaseSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseSchemas to fetch.
     */
    orderBy?: DatabaseSchemaOrderByWithRelationInput | DatabaseSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatabaseSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatabaseSchemas
    **/
    _count?: true | DatabaseSchemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatabaseSchemaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatabaseSchemaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatabaseSchemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatabaseSchemaMaxAggregateInputType
  }

  export type GetDatabaseSchemaAggregateType<T extends DatabaseSchemaAggregateArgs> = {
        [P in keyof T & keyof AggregateDatabaseSchema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatabaseSchema[P]>
      : GetScalarType<T[P], AggregateDatabaseSchema[P]>
  }




  export type DatabaseSchemaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseSchemaWhereInput
    orderBy?: DatabaseSchemaOrderByWithAggregationInput | DatabaseSchemaOrderByWithAggregationInput[]
    by: DatabaseSchemaScalarFieldEnum[] | DatabaseSchemaScalarFieldEnum
    having?: DatabaseSchemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatabaseSchemaCountAggregateInputType | true
    _avg?: DatabaseSchemaAvgAggregateInputType
    _sum?: DatabaseSchemaSumAggregateInputType
    _min?: DatabaseSchemaMinAggregateInputType
    _max?: DatabaseSchemaMaxAggregateInputType
  }

  export type DatabaseSchemaGroupByOutputType = {
    id: string
    projectId: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset: string
    collation: string
    description: string | null
    version: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    userId: string | null
    _count: DatabaseSchemaCountAggregateOutputType | null
    _avg: DatabaseSchemaAvgAggregateOutputType | null
    _sum: DatabaseSchemaSumAggregateOutputType | null
    _min: DatabaseSchemaMinAggregateOutputType | null
    _max: DatabaseSchemaMaxAggregateOutputType | null
  }

  type GetDatabaseSchemaGroupByPayload<T extends DatabaseSchemaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatabaseSchemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatabaseSchemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatabaseSchemaGroupByOutputType[P]>
            : GetScalarType<T[P], DatabaseSchemaGroupByOutputType[P]>
        }
      >
    >


  export type DatabaseSchemaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    schemaName?: boolean
    engine?: boolean
    charset?: boolean
    collation?: boolean
    description?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tables?: boolean | DatabaseSchema$tablesArgs<ExtArgs>
    User?: boolean | DatabaseSchema$UserArgs<ExtArgs>
    _count?: boolean | DatabaseSchemaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseSchema"]>

  export type DatabaseSchemaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    schemaName?: boolean
    engine?: boolean
    charset?: boolean
    collation?: boolean
    description?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | DatabaseSchema$UserArgs<ExtArgs>
  }, ExtArgs["result"]["databaseSchema"]>

  export type DatabaseSchemaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    schemaName?: boolean
    engine?: boolean
    charset?: boolean
    collation?: boolean
    description?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | DatabaseSchema$UserArgs<ExtArgs>
  }, ExtArgs["result"]["databaseSchema"]>

  export type DatabaseSchemaSelectScalar = {
    id?: boolean
    projectId?: boolean
    schemaName?: boolean
    engine?: boolean
    charset?: boolean
    collation?: boolean
    description?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
  }

  export type DatabaseSchemaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "schemaName" | "engine" | "charset" | "collation" | "description" | "version" | "createdAt" | "updatedAt" | "deletedAt" | "userId", ExtArgs["result"]["databaseSchema"]>
  export type DatabaseSchemaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tables?: boolean | DatabaseSchema$tablesArgs<ExtArgs>
    User?: boolean | DatabaseSchema$UserArgs<ExtArgs>
    _count?: boolean | DatabaseSchemaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DatabaseSchemaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | DatabaseSchema$UserArgs<ExtArgs>
  }
  export type DatabaseSchemaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | DatabaseSchema$UserArgs<ExtArgs>
  }

  export type $DatabaseSchemaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatabaseSchema"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tables: Prisma.$DatabaseTablePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      schemaName: string
      engine: $Enums.DatabaseEngine
      charset: string
      collation: string
      description: string | null
      version: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      userId: string | null
    }, ExtArgs["result"]["databaseSchema"]>
    composites: {}
  }

  type DatabaseSchemaGetPayload<S extends boolean | null | undefined | DatabaseSchemaDefaultArgs> = $Result.GetResult<Prisma.$DatabaseSchemaPayload, S>

  type DatabaseSchemaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DatabaseSchemaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DatabaseSchemaCountAggregateInputType | true
    }

  export interface DatabaseSchemaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatabaseSchema'], meta: { name: 'DatabaseSchema' } }
    /**
     * Find zero or one DatabaseSchema that matches the filter.
     * @param {DatabaseSchemaFindUniqueArgs} args - Arguments to find a DatabaseSchema
     * @example
     * // Get one DatabaseSchema
     * const databaseSchema = await prisma.databaseSchema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatabaseSchemaFindUniqueArgs>(args: SelectSubset<T, DatabaseSchemaFindUniqueArgs<ExtArgs>>): Prisma__DatabaseSchemaClient<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DatabaseSchema that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DatabaseSchemaFindUniqueOrThrowArgs} args - Arguments to find a DatabaseSchema
     * @example
     * // Get one DatabaseSchema
     * const databaseSchema = await prisma.databaseSchema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatabaseSchemaFindUniqueOrThrowArgs>(args: SelectSubset<T, DatabaseSchemaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatabaseSchemaClient<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatabaseSchema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseSchemaFindFirstArgs} args - Arguments to find a DatabaseSchema
     * @example
     * // Get one DatabaseSchema
     * const databaseSchema = await prisma.databaseSchema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatabaseSchemaFindFirstArgs>(args?: SelectSubset<T, DatabaseSchemaFindFirstArgs<ExtArgs>>): Prisma__DatabaseSchemaClient<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatabaseSchema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseSchemaFindFirstOrThrowArgs} args - Arguments to find a DatabaseSchema
     * @example
     * // Get one DatabaseSchema
     * const databaseSchema = await prisma.databaseSchema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatabaseSchemaFindFirstOrThrowArgs>(args?: SelectSubset<T, DatabaseSchemaFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatabaseSchemaClient<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DatabaseSchemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseSchemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatabaseSchemas
     * const databaseSchemas = await prisma.databaseSchema.findMany()
     * 
     * // Get first 10 DatabaseSchemas
     * const databaseSchemas = await prisma.databaseSchema.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const databaseSchemaWithIdOnly = await prisma.databaseSchema.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatabaseSchemaFindManyArgs>(args?: SelectSubset<T, DatabaseSchemaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DatabaseSchema.
     * @param {DatabaseSchemaCreateArgs} args - Arguments to create a DatabaseSchema.
     * @example
     * // Create one DatabaseSchema
     * const DatabaseSchema = await prisma.databaseSchema.create({
     *   data: {
     *     // ... data to create a DatabaseSchema
     *   }
     * })
     * 
     */
    create<T extends DatabaseSchemaCreateArgs>(args: SelectSubset<T, DatabaseSchemaCreateArgs<ExtArgs>>): Prisma__DatabaseSchemaClient<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DatabaseSchemas.
     * @param {DatabaseSchemaCreateManyArgs} args - Arguments to create many DatabaseSchemas.
     * @example
     * // Create many DatabaseSchemas
     * const databaseSchema = await prisma.databaseSchema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatabaseSchemaCreateManyArgs>(args?: SelectSubset<T, DatabaseSchemaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatabaseSchemas and returns the data saved in the database.
     * @param {DatabaseSchemaCreateManyAndReturnArgs} args - Arguments to create many DatabaseSchemas.
     * @example
     * // Create many DatabaseSchemas
     * const databaseSchema = await prisma.databaseSchema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatabaseSchemas and only return the `id`
     * const databaseSchemaWithIdOnly = await prisma.databaseSchema.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatabaseSchemaCreateManyAndReturnArgs>(args?: SelectSubset<T, DatabaseSchemaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DatabaseSchema.
     * @param {DatabaseSchemaDeleteArgs} args - Arguments to delete one DatabaseSchema.
     * @example
     * // Delete one DatabaseSchema
     * const DatabaseSchema = await prisma.databaseSchema.delete({
     *   where: {
     *     // ... filter to delete one DatabaseSchema
     *   }
     * })
     * 
     */
    delete<T extends DatabaseSchemaDeleteArgs>(args: SelectSubset<T, DatabaseSchemaDeleteArgs<ExtArgs>>): Prisma__DatabaseSchemaClient<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DatabaseSchema.
     * @param {DatabaseSchemaUpdateArgs} args - Arguments to update one DatabaseSchema.
     * @example
     * // Update one DatabaseSchema
     * const databaseSchema = await prisma.databaseSchema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatabaseSchemaUpdateArgs>(args: SelectSubset<T, DatabaseSchemaUpdateArgs<ExtArgs>>): Prisma__DatabaseSchemaClient<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DatabaseSchemas.
     * @param {DatabaseSchemaDeleteManyArgs} args - Arguments to filter DatabaseSchemas to delete.
     * @example
     * // Delete a few DatabaseSchemas
     * const { count } = await prisma.databaseSchema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatabaseSchemaDeleteManyArgs>(args?: SelectSubset<T, DatabaseSchemaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseSchemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatabaseSchemas
     * const databaseSchema = await prisma.databaseSchema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatabaseSchemaUpdateManyArgs>(args: SelectSubset<T, DatabaseSchemaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseSchemas and returns the data updated in the database.
     * @param {DatabaseSchemaUpdateManyAndReturnArgs} args - Arguments to update many DatabaseSchemas.
     * @example
     * // Update many DatabaseSchemas
     * const databaseSchema = await prisma.databaseSchema.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DatabaseSchemas and only return the `id`
     * const databaseSchemaWithIdOnly = await prisma.databaseSchema.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DatabaseSchemaUpdateManyAndReturnArgs>(args: SelectSubset<T, DatabaseSchemaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DatabaseSchema.
     * @param {DatabaseSchemaUpsertArgs} args - Arguments to update or create a DatabaseSchema.
     * @example
     * // Update or create a DatabaseSchema
     * const databaseSchema = await prisma.databaseSchema.upsert({
     *   create: {
     *     // ... data to create a DatabaseSchema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatabaseSchema we want to update
     *   }
     * })
     */
    upsert<T extends DatabaseSchemaUpsertArgs>(args: SelectSubset<T, DatabaseSchemaUpsertArgs<ExtArgs>>): Prisma__DatabaseSchemaClient<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DatabaseSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseSchemaCountArgs} args - Arguments to filter DatabaseSchemas to count.
     * @example
     * // Count the number of DatabaseSchemas
     * const count = await prisma.databaseSchema.count({
     *   where: {
     *     // ... the filter for the DatabaseSchemas we want to count
     *   }
     * })
    **/
    count<T extends DatabaseSchemaCountArgs>(
      args?: Subset<T, DatabaseSchemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatabaseSchemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatabaseSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseSchemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatabaseSchemaAggregateArgs>(args: Subset<T, DatabaseSchemaAggregateArgs>): Prisma.PrismaPromise<GetDatabaseSchemaAggregateType<T>>

    /**
     * Group by DatabaseSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseSchemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatabaseSchemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatabaseSchemaGroupByArgs['orderBy'] }
        : { orderBy?: DatabaseSchemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatabaseSchemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatabaseSchemaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatabaseSchema model
   */
  readonly fields: DatabaseSchemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatabaseSchema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatabaseSchemaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tables<T extends DatabaseSchema$tablesArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseSchema$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends DatabaseSchema$UserArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseSchema$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatabaseSchema model
   */
  interface DatabaseSchemaFieldRefs {
    readonly id: FieldRef<"DatabaseSchema", 'String'>
    readonly projectId: FieldRef<"DatabaseSchema", 'String'>
    readonly schemaName: FieldRef<"DatabaseSchema", 'String'>
    readonly engine: FieldRef<"DatabaseSchema", 'DatabaseEngine'>
    readonly charset: FieldRef<"DatabaseSchema", 'String'>
    readonly collation: FieldRef<"DatabaseSchema", 'String'>
    readonly description: FieldRef<"DatabaseSchema", 'String'>
    readonly version: FieldRef<"DatabaseSchema", 'Int'>
    readonly createdAt: FieldRef<"DatabaseSchema", 'DateTime'>
    readonly updatedAt: FieldRef<"DatabaseSchema", 'DateTime'>
    readonly deletedAt: FieldRef<"DatabaseSchema", 'DateTime'>
    readonly userId: FieldRef<"DatabaseSchema", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DatabaseSchema findUnique
   */
  export type DatabaseSchemaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseSchema to fetch.
     */
    where: DatabaseSchemaWhereUniqueInput
  }

  /**
   * DatabaseSchema findUniqueOrThrow
   */
  export type DatabaseSchemaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseSchema to fetch.
     */
    where: DatabaseSchemaWhereUniqueInput
  }

  /**
   * DatabaseSchema findFirst
   */
  export type DatabaseSchemaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseSchema to fetch.
     */
    where?: DatabaseSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseSchemas to fetch.
     */
    orderBy?: DatabaseSchemaOrderByWithRelationInput | DatabaseSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseSchemas.
     */
    cursor?: DatabaseSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseSchemas.
     */
    distinct?: DatabaseSchemaScalarFieldEnum | DatabaseSchemaScalarFieldEnum[]
  }

  /**
   * DatabaseSchema findFirstOrThrow
   */
  export type DatabaseSchemaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseSchema to fetch.
     */
    where?: DatabaseSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseSchemas to fetch.
     */
    orderBy?: DatabaseSchemaOrderByWithRelationInput | DatabaseSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseSchemas.
     */
    cursor?: DatabaseSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseSchemas.
     */
    distinct?: DatabaseSchemaScalarFieldEnum | DatabaseSchemaScalarFieldEnum[]
  }

  /**
   * DatabaseSchema findMany
   */
  export type DatabaseSchemaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseSchemas to fetch.
     */
    where?: DatabaseSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseSchemas to fetch.
     */
    orderBy?: DatabaseSchemaOrderByWithRelationInput | DatabaseSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatabaseSchemas.
     */
    cursor?: DatabaseSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseSchemas.
     */
    skip?: number
    distinct?: DatabaseSchemaScalarFieldEnum | DatabaseSchemaScalarFieldEnum[]
  }

  /**
   * DatabaseSchema create
   */
  export type DatabaseSchemaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    /**
     * The data needed to create a DatabaseSchema.
     */
    data: XOR<DatabaseSchemaCreateInput, DatabaseSchemaUncheckedCreateInput>
  }

  /**
   * DatabaseSchema createMany
   */
  export type DatabaseSchemaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatabaseSchemas.
     */
    data: DatabaseSchemaCreateManyInput | DatabaseSchemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatabaseSchema createManyAndReturn
   */
  export type DatabaseSchemaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * The data used to create many DatabaseSchemas.
     */
    data: DatabaseSchemaCreateManyInput | DatabaseSchemaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatabaseSchema update
   */
  export type DatabaseSchemaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    /**
     * The data needed to update a DatabaseSchema.
     */
    data: XOR<DatabaseSchemaUpdateInput, DatabaseSchemaUncheckedUpdateInput>
    /**
     * Choose, which DatabaseSchema to update.
     */
    where: DatabaseSchemaWhereUniqueInput
  }

  /**
   * DatabaseSchema updateMany
   */
  export type DatabaseSchemaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatabaseSchemas.
     */
    data: XOR<DatabaseSchemaUpdateManyMutationInput, DatabaseSchemaUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseSchemas to update
     */
    where?: DatabaseSchemaWhereInput
    /**
     * Limit how many DatabaseSchemas to update.
     */
    limit?: number
  }

  /**
   * DatabaseSchema updateManyAndReturn
   */
  export type DatabaseSchemaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * The data used to update DatabaseSchemas.
     */
    data: XOR<DatabaseSchemaUpdateManyMutationInput, DatabaseSchemaUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseSchemas to update
     */
    where?: DatabaseSchemaWhereInput
    /**
     * Limit how many DatabaseSchemas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatabaseSchema upsert
   */
  export type DatabaseSchemaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    /**
     * The filter to search for the DatabaseSchema to update in case it exists.
     */
    where: DatabaseSchemaWhereUniqueInput
    /**
     * In case the DatabaseSchema found by the `where` argument doesn't exist, create a new DatabaseSchema with this data.
     */
    create: XOR<DatabaseSchemaCreateInput, DatabaseSchemaUncheckedCreateInput>
    /**
     * In case the DatabaseSchema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatabaseSchemaUpdateInput, DatabaseSchemaUncheckedUpdateInput>
  }

  /**
   * DatabaseSchema delete
   */
  export type DatabaseSchemaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    /**
     * Filter which DatabaseSchema to delete.
     */
    where: DatabaseSchemaWhereUniqueInput
  }

  /**
   * DatabaseSchema deleteMany
   */
  export type DatabaseSchemaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseSchemas to delete
     */
    where?: DatabaseSchemaWhereInput
    /**
     * Limit how many DatabaseSchemas to delete.
     */
    limit?: number
  }

  /**
   * DatabaseSchema.tables
   */
  export type DatabaseSchema$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    where?: DatabaseTableWhereInput
    orderBy?: DatabaseTableOrderByWithRelationInput | DatabaseTableOrderByWithRelationInput[]
    cursor?: DatabaseTableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatabaseTableScalarFieldEnum | DatabaseTableScalarFieldEnum[]
  }

  /**
   * DatabaseSchema.User
   */
  export type DatabaseSchema$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DatabaseSchema without action
   */
  export type DatabaseSchemaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
  }


  /**
   * Model DatabaseTable
   */

  export type AggregateDatabaseTable = {
    _count: DatabaseTableCountAggregateOutputType | null
    _avg: DatabaseTableAvgAggregateOutputType | null
    _sum: DatabaseTableSumAggregateOutputType | null
    _min: DatabaseTableMinAggregateOutputType | null
    _max: DatabaseTableMaxAggregateOutputType | null
  }

  export type DatabaseTableAvgAggregateOutputType = {
    autoIncrement: number | null
  }

  export type DatabaseTableSumAggregateOutputType = {
    autoIncrement: number | null
  }

  export type DatabaseTableMinAggregateOutputType = {
    id: string | null
    schemaId: string | null
    tableName: string | null
    displayName: string | null
    description: string | null
    engine: string | null
    charset: string | null
    collation: string | null
    autoIncrement: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatabaseTableMaxAggregateOutputType = {
    id: string | null
    schemaId: string | null
    tableName: string | null
    displayName: string | null
    description: string | null
    engine: string | null
    charset: string | null
    collation: string | null
    autoIncrement: number | null
    comment: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatabaseTableCountAggregateOutputType = {
    id: number
    schemaId: number
    tableName: number
    displayName: number
    description: number
    engine: number
    charset: number
    collation: number
    autoIncrement: number
    comment: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DatabaseTableAvgAggregateInputType = {
    autoIncrement?: true
  }

  export type DatabaseTableSumAggregateInputType = {
    autoIncrement?: true
  }

  export type DatabaseTableMinAggregateInputType = {
    id?: true
    schemaId?: true
    tableName?: true
    displayName?: true
    description?: true
    engine?: true
    charset?: true
    collation?: true
    autoIncrement?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatabaseTableMaxAggregateInputType = {
    id?: true
    schemaId?: true
    tableName?: true
    displayName?: true
    description?: true
    engine?: true
    charset?: true
    collation?: true
    autoIncrement?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatabaseTableCountAggregateInputType = {
    id?: true
    schemaId?: true
    tableName?: true
    displayName?: true
    description?: true
    engine?: true
    charset?: true
    collation?: true
    autoIncrement?: true
    comment?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DatabaseTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseTable to aggregate.
     */
    where?: DatabaseTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseTables to fetch.
     */
    orderBy?: DatabaseTableOrderByWithRelationInput | DatabaseTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatabaseTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatabaseTables
    **/
    _count?: true | DatabaseTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DatabaseTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DatabaseTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatabaseTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatabaseTableMaxAggregateInputType
  }

  export type GetDatabaseTableAggregateType<T extends DatabaseTableAggregateArgs> = {
        [P in keyof T & keyof AggregateDatabaseTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatabaseTable[P]>
      : GetScalarType<T[P], AggregateDatabaseTable[P]>
  }




  export type DatabaseTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseTableWhereInput
    orderBy?: DatabaseTableOrderByWithAggregationInput | DatabaseTableOrderByWithAggregationInput[]
    by: DatabaseTableScalarFieldEnum[] | DatabaseTableScalarFieldEnum
    having?: DatabaseTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatabaseTableCountAggregateInputType | true
    _avg?: DatabaseTableAvgAggregateInputType
    _sum?: DatabaseTableSumAggregateInputType
    _min?: DatabaseTableMinAggregateInputType
    _max?: DatabaseTableMaxAggregateInputType
  }

  export type DatabaseTableGroupByOutputType = {
    id: string
    schemaId: string
    tableName: string
    displayName: string
    description: string | null
    engine: string | null
    charset: string | null
    collation: string | null
    autoIncrement: number | null
    comment: string | null
    createdAt: Date
    updatedAt: Date
    _count: DatabaseTableCountAggregateOutputType | null
    _avg: DatabaseTableAvgAggregateOutputType | null
    _sum: DatabaseTableSumAggregateOutputType | null
    _min: DatabaseTableMinAggregateOutputType | null
    _max: DatabaseTableMaxAggregateOutputType | null
  }

  type GetDatabaseTableGroupByPayload<T extends DatabaseTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatabaseTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatabaseTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatabaseTableGroupByOutputType[P]>
            : GetScalarType<T[P], DatabaseTableGroupByOutputType[P]>
        }
      >
    >


  export type DatabaseTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    tableName?: boolean
    displayName?: boolean
    description?: boolean
    engine?: boolean
    charset?: boolean
    collation?: boolean
    autoIncrement?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schema?: boolean | DatabaseSchemaDefaultArgs<ExtArgs>
    columns?: boolean | DatabaseTable$columnsArgs<ExtArgs>
    indexes?: boolean | DatabaseTable$indexesArgs<ExtArgs>
    sourceRelations?: boolean | DatabaseTable$sourceRelationsArgs<ExtArgs>
    targetRelations?: boolean | DatabaseTable$targetRelationsArgs<ExtArgs>
    _count?: boolean | DatabaseTableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseTable"]>

  export type DatabaseTableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    tableName?: boolean
    displayName?: boolean
    description?: boolean
    engine?: boolean
    charset?: boolean
    collation?: boolean
    autoIncrement?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schema?: boolean | DatabaseSchemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseTable"]>

  export type DatabaseTableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    tableName?: boolean
    displayName?: boolean
    description?: boolean
    engine?: boolean
    charset?: boolean
    collation?: boolean
    autoIncrement?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    schema?: boolean | DatabaseSchemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseTable"]>

  export type DatabaseTableSelectScalar = {
    id?: boolean
    schemaId?: boolean
    tableName?: boolean
    displayName?: boolean
    description?: boolean
    engine?: boolean
    charset?: boolean
    collation?: boolean
    autoIncrement?: boolean
    comment?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DatabaseTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schemaId" | "tableName" | "displayName" | "description" | "engine" | "charset" | "collation" | "autoIncrement" | "comment" | "createdAt" | "updatedAt", ExtArgs["result"]["databaseTable"]>
  export type DatabaseTableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schema?: boolean | DatabaseSchemaDefaultArgs<ExtArgs>
    columns?: boolean | DatabaseTable$columnsArgs<ExtArgs>
    indexes?: boolean | DatabaseTable$indexesArgs<ExtArgs>
    sourceRelations?: boolean | DatabaseTable$sourceRelationsArgs<ExtArgs>
    targetRelations?: boolean | DatabaseTable$targetRelationsArgs<ExtArgs>
    _count?: boolean | DatabaseTableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DatabaseTableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schema?: boolean | DatabaseSchemaDefaultArgs<ExtArgs>
  }
  export type DatabaseTableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schema?: boolean | DatabaseSchemaDefaultArgs<ExtArgs>
  }

  export type $DatabaseTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatabaseTable"
    objects: {
      schema: Prisma.$DatabaseSchemaPayload<ExtArgs>
      columns: Prisma.$TableColumnPayload<ExtArgs>[]
      indexes: Prisma.$DatabaseIndexPayload<ExtArgs>[]
      sourceRelations: Prisma.$DatabaseRelationPayload<ExtArgs>[]
      targetRelations: Prisma.$DatabaseRelationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schemaId: string
      tableName: string
      displayName: string
      description: string | null
      engine: string | null
      charset: string | null
      collation: string | null
      autoIncrement: number | null
      comment: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["databaseTable"]>
    composites: {}
  }

  type DatabaseTableGetPayload<S extends boolean | null | undefined | DatabaseTableDefaultArgs> = $Result.GetResult<Prisma.$DatabaseTablePayload, S>

  type DatabaseTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DatabaseTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DatabaseTableCountAggregateInputType | true
    }

  export interface DatabaseTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatabaseTable'], meta: { name: 'DatabaseTable' } }
    /**
     * Find zero or one DatabaseTable that matches the filter.
     * @param {DatabaseTableFindUniqueArgs} args - Arguments to find a DatabaseTable
     * @example
     * // Get one DatabaseTable
     * const databaseTable = await prisma.databaseTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatabaseTableFindUniqueArgs>(args: SelectSubset<T, DatabaseTableFindUniqueArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DatabaseTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DatabaseTableFindUniqueOrThrowArgs} args - Arguments to find a DatabaseTable
     * @example
     * // Get one DatabaseTable
     * const databaseTable = await prisma.databaseTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatabaseTableFindUniqueOrThrowArgs>(args: SelectSubset<T, DatabaseTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatabaseTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseTableFindFirstArgs} args - Arguments to find a DatabaseTable
     * @example
     * // Get one DatabaseTable
     * const databaseTable = await prisma.databaseTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatabaseTableFindFirstArgs>(args?: SelectSubset<T, DatabaseTableFindFirstArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatabaseTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseTableFindFirstOrThrowArgs} args - Arguments to find a DatabaseTable
     * @example
     * // Get one DatabaseTable
     * const databaseTable = await prisma.databaseTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatabaseTableFindFirstOrThrowArgs>(args?: SelectSubset<T, DatabaseTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DatabaseTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatabaseTables
     * const databaseTables = await prisma.databaseTable.findMany()
     * 
     * // Get first 10 DatabaseTables
     * const databaseTables = await prisma.databaseTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const databaseTableWithIdOnly = await prisma.databaseTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatabaseTableFindManyArgs>(args?: SelectSubset<T, DatabaseTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DatabaseTable.
     * @param {DatabaseTableCreateArgs} args - Arguments to create a DatabaseTable.
     * @example
     * // Create one DatabaseTable
     * const DatabaseTable = await prisma.databaseTable.create({
     *   data: {
     *     // ... data to create a DatabaseTable
     *   }
     * })
     * 
     */
    create<T extends DatabaseTableCreateArgs>(args: SelectSubset<T, DatabaseTableCreateArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DatabaseTables.
     * @param {DatabaseTableCreateManyArgs} args - Arguments to create many DatabaseTables.
     * @example
     * // Create many DatabaseTables
     * const databaseTable = await prisma.databaseTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatabaseTableCreateManyArgs>(args?: SelectSubset<T, DatabaseTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatabaseTables and returns the data saved in the database.
     * @param {DatabaseTableCreateManyAndReturnArgs} args - Arguments to create many DatabaseTables.
     * @example
     * // Create many DatabaseTables
     * const databaseTable = await prisma.databaseTable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatabaseTables and only return the `id`
     * const databaseTableWithIdOnly = await prisma.databaseTable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatabaseTableCreateManyAndReturnArgs>(args?: SelectSubset<T, DatabaseTableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DatabaseTable.
     * @param {DatabaseTableDeleteArgs} args - Arguments to delete one DatabaseTable.
     * @example
     * // Delete one DatabaseTable
     * const DatabaseTable = await prisma.databaseTable.delete({
     *   where: {
     *     // ... filter to delete one DatabaseTable
     *   }
     * })
     * 
     */
    delete<T extends DatabaseTableDeleteArgs>(args: SelectSubset<T, DatabaseTableDeleteArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DatabaseTable.
     * @param {DatabaseTableUpdateArgs} args - Arguments to update one DatabaseTable.
     * @example
     * // Update one DatabaseTable
     * const databaseTable = await prisma.databaseTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatabaseTableUpdateArgs>(args: SelectSubset<T, DatabaseTableUpdateArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DatabaseTables.
     * @param {DatabaseTableDeleteManyArgs} args - Arguments to filter DatabaseTables to delete.
     * @example
     * // Delete a few DatabaseTables
     * const { count } = await prisma.databaseTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatabaseTableDeleteManyArgs>(args?: SelectSubset<T, DatabaseTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatabaseTables
     * const databaseTable = await prisma.databaseTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatabaseTableUpdateManyArgs>(args: SelectSubset<T, DatabaseTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseTables and returns the data updated in the database.
     * @param {DatabaseTableUpdateManyAndReturnArgs} args - Arguments to update many DatabaseTables.
     * @example
     * // Update many DatabaseTables
     * const databaseTable = await prisma.databaseTable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DatabaseTables and only return the `id`
     * const databaseTableWithIdOnly = await prisma.databaseTable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DatabaseTableUpdateManyAndReturnArgs>(args: SelectSubset<T, DatabaseTableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DatabaseTable.
     * @param {DatabaseTableUpsertArgs} args - Arguments to update or create a DatabaseTable.
     * @example
     * // Update or create a DatabaseTable
     * const databaseTable = await prisma.databaseTable.upsert({
     *   create: {
     *     // ... data to create a DatabaseTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatabaseTable we want to update
     *   }
     * })
     */
    upsert<T extends DatabaseTableUpsertArgs>(args: SelectSubset<T, DatabaseTableUpsertArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DatabaseTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseTableCountArgs} args - Arguments to filter DatabaseTables to count.
     * @example
     * // Count the number of DatabaseTables
     * const count = await prisma.databaseTable.count({
     *   where: {
     *     // ... the filter for the DatabaseTables we want to count
     *   }
     * })
    **/
    count<T extends DatabaseTableCountArgs>(
      args?: Subset<T, DatabaseTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatabaseTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatabaseTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatabaseTableAggregateArgs>(args: Subset<T, DatabaseTableAggregateArgs>): Prisma.PrismaPromise<GetDatabaseTableAggregateType<T>>

    /**
     * Group by DatabaseTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatabaseTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatabaseTableGroupByArgs['orderBy'] }
        : { orderBy?: DatabaseTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatabaseTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatabaseTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatabaseTable model
   */
  readonly fields: DatabaseTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatabaseTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatabaseTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schema<T extends DatabaseSchemaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseSchemaDefaultArgs<ExtArgs>>): Prisma__DatabaseSchemaClient<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    columns<T extends DatabaseTable$columnsArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseTable$columnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    indexes<T extends DatabaseTable$indexesArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseTable$indexesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourceRelations<T extends DatabaseTable$sourceRelationsArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseTable$sourceRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    targetRelations<T extends DatabaseTable$targetRelationsArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseTable$targetRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatabaseTable model
   */
  interface DatabaseTableFieldRefs {
    readonly id: FieldRef<"DatabaseTable", 'String'>
    readonly schemaId: FieldRef<"DatabaseTable", 'String'>
    readonly tableName: FieldRef<"DatabaseTable", 'String'>
    readonly displayName: FieldRef<"DatabaseTable", 'String'>
    readonly description: FieldRef<"DatabaseTable", 'String'>
    readonly engine: FieldRef<"DatabaseTable", 'String'>
    readonly charset: FieldRef<"DatabaseTable", 'String'>
    readonly collation: FieldRef<"DatabaseTable", 'String'>
    readonly autoIncrement: FieldRef<"DatabaseTable", 'Int'>
    readonly comment: FieldRef<"DatabaseTable", 'String'>
    readonly createdAt: FieldRef<"DatabaseTable", 'DateTime'>
    readonly updatedAt: FieldRef<"DatabaseTable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DatabaseTable findUnique
   */
  export type DatabaseTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseTable to fetch.
     */
    where: DatabaseTableWhereUniqueInput
  }

  /**
   * DatabaseTable findUniqueOrThrow
   */
  export type DatabaseTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseTable to fetch.
     */
    where: DatabaseTableWhereUniqueInput
  }

  /**
   * DatabaseTable findFirst
   */
  export type DatabaseTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseTable to fetch.
     */
    where?: DatabaseTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseTables to fetch.
     */
    orderBy?: DatabaseTableOrderByWithRelationInput | DatabaseTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseTables.
     */
    cursor?: DatabaseTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseTables.
     */
    distinct?: DatabaseTableScalarFieldEnum | DatabaseTableScalarFieldEnum[]
  }

  /**
   * DatabaseTable findFirstOrThrow
   */
  export type DatabaseTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseTable to fetch.
     */
    where?: DatabaseTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseTables to fetch.
     */
    orderBy?: DatabaseTableOrderByWithRelationInput | DatabaseTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseTables.
     */
    cursor?: DatabaseTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseTables.
     */
    distinct?: DatabaseTableScalarFieldEnum | DatabaseTableScalarFieldEnum[]
  }

  /**
   * DatabaseTable findMany
   */
  export type DatabaseTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseTables to fetch.
     */
    where?: DatabaseTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseTables to fetch.
     */
    orderBy?: DatabaseTableOrderByWithRelationInput | DatabaseTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatabaseTables.
     */
    cursor?: DatabaseTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseTables.
     */
    skip?: number
    distinct?: DatabaseTableScalarFieldEnum | DatabaseTableScalarFieldEnum[]
  }

  /**
   * DatabaseTable create
   */
  export type DatabaseTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    /**
     * The data needed to create a DatabaseTable.
     */
    data: XOR<DatabaseTableCreateInput, DatabaseTableUncheckedCreateInput>
  }

  /**
   * DatabaseTable createMany
   */
  export type DatabaseTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatabaseTables.
     */
    data: DatabaseTableCreateManyInput | DatabaseTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatabaseTable createManyAndReturn
   */
  export type DatabaseTableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * The data used to create many DatabaseTables.
     */
    data: DatabaseTableCreateManyInput | DatabaseTableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatabaseTable update
   */
  export type DatabaseTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    /**
     * The data needed to update a DatabaseTable.
     */
    data: XOR<DatabaseTableUpdateInput, DatabaseTableUncheckedUpdateInput>
    /**
     * Choose, which DatabaseTable to update.
     */
    where: DatabaseTableWhereUniqueInput
  }

  /**
   * DatabaseTable updateMany
   */
  export type DatabaseTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatabaseTables.
     */
    data: XOR<DatabaseTableUpdateManyMutationInput, DatabaseTableUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseTables to update
     */
    where?: DatabaseTableWhereInput
    /**
     * Limit how many DatabaseTables to update.
     */
    limit?: number
  }

  /**
   * DatabaseTable updateManyAndReturn
   */
  export type DatabaseTableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * The data used to update DatabaseTables.
     */
    data: XOR<DatabaseTableUpdateManyMutationInput, DatabaseTableUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseTables to update
     */
    where?: DatabaseTableWhereInput
    /**
     * Limit how many DatabaseTables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatabaseTable upsert
   */
  export type DatabaseTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    /**
     * The filter to search for the DatabaseTable to update in case it exists.
     */
    where: DatabaseTableWhereUniqueInput
    /**
     * In case the DatabaseTable found by the `where` argument doesn't exist, create a new DatabaseTable with this data.
     */
    create: XOR<DatabaseTableCreateInput, DatabaseTableUncheckedCreateInput>
    /**
     * In case the DatabaseTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatabaseTableUpdateInput, DatabaseTableUncheckedUpdateInput>
  }

  /**
   * DatabaseTable delete
   */
  export type DatabaseTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
    /**
     * Filter which DatabaseTable to delete.
     */
    where: DatabaseTableWhereUniqueInput
  }

  /**
   * DatabaseTable deleteMany
   */
  export type DatabaseTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseTables to delete
     */
    where?: DatabaseTableWhereInput
    /**
     * Limit how many DatabaseTables to delete.
     */
    limit?: number
  }

  /**
   * DatabaseTable.columns
   */
  export type DatabaseTable$columnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    where?: TableColumnWhereInput
    orderBy?: TableColumnOrderByWithRelationInput | TableColumnOrderByWithRelationInput[]
    cursor?: TableColumnWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableColumnScalarFieldEnum | TableColumnScalarFieldEnum[]
  }

  /**
   * DatabaseTable.indexes
   */
  export type DatabaseTable$indexesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    where?: DatabaseIndexWhereInput
    orderBy?: DatabaseIndexOrderByWithRelationInput | DatabaseIndexOrderByWithRelationInput[]
    cursor?: DatabaseIndexWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatabaseIndexScalarFieldEnum | DatabaseIndexScalarFieldEnum[]
  }

  /**
   * DatabaseTable.sourceRelations
   */
  export type DatabaseTable$sourceRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    where?: DatabaseRelationWhereInput
    orderBy?: DatabaseRelationOrderByWithRelationInput | DatabaseRelationOrderByWithRelationInput[]
    cursor?: DatabaseRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatabaseRelationScalarFieldEnum | DatabaseRelationScalarFieldEnum[]
  }

  /**
   * DatabaseTable.targetRelations
   */
  export type DatabaseTable$targetRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    where?: DatabaseRelationWhereInput
    orderBy?: DatabaseRelationOrderByWithRelationInput | DatabaseRelationOrderByWithRelationInput[]
    cursor?: DatabaseRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatabaseRelationScalarFieldEnum | DatabaseRelationScalarFieldEnum[]
  }

  /**
   * DatabaseTable without action
   */
  export type DatabaseTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseTable
     */
    select?: DatabaseTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseTable
     */
    omit?: DatabaseTableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseTableInclude<ExtArgs> | null
  }


  /**
   * Model TableColumn
   */

  export type AggregateTableColumn = {
    _count: TableColumnCountAggregateOutputType | null
    _avg: TableColumnAvgAggregateOutputType | null
    _sum: TableColumnSumAggregateOutputType | null
    _min: TableColumnMinAggregateOutputType | null
    _max: TableColumnMaxAggregateOutputType | null
  }

  export type TableColumnAvgAggregateOutputType = {
    length: number | null
    precision: number | null
    scale: number | null
    position: number | null
  }

  export type TableColumnSumAggregateOutputType = {
    length: number | null
    precision: number | null
    scale: number | null
    position: number | null
  }

  export type TableColumnMinAggregateOutputType = {
    id: string | null
    tableId: string | null
    columnName: string | null
    displayName: string | null
    columnType: $Enums.ColumnType | null
    length: number | null
    precision: number | null
    scale: number | null
    isPrimaryKey: boolean | null
    isNullable: boolean | null
    isUnique: boolean | null
    isAutoIncrement: boolean | null
    defaultValue: string | null
    comment: string | null
    isForeignKey: boolean | null
    referencedTable: string | null
    referencedColumn: string | null
    onDelete: string | null
    onUpdate: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableColumnMaxAggregateOutputType = {
    id: string | null
    tableId: string | null
    columnName: string | null
    displayName: string | null
    columnType: $Enums.ColumnType | null
    length: number | null
    precision: number | null
    scale: number | null
    isPrimaryKey: boolean | null
    isNullable: boolean | null
    isUnique: boolean | null
    isAutoIncrement: boolean | null
    defaultValue: string | null
    comment: string | null
    isForeignKey: boolean | null
    referencedTable: string | null
    referencedColumn: string | null
    onDelete: string | null
    onUpdate: string | null
    position: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TableColumnCountAggregateOutputType = {
    id: number
    tableId: number
    columnName: number
    displayName: number
    columnType: number
    length: number
    precision: number
    scale: number
    isPrimaryKey: number
    isNullable: number
    isUnique: number
    isAutoIncrement: number
    defaultValue: number
    comment: number
    enumValues: number
    isForeignKey: number
    referencedTable: number
    referencedColumn: number
    onDelete: number
    onUpdate: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TableColumnAvgAggregateInputType = {
    length?: true
    precision?: true
    scale?: true
    position?: true
  }

  export type TableColumnSumAggregateInputType = {
    length?: true
    precision?: true
    scale?: true
    position?: true
  }

  export type TableColumnMinAggregateInputType = {
    id?: true
    tableId?: true
    columnName?: true
    displayName?: true
    columnType?: true
    length?: true
    precision?: true
    scale?: true
    isPrimaryKey?: true
    isNullable?: true
    isUnique?: true
    isAutoIncrement?: true
    defaultValue?: true
    comment?: true
    isForeignKey?: true
    referencedTable?: true
    referencedColumn?: true
    onDelete?: true
    onUpdate?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableColumnMaxAggregateInputType = {
    id?: true
    tableId?: true
    columnName?: true
    displayName?: true
    columnType?: true
    length?: true
    precision?: true
    scale?: true
    isPrimaryKey?: true
    isNullable?: true
    isUnique?: true
    isAutoIncrement?: true
    defaultValue?: true
    comment?: true
    isForeignKey?: true
    referencedTable?: true
    referencedColumn?: true
    onDelete?: true
    onUpdate?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TableColumnCountAggregateInputType = {
    id?: true
    tableId?: true
    columnName?: true
    displayName?: true
    columnType?: true
    length?: true
    precision?: true
    scale?: true
    isPrimaryKey?: true
    isNullable?: true
    isUnique?: true
    isAutoIncrement?: true
    defaultValue?: true
    comment?: true
    enumValues?: true
    isForeignKey?: true
    referencedTable?: true
    referencedColumn?: true
    onDelete?: true
    onUpdate?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TableColumnAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableColumn to aggregate.
     */
    where?: TableColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableColumns to fetch.
     */
    orderBy?: TableColumnOrderByWithRelationInput | TableColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TableColumns
    **/
    _count?: true | TableColumnCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TableColumnAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TableColumnSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableColumnMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableColumnMaxAggregateInputType
  }

  export type GetTableColumnAggregateType<T extends TableColumnAggregateArgs> = {
        [P in keyof T & keyof AggregateTableColumn]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTableColumn[P]>
      : GetScalarType<T[P], AggregateTableColumn[P]>
  }




  export type TableColumnGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableColumnWhereInput
    orderBy?: TableColumnOrderByWithAggregationInput | TableColumnOrderByWithAggregationInput[]
    by: TableColumnScalarFieldEnum[] | TableColumnScalarFieldEnum
    having?: TableColumnScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableColumnCountAggregateInputType | true
    _avg?: TableColumnAvgAggregateInputType
    _sum?: TableColumnSumAggregateInputType
    _min?: TableColumnMinAggregateInputType
    _max?: TableColumnMaxAggregateInputType
  }

  export type TableColumnGroupByOutputType = {
    id: string
    tableId: string
    columnName: string
    displayName: string
    columnType: $Enums.ColumnType
    length: number | null
    precision: number | null
    scale: number | null
    isPrimaryKey: boolean
    isNullable: boolean
    isUnique: boolean
    isAutoIncrement: boolean
    defaultValue: string | null
    comment: string | null
    enumValues: string[]
    isForeignKey: boolean
    referencedTable: string | null
    referencedColumn: string | null
    onDelete: string | null
    onUpdate: string | null
    position: number
    createdAt: Date
    updatedAt: Date
    _count: TableColumnCountAggregateOutputType | null
    _avg: TableColumnAvgAggregateOutputType | null
    _sum: TableColumnSumAggregateOutputType | null
    _min: TableColumnMinAggregateOutputType | null
    _max: TableColumnMaxAggregateOutputType | null
  }

  type GetTableColumnGroupByPayload<T extends TableColumnGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableColumnGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableColumnGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableColumnGroupByOutputType[P]>
            : GetScalarType<T[P], TableColumnGroupByOutputType[P]>
        }
      >
    >


  export type TableColumnSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    columnName?: boolean
    displayName?: boolean
    columnType?: boolean
    length?: boolean
    precision?: boolean
    scale?: boolean
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: boolean
    comment?: boolean
    enumValues?: boolean
    isForeignKey?: boolean
    referencedTable?: boolean
    referencedColumn?: boolean
    onDelete?: boolean
    onUpdate?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tableColumn"]>

  export type TableColumnSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    columnName?: boolean
    displayName?: boolean
    columnType?: boolean
    length?: boolean
    precision?: boolean
    scale?: boolean
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: boolean
    comment?: boolean
    enumValues?: boolean
    isForeignKey?: boolean
    referencedTable?: boolean
    referencedColumn?: boolean
    onDelete?: boolean
    onUpdate?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tableColumn"]>

  export type TableColumnSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    columnName?: boolean
    displayName?: boolean
    columnType?: boolean
    length?: boolean
    precision?: boolean
    scale?: boolean
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: boolean
    comment?: boolean
    enumValues?: boolean
    isForeignKey?: boolean
    referencedTable?: boolean
    referencedColumn?: boolean
    onDelete?: boolean
    onUpdate?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tableColumn"]>

  export type TableColumnSelectScalar = {
    id?: boolean
    tableId?: boolean
    columnName?: boolean
    displayName?: boolean
    columnType?: boolean
    length?: boolean
    precision?: boolean
    scale?: boolean
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: boolean
    comment?: boolean
    enumValues?: boolean
    isForeignKey?: boolean
    referencedTable?: boolean
    referencedColumn?: boolean
    onDelete?: boolean
    onUpdate?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TableColumnOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableId" | "columnName" | "displayName" | "columnType" | "length" | "precision" | "scale" | "isPrimaryKey" | "isNullable" | "isUnique" | "isAutoIncrement" | "defaultValue" | "comment" | "enumValues" | "isForeignKey" | "referencedTable" | "referencedColumn" | "onDelete" | "onUpdate" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["tableColumn"]>
  export type TableColumnInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }
  export type TableColumnIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }
  export type TableColumnIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }

  export type $TableColumnPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TableColumn"
    objects: {
      table: Prisma.$DatabaseTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableId: string
      columnName: string
      displayName: string
      columnType: $Enums.ColumnType
      length: number | null
      precision: number | null
      scale: number | null
      isPrimaryKey: boolean
      isNullable: boolean
      isUnique: boolean
      isAutoIncrement: boolean
      defaultValue: string | null
      comment: string | null
      enumValues: string[]
      isForeignKey: boolean
      referencedTable: string | null
      referencedColumn: string | null
      onDelete: string | null
      onUpdate: string | null
      position: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tableColumn"]>
    composites: {}
  }

  type TableColumnGetPayload<S extends boolean | null | undefined | TableColumnDefaultArgs> = $Result.GetResult<Prisma.$TableColumnPayload, S>

  type TableColumnCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TableColumnFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TableColumnCountAggregateInputType | true
    }

  export interface TableColumnDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TableColumn'], meta: { name: 'TableColumn' } }
    /**
     * Find zero or one TableColumn that matches the filter.
     * @param {TableColumnFindUniqueArgs} args - Arguments to find a TableColumn
     * @example
     * // Get one TableColumn
     * const tableColumn = await prisma.tableColumn.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableColumnFindUniqueArgs>(args: SelectSubset<T, TableColumnFindUniqueArgs<ExtArgs>>): Prisma__TableColumnClient<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TableColumn that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TableColumnFindUniqueOrThrowArgs} args - Arguments to find a TableColumn
     * @example
     * // Get one TableColumn
     * const tableColumn = await prisma.tableColumn.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableColumnFindUniqueOrThrowArgs>(args: SelectSubset<T, TableColumnFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableColumnClient<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TableColumn that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableColumnFindFirstArgs} args - Arguments to find a TableColumn
     * @example
     * // Get one TableColumn
     * const tableColumn = await prisma.tableColumn.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableColumnFindFirstArgs>(args?: SelectSubset<T, TableColumnFindFirstArgs<ExtArgs>>): Prisma__TableColumnClient<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TableColumn that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableColumnFindFirstOrThrowArgs} args - Arguments to find a TableColumn
     * @example
     * // Get one TableColumn
     * const tableColumn = await prisma.tableColumn.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableColumnFindFirstOrThrowArgs>(args?: SelectSubset<T, TableColumnFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableColumnClient<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TableColumns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableColumnFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TableColumns
     * const tableColumns = await prisma.tableColumn.findMany()
     * 
     * // Get first 10 TableColumns
     * const tableColumns = await prisma.tableColumn.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tableColumnWithIdOnly = await prisma.tableColumn.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TableColumnFindManyArgs>(args?: SelectSubset<T, TableColumnFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TableColumn.
     * @param {TableColumnCreateArgs} args - Arguments to create a TableColumn.
     * @example
     * // Create one TableColumn
     * const TableColumn = await prisma.tableColumn.create({
     *   data: {
     *     // ... data to create a TableColumn
     *   }
     * })
     * 
     */
    create<T extends TableColumnCreateArgs>(args: SelectSubset<T, TableColumnCreateArgs<ExtArgs>>): Prisma__TableColumnClient<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TableColumns.
     * @param {TableColumnCreateManyArgs} args - Arguments to create many TableColumns.
     * @example
     * // Create many TableColumns
     * const tableColumn = await prisma.tableColumn.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableColumnCreateManyArgs>(args?: SelectSubset<T, TableColumnCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TableColumns and returns the data saved in the database.
     * @param {TableColumnCreateManyAndReturnArgs} args - Arguments to create many TableColumns.
     * @example
     * // Create many TableColumns
     * const tableColumn = await prisma.tableColumn.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TableColumns and only return the `id`
     * const tableColumnWithIdOnly = await prisma.tableColumn.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TableColumnCreateManyAndReturnArgs>(args?: SelectSubset<T, TableColumnCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TableColumn.
     * @param {TableColumnDeleteArgs} args - Arguments to delete one TableColumn.
     * @example
     * // Delete one TableColumn
     * const TableColumn = await prisma.tableColumn.delete({
     *   where: {
     *     // ... filter to delete one TableColumn
     *   }
     * })
     * 
     */
    delete<T extends TableColumnDeleteArgs>(args: SelectSubset<T, TableColumnDeleteArgs<ExtArgs>>): Prisma__TableColumnClient<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TableColumn.
     * @param {TableColumnUpdateArgs} args - Arguments to update one TableColumn.
     * @example
     * // Update one TableColumn
     * const tableColumn = await prisma.tableColumn.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableColumnUpdateArgs>(args: SelectSubset<T, TableColumnUpdateArgs<ExtArgs>>): Prisma__TableColumnClient<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TableColumns.
     * @param {TableColumnDeleteManyArgs} args - Arguments to filter TableColumns to delete.
     * @example
     * // Delete a few TableColumns
     * const { count } = await prisma.tableColumn.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableColumnDeleteManyArgs>(args?: SelectSubset<T, TableColumnDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TableColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableColumnUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TableColumns
     * const tableColumn = await prisma.tableColumn.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableColumnUpdateManyArgs>(args: SelectSubset<T, TableColumnUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TableColumns and returns the data updated in the database.
     * @param {TableColumnUpdateManyAndReturnArgs} args - Arguments to update many TableColumns.
     * @example
     * // Update many TableColumns
     * const tableColumn = await prisma.tableColumn.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TableColumns and only return the `id`
     * const tableColumnWithIdOnly = await prisma.tableColumn.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TableColumnUpdateManyAndReturnArgs>(args: SelectSubset<T, TableColumnUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TableColumn.
     * @param {TableColumnUpsertArgs} args - Arguments to update or create a TableColumn.
     * @example
     * // Update or create a TableColumn
     * const tableColumn = await prisma.tableColumn.upsert({
     *   create: {
     *     // ... data to create a TableColumn
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TableColumn we want to update
     *   }
     * })
     */
    upsert<T extends TableColumnUpsertArgs>(args: SelectSubset<T, TableColumnUpsertArgs<ExtArgs>>): Prisma__TableColumnClient<$Result.GetResult<Prisma.$TableColumnPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TableColumns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableColumnCountArgs} args - Arguments to filter TableColumns to count.
     * @example
     * // Count the number of TableColumns
     * const count = await prisma.tableColumn.count({
     *   where: {
     *     // ... the filter for the TableColumns we want to count
     *   }
     * })
    **/
    count<T extends TableColumnCountArgs>(
      args?: Subset<T, TableColumnCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableColumnCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TableColumn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableColumnAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableColumnAggregateArgs>(args: Subset<T, TableColumnAggregateArgs>): Prisma.PrismaPromise<GetTableColumnAggregateType<T>>

    /**
     * Group by TableColumn.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableColumnGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableColumnGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableColumnGroupByArgs['orderBy'] }
        : { orderBy?: TableColumnGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableColumnGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableColumnGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TableColumn model
   */
  readonly fields: TableColumnFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TableColumn.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableColumnClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    table<T extends DatabaseTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseTableDefaultArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TableColumn model
   */
  interface TableColumnFieldRefs {
    readonly id: FieldRef<"TableColumn", 'String'>
    readonly tableId: FieldRef<"TableColumn", 'String'>
    readonly columnName: FieldRef<"TableColumn", 'String'>
    readonly displayName: FieldRef<"TableColumn", 'String'>
    readonly columnType: FieldRef<"TableColumn", 'ColumnType'>
    readonly length: FieldRef<"TableColumn", 'Int'>
    readonly precision: FieldRef<"TableColumn", 'Int'>
    readonly scale: FieldRef<"TableColumn", 'Int'>
    readonly isPrimaryKey: FieldRef<"TableColumn", 'Boolean'>
    readonly isNullable: FieldRef<"TableColumn", 'Boolean'>
    readonly isUnique: FieldRef<"TableColumn", 'Boolean'>
    readonly isAutoIncrement: FieldRef<"TableColumn", 'Boolean'>
    readonly defaultValue: FieldRef<"TableColumn", 'String'>
    readonly comment: FieldRef<"TableColumn", 'String'>
    readonly enumValues: FieldRef<"TableColumn", 'String[]'>
    readonly isForeignKey: FieldRef<"TableColumn", 'Boolean'>
    readonly referencedTable: FieldRef<"TableColumn", 'String'>
    readonly referencedColumn: FieldRef<"TableColumn", 'String'>
    readonly onDelete: FieldRef<"TableColumn", 'String'>
    readonly onUpdate: FieldRef<"TableColumn", 'String'>
    readonly position: FieldRef<"TableColumn", 'Int'>
    readonly createdAt: FieldRef<"TableColumn", 'DateTime'>
    readonly updatedAt: FieldRef<"TableColumn", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TableColumn findUnique
   */
  export type TableColumnFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    /**
     * Filter, which TableColumn to fetch.
     */
    where: TableColumnWhereUniqueInput
  }

  /**
   * TableColumn findUniqueOrThrow
   */
  export type TableColumnFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    /**
     * Filter, which TableColumn to fetch.
     */
    where: TableColumnWhereUniqueInput
  }

  /**
   * TableColumn findFirst
   */
  export type TableColumnFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    /**
     * Filter, which TableColumn to fetch.
     */
    where?: TableColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableColumns to fetch.
     */
    orderBy?: TableColumnOrderByWithRelationInput | TableColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableColumns.
     */
    cursor?: TableColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableColumns.
     */
    distinct?: TableColumnScalarFieldEnum | TableColumnScalarFieldEnum[]
  }

  /**
   * TableColumn findFirstOrThrow
   */
  export type TableColumnFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    /**
     * Filter, which TableColumn to fetch.
     */
    where?: TableColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableColumns to fetch.
     */
    orderBy?: TableColumnOrderByWithRelationInput | TableColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TableColumns.
     */
    cursor?: TableColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableColumns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TableColumns.
     */
    distinct?: TableColumnScalarFieldEnum | TableColumnScalarFieldEnum[]
  }

  /**
   * TableColumn findMany
   */
  export type TableColumnFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    /**
     * Filter, which TableColumns to fetch.
     */
    where?: TableColumnWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TableColumns to fetch.
     */
    orderBy?: TableColumnOrderByWithRelationInput | TableColumnOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TableColumns.
     */
    cursor?: TableColumnWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TableColumns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TableColumns.
     */
    skip?: number
    distinct?: TableColumnScalarFieldEnum | TableColumnScalarFieldEnum[]
  }

  /**
   * TableColumn create
   */
  export type TableColumnCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    /**
     * The data needed to create a TableColumn.
     */
    data: XOR<TableColumnCreateInput, TableColumnUncheckedCreateInput>
  }

  /**
   * TableColumn createMany
   */
  export type TableColumnCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TableColumns.
     */
    data: TableColumnCreateManyInput | TableColumnCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TableColumn createManyAndReturn
   */
  export type TableColumnCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * The data used to create many TableColumns.
     */
    data: TableColumnCreateManyInput | TableColumnCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TableColumn update
   */
  export type TableColumnUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    /**
     * The data needed to update a TableColumn.
     */
    data: XOR<TableColumnUpdateInput, TableColumnUncheckedUpdateInput>
    /**
     * Choose, which TableColumn to update.
     */
    where: TableColumnWhereUniqueInput
  }

  /**
   * TableColumn updateMany
   */
  export type TableColumnUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TableColumns.
     */
    data: XOR<TableColumnUpdateManyMutationInput, TableColumnUncheckedUpdateManyInput>
    /**
     * Filter which TableColumns to update
     */
    where?: TableColumnWhereInput
    /**
     * Limit how many TableColumns to update.
     */
    limit?: number
  }

  /**
   * TableColumn updateManyAndReturn
   */
  export type TableColumnUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * The data used to update TableColumns.
     */
    data: XOR<TableColumnUpdateManyMutationInput, TableColumnUncheckedUpdateManyInput>
    /**
     * Filter which TableColumns to update
     */
    where?: TableColumnWhereInput
    /**
     * Limit how many TableColumns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TableColumn upsert
   */
  export type TableColumnUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    /**
     * The filter to search for the TableColumn to update in case it exists.
     */
    where: TableColumnWhereUniqueInput
    /**
     * In case the TableColumn found by the `where` argument doesn't exist, create a new TableColumn with this data.
     */
    create: XOR<TableColumnCreateInput, TableColumnUncheckedCreateInput>
    /**
     * In case the TableColumn was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableColumnUpdateInput, TableColumnUncheckedUpdateInput>
  }

  /**
   * TableColumn delete
   */
  export type TableColumnDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
    /**
     * Filter which TableColumn to delete.
     */
    where: TableColumnWhereUniqueInput
  }

  /**
   * TableColumn deleteMany
   */
  export type TableColumnDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TableColumns to delete
     */
    where?: TableColumnWhereInput
    /**
     * Limit how many TableColumns to delete.
     */
    limit?: number
  }

  /**
   * TableColumn without action
   */
  export type TableColumnDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableColumn
     */
    select?: TableColumnSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TableColumn
     */
    omit?: TableColumnOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableColumnInclude<ExtArgs> | null
  }


  /**
   * Model DatabaseIndex
   */

  export type AggregateDatabaseIndex = {
    _count: DatabaseIndexCountAggregateOutputType | null
    _min: DatabaseIndexMinAggregateOutputType | null
    _max: DatabaseIndexMaxAggregateOutputType | null
  }

  export type DatabaseIndexMinAggregateOutputType = {
    id: string | null
    tableId: string | null
    indexName: string | null
    indexType: $Enums.IndexType | null
    isUnique: boolean | null
    comment: string | null
    algorithm: string | null
    lockOption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatabaseIndexMaxAggregateOutputType = {
    id: string | null
    tableId: string | null
    indexName: string | null
    indexType: $Enums.IndexType | null
    isUnique: boolean | null
    comment: string | null
    algorithm: string | null
    lockOption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatabaseIndexCountAggregateOutputType = {
    id: number
    tableId: number
    indexName: number
    indexType: number
    columns: number
    isUnique: number
    comment: number
    algorithm: number
    lockOption: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DatabaseIndexMinAggregateInputType = {
    id?: true
    tableId?: true
    indexName?: true
    indexType?: true
    isUnique?: true
    comment?: true
    algorithm?: true
    lockOption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatabaseIndexMaxAggregateInputType = {
    id?: true
    tableId?: true
    indexName?: true
    indexType?: true
    isUnique?: true
    comment?: true
    algorithm?: true
    lockOption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatabaseIndexCountAggregateInputType = {
    id?: true
    tableId?: true
    indexName?: true
    indexType?: true
    columns?: true
    isUnique?: true
    comment?: true
    algorithm?: true
    lockOption?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DatabaseIndexAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseIndex to aggregate.
     */
    where?: DatabaseIndexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseIndices to fetch.
     */
    orderBy?: DatabaseIndexOrderByWithRelationInput | DatabaseIndexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatabaseIndexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseIndices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseIndices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatabaseIndices
    **/
    _count?: true | DatabaseIndexCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatabaseIndexMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatabaseIndexMaxAggregateInputType
  }

  export type GetDatabaseIndexAggregateType<T extends DatabaseIndexAggregateArgs> = {
        [P in keyof T & keyof AggregateDatabaseIndex]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatabaseIndex[P]>
      : GetScalarType<T[P], AggregateDatabaseIndex[P]>
  }




  export type DatabaseIndexGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseIndexWhereInput
    orderBy?: DatabaseIndexOrderByWithAggregationInput | DatabaseIndexOrderByWithAggregationInput[]
    by: DatabaseIndexScalarFieldEnum[] | DatabaseIndexScalarFieldEnum
    having?: DatabaseIndexScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatabaseIndexCountAggregateInputType | true
    _min?: DatabaseIndexMinAggregateInputType
    _max?: DatabaseIndexMaxAggregateInputType
  }

  export type DatabaseIndexGroupByOutputType = {
    id: string
    tableId: string
    indexName: string
    indexType: $Enums.IndexType
    columns: string[]
    isUnique: boolean
    comment: string | null
    algorithm: string | null
    lockOption: string | null
    createdAt: Date
    updatedAt: Date
    _count: DatabaseIndexCountAggregateOutputType | null
    _min: DatabaseIndexMinAggregateOutputType | null
    _max: DatabaseIndexMaxAggregateOutputType | null
  }

  type GetDatabaseIndexGroupByPayload<T extends DatabaseIndexGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatabaseIndexGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatabaseIndexGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatabaseIndexGroupByOutputType[P]>
            : GetScalarType<T[P], DatabaseIndexGroupByOutputType[P]>
        }
      >
    >


  export type DatabaseIndexSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    indexName?: boolean
    indexType?: boolean
    columns?: boolean
    isUnique?: boolean
    comment?: boolean
    algorithm?: boolean
    lockOption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseIndex"]>

  export type DatabaseIndexSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    indexName?: boolean
    indexType?: boolean
    columns?: boolean
    isUnique?: boolean
    comment?: boolean
    algorithm?: boolean
    lockOption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseIndex"]>

  export type DatabaseIndexSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableId?: boolean
    indexName?: boolean
    indexType?: boolean
    columns?: boolean
    isUnique?: boolean
    comment?: boolean
    algorithm?: boolean
    lockOption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseIndex"]>

  export type DatabaseIndexSelectScalar = {
    id?: boolean
    tableId?: boolean
    indexName?: boolean
    indexType?: boolean
    columns?: boolean
    isUnique?: boolean
    comment?: boolean
    algorithm?: boolean
    lockOption?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DatabaseIndexOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableId" | "indexName" | "indexType" | "columns" | "isUnique" | "comment" | "algorithm" | "lockOption" | "createdAt" | "updatedAt", ExtArgs["result"]["databaseIndex"]>
  export type DatabaseIndexInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }
  export type DatabaseIndexIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }
  export type DatabaseIndexIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    table?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }

  export type $DatabaseIndexPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatabaseIndex"
    objects: {
      table: Prisma.$DatabaseTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableId: string
      indexName: string
      indexType: $Enums.IndexType
      columns: string[]
      isUnique: boolean
      comment: string | null
      algorithm: string | null
      lockOption: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["databaseIndex"]>
    composites: {}
  }

  type DatabaseIndexGetPayload<S extends boolean | null | undefined | DatabaseIndexDefaultArgs> = $Result.GetResult<Prisma.$DatabaseIndexPayload, S>

  type DatabaseIndexCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DatabaseIndexFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DatabaseIndexCountAggregateInputType | true
    }

  export interface DatabaseIndexDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatabaseIndex'], meta: { name: 'DatabaseIndex' } }
    /**
     * Find zero or one DatabaseIndex that matches the filter.
     * @param {DatabaseIndexFindUniqueArgs} args - Arguments to find a DatabaseIndex
     * @example
     * // Get one DatabaseIndex
     * const databaseIndex = await prisma.databaseIndex.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatabaseIndexFindUniqueArgs>(args: SelectSubset<T, DatabaseIndexFindUniqueArgs<ExtArgs>>): Prisma__DatabaseIndexClient<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DatabaseIndex that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DatabaseIndexFindUniqueOrThrowArgs} args - Arguments to find a DatabaseIndex
     * @example
     * // Get one DatabaseIndex
     * const databaseIndex = await prisma.databaseIndex.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatabaseIndexFindUniqueOrThrowArgs>(args: SelectSubset<T, DatabaseIndexFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatabaseIndexClient<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatabaseIndex that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseIndexFindFirstArgs} args - Arguments to find a DatabaseIndex
     * @example
     * // Get one DatabaseIndex
     * const databaseIndex = await prisma.databaseIndex.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatabaseIndexFindFirstArgs>(args?: SelectSubset<T, DatabaseIndexFindFirstArgs<ExtArgs>>): Prisma__DatabaseIndexClient<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatabaseIndex that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseIndexFindFirstOrThrowArgs} args - Arguments to find a DatabaseIndex
     * @example
     * // Get one DatabaseIndex
     * const databaseIndex = await prisma.databaseIndex.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatabaseIndexFindFirstOrThrowArgs>(args?: SelectSubset<T, DatabaseIndexFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatabaseIndexClient<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DatabaseIndices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseIndexFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatabaseIndices
     * const databaseIndices = await prisma.databaseIndex.findMany()
     * 
     * // Get first 10 DatabaseIndices
     * const databaseIndices = await prisma.databaseIndex.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const databaseIndexWithIdOnly = await prisma.databaseIndex.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatabaseIndexFindManyArgs>(args?: SelectSubset<T, DatabaseIndexFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DatabaseIndex.
     * @param {DatabaseIndexCreateArgs} args - Arguments to create a DatabaseIndex.
     * @example
     * // Create one DatabaseIndex
     * const DatabaseIndex = await prisma.databaseIndex.create({
     *   data: {
     *     // ... data to create a DatabaseIndex
     *   }
     * })
     * 
     */
    create<T extends DatabaseIndexCreateArgs>(args: SelectSubset<T, DatabaseIndexCreateArgs<ExtArgs>>): Prisma__DatabaseIndexClient<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DatabaseIndices.
     * @param {DatabaseIndexCreateManyArgs} args - Arguments to create many DatabaseIndices.
     * @example
     * // Create many DatabaseIndices
     * const databaseIndex = await prisma.databaseIndex.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatabaseIndexCreateManyArgs>(args?: SelectSubset<T, DatabaseIndexCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatabaseIndices and returns the data saved in the database.
     * @param {DatabaseIndexCreateManyAndReturnArgs} args - Arguments to create many DatabaseIndices.
     * @example
     * // Create many DatabaseIndices
     * const databaseIndex = await prisma.databaseIndex.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatabaseIndices and only return the `id`
     * const databaseIndexWithIdOnly = await prisma.databaseIndex.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatabaseIndexCreateManyAndReturnArgs>(args?: SelectSubset<T, DatabaseIndexCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DatabaseIndex.
     * @param {DatabaseIndexDeleteArgs} args - Arguments to delete one DatabaseIndex.
     * @example
     * // Delete one DatabaseIndex
     * const DatabaseIndex = await prisma.databaseIndex.delete({
     *   where: {
     *     // ... filter to delete one DatabaseIndex
     *   }
     * })
     * 
     */
    delete<T extends DatabaseIndexDeleteArgs>(args: SelectSubset<T, DatabaseIndexDeleteArgs<ExtArgs>>): Prisma__DatabaseIndexClient<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DatabaseIndex.
     * @param {DatabaseIndexUpdateArgs} args - Arguments to update one DatabaseIndex.
     * @example
     * // Update one DatabaseIndex
     * const databaseIndex = await prisma.databaseIndex.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatabaseIndexUpdateArgs>(args: SelectSubset<T, DatabaseIndexUpdateArgs<ExtArgs>>): Prisma__DatabaseIndexClient<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DatabaseIndices.
     * @param {DatabaseIndexDeleteManyArgs} args - Arguments to filter DatabaseIndices to delete.
     * @example
     * // Delete a few DatabaseIndices
     * const { count } = await prisma.databaseIndex.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatabaseIndexDeleteManyArgs>(args?: SelectSubset<T, DatabaseIndexDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseIndices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseIndexUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatabaseIndices
     * const databaseIndex = await prisma.databaseIndex.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatabaseIndexUpdateManyArgs>(args: SelectSubset<T, DatabaseIndexUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseIndices and returns the data updated in the database.
     * @param {DatabaseIndexUpdateManyAndReturnArgs} args - Arguments to update many DatabaseIndices.
     * @example
     * // Update many DatabaseIndices
     * const databaseIndex = await prisma.databaseIndex.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DatabaseIndices and only return the `id`
     * const databaseIndexWithIdOnly = await prisma.databaseIndex.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DatabaseIndexUpdateManyAndReturnArgs>(args: SelectSubset<T, DatabaseIndexUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DatabaseIndex.
     * @param {DatabaseIndexUpsertArgs} args - Arguments to update or create a DatabaseIndex.
     * @example
     * // Update or create a DatabaseIndex
     * const databaseIndex = await prisma.databaseIndex.upsert({
     *   create: {
     *     // ... data to create a DatabaseIndex
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatabaseIndex we want to update
     *   }
     * })
     */
    upsert<T extends DatabaseIndexUpsertArgs>(args: SelectSubset<T, DatabaseIndexUpsertArgs<ExtArgs>>): Prisma__DatabaseIndexClient<$Result.GetResult<Prisma.$DatabaseIndexPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DatabaseIndices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseIndexCountArgs} args - Arguments to filter DatabaseIndices to count.
     * @example
     * // Count the number of DatabaseIndices
     * const count = await prisma.databaseIndex.count({
     *   where: {
     *     // ... the filter for the DatabaseIndices we want to count
     *   }
     * })
    **/
    count<T extends DatabaseIndexCountArgs>(
      args?: Subset<T, DatabaseIndexCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatabaseIndexCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatabaseIndex.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseIndexAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatabaseIndexAggregateArgs>(args: Subset<T, DatabaseIndexAggregateArgs>): Prisma.PrismaPromise<GetDatabaseIndexAggregateType<T>>

    /**
     * Group by DatabaseIndex.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseIndexGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatabaseIndexGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatabaseIndexGroupByArgs['orderBy'] }
        : { orderBy?: DatabaseIndexGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatabaseIndexGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatabaseIndexGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatabaseIndex model
   */
  readonly fields: DatabaseIndexFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatabaseIndex.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatabaseIndexClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    table<T extends DatabaseTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseTableDefaultArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatabaseIndex model
   */
  interface DatabaseIndexFieldRefs {
    readonly id: FieldRef<"DatabaseIndex", 'String'>
    readonly tableId: FieldRef<"DatabaseIndex", 'String'>
    readonly indexName: FieldRef<"DatabaseIndex", 'String'>
    readonly indexType: FieldRef<"DatabaseIndex", 'IndexType'>
    readonly columns: FieldRef<"DatabaseIndex", 'String[]'>
    readonly isUnique: FieldRef<"DatabaseIndex", 'Boolean'>
    readonly comment: FieldRef<"DatabaseIndex", 'String'>
    readonly algorithm: FieldRef<"DatabaseIndex", 'String'>
    readonly lockOption: FieldRef<"DatabaseIndex", 'String'>
    readonly createdAt: FieldRef<"DatabaseIndex", 'DateTime'>
    readonly updatedAt: FieldRef<"DatabaseIndex", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DatabaseIndex findUnique
   */
  export type DatabaseIndexFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseIndex to fetch.
     */
    where: DatabaseIndexWhereUniqueInput
  }

  /**
   * DatabaseIndex findUniqueOrThrow
   */
  export type DatabaseIndexFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseIndex to fetch.
     */
    where: DatabaseIndexWhereUniqueInput
  }

  /**
   * DatabaseIndex findFirst
   */
  export type DatabaseIndexFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseIndex to fetch.
     */
    where?: DatabaseIndexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseIndices to fetch.
     */
    orderBy?: DatabaseIndexOrderByWithRelationInput | DatabaseIndexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseIndices.
     */
    cursor?: DatabaseIndexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseIndices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseIndices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseIndices.
     */
    distinct?: DatabaseIndexScalarFieldEnum | DatabaseIndexScalarFieldEnum[]
  }

  /**
   * DatabaseIndex findFirstOrThrow
   */
  export type DatabaseIndexFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseIndex to fetch.
     */
    where?: DatabaseIndexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseIndices to fetch.
     */
    orderBy?: DatabaseIndexOrderByWithRelationInput | DatabaseIndexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseIndices.
     */
    cursor?: DatabaseIndexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseIndices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseIndices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseIndices.
     */
    distinct?: DatabaseIndexScalarFieldEnum | DatabaseIndexScalarFieldEnum[]
  }

  /**
   * DatabaseIndex findMany
   */
  export type DatabaseIndexFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseIndices to fetch.
     */
    where?: DatabaseIndexWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseIndices to fetch.
     */
    orderBy?: DatabaseIndexOrderByWithRelationInput | DatabaseIndexOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatabaseIndices.
     */
    cursor?: DatabaseIndexWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseIndices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseIndices.
     */
    skip?: number
    distinct?: DatabaseIndexScalarFieldEnum | DatabaseIndexScalarFieldEnum[]
  }

  /**
   * DatabaseIndex create
   */
  export type DatabaseIndexCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    /**
     * The data needed to create a DatabaseIndex.
     */
    data: XOR<DatabaseIndexCreateInput, DatabaseIndexUncheckedCreateInput>
  }

  /**
   * DatabaseIndex createMany
   */
  export type DatabaseIndexCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatabaseIndices.
     */
    data: DatabaseIndexCreateManyInput | DatabaseIndexCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatabaseIndex createManyAndReturn
   */
  export type DatabaseIndexCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * The data used to create many DatabaseIndices.
     */
    data: DatabaseIndexCreateManyInput | DatabaseIndexCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatabaseIndex update
   */
  export type DatabaseIndexUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    /**
     * The data needed to update a DatabaseIndex.
     */
    data: XOR<DatabaseIndexUpdateInput, DatabaseIndexUncheckedUpdateInput>
    /**
     * Choose, which DatabaseIndex to update.
     */
    where: DatabaseIndexWhereUniqueInput
  }

  /**
   * DatabaseIndex updateMany
   */
  export type DatabaseIndexUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatabaseIndices.
     */
    data: XOR<DatabaseIndexUpdateManyMutationInput, DatabaseIndexUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseIndices to update
     */
    where?: DatabaseIndexWhereInput
    /**
     * Limit how many DatabaseIndices to update.
     */
    limit?: number
  }

  /**
   * DatabaseIndex updateManyAndReturn
   */
  export type DatabaseIndexUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * The data used to update DatabaseIndices.
     */
    data: XOR<DatabaseIndexUpdateManyMutationInput, DatabaseIndexUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseIndices to update
     */
    where?: DatabaseIndexWhereInput
    /**
     * Limit how many DatabaseIndices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatabaseIndex upsert
   */
  export type DatabaseIndexUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    /**
     * The filter to search for the DatabaseIndex to update in case it exists.
     */
    where: DatabaseIndexWhereUniqueInput
    /**
     * In case the DatabaseIndex found by the `where` argument doesn't exist, create a new DatabaseIndex with this data.
     */
    create: XOR<DatabaseIndexCreateInput, DatabaseIndexUncheckedCreateInput>
    /**
     * In case the DatabaseIndex was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatabaseIndexUpdateInput, DatabaseIndexUncheckedUpdateInput>
  }

  /**
   * DatabaseIndex delete
   */
  export type DatabaseIndexDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
    /**
     * Filter which DatabaseIndex to delete.
     */
    where: DatabaseIndexWhereUniqueInput
  }

  /**
   * DatabaseIndex deleteMany
   */
  export type DatabaseIndexDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseIndices to delete
     */
    where?: DatabaseIndexWhereInput
    /**
     * Limit how many DatabaseIndices to delete.
     */
    limit?: number
  }

  /**
   * DatabaseIndex without action
   */
  export type DatabaseIndexDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseIndex
     */
    select?: DatabaseIndexSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseIndex
     */
    omit?: DatabaseIndexOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseIndexInclude<ExtArgs> | null
  }


  /**
   * Model DatabaseRelation
   */

  export type AggregateDatabaseRelation = {
    _count: DatabaseRelationCountAggregateOutputType | null
    _min: DatabaseRelationMinAggregateOutputType | null
    _max: DatabaseRelationMaxAggregateOutputType | null
  }

  export type DatabaseRelationMinAggregateOutputType = {
    id: string | null
    schemaId: string | null
    relationName: string | null
    relationType: $Enums.RelationType | null
    sourceTableId: string | null
    targetTableId: string | null
    onDelete: string | null
    onUpdate: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatabaseRelationMaxAggregateOutputType = {
    id: string | null
    schemaId: string | null
    relationName: string | null
    relationType: $Enums.RelationType | null
    sourceTableId: string | null
    targetTableId: string | null
    onDelete: string | null
    onUpdate: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DatabaseRelationCountAggregateOutputType = {
    id: number
    schemaId: number
    relationName: number
    relationType: number
    sourceTableId: number
    sourceColumns: number
    targetTableId: number
    targetColumns: number
    onDelete: number
    onUpdate: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DatabaseRelationMinAggregateInputType = {
    id?: true
    schemaId?: true
    relationName?: true
    relationType?: true
    sourceTableId?: true
    targetTableId?: true
    onDelete?: true
    onUpdate?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatabaseRelationMaxAggregateInputType = {
    id?: true
    schemaId?: true
    relationName?: true
    relationType?: true
    sourceTableId?: true
    targetTableId?: true
    onDelete?: true
    onUpdate?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DatabaseRelationCountAggregateInputType = {
    id?: true
    schemaId?: true
    relationName?: true
    relationType?: true
    sourceTableId?: true
    sourceColumns?: true
    targetTableId?: true
    targetColumns?: true
    onDelete?: true
    onUpdate?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DatabaseRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseRelation to aggregate.
     */
    where?: DatabaseRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseRelations to fetch.
     */
    orderBy?: DatabaseRelationOrderByWithRelationInput | DatabaseRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DatabaseRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DatabaseRelations
    **/
    _count?: true | DatabaseRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DatabaseRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DatabaseRelationMaxAggregateInputType
  }

  export type GetDatabaseRelationAggregateType<T extends DatabaseRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateDatabaseRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDatabaseRelation[P]>
      : GetScalarType<T[P], AggregateDatabaseRelation[P]>
  }




  export type DatabaseRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DatabaseRelationWhereInput
    orderBy?: DatabaseRelationOrderByWithAggregationInput | DatabaseRelationOrderByWithAggregationInput[]
    by: DatabaseRelationScalarFieldEnum[] | DatabaseRelationScalarFieldEnum
    having?: DatabaseRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DatabaseRelationCountAggregateInputType | true
    _min?: DatabaseRelationMinAggregateInputType
    _max?: DatabaseRelationMaxAggregateInputType
  }

  export type DatabaseRelationGroupByOutputType = {
    id: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceTableId: string
    sourceColumns: string[]
    targetTableId: string
    targetColumns: string[]
    onDelete: string | null
    onUpdate: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: DatabaseRelationCountAggregateOutputType | null
    _min: DatabaseRelationMinAggregateOutputType | null
    _max: DatabaseRelationMaxAggregateOutputType | null
  }

  type GetDatabaseRelationGroupByPayload<T extends DatabaseRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DatabaseRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DatabaseRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DatabaseRelationGroupByOutputType[P]>
            : GetScalarType<T[P], DatabaseRelationGroupByOutputType[P]>
        }
      >
    >


  export type DatabaseRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    relationName?: boolean
    relationType?: boolean
    sourceTableId?: boolean
    sourceColumns?: boolean
    targetTableId?: boolean
    targetColumns?: boolean
    onDelete?: boolean
    onUpdate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
    targetTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseRelation"]>

  export type DatabaseRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    relationName?: boolean
    relationType?: boolean
    sourceTableId?: boolean
    sourceColumns?: boolean
    targetTableId?: boolean
    targetColumns?: boolean
    onDelete?: boolean
    onUpdate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
    targetTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseRelation"]>

  export type DatabaseRelationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    relationName?: boolean
    relationType?: boolean
    sourceTableId?: boolean
    sourceColumns?: boolean
    targetTableId?: boolean
    targetColumns?: boolean
    onDelete?: boolean
    onUpdate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
    targetTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["databaseRelation"]>

  export type DatabaseRelationSelectScalar = {
    id?: boolean
    schemaId?: boolean
    relationName?: boolean
    relationType?: boolean
    sourceTableId?: boolean
    sourceColumns?: boolean
    targetTableId?: boolean
    targetColumns?: boolean
    onDelete?: boolean
    onUpdate?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DatabaseRelationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schemaId" | "relationName" | "relationType" | "sourceTableId" | "sourceColumns" | "targetTableId" | "targetColumns" | "onDelete" | "onUpdate" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["databaseRelation"]>
  export type DatabaseRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
    targetTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }
  export type DatabaseRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
    targetTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }
  export type DatabaseRelationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
    targetTable?: boolean | DatabaseTableDefaultArgs<ExtArgs>
  }

  export type $DatabaseRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DatabaseRelation"
    objects: {
      sourceTable: Prisma.$DatabaseTablePayload<ExtArgs>
      targetTable: Prisma.$DatabaseTablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      schemaId: string
      relationName: string
      relationType: $Enums.RelationType
      sourceTableId: string
      sourceColumns: string[]
      targetTableId: string
      targetColumns: string[]
      onDelete: string | null
      onUpdate: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["databaseRelation"]>
    composites: {}
  }

  type DatabaseRelationGetPayload<S extends boolean | null | undefined | DatabaseRelationDefaultArgs> = $Result.GetResult<Prisma.$DatabaseRelationPayload, S>

  type DatabaseRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DatabaseRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DatabaseRelationCountAggregateInputType | true
    }

  export interface DatabaseRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DatabaseRelation'], meta: { name: 'DatabaseRelation' } }
    /**
     * Find zero or one DatabaseRelation that matches the filter.
     * @param {DatabaseRelationFindUniqueArgs} args - Arguments to find a DatabaseRelation
     * @example
     * // Get one DatabaseRelation
     * const databaseRelation = await prisma.databaseRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DatabaseRelationFindUniqueArgs>(args: SelectSubset<T, DatabaseRelationFindUniqueArgs<ExtArgs>>): Prisma__DatabaseRelationClient<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DatabaseRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DatabaseRelationFindUniqueOrThrowArgs} args - Arguments to find a DatabaseRelation
     * @example
     * // Get one DatabaseRelation
     * const databaseRelation = await prisma.databaseRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DatabaseRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, DatabaseRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DatabaseRelationClient<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatabaseRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseRelationFindFirstArgs} args - Arguments to find a DatabaseRelation
     * @example
     * // Get one DatabaseRelation
     * const databaseRelation = await prisma.databaseRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DatabaseRelationFindFirstArgs>(args?: SelectSubset<T, DatabaseRelationFindFirstArgs<ExtArgs>>): Prisma__DatabaseRelationClient<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DatabaseRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseRelationFindFirstOrThrowArgs} args - Arguments to find a DatabaseRelation
     * @example
     * // Get one DatabaseRelation
     * const databaseRelation = await prisma.databaseRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DatabaseRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, DatabaseRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DatabaseRelationClient<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DatabaseRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DatabaseRelations
     * const databaseRelations = await prisma.databaseRelation.findMany()
     * 
     * // Get first 10 DatabaseRelations
     * const databaseRelations = await prisma.databaseRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const databaseRelationWithIdOnly = await prisma.databaseRelation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DatabaseRelationFindManyArgs>(args?: SelectSubset<T, DatabaseRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DatabaseRelation.
     * @param {DatabaseRelationCreateArgs} args - Arguments to create a DatabaseRelation.
     * @example
     * // Create one DatabaseRelation
     * const DatabaseRelation = await prisma.databaseRelation.create({
     *   data: {
     *     // ... data to create a DatabaseRelation
     *   }
     * })
     * 
     */
    create<T extends DatabaseRelationCreateArgs>(args: SelectSubset<T, DatabaseRelationCreateArgs<ExtArgs>>): Prisma__DatabaseRelationClient<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DatabaseRelations.
     * @param {DatabaseRelationCreateManyArgs} args - Arguments to create many DatabaseRelations.
     * @example
     * // Create many DatabaseRelations
     * const databaseRelation = await prisma.databaseRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DatabaseRelationCreateManyArgs>(args?: SelectSubset<T, DatabaseRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DatabaseRelations and returns the data saved in the database.
     * @param {DatabaseRelationCreateManyAndReturnArgs} args - Arguments to create many DatabaseRelations.
     * @example
     * // Create many DatabaseRelations
     * const databaseRelation = await prisma.databaseRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DatabaseRelations and only return the `id`
     * const databaseRelationWithIdOnly = await prisma.databaseRelation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DatabaseRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, DatabaseRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DatabaseRelation.
     * @param {DatabaseRelationDeleteArgs} args - Arguments to delete one DatabaseRelation.
     * @example
     * // Delete one DatabaseRelation
     * const DatabaseRelation = await prisma.databaseRelation.delete({
     *   where: {
     *     // ... filter to delete one DatabaseRelation
     *   }
     * })
     * 
     */
    delete<T extends DatabaseRelationDeleteArgs>(args: SelectSubset<T, DatabaseRelationDeleteArgs<ExtArgs>>): Prisma__DatabaseRelationClient<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DatabaseRelation.
     * @param {DatabaseRelationUpdateArgs} args - Arguments to update one DatabaseRelation.
     * @example
     * // Update one DatabaseRelation
     * const databaseRelation = await prisma.databaseRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DatabaseRelationUpdateArgs>(args: SelectSubset<T, DatabaseRelationUpdateArgs<ExtArgs>>): Prisma__DatabaseRelationClient<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DatabaseRelations.
     * @param {DatabaseRelationDeleteManyArgs} args - Arguments to filter DatabaseRelations to delete.
     * @example
     * // Delete a few DatabaseRelations
     * const { count } = await prisma.databaseRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DatabaseRelationDeleteManyArgs>(args?: SelectSubset<T, DatabaseRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DatabaseRelations
     * const databaseRelation = await prisma.databaseRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DatabaseRelationUpdateManyArgs>(args: SelectSubset<T, DatabaseRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DatabaseRelations and returns the data updated in the database.
     * @param {DatabaseRelationUpdateManyAndReturnArgs} args - Arguments to update many DatabaseRelations.
     * @example
     * // Update many DatabaseRelations
     * const databaseRelation = await prisma.databaseRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DatabaseRelations and only return the `id`
     * const databaseRelationWithIdOnly = await prisma.databaseRelation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DatabaseRelationUpdateManyAndReturnArgs>(args: SelectSubset<T, DatabaseRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DatabaseRelation.
     * @param {DatabaseRelationUpsertArgs} args - Arguments to update or create a DatabaseRelation.
     * @example
     * // Update or create a DatabaseRelation
     * const databaseRelation = await prisma.databaseRelation.upsert({
     *   create: {
     *     // ... data to create a DatabaseRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DatabaseRelation we want to update
     *   }
     * })
     */
    upsert<T extends DatabaseRelationUpsertArgs>(args: SelectSubset<T, DatabaseRelationUpsertArgs<ExtArgs>>): Prisma__DatabaseRelationClient<$Result.GetResult<Prisma.$DatabaseRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DatabaseRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseRelationCountArgs} args - Arguments to filter DatabaseRelations to count.
     * @example
     * // Count the number of DatabaseRelations
     * const count = await prisma.databaseRelation.count({
     *   where: {
     *     // ... the filter for the DatabaseRelations we want to count
     *   }
     * })
    **/
    count<T extends DatabaseRelationCountArgs>(
      args?: Subset<T, DatabaseRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DatabaseRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DatabaseRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DatabaseRelationAggregateArgs>(args: Subset<T, DatabaseRelationAggregateArgs>): Prisma.PrismaPromise<GetDatabaseRelationAggregateType<T>>

    /**
     * Group by DatabaseRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DatabaseRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DatabaseRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DatabaseRelationGroupByArgs['orderBy'] }
        : { orderBy?: DatabaseRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DatabaseRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDatabaseRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DatabaseRelation model
   */
  readonly fields: DatabaseRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DatabaseRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DatabaseRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceTable<T extends DatabaseTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseTableDefaultArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    targetTable<T extends DatabaseTableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DatabaseTableDefaultArgs<ExtArgs>>): Prisma__DatabaseTableClient<$Result.GetResult<Prisma.$DatabaseTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DatabaseRelation model
   */
  interface DatabaseRelationFieldRefs {
    readonly id: FieldRef<"DatabaseRelation", 'String'>
    readonly schemaId: FieldRef<"DatabaseRelation", 'String'>
    readonly relationName: FieldRef<"DatabaseRelation", 'String'>
    readonly relationType: FieldRef<"DatabaseRelation", 'RelationType'>
    readonly sourceTableId: FieldRef<"DatabaseRelation", 'String'>
    readonly sourceColumns: FieldRef<"DatabaseRelation", 'String[]'>
    readonly targetTableId: FieldRef<"DatabaseRelation", 'String'>
    readonly targetColumns: FieldRef<"DatabaseRelation", 'String[]'>
    readonly onDelete: FieldRef<"DatabaseRelation", 'String'>
    readonly onUpdate: FieldRef<"DatabaseRelation", 'String'>
    readonly description: FieldRef<"DatabaseRelation", 'String'>
    readonly createdAt: FieldRef<"DatabaseRelation", 'DateTime'>
    readonly updatedAt: FieldRef<"DatabaseRelation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DatabaseRelation findUnique
   */
  export type DatabaseRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseRelation to fetch.
     */
    where: DatabaseRelationWhereUniqueInput
  }

  /**
   * DatabaseRelation findUniqueOrThrow
   */
  export type DatabaseRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseRelation to fetch.
     */
    where: DatabaseRelationWhereUniqueInput
  }

  /**
   * DatabaseRelation findFirst
   */
  export type DatabaseRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseRelation to fetch.
     */
    where?: DatabaseRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseRelations to fetch.
     */
    orderBy?: DatabaseRelationOrderByWithRelationInput | DatabaseRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseRelations.
     */
    cursor?: DatabaseRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseRelations.
     */
    distinct?: DatabaseRelationScalarFieldEnum | DatabaseRelationScalarFieldEnum[]
  }

  /**
   * DatabaseRelation findFirstOrThrow
   */
  export type DatabaseRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseRelation to fetch.
     */
    where?: DatabaseRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseRelations to fetch.
     */
    orderBy?: DatabaseRelationOrderByWithRelationInput | DatabaseRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DatabaseRelations.
     */
    cursor?: DatabaseRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DatabaseRelations.
     */
    distinct?: DatabaseRelationScalarFieldEnum | DatabaseRelationScalarFieldEnum[]
  }

  /**
   * DatabaseRelation findMany
   */
  export type DatabaseRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    /**
     * Filter, which DatabaseRelations to fetch.
     */
    where?: DatabaseRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DatabaseRelations to fetch.
     */
    orderBy?: DatabaseRelationOrderByWithRelationInput | DatabaseRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DatabaseRelations.
     */
    cursor?: DatabaseRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DatabaseRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DatabaseRelations.
     */
    skip?: number
    distinct?: DatabaseRelationScalarFieldEnum | DatabaseRelationScalarFieldEnum[]
  }

  /**
   * DatabaseRelation create
   */
  export type DatabaseRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a DatabaseRelation.
     */
    data: XOR<DatabaseRelationCreateInput, DatabaseRelationUncheckedCreateInput>
  }

  /**
   * DatabaseRelation createMany
   */
  export type DatabaseRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DatabaseRelations.
     */
    data: DatabaseRelationCreateManyInput | DatabaseRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DatabaseRelation createManyAndReturn
   */
  export type DatabaseRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * The data used to create many DatabaseRelations.
     */
    data: DatabaseRelationCreateManyInput | DatabaseRelationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatabaseRelation update
   */
  export type DatabaseRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a DatabaseRelation.
     */
    data: XOR<DatabaseRelationUpdateInput, DatabaseRelationUncheckedUpdateInput>
    /**
     * Choose, which DatabaseRelation to update.
     */
    where: DatabaseRelationWhereUniqueInput
  }

  /**
   * DatabaseRelation updateMany
   */
  export type DatabaseRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DatabaseRelations.
     */
    data: XOR<DatabaseRelationUpdateManyMutationInput, DatabaseRelationUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseRelations to update
     */
    where?: DatabaseRelationWhereInput
    /**
     * Limit how many DatabaseRelations to update.
     */
    limit?: number
  }

  /**
   * DatabaseRelation updateManyAndReturn
   */
  export type DatabaseRelationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * The data used to update DatabaseRelations.
     */
    data: XOR<DatabaseRelationUpdateManyMutationInput, DatabaseRelationUncheckedUpdateManyInput>
    /**
     * Filter which DatabaseRelations to update
     */
    where?: DatabaseRelationWhereInput
    /**
     * Limit how many DatabaseRelations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DatabaseRelation upsert
   */
  export type DatabaseRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the DatabaseRelation to update in case it exists.
     */
    where: DatabaseRelationWhereUniqueInput
    /**
     * In case the DatabaseRelation found by the `where` argument doesn't exist, create a new DatabaseRelation with this data.
     */
    create: XOR<DatabaseRelationCreateInput, DatabaseRelationUncheckedCreateInput>
    /**
     * In case the DatabaseRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DatabaseRelationUpdateInput, DatabaseRelationUncheckedUpdateInput>
  }

  /**
   * DatabaseRelation delete
   */
  export type DatabaseRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
    /**
     * Filter which DatabaseRelation to delete.
     */
    where: DatabaseRelationWhereUniqueInput
  }

  /**
   * DatabaseRelation deleteMany
   */
  export type DatabaseRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DatabaseRelations to delete
     */
    where?: DatabaseRelationWhereInput
    /**
     * Limit how many DatabaseRelations to delete.
     */
    limit?: number
  }

  /**
   * DatabaseRelation without action
   */
  export type DatabaseRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseRelation
     */
    select?: DatabaseRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseRelation
     */
    omit?: DatabaseRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseRelationInclude<ExtArgs> | null
  }


  /**
   * Model Documentation
   */

  export type AggregateDocumentation = {
    _count: DocumentationCountAggregateOutputType | null
    _avg: DocumentationAvgAggregateOutputType | null
    _sum: DocumentationSumAggregateOutputType | null
    _min: DocumentationMinAggregateOutputType | null
    _max: DocumentationMaxAggregateOutputType | null
  }

  export type DocumentationAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type DocumentationSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type DocumentationMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    content: string | null
    summary: string | null
    type: $Enums.DocumentType | null
    status: $Enums.DocumentStatus | null
    visibility: $Enums.DocumentVisibility | null
    category: string | null
    url: string | null
    version: string | null
    versionNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type DocumentationMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    content: string | null
    summary: string | null
    type: $Enums.DocumentType | null
    status: $Enums.DocumentStatus | null
    visibility: $Enums.DocumentVisibility | null
    category: string | null
    url: string | null
    version: string | null
    versionNumber: number | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type DocumentationCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    content: number
    summary: number
    type: number
    status: number
    visibility: number
    category: number
    url: number
    version: number
    versionNumber: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    deletedAt: number
    userId: number
    _all: number
  }


  export type DocumentationAvgAggregateInputType = {
    versionNumber?: true
  }

  export type DocumentationSumAggregateInputType = {
    versionNumber?: true
  }

  export type DocumentationMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    summary?: true
    type?: true
    status?: true
    visibility?: true
    category?: true
    url?: true
    version?: true
    versionNumber?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type DocumentationMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    summary?: true
    type?: true
    status?: true
    visibility?: true
    category?: true
    url?: true
    version?: true
    versionNumber?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type DocumentationCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    summary?: true
    type?: true
    status?: true
    visibility?: true
    category?: true
    url?: true
    version?: true
    versionNumber?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    deletedAt?: true
    userId?: true
    _all?: true
  }

  export type DocumentationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documentation to aggregate.
     */
    where?: DocumentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentations to fetch.
     */
    orderBy?: DocumentationOrderByWithRelationInput | DocumentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documentations
    **/
    _count?: true | DocumentationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentationMaxAggregateInputType
  }

  export type GetDocumentationAggregateType<T extends DocumentationAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentation[P]>
      : GetScalarType<T[P], AggregateDocumentation[P]>
  }




  export type DocumentationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentationWhereInput
    orderBy?: DocumentationOrderByWithAggregationInput | DocumentationOrderByWithAggregationInput[]
    by: DocumentationScalarFieldEnum[] | DocumentationScalarFieldEnum
    having?: DocumentationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentationCountAggregateInputType | true
    _avg?: DocumentationAvgAggregateInputType
    _sum?: DocumentationSumAggregateInputType
    _min?: DocumentationMinAggregateInputType
    _max?: DocumentationMaxAggregateInputType
  }

  export type DocumentationGroupByOutputType = {
    id: string
    projectId: string
    title: string
    content: string
    summary: string | null
    type: $Enums.DocumentType
    status: $Enums.DocumentStatus
    visibility: $Enums.DocumentVisibility
    category: string | null
    url: string | null
    version: string
    versionNumber: number
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    deletedAt: Date | null
    userId: string | null
    _count: DocumentationCountAggregateOutputType | null
    _avg: DocumentationAvgAggregateOutputType | null
    _sum: DocumentationSumAggregateOutputType | null
    _min: DocumentationMinAggregateOutputType | null
    _max: DocumentationMaxAggregateOutputType | null
  }

  type GetDocumentationGroupByPayload<T extends DocumentationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentationGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentationGroupByOutputType[P]>
        }
      >
    >


  export type DocumentationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    type?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    url?: boolean
    version?: boolean
    versionNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tags?: boolean | Documentation$tagsArgs<ExtArgs>
    versions?: boolean | Documentation$versionsArgs<ExtArgs>
    comments?: boolean | Documentation$commentsArgs<ExtArgs>
    attachments?: boolean | Documentation$attachmentsArgs<ExtArgs>
    User?: boolean | Documentation$UserArgs<ExtArgs>
    _count?: boolean | DocumentationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentation"]>

  export type DocumentationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    type?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    url?: boolean
    version?: boolean
    versionNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | Documentation$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentation"]>

  export type DocumentationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    type?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    url?: boolean
    version?: boolean
    versionNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | Documentation$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentation"]>

  export type DocumentationSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    type?: boolean
    status?: boolean
    visibility?: boolean
    category?: boolean
    url?: boolean
    version?: boolean
    versionNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
  }

  export type DocumentationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "title" | "content" | "summary" | "type" | "status" | "visibility" | "category" | "url" | "version" | "versionNumber" | "createdAt" | "updatedAt" | "publishedAt" | "deletedAt" | "userId", ExtArgs["result"]["documentation"]>
  export type DocumentationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tags?: boolean | Documentation$tagsArgs<ExtArgs>
    versions?: boolean | Documentation$versionsArgs<ExtArgs>
    comments?: boolean | Documentation$commentsArgs<ExtArgs>
    attachments?: boolean | Documentation$attachmentsArgs<ExtArgs>
    User?: boolean | Documentation$UserArgs<ExtArgs>
    _count?: boolean | DocumentationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | Documentation$UserArgs<ExtArgs>
  }
  export type DocumentationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | Documentation$UserArgs<ExtArgs>
  }

  export type $DocumentationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Documentation"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tags: Prisma.$DocumentTagPayload<ExtArgs>[]
      versions: Prisma.$DocumentVersionPayload<ExtArgs>[]
      comments: Prisma.$DocumentCommentPayload<ExtArgs>[]
      attachments: Prisma.$DocumentAttachmentPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      content: string
      summary: string | null
      type: $Enums.DocumentType
      status: $Enums.DocumentStatus
      visibility: $Enums.DocumentVisibility
      category: string | null
      url: string | null
      version: string
      versionNumber: number
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
      deletedAt: Date | null
      userId: string | null
    }, ExtArgs["result"]["documentation"]>
    composites: {}
  }

  type DocumentationGetPayload<S extends boolean | null | undefined | DocumentationDefaultArgs> = $Result.GetResult<Prisma.$DocumentationPayload, S>

  type DocumentationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentationCountAggregateInputType | true
    }

  export interface DocumentationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Documentation'], meta: { name: 'Documentation' } }
    /**
     * Find zero or one Documentation that matches the filter.
     * @param {DocumentationFindUniqueArgs} args - Arguments to find a Documentation
     * @example
     * // Get one Documentation
     * const documentation = await prisma.documentation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentationFindUniqueArgs>(args: SelectSubset<T, DocumentationFindUniqueArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Documentation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentationFindUniqueOrThrowArgs} args - Arguments to find a Documentation
     * @example
     * // Get one Documentation
     * const documentation = await prisma.documentation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentationFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documentation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationFindFirstArgs} args - Arguments to find a Documentation
     * @example
     * // Get one Documentation
     * const documentation = await prisma.documentation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentationFindFirstArgs>(args?: SelectSubset<T, DocumentationFindFirstArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Documentation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationFindFirstOrThrowArgs} args - Arguments to find a Documentation
     * @example
     * // Get one Documentation
     * const documentation = await prisma.documentation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentationFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documentations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documentations
     * const documentations = await prisma.documentation.findMany()
     * 
     * // Get first 10 Documentations
     * const documentations = await prisma.documentation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentationWithIdOnly = await prisma.documentation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentationFindManyArgs>(args?: SelectSubset<T, DocumentationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Documentation.
     * @param {DocumentationCreateArgs} args - Arguments to create a Documentation.
     * @example
     * // Create one Documentation
     * const Documentation = await prisma.documentation.create({
     *   data: {
     *     // ... data to create a Documentation
     *   }
     * })
     * 
     */
    create<T extends DocumentationCreateArgs>(args: SelectSubset<T, DocumentationCreateArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documentations.
     * @param {DocumentationCreateManyArgs} args - Arguments to create many Documentations.
     * @example
     * // Create many Documentations
     * const documentation = await prisma.documentation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentationCreateManyArgs>(args?: SelectSubset<T, DocumentationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documentations and returns the data saved in the database.
     * @param {DocumentationCreateManyAndReturnArgs} args - Arguments to create many Documentations.
     * @example
     * // Create many Documentations
     * const documentation = await prisma.documentation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documentations and only return the `id`
     * const documentationWithIdOnly = await prisma.documentation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentationCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Documentation.
     * @param {DocumentationDeleteArgs} args - Arguments to delete one Documentation.
     * @example
     * // Delete one Documentation
     * const Documentation = await prisma.documentation.delete({
     *   where: {
     *     // ... filter to delete one Documentation
     *   }
     * })
     * 
     */
    delete<T extends DocumentationDeleteArgs>(args: SelectSubset<T, DocumentationDeleteArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Documentation.
     * @param {DocumentationUpdateArgs} args - Arguments to update one Documentation.
     * @example
     * // Update one Documentation
     * const documentation = await prisma.documentation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentationUpdateArgs>(args: SelectSubset<T, DocumentationUpdateArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documentations.
     * @param {DocumentationDeleteManyArgs} args - Arguments to filter Documentations to delete.
     * @example
     * // Delete a few Documentations
     * const { count } = await prisma.documentation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentationDeleteManyArgs>(args?: SelectSubset<T, DocumentationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documentations
     * const documentation = await prisma.documentation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentationUpdateManyArgs>(args: SelectSubset<T, DocumentationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentations and returns the data updated in the database.
     * @param {DocumentationUpdateManyAndReturnArgs} args - Arguments to update many Documentations.
     * @example
     * // Update many Documentations
     * const documentation = await prisma.documentation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documentations and only return the `id`
     * const documentationWithIdOnly = await prisma.documentation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentationUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Documentation.
     * @param {DocumentationUpsertArgs} args - Arguments to update or create a Documentation.
     * @example
     * // Update or create a Documentation
     * const documentation = await prisma.documentation.upsert({
     *   create: {
     *     // ... data to create a Documentation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documentation we want to update
     *   }
     * })
     */
    upsert<T extends DocumentationUpsertArgs>(args: SelectSubset<T, DocumentationUpsertArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documentations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationCountArgs} args - Arguments to filter Documentations to count.
     * @example
     * // Count the number of Documentations
     * const count = await prisma.documentation.count({
     *   where: {
     *     // ... the filter for the Documentations we want to count
     *   }
     * })
    **/
    count<T extends DocumentationCountArgs>(
      args?: Subset<T, DocumentationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentationAggregateArgs>(args: Subset<T, DocumentationAggregateArgs>): Prisma.PrismaPromise<GetDocumentationAggregateType<T>>

    /**
     * Group by Documentation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentationGroupByArgs['orderBy'] }
        : { orderBy?: DocumentationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Documentation model
   */
  readonly fields: DocumentationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Documentation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends Documentation$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Documentation$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    versions<T extends Documentation$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Documentation$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Documentation$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Documentation$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Documentation$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Documentation$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Documentation$UserArgs<ExtArgs> = {}>(args?: Subset<T, Documentation$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Documentation model
   */
  interface DocumentationFieldRefs {
    readonly id: FieldRef<"Documentation", 'String'>
    readonly projectId: FieldRef<"Documentation", 'String'>
    readonly title: FieldRef<"Documentation", 'String'>
    readonly content: FieldRef<"Documentation", 'String'>
    readonly summary: FieldRef<"Documentation", 'String'>
    readonly type: FieldRef<"Documentation", 'DocumentType'>
    readonly status: FieldRef<"Documentation", 'DocumentStatus'>
    readonly visibility: FieldRef<"Documentation", 'DocumentVisibility'>
    readonly category: FieldRef<"Documentation", 'String'>
    readonly url: FieldRef<"Documentation", 'String'>
    readonly version: FieldRef<"Documentation", 'String'>
    readonly versionNumber: FieldRef<"Documentation", 'Int'>
    readonly createdAt: FieldRef<"Documentation", 'DateTime'>
    readonly updatedAt: FieldRef<"Documentation", 'DateTime'>
    readonly publishedAt: FieldRef<"Documentation", 'DateTime'>
    readonly deletedAt: FieldRef<"Documentation", 'DateTime'>
    readonly userId: FieldRef<"Documentation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Documentation findUnique
   */
  export type DocumentationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    /**
     * Filter, which Documentation to fetch.
     */
    where: DocumentationWhereUniqueInput
  }

  /**
   * Documentation findUniqueOrThrow
   */
  export type DocumentationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    /**
     * Filter, which Documentation to fetch.
     */
    where: DocumentationWhereUniqueInput
  }

  /**
   * Documentation findFirst
   */
  export type DocumentationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    /**
     * Filter, which Documentation to fetch.
     */
    where?: DocumentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentations to fetch.
     */
    orderBy?: DocumentationOrderByWithRelationInput | DocumentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentations.
     */
    cursor?: DocumentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentations.
     */
    distinct?: DocumentationScalarFieldEnum | DocumentationScalarFieldEnum[]
  }

  /**
   * Documentation findFirstOrThrow
   */
  export type DocumentationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    /**
     * Filter, which Documentation to fetch.
     */
    where?: DocumentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentations to fetch.
     */
    orderBy?: DocumentationOrderByWithRelationInput | DocumentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentations.
     */
    cursor?: DocumentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentations.
     */
    distinct?: DocumentationScalarFieldEnum | DocumentationScalarFieldEnum[]
  }

  /**
   * Documentation findMany
   */
  export type DocumentationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    /**
     * Filter, which Documentations to fetch.
     */
    where?: DocumentationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentations to fetch.
     */
    orderBy?: DocumentationOrderByWithRelationInput | DocumentationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documentations.
     */
    cursor?: DocumentationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentations.
     */
    skip?: number
    distinct?: DocumentationScalarFieldEnum | DocumentationScalarFieldEnum[]
  }

  /**
   * Documentation create
   */
  export type DocumentationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    /**
     * The data needed to create a Documentation.
     */
    data: XOR<DocumentationCreateInput, DocumentationUncheckedCreateInput>
  }

  /**
   * Documentation createMany
   */
  export type DocumentationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documentations.
     */
    data: DocumentationCreateManyInput | DocumentationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Documentation createManyAndReturn
   */
  export type DocumentationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * The data used to create many Documentations.
     */
    data: DocumentationCreateManyInput | DocumentationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Documentation update
   */
  export type DocumentationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    /**
     * The data needed to update a Documentation.
     */
    data: XOR<DocumentationUpdateInput, DocumentationUncheckedUpdateInput>
    /**
     * Choose, which Documentation to update.
     */
    where: DocumentationWhereUniqueInput
  }

  /**
   * Documentation updateMany
   */
  export type DocumentationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documentations.
     */
    data: XOR<DocumentationUpdateManyMutationInput, DocumentationUncheckedUpdateManyInput>
    /**
     * Filter which Documentations to update
     */
    where?: DocumentationWhereInput
    /**
     * Limit how many Documentations to update.
     */
    limit?: number
  }

  /**
   * Documentation updateManyAndReturn
   */
  export type DocumentationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * The data used to update Documentations.
     */
    data: XOR<DocumentationUpdateManyMutationInput, DocumentationUncheckedUpdateManyInput>
    /**
     * Filter which Documentations to update
     */
    where?: DocumentationWhereInput
    /**
     * Limit how many Documentations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Documentation upsert
   */
  export type DocumentationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    /**
     * The filter to search for the Documentation to update in case it exists.
     */
    where: DocumentationWhereUniqueInput
    /**
     * In case the Documentation found by the `where` argument doesn't exist, create a new Documentation with this data.
     */
    create: XOR<DocumentationCreateInput, DocumentationUncheckedCreateInput>
    /**
     * In case the Documentation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentationUpdateInput, DocumentationUncheckedUpdateInput>
  }

  /**
   * Documentation delete
   */
  export type DocumentationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    /**
     * Filter which Documentation to delete.
     */
    where: DocumentationWhereUniqueInput
  }

  /**
   * Documentation deleteMany
   */
  export type DocumentationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documentations to delete
     */
    where?: DocumentationWhereInput
    /**
     * Limit how many Documentations to delete.
     */
    limit?: number
  }

  /**
   * Documentation.tags
   */
  export type Documentation$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    where?: DocumentTagWhereInput
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    cursor?: DocumentTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * Documentation.versions
   */
  export type Documentation$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    where?: DocumentVersionWhereInput
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    cursor?: DocumentVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * Documentation.comments
   */
  export type Documentation$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    where?: DocumentCommentWhereInput
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    cursor?: DocumentCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * Documentation.attachments
   */
  export type Documentation$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    where?: DocumentAttachmentWhereInput
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    cursor?: DocumentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * Documentation.User
   */
  export type Documentation$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Documentation without action
   */
  export type DocumentationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
  }


  /**
   * Model DocumentVersion
   */

  export type AggregateDocumentVersion = {
    _count: DocumentVersionCountAggregateOutputType | null
    _min: DocumentVersionMinAggregateOutputType | null
    _max: DocumentVersionMaxAggregateOutputType | null
  }

  export type DocumentVersionMinAggregateOutputType = {
    id: string | null
    documentationId: string | null
    version: string | null
    content: string | null
    changeLog: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type DocumentVersionMaxAggregateOutputType = {
    id: string | null
    documentationId: string | null
    version: string | null
    content: string | null
    changeLog: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type DocumentVersionCountAggregateOutputType = {
    id: number
    documentationId: number
    version: number
    content: number
    changeLog: number
    createdAt: number
    userId: number
    _all: number
  }


  export type DocumentVersionMinAggregateInputType = {
    id?: true
    documentationId?: true
    version?: true
    content?: true
    changeLog?: true
    createdAt?: true
    userId?: true
  }

  export type DocumentVersionMaxAggregateInputType = {
    id?: true
    documentationId?: true
    version?: true
    content?: true
    changeLog?: true
    createdAt?: true
    userId?: true
  }

  export type DocumentVersionCountAggregateInputType = {
    id?: true
    documentationId?: true
    version?: true
    content?: true
    changeLog?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type DocumentVersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVersion to aggregate.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentVersions
    **/
    _count?: true | DocumentVersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentVersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentVersionMaxAggregateInputType
  }

  export type GetDocumentVersionAggregateType<T extends DocumentVersionAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentVersion[P]>
      : GetScalarType<T[P], AggregateDocumentVersion[P]>
  }




  export type DocumentVersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentVersionWhereInput
    orderBy?: DocumentVersionOrderByWithAggregationInput | DocumentVersionOrderByWithAggregationInput[]
    by: DocumentVersionScalarFieldEnum[] | DocumentVersionScalarFieldEnum
    having?: DocumentVersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentVersionCountAggregateInputType | true
    _min?: DocumentVersionMinAggregateInputType
    _max?: DocumentVersionMaxAggregateInputType
  }

  export type DocumentVersionGroupByOutputType = {
    id: string
    documentationId: string
    version: string
    content: string
    changeLog: string
    createdAt: Date
    userId: string | null
    _count: DocumentVersionCountAggregateOutputType | null
    _min: DocumentVersionMinAggregateOutputType | null
    _max: DocumentVersionMaxAggregateOutputType | null
  }

  type GetDocumentVersionGroupByPayload<T extends DocumentVersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentVersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentVersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentVersionGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentVersionGroupByOutputType[P]>
        }
      >
    >


  export type DocumentVersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentationId?: boolean
    version?: boolean
    content?: boolean
    changeLog?: boolean
    createdAt?: boolean
    userId?: boolean
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentVersion$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentVersion"]>

  export type DocumentVersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentationId?: boolean
    version?: boolean
    content?: boolean
    changeLog?: boolean
    createdAt?: boolean
    userId?: boolean
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentVersion$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentVersion"]>

  export type DocumentVersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentationId?: boolean
    version?: boolean
    content?: boolean
    changeLog?: boolean
    createdAt?: boolean
    userId?: boolean
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentVersion$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentVersion"]>

  export type DocumentVersionSelectScalar = {
    id?: boolean
    documentationId?: boolean
    version?: boolean
    content?: boolean
    changeLog?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type DocumentVersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentationId" | "version" | "content" | "changeLog" | "createdAt" | "userId", ExtArgs["result"]["documentVersion"]>
  export type DocumentVersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentVersion$UserArgs<ExtArgs>
  }
  export type DocumentVersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentVersion$UserArgs<ExtArgs>
  }
  export type DocumentVersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentVersion$UserArgs<ExtArgs>
  }

  export type $DocumentVersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentVersion"
    objects: {
      documentation: Prisma.$DocumentationPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentationId: string
      version: string
      content: string
      changeLog: string
      createdAt: Date
      userId: string | null
    }, ExtArgs["result"]["documentVersion"]>
    composites: {}
  }

  type DocumentVersionGetPayload<S extends boolean | null | undefined | DocumentVersionDefaultArgs> = $Result.GetResult<Prisma.$DocumentVersionPayload, S>

  type DocumentVersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentVersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentVersionCountAggregateInputType | true
    }

  export interface DocumentVersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentVersion'], meta: { name: 'DocumentVersion' } }
    /**
     * Find zero or one DocumentVersion that matches the filter.
     * @param {DocumentVersionFindUniqueArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentVersionFindUniqueArgs>(args: SelectSubset<T, DocumentVersionFindUniqueArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentVersion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentVersionFindUniqueOrThrowArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentVersionFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentVersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentVersion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionFindFirstArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentVersionFindFirstArgs>(args?: SelectSubset<T, DocumentVersionFindFirstArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentVersion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionFindFirstOrThrowArgs} args - Arguments to find a DocumentVersion
     * @example
     * // Get one DocumentVersion
     * const documentVersion = await prisma.documentVersion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentVersionFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentVersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentVersions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentVersions
     * const documentVersions = await prisma.documentVersion.findMany()
     * 
     * // Get first 10 DocumentVersions
     * const documentVersions = await prisma.documentVersion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentVersionWithIdOnly = await prisma.documentVersion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentVersionFindManyArgs>(args?: SelectSubset<T, DocumentVersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentVersion.
     * @param {DocumentVersionCreateArgs} args - Arguments to create a DocumentVersion.
     * @example
     * // Create one DocumentVersion
     * const DocumentVersion = await prisma.documentVersion.create({
     *   data: {
     *     // ... data to create a DocumentVersion
     *   }
     * })
     * 
     */
    create<T extends DocumentVersionCreateArgs>(args: SelectSubset<T, DocumentVersionCreateArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentVersions.
     * @param {DocumentVersionCreateManyArgs} args - Arguments to create many DocumentVersions.
     * @example
     * // Create many DocumentVersions
     * const documentVersion = await prisma.documentVersion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentVersionCreateManyArgs>(args?: SelectSubset<T, DocumentVersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentVersions and returns the data saved in the database.
     * @param {DocumentVersionCreateManyAndReturnArgs} args - Arguments to create many DocumentVersions.
     * @example
     * // Create many DocumentVersions
     * const documentVersion = await prisma.documentVersion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentVersions and only return the `id`
     * const documentVersionWithIdOnly = await prisma.documentVersion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentVersionCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentVersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentVersion.
     * @param {DocumentVersionDeleteArgs} args - Arguments to delete one DocumentVersion.
     * @example
     * // Delete one DocumentVersion
     * const DocumentVersion = await prisma.documentVersion.delete({
     *   where: {
     *     // ... filter to delete one DocumentVersion
     *   }
     * })
     * 
     */
    delete<T extends DocumentVersionDeleteArgs>(args: SelectSubset<T, DocumentVersionDeleteArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentVersion.
     * @param {DocumentVersionUpdateArgs} args - Arguments to update one DocumentVersion.
     * @example
     * // Update one DocumentVersion
     * const documentVersion = await prisma.documentVersion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentVersionUpdateArgs>(args: SelectSubset<T, DocumentVersionUpdateArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentVersions.
     * @param {DocumentVersionDeleteManyArgs} args - Arguments to filter DocumentVersions to delete.
     * @example
     * // Delete a few DocumentVersions
     * const { count } = await prisma.documentVersion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentVersionDeleteManyArgs>(args?: SelectSubset<T, DocumentVersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentVersions
     * const documentVersion = await prisma.documentVersion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentVersionUpdateManyArgs>(args: SelectSubset<T, DocumentVersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentVersions and returns the data updated in the database.
     * @param {DocumentVersionUpdateManyAndReturnArgs} args - Arguments to update many DocumentVersions.
     * @example
     * // Update many DocumentVersions
     * const documentVersion = await prisma.documentVersion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentVersions and only return the `id`
     * const documentVersionWithIdOnly = await prisma.documentVersion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentVersionUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentVersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentVersion.
     * @param {DocumentVersionUpsertArgs} args - Arguments to update or create a DocumentVersion.
     * @example
     * // Update or create a DocumentVersion
     * const documentVersion = await prisma.documentVersion.upsert({
     *   create: {
     *     // ... data to create a DocumentVersion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentVersion we want to update
     *   }
     * })
     */
    upsert<T extends DocumentVersionUpsertArgs>(args: SelectSubset<T, DocumentVersionUpsertArgs<ExtArgs>>): Prisma__DocumentVersionClient<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentVersions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionCountArgs} args - Arguments to filter DocumentVersions to count.
     * @example
     * // Count the number of DocumentVersions
     * const count = await prisma.documentVersion.count({
     *   where: {
     *     // ... the filter for the DocumentVersions we want to count
     *   }
     * })
    **/
    count<T extends DocumentVersionCountArgs>(
      args?: Subset<T, DocumentVersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentVersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentVersionAggregateArgs>(args: Subset<T, DocumentVersionAggregateArgs>): Prisma.PrismaPromise<GetDocumentVersionAggregateType<T>>

    /**
     * Group by DocumentVersion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentVersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentVersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentVersionGroupByArgs['orderBy'] }
        : { orderBy?: DocumentVersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentVersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentVersion model
   */
  readonly fields: DocumentVersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentVersion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentVersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentation<T extends DocumentationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentationDefaultArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends DocumentVersion$UserArgs<ExtArgs> = {}>(args?: Subset<T, DocumentVersion$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentVersion model
   */
  interface DocumentVersionFieldRefs {
    readonly id: FieldRef<"DocumentVersion", 'String'>
    readonly documentationId: FieldRef<"DocumentVersion", 'String'>
    readonly version: FieldRef<"DocumentVersion", 'String'>
    readonly content: FieldRef<"DocumentVersion", 'String'>
    readonly changeLog: FieldRef<"DocumentVersion", 'String'>
    readonly createdAt: FieldRef<"DocumentVersion", 'DateTime'>
    readonly userId: FieldRef<"DocumentVersion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentVersion findUnique
   */
  export type DocumentVersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where: DocumentVersionWhereUniqueInput
  }

  /**
   * DocumentVersion findUniqueOrThrow
   */
  export type DocumentVersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where: DocumentVersionWhereUniqueInput
  }

  /**
   * DocumentVersion findFirst
   */
  export type DocumentVersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVersions.
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVersions.
     */
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * DocumentVersion findFirstOrThrow
   */
  export type DocumentVersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersion to fetch.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentVersions.
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentVersions.
     */
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * DocumentVersion findMany
   */
  export type DocumentVersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentVersions to fetch.
     */
    where?: DocumentVersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentVersions to fetch.
     */
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentVersions.
     */
    cursor?: DocumentVersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentVersions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentVersions.
     */
    skip?: number
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * DocumentVersion create
   */
  export type DocumentVersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentVersion.
     */
    data: XOR<DocumentVersionCreateInput, DocumentVersionUncheckedCreateInput>
  }

  /**
   * DocumentVersion createMany
   */
  export type DocumentVersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentVersions.
     */
    data: DocumentVersionCreateManyInput | DocumentVersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentVersion createManyAndReturn
   */
  export type DocumentVersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentVersions.
     */
    data: DocumentVersionCreateManyInput | DocumentVersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentVersion update
   */
  export type DocumentVersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentVersion.
     */
    data: XOR<DocumentVersionUpdateInput, DocumentVersionUncheckedUpdateInput>
    /**
     * Choose, which DocumentVersion to update.
     */
    where: DocumentVersionWhereUniqueInput
  }

  /**
   * DocumentVersion updateMany
   */
  export type DocumentVersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentVersions.
     */
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentVersions to update
     */
    where?: DocumentVersionWhereInput
    /**
     * Limit how many DocumentVersions to update.
     */
    limit?: number
  }

  /**
   * DocumentVersion updateManyAndReturn
   */
  export type DocumentVersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * The data used to update DocumentVersions.
     */
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentVersions to update
     */
    where?: DocumentVersionWhereInput
    /**
     * Limit how many DocumentVersions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentVersion upsert
   */
  export type DocumentVersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentVersion to update in case it exists.
     */
    where: DocumentVersionWhereUniqueInput
    /**
     * In case the DocumentVersion found by the `where` argument doesn't exist, create a new DocumentVersion with this data.
     */
    create: XOR<DocumentVersionCreateInput, DocumentVersionUncheckedCreateInput>
    /**
     * In case the DocumentVersion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentVersionUpdateInput, DocumentVersionUncheckedUpdateInput>
  }

  /**
   * DocumentVersion delete
   */
  export type DocumentVersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    /**
     * Filter which DocumentVersion to delete.
     */
    where: DocumentVersionWhereUniqueInput
  }

  /**
   * DocumentVersion deleteMany
   */
  export type DocumentVersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentVersions to delete
     */
    where?: DocumentVersionWhereInput
    /**
     * Limit how many DocumentVersions to delete.
     */
    limit?: number
  }

  /**
   * DocumentVersion.User
   */
  export type DocumentVersion$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DocumentVersion without action
   */
  export type DocumentVersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
  }


  /**
   * Model DocumentTag
   */

  export type AggregateDocumentTag = {
    _count: DocumentTagCountAggregateOutputType | null
    _min: DocumentTagMinAggregateOutputType | null
    _max: DocumentTagMaxAggregateOutputType | null
  }

  export type DocumentTagMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentTagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentTagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentTagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentTagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentTagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTag to aggregate.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentTags
    **/
    _count?: true | DocumentTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentTagMaxAggregateInputType
  }

  export type GetDocumentTagAggregateType<T extends DocumentTagAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentTag[P]>
      : GetScalarType<T[P], AggregateDocumentTag[P]>
  }




  export type DocumentTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentTagWhereInput
    orderBy?: DocumentTagOrderByWithAggregationInput | DocumentTagOrderByWithAggregationInput[]
    by: DocumentTagScalarFieldEnum[] | DocumentTagScalarFieldEnum
    having?: DocumentTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentTagCountAggregateInputType | true
    _min?: DocumentTagMinAggregateInputType
    _max?: DocumentTagMaxAggregateInputType
  }

  export type DocumentTagGroupByOutputType = {
    id: string
    name: string
    description: string | null
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentTagCountAggregateOutputType | null
    _min: DocumentTagMinAggregateOutputType | null
    _max: DocumentTagMaxAggregateOutputType | null
  }

  type GetDocumentTagGroupByPayload<T extends DocumentTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentTagGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentTagGroupByOutputType[P]>
        }
      >
    >


  export type DocumentTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    documentations?: boolean | DocumentTag$documentationsArgs<ExtArgs>
    _count?: boolean | DocumentTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentTag"]>

  export type DocumentTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentTag"]>

  export type DocumentTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["documentTag"]>

  export type DocumentTagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["documentTag"]>
  export type DocumentTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentations?: boolean | DocumentTag$documentationsArgs<ExtArgs>
    _count?: boolean | DocumentTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DocumentTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DocumentTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentTag"
    objects: {
      documentations: Prisma.$DocumentationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["documentTag"]>
    composites: {}
  }

  type DocumentTagGetPayload<S extends boolean | null | undefined | DocumentTagDefaultArgs> = $Result.GetResult<Prisma.$DocumentTagPayload, S>

  type DocumentTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentTagCountAggregateInputType | true
    }

  export interface DocumentTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentTag'], meta: { name: 'DocumentTag' } }
    /**
     * Find zero or one DocumentTag that matches the filter.
     * @param {DocumentTagFindUniqueArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentTagFindUniqueArgs>(args: SelectSubset<T, DocumentTagFindUniqueArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentTagFindUniqueOrThrowArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentTagFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagFindFirstArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentTagFindFirstArgs>(args?: SelectSubset<T, DocumentTagFindFirstArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagFindFirstOrThrowArgs} args - Arguments to find a DocumentTag
     * @example
     * // Get one DocumentTag
     * const documentTag = await prisma.documentTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentTagFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentTags
     * const documentTags = await prisma.documentTag.findMany()
     * 
     * // Get first 10 DocumentTags
     * const documentTags = await prisma.documentTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentTagWithIdOnly = await prisma.documentTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentTagFindManyArgs>(args?: SelectSubset<T, DocumentTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentTag.
     * @param {DocumentTagCreateArgs} args - Arguments to create a DocumentTag.
     * @example
     * // Create one DocumentTag
     * const DocumentTag = await prisma.documentTag.create({
     *   data: {
     *     // ... data to create a DocumentTag
     *   }
     * })
     * 
     */
    create<T extends DocumentTagCreateArgs>(args: SelectSubset<T, DocumentTagCreateArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentTags.
     * @param {DocumentTagCreateManyArgs} args - Arguments to create many DocumentTags.
     * @example
     * // Create many DocumentTags
     * const documentTag = await prisma.documentTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentTagCreateManyArgs>(args?: SelectSubset<T, DocumentTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentTags and returns the data saved in the database.
     * @param {DocumentTagCreateManyAndReturnArgs} args - Arguments to create many DocumentTags.
     * @example
     * // Create many DocumentTags
     * const documentTag = await prisma.documentTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentTags and only return the `id`
     * const documentTagWithIdOnly = await prisma.documentTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentTagCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentTag.
     * @param {DocumentTagDeleteArgs} args - Arguments to delete one DocumentTag.
     * @example
     * // Delete one DocumentTag
     * const DocumentTag = await prisma.documentTag.delete({
     *   where: {
     *     // ... filter to delete one DocumentTag
     *   }
     * })
     * 
     */
    delete<T extends DocumentTagDeleteArgs>(args: SelectSubset<T, DocumentTagDeleteArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentTag.
     * @param {DocumentTagUpdateArgs} args - Arguments to update one DocumentTag.
     * @example
     * // Update one DocumentTag
     * const documentTag = await prisma.documentTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentTagUpdateArgs>(args: SelectSubset<T, DocumentTagUpdateArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentTags.
     * @param {DocumentTagDeleteManyArgs} args - Arguments to filter DocumentTags to delete.
     * @example
     * // Delete a few DocumentTags
     * const { count } = await prisma.documentTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentTagDeleteManyArgs>(args?: SelectSubset<T, DocumentTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentTags
     * const documentTag = await prisma.documentTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentTagUpdateManyArgs>(args: SelectSubset<T, DocumentTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentTags and returns the data updated in the database.
     * @param {DocumentTagUpdateManyAndReturnArgs} args - Arguments to update many DocumentTags.
     * @example
     * // Update many DocumentTags
     * const documentTag = await prisma.documentTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentTags and only return the `id`
     * const documentTagWithIdOnly = await prisma.documentTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentTagUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentTag.
     * @param {DocumentTagUpsertArgs} args - Arguments to update or create a DocumentTag.
     * @example
     * // Update or create a DocumentTag
     * const documentTag = await prisma.documentTag.upsert({
     *   create: {
     *     // ... data to create a DocumentTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentTag we want to update
     *   }
     * })
     */
    upsert<T extends DocumentTagUpsertArgs>(args: SelectSubset<T, DocumentTagUpsertArgs<ExtArgs>>): Prisma__DocumentTagClient<$Result.GetResult<Prisma.$DocumentTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagCountArgs} args - Arguments to filter DocumentTags to count.
     * @example
     * // Count the number of DocumentTags
     * const count = await prisma.documentTag.count({
     *   where: {
     *     // ... the filter for the DocumentTags we want to count
     *   }
     * })
    **/
    count<T extends DocumentTagCountArgs>(
      args?: Subset<T, DocumentTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentTagAggregateArgs>(args: Subset<T, DocumentTagAggregateArgs>): Prisma.PrismaPromise<GetDocumentTagAggregateType<T>>

    /**
     * Group by DocumentTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentTagGroupByArgs['orderBy'] }
        : { orderBy?: DocumentTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentTag model
   */
  readonly fields: DocumentTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentations<T extends DocumentTag$documentationsArgs<ExtArgs> = {}>(args?: Subset<T, DocumentTag$documentationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentTag model
   */
  interface DocumentTagFieldRefs {
    readonly id: FieldRef<"DocumentTag", 'String'>
    readonly name: FieldRef<"DocumentTag", 'String'>
    readonly description: FieldRef<"DocumentTag", 'String'>
    readonly color: FieldRef<"DocumentTag", 'String'>
    readonly createdAt: FieldRef<"DocumentTag", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentTag findUnique
   */
  export type DocumentTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag findUniqueOrThrow
   */
  export type DocumentTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag findFirst
   */
  export type DocumentTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTags.
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTags.
     */
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * DocumentTag findFirstOrThrow
   */
  export type DocumentTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTag to fetch.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentTags.
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentTags.
     */
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * DocumentTag findMany
   */
  export type DocumentTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter, which DocumentTags to fetch.
     */
    where?: DocumentTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentTags to fetch.
     */
    orderBy?: DocumentTagOrderByWithRelationInput | DocumentTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentTags.
     */
    cursor?: DocumentTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentTags.
     */
    skip?: number
    distinct?: DocumentTagScalarFieldEnum | DocumentTagScalarFieldEnum[]
  }

  /**
   * DocumentTag create
   */
  export type DocumentTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentTag.
     */
    data: XOR<DocumentTagCreateInput, DocumentTagUncheckedCreateInput>
  }

  /**
   * DocumentTag createMany
   */
  export type DocumentTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentTags.
     */
    data: DocumentTagCreateManyInput | DocumentTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentTag createManyAndReturn
   */
  export type DocumentTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentTags.
     */
    data: DocumentTagCreateManyInput | DocumentTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentTag update
   */
  export type DocumentTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentTag.
     */
    data: XOR<DocumentTagUpdateInput, DocumentTagUncheckedUpdateInput>
    /**
     * Choose, which DocumentTag to update.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag updateMany
   */
  export type DocumentTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentTags.
     */
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTags to update
     */
    where?: DocumentTagWhereInput
    /**
     * Limit how many DocumentTags to update.
     */
    limit?: number
  }

  /**
   * DocumentTag updateManyAndReturn
   */
  export type DocumentTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * The data used to update DocumentTags.
     */
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyInput>
    /**
     * Filter which DocumentTags to update
     */
    where?: DocumentTagWhereInput
    /**
     * Limit how many DocumentTags to update.
     */
    limit?: number
  }

  /**
   * DocumentTag upsert
   */
  export type DocumentTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentTag to update in case it exists.
     */
    where: DocumentTagWhereUniqueInput
    /**
     * In case the DocumentTag found by the `where` argument doesn't exist, create a new DocumentTag with this data.
     */
    create: XOR<DocumentTagCreateInput, DocumentTagUncheckedCreateInput>
    /**
     * In case the DocumentTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentTagUpdateInput, DocumentTagUncheckedUpdateInput>
  }

  /**
   * DocumentTag delete
   */
  export type DocumentTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
    /**
     * Filter which DocumentTag to delete.
     */
    where: DocumentTagWhereUniqueInput
  }

  /**
   * DocumentTag deleteMany
   */
  export type DocumentTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentTags to delete
     */
    where?: DocumentTagWhereInput
    /**
     * Limit how many DocumentTags to delete.
     */
    limit?: number
  }

  /**
   * DocumentTag.documentations
   */
  export type DocumentTag$documentationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    where?: DocumentationWhereInput
    orderBy?: DocumentationOrderByWithRelationInput | DocumentationOrderByWithRelationInput[]
    cursor?: DocumentationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentationScalarFieldEnum | DocumentationScalarFieldEnum[]
  }

  /**
   * DocumentTag without action
   */
  export type DocumentTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentTag
     */
    select?: DocumentTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentTag
     */
    omit?: DocumentTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentTagInclude<ExtArgs> | null
  }


  /**
   * Model DocumentComment
   */

  export type AggregateDocumentComment = {
    _count: DocumentCommentCountAggregateOutputType | null
    _min: DocumentCommentMinAggregateOutputType | null
    _max: DocumentCommentMaxAggregateOutputType | null
  }

  export type DocumentCommentMinAggregateOutputType = {
    id: string | null
    documentationId: string | null
    content: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type DocumentCommentMaxAggregateOutputType = {
    id: string | null
    documentationId: string | null
    content: string | null
    parentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
  }

  export type DocumentCommentCountAggregateOutputType = {
    id: number
    documentationId: number
    content: number
    parentId: number
    createdAt: number
    updatedAt: number
    userId: number
    _all: number
  }


  export type DocumentCommentMinAggregateInputType = {
    id?: true
    documentationId?: true
    content?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type DocumentCommentMaxAggregateInputType = {
    id?: true
    documentationId?: true
    content?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
  }

  export type DocumentCommentCountAggregateInputType = {
    id?: true
    documentationId?: true
    content?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    _all?: true
  }

  export type DocumentCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentComment to aggregate.
     */
    where?: DocumentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentComments
    **/
    _count?: true | DocumentCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentCommentMaxAggregateInputType
  }

  export type GetDocumentCommentAggregateType<T extends DocumentCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentComment[P]>
      : GetScalarType<T[P], AggregateDocumentComment[P]>
  }




  export type DocumentCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentCommentWhereInput
    orderBy?: DocumentCommentOrderByWithAggregationInput | DocumentCommentOrderByWithAggregationInput[]
    by: DocumentCommentScalarFieldEnum[] | DocumentCommentScalarFieldEnum
    having?: DocumentCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCommentCountAggregateInputType | true
    _min?: DocumentCommentMinAggregateInputType
    _max?: DocumentCommentMaxAggregateInputType
  }

  export type DocumentCommentGroupByOutputType = {
    id: string
    documentationId: string
    content: string
    parentId: string | null
    createdAt: Date
    updatedAt: Date
    userId: string | null
    _count: DocumentCommentCountAggregateOutputType | null
    _min: DocumentCommentMinAggregateOutputType | null
    _max: DocumentCommentMaxAggregateOutputType | null
  }

  type GetDocumentCommentGroupByPayload<T extends DocumentCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentCommentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentCommentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentationId?: boolean
    content?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    parent?: boolean | DocumentComment$parentArgs<ExtArgs>
    replies?: boolean | DocumentComment$repliesArgs<ExtArgs>
    User?: boolean | DocumentComment$UserArgs<ExtArgs>
    _count?: boolean | DocumentCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentComment"]>

  export type DocumentCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentationId?: boolean
    content?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    parent?: boolean | DocumentComment$parentArgs<ExtArgs>
    User?: boolean | DocumentComment$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentComment"]>

  export type DocumentCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentationId?: boolean
    content?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    parent?: boolean | DocumentComment$parentArgs<ExtArgs>
    User?: boolean | DocumentComment$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentComment"]>

  export type DocumentCommentSelectScalar = {
    id?: boolean
    documentationId?: boolean
    content?: boolean
    parentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
  }

  export type DocumentCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentationId" | "content" | "parentId" | "createdAt" | "updatedAt" | "userId", ExtArgs["result"]["documentComment"]>
  export type DocumentCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    parent?: boolean | DocumentComment$parentArgs<ExtArgs>
    replies?: boolean | DocumentComment$repliesArgs<ExtArgs>
    User?: boolean | DocumentComment$UserArgs<ExtArgs>
    _count?: boolean | DocumentCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    parent?: boolean | DocumentComment$parentArgs<ExtArgs>
    User?: boolean | DocumentComment$UserArgs<ExtArgs>
  }
  export type DocumentCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    parent?: boolean | DocumentComment$parentArgs<ExtArgs>
    User?: boolean | DocumentComment$UserArgs<ExtArgs>
  }

  export type $DocumentCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentComment"
    objects: {
      documentation: Prisma.$DocumentationPayload<ExtArgs>
      parent: Prisma.$DocumentCommentPayload<ExtArgs> | null
      replies: Prisma.$DocumentCommentPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentationId: string
      content: string
      parentId: string | null
      createdAt: Date
      updatedAt: Date
      userId: string | null
    }, ExtArgs["result"]["documentComment"]>
    composites: {}
  }

  type DocumentCommentGetPayload<S extends boolean | null | undefined | DocumentCommentDefaultArgs> = $Result.GetResult<Prisma.$DocumentCommentPayload, S>

  type DocumentCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCommentCountAggregateInputType | true
    }

  export interface DocumentCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentComment'], meta: { name: 'DocumentComment' } }
    /**
     * Find zero or one DocumentComment that matches the filter.
     * @param {DocumentCommentFindUniqueArgs} args - Arguments to find a DocumentComment
     * @example
     * // Get one DocumentComment
     * const documentComment = await prisma.documentComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentCommentFindUniqueArgs>(args: SelectSubset<T, DocumentCommentFindUniqueArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentCommentFindUniqueOrThrowArgs} args - Arguments to find a DocumentComment
     * @example
     * // Get one DocumentComment
     * const documentComment = await prisma.documentComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentFindFirstArgs} args - Arguments to find a DocumentComment
     * @example
     * // Get one DocumentComment
     * const documentComment = await prisma.documentComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentCommentFindFirstArgs>(args?: SelectSubset<T, DocumentCommentFindFirstArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentFindFirstOrThrowArgs} args - Arguments to find a DocumentComment
     * @example
     * // Get one DocumentComment
     * const documentComment = await prisma.documentComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentComments
     * const documentComments = await prisma.documentComment.findMany()
     * 
     * // Get first 10 DocumentComments
     * const documentComments = await prisma.documentComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentCommentWithIdOnly = await prisma.documentComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentCommentFindManyArgs>(args?: SelectSubset<T, DocumentCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentComment.
     * @param {DocumentCommentCreateArgs} args - Arguments to create a DocumentComment.
     * @example
     * // Create one DocumentComment
     * const DocumentComment = await prisma.documentComment.create({
     *   data: {
     *     // ... data to create a DocumentComment
     *   }
     * })
     * 
     */
    create<T extends DocumentCommentCreateArgs>(args: SelectSubset<T, DocumentCommentCreateArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentComments.
     * @param {DocumentCommentCreateManyArgs} args - Arguments to create many DocumentComments.
     * @example
     * // Create many DocumentComments
     * const documentComment = await prisma.documentComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCommentCreateManyArgs>(args?: SelectSubset<T, DocumentCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentComments and returns the data saved in the database.
     * @param {DocumentCommentCreateManyAndReturnArgs} args - Arguments to create many DocumentComments.
     * @example
     * // Create many DocumentComments
     * const documentComment = await prisma.documentComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentComments and only return the `id`
     * const documentCommentWithIdOnly = await prisma.documentComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentComment.
     * @param {DocumentCommentDeleteArgs} args - Arguments to delete one DocumentComment.
     * @example
     * // Delete one DocumentComment
     * const DocumentComment = await prisma.documentComment.delete({
     *   where: {
     *     // ... filter to delete one DocumentComment
     *   }
     * })
     * 
     */
    delete<T extends DocumentCommentDeleteArgs>(args: SelectSubset<T, DocumentCommentDeleteArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentComment.
     * @param {DocumentCommentUpdateArgs} args - Arguments to update one DocumentComment.
     * @example
     * // Update one DocumentComment
     * const documentComment = await prisma.documentComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentCommentUpdateArgs>(args: SelectSubset<T, DocumentCommentUpdateArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentComments.
     * @param {DocumentCommentDeleteManyArgs} args - Arguments to filter DocumentComments to delete.
     * @example
     * // Delete a few DocumentComments
     * const { count } = await prisma.documentComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentCommentDeleteManyArgs>(args?: SelectSubset<T, DocumentCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentComments
     * const documentComment = await prisma.documentComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentCommentUpdateManyArgs>(args: SelectSubset<T, DocumentCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentComments and returns the data updated in the database.
     * @param {DocumentCommentUpdateManyAndReturnArgs} args - Arguments to update many DocumentComments.
     * @example
     * // Update many DocumentComments
     * const documentComment = await prisma.documentComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentComments and only return the `id`
     * const documentCommentWithIdOnly = await prisma.documentComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentComment.
     * @param {DocumentCommentUpsertArgs} args - Arguments to update or create a DocumentComment.
     * @example
     * // Update or create a DocumentComment
     * const documentComment = await prisma.documentComment.upsert({
     *   create: {
     *     // ... data to create a DocumentComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentComment we want to update
     *   }
     * })
     */
    upsert<T extends DocumentCommentUpsertArgs>(args: SelectSubset<T, DocumentCommentUpsertArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentCountArgs} args - Arguments to filter DocumentComments to count.
     * @example
     * // Count the number of DocumentComments
     * const count = await prisma.documentComment.count({
     *   where: {
     *     // ... the filter for the DocumentComments we want to count
     *   }
     * })
    **/
    count<T extends DocumentCommentCountArgs>(
      args?: Subset<T, DocumentCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentCommentAggregateArgs>(args: Subset<T, DocumentCommentAggregateArgs>): Prisma.PrismaPromise<GetDocumentCommentAggregateType<T>>

    /**
     * Group by DocumentComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentCommentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentComment model
   */
  readonly fields: DocumentCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentation<T extends DocumentationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentationDefaultArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends DocumentComment$parentArgs<ExtArgs> = {}>(args?: Subset<T, DocumentComment$parentArgs<ExtArgs>>): Prisma__DocumentCommentClient<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends DocumentComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, DocumentComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends DocumentComment$UserArgs<ExtArgs> = {}>(args?: Subset<T, DocumentComment$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentComment model
   */
  interface DocumentCommentFieldRefs {
    readonly id: FieldRef<"DocumentComment", 'String'>
    readonly documentationId: FieldRef<"DocumentComment", 'String'>
    readonly content: FieldRef<"DocumentComment", 'String'>
    readonly parentId: FieldRef<"DocumentComment", 'String'>
    readonly createdAt: FieldRef<"DocumentComment", 'DateTime'>
    readonly updatedAt: FieldRef<"DocumentComment", 'DateTime'>
    readonly userId: FieldRef<"DocumentComment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentComment findUnique
   */
  export type DocumentCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComment to fetch.
     */
    where: DocumentCommentWhereUniqueInput
  }

  /**
   * DocumentComment findUniqueOrThrow
   */
  export type DocumentCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComment to fetch.
     */
    where: DocumentCommentWhereUniqueInput
  }

  /**
   * DocumentComment findFirst
   */
  export type DocumentCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComment to fetch.
     */
    where?: DocumentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentComments.
     */
    cursor?: DocumentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentComments.
     */
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * DocumentComment findFirstOrThrow
   */
  export type DocumentCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComment to fetch.
     */
    where?: DocumentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentComments.
     */
    cursor?: DocumentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentComments.
     */
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * DocumentComment findMany
   */
  export type DocumentCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentComments to fetch.
     */
    where?: DocumentCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentComments to fetch.
     */
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentComments.
     */
    cursor?: DocumentCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentComments.
     */
    skip?: number
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * DocumentComment create
   */
  export type DocumentCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentComment.
     */
    data: XOR<DocumentCommentCreateInput, DocumentCommentUncheckedCreateInput>
  }

  /**
   * DocumentComment createMany
   */
  export type DocumentCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentComments.
     */
    data: DocumentCommentCreateManyInput | DocumentCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentComment createManyAndReturn
   */
  export type DocumentCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentComments.
     */
    data: DocumentCommentCreateManyInput | DocumentCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentComment update
   */
  export type DocumentCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentComment.
     */
    data: XOR<DocumentCommentUpdateInput, DocumentCommentUncheckedUpdateInput>
    /**
     * Choose, which DocumentComment to update.
     */
    where: DocumentCommentWhereUniqueInput
  }

  /**
   * DocumentComment updateMany
   */
  export type DocumentCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentComments.
     */
    data: XOR<DocumentCommentUpdateManyMutationInput, DocumentCommentUncheckedUpdateManyInput>
    /**
     * Filter which DocumentComments to update
     */
    where?: DocumentCommentWhereInput
    /**
     * Limit how many DocumentComments to update.
     */
    limit?: number
  }

  /**
   * DocumentComment updateManyAndReturn
   */
  export type DocumentCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * The data used to update DocumentComments.
     */
    data: XOR<DocumentCommentUpdateManyMutationInput, DocumentCommentUncheckedUpdateManyInput>
    /**
     * Filter which DocumentComments to update
     */
    where?: DocumentCommentWhereInput
    /**
     * Limit how many DocumentComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentComment upsert
   */
  export type DocumentCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentComment to update in case it exists.
     */
    where: DocumentCommentWhereUniqueInput
    /**
     * In case the DocumentComment found by the `where` argument doesn't exist, create a new DocumentComment with this data.
     */
    create: XOR<DocumentCommentCreateInput, DocumentCommentUncheckedCreateInput>
    /**
     * In case the DocumentComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentCommentUpdateInput, DocumentCommentUncheckedUpdateInput>
  }

  /**
   * DocumentComment delete
   */
  export type DocumentCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    /**
     * Filter which DocumentComment to delete.
     */
    where: DocumentCommentWhereUniqueInput
  }

  /**
   * DocumentComment deleteMany
   */
  export type DocumentCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentComments to delete
     */
    where?: DocumentCommentWhereInput
    /**
     * Limit how many DocumentComments to delete.
     */
    limit?: number
  }

  /**
   * DocumentComment.parent
   */
  export type DocumentComment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    where?: DocumentCommentWhereInput
  }

  /**
   * DocumentComment.replies
   */
  export type DocumentComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    where?: DocumentCommentWhereInput
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    cursor?: DocumentCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * DocumentComment.User
   */
  export type DocumentComment$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DocumentComment without action
   */
  export type DocumentCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentAttachment
   */

  export type AggregateDocumentAttachment = {
    _count: DocumentAttachmentCountAggregateOutputType | null
    _avg: DocumentAttachmentAvgAggregateOutputType | null
    _sum: DocumentAttachmentSumAggregateOutputType | null
    _min: DocumentAttachmentMinAggregateOutputType | null
    _max: DocumentAttachmentMaxAggregateOutputType | null
  }

  export type DocumentAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentAttachmentMinAggregateOutputType = {
    id: string | null
    documentationId: string | null
    fileName: string | null
    fileUrl: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type DocumentAttachmentMaxAggregateOutputType = {
    id: string | null
    documentationId: string | null
    fileName: string | null
    fileUrl: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type DocumentAttachmentCountAggregateOutputType = {
    id: number
    documentationId: number
    fileName: number
    fileUrl: number
    fileSize: number
    mimeType: number
    createdAt: number
    userId: number
    _all: number
  }


  export type DocumentAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentAttachmentMinAggregateInputType = {
    id?: true
    documentationId?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    userId?: true
  }

  export type DocumentAttachmentMaxAggregateInputType = {
    id?: true
    documentationId?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    userId?: true
  }

  export type DocumentAttachmentCountAggregateInputType = {
    id?: true
    documentationId?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type DocumentAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAttachment to aggregate.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentAttachments
    **/
    _count?: true | DocumentAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentAttachmentMaxAggregateInputType
  }

  export type GetDocumentAttachmentAggregateType<T extends DocumentAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentAttachment[P]>
      : GetScalarType<T[P], AggregateDocumentAttachment[P]>
  }




  export type DocumentAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentAttachmentWhereInput
    orderBy?: DocumentAttachmentOrderByWithAggregationInput | DocumentAttachmentOrderByWithAggregationInput[]
    by: DocumentAttachmentScalarFieldEnum[] | DocumentAttachmentScalarFieldEnum
    having?: DocumentAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentAttachmentCountAggregateInputType | true
    _avg?: DocumentAttachmentAvgAggregateInputType
    _sum?: DocumentAttachmentSumAggregateInputType
    _min?: DocumentAttachmentMinAggregateInputType
    _max?: DocumentAttachmentMaxAggregateInputType
  }

  export type DocumentAttachmentGroupByOutputType = {
    id: string
    documentationId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt: Date
    userId: string | null
    _count: DocumentAttachmentCountAggregateOutputType | null
    _avg: DocumentAttachmentAvgAggregateOutputType | null
    _sum: DocumentAttachmentSumAggregateOutputType | null
    _min: DocumentAttachmentMinAggregateOutputType | null
    _max: DocumentAttachmentMaxAggregateOutputType | null
  }

  type GetDocumentAttachmentGroupByPayload<T extends DocumentAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentationId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    userId?: boolean
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentAttachment$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentAttachment"]>

  export type DocumentAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentationId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    userId?: boolean
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentAttachment$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentAttachment"]>

  export type DocumentAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentationId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    userId?: boolean
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentAttachment$UserArgs<ExtArgs>
  }, ExtArgs["result"]["documentAttachment"]>

  export type DocumentAttachmentSelectScalar = {
    id?: boolean
    documentationId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type DocumentAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentationId" | "fileName" | "fileUrl" | "fileSize" | "mimeType" | "createdAt" | "userId", ExtArgs["result"]["documentAttachment"]>
  export type DocumentAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentAttachment$UserArgs<ExtArgs>
  }
  export type DocumentAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentAttachment$UserArgs<ExtArgs>
  }
  export type DocumentAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentation?: boolean | DocumentationDefaultArgs<ExtArgs>
    User?: boolean | DocumentAttachment$UserArgs<ExtArgs>
  }

  export type $DocumentAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentAttachment"
    objects: {
      documentation: Prisma.$DocumentationPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentationId: string
      fileName: string
      fileUrl: string
      fileSize: number
      mimeType: string
      createdAt: Date
      userId: string | null
    }, ExtArgs["result"]["documentAttachment"]>
    composites: {}
  }

  type DocumentAttachmentGetPayload<S extends boolean | null | undefined | DocumentAttachmentDefaultArgs> = $Result.GetResult<Prisma.$DocumentAttachmentPayload, S>

  type DocumentAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentAttachmentCountAggregateInputType | true
    }

  export interface DocumentAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentAttachment'], meta: { name: 'DocumentAttachment' } }
    /**
     * Find zero or one DocumentAttachment that matches the filter.
     * @param {DocumentAttachmentFindUniqueArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentAttachmentFindUniqueArgs>(args: SelectSubset<T, DocumentAttachmentFindUniqueArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentAttachmentFindUniqueOrThrowArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentFindFirstArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentAttachmentFindFirstArgs>(args?: SelectSubset<T, DocumentAttachmentFindFirstArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentFindFirstOrThrowArgs} args - Arguments to find a DocumentAttachment
     * @example
     * // Get one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentAttachments
     * const documentAttachments = await prisma.documentAttachment.findMany()
     * 
     * // Get first 10 DocumentAttachments
     * const documentAttachments = await prisma.documentAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentAttachmentWithIdOnly = await prisma.documentAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentAttachmentFindManyArgs>(args?: SelectSubset<T, DocumentAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentAttachment.
     * @param {DocumentAttachmentCreateArgs} args - Arguments to create a DocumentAttachment.
     * @example
     * // Create one DocumentAttachment
     * const DocumentAttachment = await prisma.documentAttachment.create({
     *   data: {
     *     // ... data to create a DocumentAttachment
     *   }
     * })
     * 
     */
    create<T extends DocumentAttachmentCreateArgs>(args: SelectSubset<T, DocumentAttachmentCreateArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentAttachments.
     * @param {DocumentAttachmentCreateManyArgs} args - Arguments to create many DocumentAttachments.
     * @example
     * // Create many DocumentAttachments
     * const documentAttachment = await prisma.documentAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentAttachmentCreateManyArgs>(args?: SelectSubset<T, DocumentAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentAttachments and returns the data saved in the database.
     * @param {DocumentAttachmentCreateManyAndReturnArgs} args - Arguments to create many DocumentAttachments.
     * @example
     * // Create many DocumentAttachments
     * const documentAttachment = await prisma.documentAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentAttachments and only return the `id`
     * const documentAttachmentWithIdOnly = await prisma.documentAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentAttachment.
     * @param {DocumentAttachmentDeleteArgs} args - Arguments to delete one DocumentAttachment.
     * @example
     * // Delete one DocumentAttachment
     * const DocumentAttachment = await prisma.documentAttachment.delete({
     *   where: {
     *     // ... filter to delete one DocumentAttachment
     *   }
     * })
     * 
     */
    delete<T extends DocumentAttachmentDeleteArgs>(args: SelectSubset<T, DocumentAttachmentDeleteArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentAttachment.
     * @param {DocumentAttachmentUpdateArgs} args - Arguments to update one DocumentAttachment.
     * @example
     * // Update one DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentAttachmentUpdateArgs>(args: SelectSubset<T, DocumentAttachmentUpdateArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentAttachments.
     * @param {DocumentAttachmentDeleteManyArgs} args - Arguments to filter DocumentAttachments to delete.
     * @example
     * // Delete a few DocumentAttachments
     * const { count } = await prisma.documentAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentAttachmentDeleteManyArgs>(args?: SelectSubset<T, DocumentAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentAttachments
     * const documentAttachment = await prisma.documentAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentAttachmentUpdateManyArgs>(args: SelectSubset<T, DocumentAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentAttachments and returns the data updated in the database.
     * @param {DocumentAttachmentUpdateManyAndReturnArgs} args - Arguments to update many DocumentAttachments.
     * @example
     * // Update many DocumentAttachments
     * const documentAttachment = await prisma.documentAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentAttachments and only return the `id`
     * const documentAttachmentWithIdOnly = await prisma.documentAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentAttachment.
     * @param {DocumentAttachmentUpsertArgs} args - Arguments to update or create a DocumentAttachment.
     * @example
     * // Update or create a DocumentAttachment
     * const documentAttachment = await prisma.documentAttachment.upsert({
     *   create: {
     *     // ... data to create a DocumentAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentAttachment we want to update
     *   }
     * })
     */
    upsert<T extends DocumentAttachmentUpsertArgs>(args: SelectSubset<T, DocumentAttachmentUpsertArgs<ExtArgs>>): Prisma__DocumentAttachmentClient<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentCountArgs} args - Arguments to filter DocumentAttachments to count.
     * @example
     * // Count the number of DocumentAttachments
     * const count = await prisma.documentAttachment.count({
     *   where: {
     *     // ... the filter for the DocumentAttachments we want to count
     *   }
     * })
    **/
    count<T extends DocumentAttachmentCountArgs>(
      args?: Subset<T, DocumentAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAttachmentAggregateArgs>(args: Subset<T, DocumentAttachmentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAttachmentAggregateType<T>>

    /**
     * Group by DocumentAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentAttachment model
   */
  readonly fields: DocumentAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentation<T extends DocumentationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentationDefaultArgs<ExtArgs>>): Prisma__DocumentationClient<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends DocumentAttachment$UserArgs<ExtArgs> = {}>(args?: Subset<T, DocumentAttachment$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentAttachment model
   */
  interface DocumentAttachmentFieldRefs {
    readonly id: FieldRef<"DocumentAttachment", 'String'>
    readonly documentationId: FieldRef<"DocumentAttachment", 'String'>
    readonly fileName: FieldRef<"DocumentAttachment", 'String'>
    readonly fileUrl: FieldRef<"DocumentAttachment", 'String'>
    readonly fileSize: FieldRef<"DocumentAttachment", 'Int'>
    readonly mimeType: FieldRef<"DocumentAttachment", 'String'>
    readonly createdAt: FieldRef<"DocumentAttachment", 'DateTime'>
    readonly userId: FieldRef<"DocumentAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DocumentAttachment findUnique
   */
  export type DocumentAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where: DocumentAttachmentWhereUniqueInput
  }

  /**
   * DocumentAttachment findUniqueOrThrow
   */
  export type DocumentAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where: DocumentAttachmentWhereUniqueInput
  }

  /**
   * DocumentAttachment findFirst
   */
  export type DocumentAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAttachments.
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAttachments.
     */
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * DocumentAttachment findFirstOrThrow
   */
  export type DocumentAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachment to fetch.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentAttachments.
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentAttachments.
     */
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * DocumentAttachment findMany
   */
  export type DocumentAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which DocumentAttachments to fetch.
     */
    where?: DocumentAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentAttachments to fetch.
     */
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentAttachments.
     */
    cursor?: DocumentAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentAttachments.
     */
    skip?: number
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * DocumentAttachment create
   */
  export type DocumentAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentAttachment.
     */
    data: XOR<DocumentAttachmentCreateInput, DocumentAttachmentUncheckedCreateInput>
  }

  /**
   * DocumentAttachment createMany
   */
  export type DocumentAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentAttachments.
     */
    data: DocumentAttachmentCreateManyInput | DocumentAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentAttachment createManyAndReturn
   */
  export type DocumentAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentAttachments.
     */
    data: DocumentAttachmentCreateManyInput | DocumentAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAttachment update
   */
  export type DocumentAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentAttachment.
     */
    data: XOR<DocumentAttachmentUpdateInput, DocumentAttachmentUncheckedUpdateInput>
    /**
     * Choose, which DocumentAttachment to update.
     */
    where: DocumentAttachmentWhereUniqueInput
  }

  /**
   * DocumentAttachment updateMany
   */
  export type DocumentAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentAttachments.
     */
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which DocumentAttachments to update
     */
    where?: DocumentAttachmentWhereInput
    /**
     * Limit how many DocumentAttachments to update.
     */
    limit?: number
  }

  /**
   * DocumentAttachment updateManyAndReturn
   */
  export type DocumentAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update DocumentAttachments.
     */
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which DocumentAttachments to update
     */
    where?: DocumentAttachmentWhereInput
    /**
     * Limit how many DocumentAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentAttachment upsert
   */
  export type DocumentAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentAttachment to update in case it exists.
     */
    where: DocumentAttachmentWhereUniqueInput
    /**
     * In case the DocumentAttachment found by the `where` argument doesn't exist, create a new DocumentAttachment with this data.
     */
    create: XOR<DocumentAttachmentCreateInput, DocumentAttachmentUncheckedCreateInput>
    /**
     * In case the DocumentAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentAttachmentUpdateInput, DocumentAttachmentUncheckedUpdateInput>
  }

  /**
   * DocumentAttachment delete
   */
  export type DocumentAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    /**
     * Filter which DocumentAttachment to delete.
     */
    where: DocumentAttachmentWhereUniqueInput
  }

  /**
   * DocumentAttachment deleteMany
   */
  export type DocumentAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentAttachments to delete
     */
    where?: DocumentAttachmentWhereInput
    /**
     * Limit how many DocumentAttachments to delete.
     */
    limit?: number
  }

  /**
   * DocumentAttachment.User
   */
  export type DocumentAttachment$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DocumentAttachment without action
   */
  export type DocumentAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model MindMap
   */

  export type AggregateMindMap = {
    _count: MindMapCountAggregateOutputType | null
    _avg: MindMapAvgAggregateOutputType | null
    _sum: MindMapSumAggregateOutputType | null
    _min: MindMapMinAggregateOutputType | null
    _max: MindMapMaxAggregateOutputType | null
  }

  export type MindMapAvgAggregateOutputType = {
    version: number | null
  }

  export type MindMapSumAggregateOutputType = {
    version: number | null
  }

  export type MindMapMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    overview: string | null
    nodeId: string | null
    layout: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type MindMapMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    description: string | null
    overview: string | null
    nodeId: string | null
    layout: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type MindMapCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    description: number
    overview: number
    nodeId: number
    theme: number
    layout: number
    version: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    userId: number
    _all: number
  }


  export type MindMapAvgAggregateInputType = {
    version?: true
  }

  export type MindMapSumAggregateInputType = {
    version?: true
  }

  export type MindMapMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    overview?: true
    nodeId?: true
    layout?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type MindMapMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    overview?: true
    nodeId?: true
    layout?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type MindMapCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    description?: true
    overview?: true
    nodeId?: true
    theme?: true
    layout?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
    _all?: true
  }

  export type MindMapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MindMap to aggregate.
     */
    where?: MindMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MindMaps to fetch.
     */
    orderBy?: MindMapOrderByWithRelationInput | MindMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MindMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MindMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MindMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MindMaps
    **/
    _count?: true | MindMapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MindMapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MindMapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MindMapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MindMapMaxAggregateInputType
  }

  export type GetMindMapAggregateType<T extends MindMapAggregateArgs> = {
        [P in keyof T & keyof AggregateMindMap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMindMap[P]>
      : GetScalarType<T[P], AggregateMindMap[P]>
  }




  export type MindMapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MindMapWhereInput
    orderBy?: MindMapOrderByWithAggregationInput | MindMapOrderByWithAggregationInput[]
    by: MindMapScalarFieldEnum[] | MindMapScalarFieldEnum
    having?: MindMapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MindMapCountAggregateInputType | true
    _avg?: MindMapAvgAggregateInputType
    _sum?: MindMapSumAggregateInputType
    _min?: MindMapMinAggregateInputType
    _max?: MindMapMaxAggregateInputType
  }

  export type MindMapGroupByOutputType = {
    id: string
    projectId: string
    title: string
    description: string | null
    overview: string
    nodeId: string | null
    theme: JsonValue | null
    layout: string
    version: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    userId: string | null
    _count: MindMapCountAggregateOutputType | null
    _avg: MindMapAvgAggregateOutputType | null
    _sum: MindMapSumAggregateOutputType | null
    _min: MindMapMinAggregateOutputType | null
    _max: MindMapMaxAggregateOutputType | null
  }

  type GetMindMapGroupByPayload<T extends MindMapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MindMapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MindMapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MindMapGroupByOutputType[P]>
            : GetScalarType<T[P], MindMapGroupByOutputType[P]>
        }
      >
    >


  export type MindMapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    overview?: boolean
    nodeId?: boolean
    theme?: boolean
    layout?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    rootNode?: boolean | MindMap$rootNodeArgs<ExtArgs>
    nodes?: boolean | MindMap$nodesArgs<ExtArgs>
    User?: boolean | MindMap$UserArgs<ExtArgs>
    _count?: boolean | MindMapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mindMap"]>

  export type MindMapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    overview?: boolean
    nodeId?: boolean
    theme?: boolean
    layout?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    rootNode?: boolean | MindMap$rootNodeArgs<ExtArgs>
    User?: boolean | MindMap$UserArgs<ExtArgs>
  }, ExtArgs["result"]["mindMap"]>

  export type MindMapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    overview?: boolean
    nodeId?: boolean
    theme?: boolean
    layout?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    rootNode?: boolean | MindMap$rootNodeArgs<ExtArgs>
    User?: boolean | MindMap$UserArgs<ExtArgs>
  }, ExtArgs["result"]["mindMap"]>

  export type MindMapSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    description?: boolean
    overview?: boolean
    nodeId?: boolean
    theme?: boolean
    layout?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
  }

  export type MindMapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "title" | "description" | "overview" | "nodeId" | "theme" | "layout" | "version" | "createdAt" | "updatedAt" | "deletedAt" | "userId", ExtArgs["result"]["mindMap"]>
  export type MindMapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    rootNode?: boolean | MindMap$rootNodeArgs<ExtArgs>
    nodes?: boolean | MindMap$nodesArgs<ExtArgs>
    User?: boolean | MindMap$UserArgs<ExtArgs>
    _count?: boolean | MindMapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MindMapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    rootNode?: boolean | MindMap$rootNodeArgs<ExtArgs>
    User?: boolean | MindMap$UserArgs<ExtArgs>
  }
  export type MindMapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    rootNode?: boolean | MindMap$rootNodeArgs<ExtArgs>
    User?: boolean | MindMap$UserArgs<ExtArgs>
  }

  export type $MindMapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MindMap"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      rootNode: Prisma.$MindMapNodePayload<ExtArgs> | null
      nodes: Prisma.$MindMapNodePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      description: string | null
      overview: string
      nodeId: string | null
      theme: Prisma.JsonValue | null
      layout: string
      version: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      userId: string | null
    }, ExtArgs["result"]["mindMap"]>
    composites: {}
  }

  type MindMapGetPayload<S extends boolean | null | undefined | MindMapDefaultArgs> = $Result.GetResult<Prisma.$MindMapPayload, S>

  type MindMapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MindMapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MindMapCountAggregateInputType | true
    }

  export interface MindMapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MindMap'], meta: { name: 'MindMap' } }
    /**
     * Find zero or one MindMap that matches the filter.
     * @param {MindMapFindUniqueArgs} args - Arguments to find a MindMap
     * @example
     * // Get one MindMap
     * const mindMap = await prisma.mindMap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MindMapFindUniqueArgs>(args: SelectSubset<T, MindMapFindUniqueArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MindMap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MindMapFindUniqueOrThrowArgs} args - Arguments to find a MindMap
     * @example
     * // Get one MindMap
     * const mindMap = await prisma.mindMap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MindMapFindUniqueOrThrowArgs>(args: SelectSubset<T, MindMapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MindMap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapFindFirstArgs} args - Arguments to find a MindMap
     * @example
     * // Get one MindMap
     * const mindMap = await prisma.mindMap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MindMapFindFirstArgs>(args?: SelectSubset<T, MindMapFindFirstArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MindMap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapFindFirstOrThrowArgs} args - Arguments to find a MindMap
     * @example
     * // Get one MindMap
     * const mindMap = await prisma.mindMap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MindMapFindFirstOrThrowArgs>(args?: SelectSubset<T, MindMapFindFirstOrThrowArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MindMaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MindMaps
     * const mindMaps = await prisma.mindMap.findMany()
     * 
     * // Get first 10 MindMaps
     * const mindMaps = await prisma.mindMap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mindMapWithIdOnly = await prisma.mindMap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MindMapFindManyArgs>(args?: SelectSubset<T, MindMapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MindMap.
     * @param {MindMapCreateArgs} args - Arguments to create a MindMap.
     * @example
     * // Create one MindMap
     * const MindMap = await prisma.mindMap.create({
     *   data: {
     *     // ... data to create a MindMap
     *   }
     * })
     * 
     */
    create<T extends MindMapCreateArgs>(args: SelectSubset<T, MindMapCreateArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MindMaps.
     * @param {MindMapCreateManyArgs} args - Arguments to create many MindMaps.
     * @example
     * // Create many MindMaps
     * const mindMap = await prisma.mindMap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MindMapCreateManyArgs>(args?: SelectSubset<T, MindMapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MindMaps and returns the data saved in the database.
     * @param {MindMapCreateManyAndReturnArgs} args - Arguments to create many MindMaps.
     * @example
     * // Create many MindMaps
     * const mindMap = await prisma.mindMap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MindMaps and only return the `id`
     * const mindMapWithIdOnly = await prisma.mindMap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MindMapCreateManyAndReturnArgs>(args?: SelectSubset<T, MindMapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MindMap.
     * @param {MindMapDeleteArgs} args - Arguments to delete one MindMap.
     * @example
     * // Delete one MindMap
     * const MindMap = await prisma.mindMap.delete({
     *   where: {
     *     // ... filter to delete one MindMap
     *   }
     * })
     * 
     */
    delete<T extends MindMapDeleteArgs>(args: SelectSubset<T, MindMapDeleteArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MindMap.
     * @param {MindMapUpdateArgs} args - Arguments to update one MindMap.
     * @example
     * // Update one MindMap
     * const mindMap = await prisma.mindMap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MindMapUpdateArgs>(args: SelectSubset<T, MindMapUpdateArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MindMaps.
     * @param {MindMapDeleteManyArgs} args - Arguments to filter MindMaps to delete.
     * @example
     * // Delete a few MindMaps
     * const { count } = await prisma.mindMap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MindMapDeleteManyArgs>(args?: SelectSubset<T, MindMapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MindMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MindMaps
     * const mindMap = await prisma.mindMap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MindMapUpdateManyArgs>(args: SelectSubset<T, MindMapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MindMaps and returns the data updated in the database.
     * @param {MindMapUpdateManyAndReturnArgs} args - Arguments to update many MindMaps.
     * @example
     * // Update many MindMaps
     * const mindMap = await prisma.mindMap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MindMaps and only return the `id`
     * const mindMapWithIdOnly = await prisma.mindMap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MindMapUpdateManyAndReturnArgs>(args: SelectSubset<T, MindMapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MindMap.
     * @param {MindMapUpsertArgs} args - Arguments to update or create a MindMap.
     * @example
     * // Update or create a MindMap
     * const mindMap = await prisma.mindMap.upsert({
     *   create: {
     *     // ... data to create a MindMap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MindMap we want to update
     *   }
     * })
     */
    upsert<T extends MindMapUpsertArgs>(args: SelectSubset<T, MindMapUpsertArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MindMaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapCountArgs} args - Arguments to filter MindMaps to count.
     * @example
     * // Count the number of MindMaps
     * const count = await prisma.mindMap.count({
     *   where: {
     *     // ... the filter for the MindMaps we want to count
     *   }
     * })
    **/
    count<T extends MindMapCountArgs>(
      args?: Subset<T, MindMapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MindMapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MindMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MindMapAggregateArgs>(args: Subset<T, MindMapAggregateArgs>): Prisma.PrismaPromise<GetMindMapAggregateType<T>>

    /**
     * Group by MindMap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MindMapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MindMapGroupByArgs['orderBy'] }
        : { orderBy?: MindMapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MindMapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMindMapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MindMap model
   */
  readonly fields: MindMapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MindMap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MindMapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rootNode<T extends MindMap$rootNodeArgs<ExtArgs> = {}>(args?: Subset<T, MindMap$rootNodeArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nodes<T extends MindMap$nodesArgs<ExtArgs> = {}>(args?: Subset<T, MindMap$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends MindMap$UserArgs<ExtArgs> = {}>(args?: Subset<T, MindMap$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MindMap model
   */
  interface MindMapFieldRefs {
    readonly id: FieldRef<"MindMap", 'String'>
    readonly projectId: FieldRef<"MindMap", 'String'>
    readonly title: FieldRef<"MindMap", 'String'>
    readonly description: FieldRef<"MindMap", 'String'>
    readonly overview: FieldRef<"MindMap", 'String'>
    readonly nodeId: FieldRef<"MindMap", 'String'>
    readonly theme: FieldRef<"MindMap", 'Json'>
    readonly layout: FieldRef<"MindMap", 'String'>
    readonly version: FieldRef<"MindMap", 'Int'>
    readonly createdAt: FieldRef<"MindMap", 'DateTime'>
    readonly updatedAt: FieldRef<"MindMap", 'DateTime'>
    readonly deletedAt: FieldRef<"MindMap", 'DateTime'>
    readonly userId: FieldRef<"MindMap", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MindMap findUnique
   */
  export type MindMapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    /**
     * Filter, which MindMap to fetch.
     */
    where: MindMapWhereUniqueInput
  }

  /**
   * MindMap findUniqueOrThrow
   */
  export type MindMapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    /**
     * Filter, which MindMap to fetch.
     */
    where: MindMapWhereUniqueInput
  }

  /**
   * MindMap findFirst
   */
  export type MindMapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    /**
     * Filter, which MindMap to fetch.
     */
    where?: MindMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MindMaps to fetch.
     */
    orderBy?: MindMapOrderByWithRelationInput | MindMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MindMaps.
     */
    cursor?: MindMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MindMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MindMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MindMaps.
     */
    distinct?: MindMapScalarFieldEnum | MindMapScalarFieldEnum[]
  }

  /**
   * MindMap findFirstOrThrow
   */
  export type MindMapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    /**
     * Filter, which MindMap to fetch.
     */
    where?: MindMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MindMaps to fetch.
     */
    orderBy?: MindMapOrderByWithRelationInput | MindMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MindMaps.
     */
    cursor?: MindMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MindMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MindMaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MindMaps.
     */
    distinct?: MindMapScalarFieldEnum | MindMapScalarFieldEnum[]
  }

  /**
   * MindMap findMany
   */
  export type MindMapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    /**
     * Filter, which MindMaps to fetch.
     */
    where?: MindMapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MindMaps to fetch.
     */
    orderBy?: MindMapOrderByWithRelationInput | MindMapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MindMaps.
     */
    cursor?: MindMapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MindMaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MindMaps.
     */
    skip?: number
    distinct?: MindMapScalarFieldEnum | MindMapScalarFieldEnum[]
  }

  /**
   * MindMap create
   */
  export type MindMapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    /**
     * The data needed to create a MindMap.
     */
    data: XOR<MindMapCreateInput, MindMapUncheckedCreateInput>
  }

  /**
   * MindMap createMany
   */
  export type MindMapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MindMaps.
     */
    data: MindMapCreateManyInput | MindMapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MindMap createManyAndReturn
   */
  export type MindMapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * The data used to create many MindMaps.
     */
    data: MindMapCreateManyInput | MindMapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MindMap update
   */
  export type MindMapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    /**
     * The data needed to update a MindMap.
     */
    data: XOR<MindMapUpdateInput, MindMapUncheckedUpdateInput>
    /**
     * Choose, which MindMap to update.
     */
    where: MindMapWhereUniqueInput
  }

  /**
   * MindMap updateMany
   */
  export type MindMapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MindMaps.
     */
    data: XOR<MindMapUpdateManyMutationInput, MindMapUncheckedUpdateManyInput>
    /**
     * Filter which MindMaps to update
     */
    where?: MindMapWhereInput
    /**
     * Limit how many MindMaps to update.
     */
    limit?: number
  }

  /**
   * MindMap updateManyAndReturn
   */
  export type MindMapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * The data used to update MindMaps.
     */
    data: XOR<MindMapUpdateManyMutationInput, MindMapUncheckedUpdateManyInput>
    /**
     * Filter which MindMaps to update
     */
    where?: MindMapWhereInput
    /**
     * Limit how many MindMaps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MindMap upsert
   */
  export type MindMapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    /**
     * The filter to search for the MindMap to update in case it exists.
     */
    where: MindMapWhereUniqueInput
    /**
     * In case the MindMap found by the `where` argument doesn't exist, create a new MindMap with this data.
     */
    create: XOR<MindMapCreateInput, MindMapUncheckedCreateInput>
    /**
     * In case the MindMap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MindMapUpdateInput, MindMapUncheckedUpdateInput>
  }

  /**
   * MindMap delete
   */
  export type MindMapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    /**
     * Filter which MindMap to delete.
     */
    where: MindMapWhereUniqueInput
  }

  /**
   * MindMap deleteMany
   */
  export type MindMapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MindMaps to delete
     */
    where?: MindMapWhereInput
    /**
     * Limit how many MindMaps to delete.
     */
    limit?: number
  }

  /**
   * MindMap.rootNode
   */
  export type MindMap$rootNodeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    where?: MindMapNodeWhereInput
  }

  /**
   * MindMap.nodes
   */
  export type MindMap$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    where?: MindMapNodeWhereInput
    orderBy?: MindMapNodeOrderByWithRelationInput | MindMapNodeOrderByWithRelationInput[]
    cursor?: MindMapNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MindMapNodeScalarFieldEnum | MindMapNodeScalarFieldEnum[]
  }

  /**
   * MindMap.User
   */
  export type MindMap$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * MindMap without action
   */
  export type MindMapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
  }


  /**
   * Model MindMapNode
   */

  export type AggregateMindMapNode = {
    _count: MindMapNodeCountAggregateOutputType | null
    _avg: MindMapNodeAvgAggregateOutputType | null
    _sum: MindMapNodeSumAggregateOutputType | null
    _min: MindMapNodeMinAggregateOutputType | null
    _max: MindMapNodeMaxAggregateOutputType | null
  }

  export type MindMapNodeAvgAggregateOutputType = {
    position: number | null
    priority: number | null
    progress: number | null
  }

  export type MindMapNodeSumAggregateOutputType = {
    position: number | null
    priority: number | null
    progress: number | null
  }

  export type MindMapNodeMinAggregateOutputType = {
    id: string | null
    mindMapId: string | null
    content: string | null
    note: string | null
    nodeType: $Enums.NodeType | null
    parentId: string | null
    position: number | null
    expanded: boolean | null
    link: string | null
    icon: string | null
    priority: number | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MindMapNodeMaxAggregateOutputType = {
    id: string | null
    mindMapId: string | null
    content: string | null
    note: string | null
    nodeType: $Enums.NodeType | null
    parentId: string | null
    position: number | null
    expanded: boolean | null
    link: string | null
    icon: string | null
    priority: number | null
    progress: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MindMapNodeCountAggregateOutputType = {
    id: number
    mindMapId: number
    content: number
    note: number
    nodeType: number
    parentId: number
    position: number
    expanded: number
    style: number
    link: number
    icon: number
    priority: number
    progress: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MindMapNodeAvgAggregateInputType = {
    position?: true
    priority?: true
    progress?: true
  }

  export type MindMapNodeSumAggregateInputType = {
    position?: true
    priority?: true
    progress?: true
  }

  export type MindMapNodeMinAggregateInputType = {
    id?: true
    mindMapId?: true
    content?: true
    note?: true
    nodeType?: true
    parentId?: true
    position?: true
    expanded?: true
    link?: true
    icon?: true
    priority?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MindMapNodeMaxAggregateInputType = {
    id?: true
    mindMapId?: true
    content?: true
    note?: true
    nodeType?: true
    parentId?: true
    position?: true
    expanded?: true
    link?: true
    icon?: true
    priority?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MindMapNodeCountAggregateInputType = {
    id?: true
    mindMapId?: true
    content?: true
    note?: true
    nodeType?: true
    parentId?: true
    position?: true
    expanded?: true
    style?: true
    link?: true
    icon?: true
    priority?: true
    progress?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MindMapNodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MindMapNode to aggregate.
     */
    where?: MindMapNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MindMapNodes to fetch.
     */
    orderBy?: MindMapNodeOrderByWithRelationInput | MindMapNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MindMapNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MindMapNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MindMapNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MindMapNodes
    **/
    _count?: true | MindMapNodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MindMapNodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MindMapNodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MindMapNodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MindMapNodeMaxAggregateInputType
  }

  export type GetMindMapNodeAggregateType<T extends MindMapNodeAggregateArgs> = {
        [P in keyof T & keyof AggregateMindMapNode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMindMapNode[P]>
      : GetScalarType<T[P], AggregateMindMapNode[P]>
  }




  export type MindMapNodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MindMapNodeWhereInput
    orderBy?: MindMapNodeOrderByWithAggregationInput | MindMapNodeOrderByWithAggregationInput[]
    by: MindMapNodeScalarFieldEnum[] | MindMapNodeScalarFieldEnum
    having?: MindMapNodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MindMapNodeCountAggregateInputType | true
    _avg?: MindMapNodeAvgAggregateInputType
    _sum?: MindMapNodeSumAggregateInputType
    _min?: MindMapNodeMinAggregateInputType
    _max?: MindMapNodeMaxAggregateInputType
  }

  export type MindMapNodeGroupByOutputType = {
    id: string
    mindMapId: string
    content: string
    note: string | null
    nodeType: $Enums.NodeType
    parentId: string | null
    position: number
    expanded: boolean
    style: JsonValue | null
    link: string | null
    icon: string | null
    priority: number | null
    progress: number | null
    createdAt: Date
    updatedAt: Date
    _count: MindMapNodeCountAggregateOutputType | null
    _avg: MindMapNodeAvgAggregateOutputType | null
    _sum: MindMapNodeSumAggregateOutputType | null
    _min: MindMapNodeMinAggregateOutputType | null
    _max: MindMapNodeMaxAggregateOutputType | null
  }

  type GetMindMapNodeGroupByPayload<T extends MindMapNodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MindMapNodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MindMapNodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MindMapNodeGroupByOutputType[P]>
            : GetScalarType<T[P], MindMapNodeGroupByOutputType[P]>
        }
      >
    >


  export type MindMapNodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mindMapId?: boolean
    content?: boolean
    note?: boolean
    nodeType?: boolean
    parentId?: boolean
    position?: boolean
    expanded?: boolean
    style?: boolean
    link?: boolean
    icon?: boolean
    priority?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mindMap?: boolean | MindMapDefaultArgs<ExtArgs>
    rootOfMap?: boolean | MindMapNode$rootOfMapArgs<ExtArgs>
    parent?: boolean | MindMapNode$parentArgs<ExtArgs>
    children?: boolean | MindMapNode$childrenArgs<ExtArgs>
    _count?: boolean | MindMapNodeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mindMapNode"]>

  export type MindMapNodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mindMapId?: boolean
    content?: boolean
    note?: boolean
    nodeType?: boolean
    parentId?: boolean
    position?: boolean
    expanded?: boolean
    style?: boolean
    link?: boolean
    icon?: boolean
    priority?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mindMap?: boolean | MindMapDefaultArgs<ExtArgs>
    parent?: boolean | MindMapNode$parentArgs<ExtArgs>
  }, ExtArgs["result"]["mindMapNode"]>

  export type MindMapNodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mindMapId?: boolean
    content?: boolean
    note?: boolean
    nodeType?: boolean
    parentId?: boolean
    position?: boolean
    expanded?: boolean
    style?: boolean
    link?: boolean
    icon?: boolean
    priority?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    mindMap?: boolean | MindMapDefaultArgs<ExtArgs>
    parent?: boolean | MindMapNode$parentArgs<ExtArgs>
  }, ExtArgs["result"]["mindMapNode"]>

  export type MindMapNodeSelectScalar = {
    id?: boolean
    mindMapId?: boolean
    content?: boolean
    note?: boolean
    nodeType?: boolean
    parentId?: boolean
    position?: boolean
    expanded?: boolean
    style?: boolean
    link?: boolean
    icon?: boolean
    priority?: boolean
    progress?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MindMapNodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mindMapId" | "content" | "note" | "nodeType" | "parentId" | "position" | "expanded" | "style" | "link" | "icon" | "priority" | "progress" | "createdAt" | "updatedAt", ExtArgs["result"]["mindMapNode"]>
  export type MindMapNodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mindMap?: boolean | MindMapDefaultArgs<ExtArgs>
    rootOfMap?: boolean | MindMapNode$rootOfMapArgs<ExtArgs>
    parent?: boolean | MindMapNode$parentArgs<ExtArgs>
    children?: boolean | MindMapNode$childrenArgs<ExtArgs>
    _count?: boolean | MindMapNodeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MindMapNodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mindMap?: boolean | MindMapDefaultArgs<ExtArgs>
    parent?: boolean | MindMapNode$parentArgs<ExtArgs>
  }
  export type MindMapNodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mindMap?: boolean | MindMapDefaultArgs<ExtArgs>
    parent?: boolean | MindMapNode$parentArgs<ExtArgs>
  }

  export type $MindMapNodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MindMapNode"
    objects: {
      mindMap: Prisma.$MindMapPayload<ExtArgs>
      rootOfMap: Prisma.$MindMapPayload<ExtArgs> | null
      parent: Prisma.$MindMapNodePayload<ExtArgs> | null
      children: Prisma.$MindMapNodePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mindMapId: string
      content: string
      note: string | null
      nodeType: $Enums.NodeType
      parentId: string | null
      position: number
      expanded: boolean
      style: Prisma.JsonValue | null
      link: string | null
      icon: string | null
      priority: number | null
      progress: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mindMapNode"]>
    composites: {}
  }

  type MindMapNodeGetPayload<S extends boolean | null | undefined | MindMapNodeDefaultArgs> = $Result.GetResult<Prisma.$MindMapNodePayload, S>

  type MindMapNodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MindMapNodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MindMapNodeCountAggregateInputType | true
    }

  export interface MindMapNodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MindMapNode'], meta: { name: 'MindMapNode' } }
    /**
     * Find zero or one MindMapNode that matches the filter.
     * @param {MindMapNodeFindUniqueArgs} args - Arguments to find a MindMapNode
     * @example
     * // Get one MindMapNode
     * const mindMapNode = await prisma.mindMapNode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MindMapNodeFindUniqueArgs>(args: SelectSubset<T, MindMapNodeFindUniqueArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MindMapNode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MindMapNodeFindUniqueOrThrowArgs} args - Arguments to find a MindMapNode
     * @example
     * // Get one MindMapNode
     * const mindMapNode = await prisma.mindMapNode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MindMapNodeFindUniqueOrThrowArgs>(args: SelectSubset<T, MindMapNodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MindMapNode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapNodeFindFirstArgs} args - Arguments to find a MindMapNode
     * @example
     * // Get one MindMapNode
     * const mindMapNode = await prisma.mindMapNode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MindMapNodeFindFirstArgs>(args?: SelectSubset<T, MindMapNodeFindFirstArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MindMapNode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapNodeFindFirstOrThrowArgs} args - Arguments to find a MindMapNode
     * @example
     * // Get one MindMapNode
     * const mindMapNode = await prisma.mindMapNode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MindMapNodeFindFirstOrThrowArgs>(args?: SelectSubset<T, MindMapNodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MindMapNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapNodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MindMapNodes
     * const mindMapNodes = await prisma.mindMapNode.findMany()
     * 
     * // Get first 10 MindMapNodes
     * const mindMapNodes = await prisma.mindMapNode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mindMapNodeWithIdOnly = await prisma.mindMapNode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MindMapNodeFindManyArgs>(args?: SelectSubset<T, MindMapNodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MindMapNode.
     * @param {MindMapNodeCreateArgs} args - Arguments to create a MindMapNode.
     * @example
     * // Create one MindMapNode
     * const MindMapNode = await prisma.mindMapNode.create({
     *   data: {
     *     // ... data to create a MindMapNode
     *   }
     * })
     * 
     */
    create<T extends MindMapNodeCreateArgs>(args: SelectSubset<T, MindMapNodeCreateArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MindMapNodes.
     * @param {MindMapNodeCreateManyArgs} args - Arguments to create many MindMapNodes.
     * @example
     * // Create many MindMapNodes
     * const mindMapNode = await prisma.mindMapNode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MindMapNodeCreateManyArgs>(args?: SelectSubset<T, MindMapNodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MindMapNodes and returns the data saved in the database.
     * @param {MindMapNodeCreateManyAndReturnArgs} args - Arguments to create many MindMapNodes.
     * @example
     * // Create many MindMapNodes
     * const mindMapNode = await prisma.mindMapNode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MindMapNodes and only return the `id`
     * const mindMapNodeWithIdOnly = await prisma.mindMapNode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MindMapNodeCreateManyAndReturnArgs>(args?: SelectSubset<T, MindMapNodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MindMapNode.
     * @param {MindMapNodeDeleteArgs} args - Arguments to delete one MindMapNode.
     * @example
     * // Delete one MindMapNode
     * const MindMapNode = await prisma.mindMapNode.delete({
     *   where: {
     *     // ... filter to delete one MindMapNode
     *   }
     * })
     * 
     */
    delete<T extends MindMapNodeDeleteArgs>(args: SelectSubset<T, MindMapNodeDeleteArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MindMapNode.
     * @param {MindMapNodeUpdateArgs} args - Arguments to update one MindMapNode.
     * @example
     * // Update one MindMapNode
     * const mindMapNode = await prisma.mindMapNode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MindMapNodeUpdateArgs>(args: SelectSubset<T, MindMapNodeUpdateArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MindMapNodes.
     * @param {MindMapNodeDeleteManyArgs} args - Arguments to filter MindMapNodes to delete.
     * @example
     * // Delete a few MindMapNodes
     * const { count } = await prisma.mindMapNode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MindMapNodeDeleteManyArgs>(args?: SelectSubset<T, MindMapNodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MindMapNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapNodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MindMapNodes
     * const mindMapNode = await prisma.mindMapNode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MindMapNodeUpdateManyArgs>(args: SelectSubset<T, MindMapNodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MindMapNodes and returns the data updated in the database.
     * @param {MindMapNodeUpdateManyAndReturnArgs} args - Arguments to update many MindMapNodes.
     * @example
     * // Update many MindMapNodes
     * const mindMapNode = await prisma.mindMapNode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MindMapNodes and only return the `id`
     * const mindMapNodeWithIdOnly = await prisma.mindMapNode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MindMapNodeUpdateManyAndReturnArgs>(args: SelectSubset<T, MindMapNodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MindMapNode.
     * @param {MindMapNodeUpsertArgs} args - Arguments to update or create a MindMapNode.
     * @example
     * // Update or create a MindMapNode
     * const mindMapNode = await prisma.mindMapNode.upsert({
     *   create: {
     *     // ... data to create a MindMapNode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MindMapNode we want to update
     *   }
     * })
     */
    upsert<T extends MindMapNodeUpsertArgs>(args: SelectSubset<T, MindMapNodeUpsertArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MindMapNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapNodeCountArgs} args - Arguments to filter MindMapNodes to count.
     * @example
     * // Count the number of MindMapNodes
     * const count = await prisma.mindMapNode.count({
     *   where: {
     *     // ... the filter for the MindMapNodes we want to count
     *   }
     * })
    **/
    count<T extends MindMapNodeCountArgs>(
      args?: Subset<T, MindMapNodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MindMapNodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MindMapNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapNodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MindMapNodeAggregateArgs>(args: Subset<T, MindMapNodeAggregateArgs>): Prisma.PrismaPromise<GetMindMapNodeAggregateType<T>>

    /**
     * Group by MindMapNode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MindMapNodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MindMapNodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MindMapNodeGroupByArgs['orderBy'] }
        : { orderBy?: MindMapNodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MindMapNodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMindMapNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MindMapNode model
   */
  readonly fields: MindMapNodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MindMapNode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MindMapNodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mindMap<T extends MindMapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MindMapDefaultArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rootOfMap<T extends MindMapNode$rootOfMapArgs<ExtArgs> = {}>(args?: Subset<T, MindMapNode$rootOfMapArgs<ExtArgs>>): Prisma__MindMapClient<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends MindMapNode$parentArgs<ExtArgs> = {}>(args?: Subset<T, MindMapNode$parentArgs<ExtArgs>>): Prisma__MindMapNodeClient<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends MindMapNode$childrenArgs<ExtArgs> = {}>(args?: Subset<T, MindMapNode$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapNodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MindMapNode model
   */
  interface MindMapNodeFieldRefs {
    readonly id: FieldRef<"MindMapNode", 'String'>
    readonly mindMapId: FieldRef<"MindMapNode", 'String'>
    readonly content: FieldRef<"MindMapNode", 'String'>
    readonly note: FieldRef<"MindMapNode", 'String'>
    readonly nodeType: FieldRef<"MindMapNode", 'NodeType'>
    readonly parentId: FieldRef<"MindMapNode", 'String'>
    readonly position: FieldRef<"MindMapNode", 'Int'>
    readonly expanded: FieldRef<"MindMapNode", 'Boolean'>
    readonly style: FieldRef<"MindMapNode", 'Json'>
    readonly link: FieldRef<"MindMapNode", 'String'>
    readonly icon: FieldRef<"MindMapNode", 'String'>
    readonly priority: FieldRef<"MindMapNode", 'Int'>
    readonly progress: FieldRef<"MindMapNode", 'Int'>
    readonly createdAt: FieldRef<"MindMapNode", 'DateTime'>
    readonly updatedAt: FieldRef<"MindMapNode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MindMapNode findUnique
   */
  export type MindMapNodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    /**
     * Filter, which MindMapNode to fetch.
     */
    where: MindMapNodeWhereUniqueInput
  }

  /**
   * MindMapNode findUniqueOrThrow
   */
  export type MindMapNodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    /**
     * Filter, which MindMapNode to fetch.
     */
    where: MindMapNodeWhereUniqueInput
  }

  /**
   * MindMapNode findFirst
   */
  export type MindMapNodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    /**
     * Filter, which MindMapNode to fetch.
     */
    where?: MindMapNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MindMapNodes to fetch.
     */
    orderBy?: MindMapNodeOrderByWithRelationInput | MindMapNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MindMapNodes.
     */
    cursor?: MindMapNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MindMapNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MindMapNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MindMapNodes.
     */
    distinct?: MindMapNodeScalarFieldEnum | MindMapNodeScalarFieldEnum[]
  }

  /**
   * MindMapNode findFirstOrThrow
   */
  export type MindMapNodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    /**
     * Filter, which MindMapNode to fetch.
     */
    where?: MindMapNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MindMapNodes to fetch.
     */
    orderBy?: MindMapNodeOrderByWithRelationInput | MindMapNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MindMapNodes.
     */
    cursor?: MindMapNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MindMapNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MindMapNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MindMapNodes.
     */
    distinct?: MindMapNodeScalarFieldEnum | MindMapNodeScalarFieldEnum[]
  }

  /**
   * MindMapNode findMany
   */
  export type MindMapNodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    /**
     * Filter, which MindMapNodes to fetch.
     */
    where?: MindMapNodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MindMapNodes to fetch.
     */
    orderBy?: MindMapNodeOrderByWithRelationInput | MindMapNodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MindMapNodes.
     */
    cursor?: MindMapNodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MindMapNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MindMapNodes.
     */
    skip?: number
    distinct?: MindMapNodeScalarFieldEnum | MindMapNodeScalarFieldEnum[]
  }

  /**
   * MindMapNode create
   */
  export type MindMapNodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    /**
     * The data needed to create a MindMapNode.
     */
    data: XOR<MindMapNodeCreateInput, MindMapNodeUncheckedCreateInput>
  }

  /**
   * MindMapNode createMany
   */
  export type MindMapNodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MindMapNodes.
     */
    data: MindMapNodeCreateManyInput | MindMapNodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MindMapNode createManyAndReturn
   */
  export type MindMapNodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * The data used to create many MindMapNodes.
     */
    data: MindMapNodeCreateManyInput | MindMapNodeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MindMapNode update
   */
  export type MindMapNodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    /**
     * The data needed to update a MindMapNode.
     */
    data: XOR<MindMapNodeUpdateInput, MindMapNodeUncheckedUpdateInput>
    /**
     * Choose, which MindMapNode to update.
     */
    where: MindMapNodeWhereUniqueInput
  }

  /**
   * MindMapNode updateMany
   */
  export type MindMapNodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MindMapNodes.
     */
    data: XOR<MindMapNodeUpdateManyMutationInput, MindMapNodeUncheckedUpdateManyInput>
    /**
     * Filter which MindMapNodes to update
     */
    where?: MindMapNodeWhereInput
    /**
     * Limit how many MindMapNodes to update.
     */
    limit?: number
  }

  /**
   * MindMapNode updateManyAndReturn
   */
  export type MindMapNodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * The data used to update MindMapNodes.
     */
    data: XOR<MindMapNodeUpdateManyMutationInput, MindMapNodeUncheckedUpdateManyInput>
    /**
     * Filter which MindMapNodes to update
     */
    where?: MindMapNodeWhereInput
    /**
     * Limit how many MindMapNodes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MindMapNode upsert
   */
  export type MindMapNodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    /**
     * The filter to search for the MindMapNode to update in case it exists.
     */
    where: MindMapNodeWhereUniqueInput
    /**
     * In case the MindMapNode found by the `where` argument doesn't exist, create a new MindMapNode with this data.
     */
    create: XOR<MindMapNodeCreateInput, MindMapNodeUncheckedCreateInput>
    /**
     * In case the MindMapNode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MindMapNodeUpdateInput, MindMapNodeUncheckedUpdateInput>
  }

  /**
   * MindMapNode delete
   */
  export type MindMapNodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    /**
     * Filter which MindMapNode to delete.
     */
    where: MindMapNodeWhereUniqueInput
  }

  /**
   * MindMapNode deleteMany
   */
  export type MindMapNodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MindMapNodes to delete
     */
    where?: MindMapNodeWhereInput
    /**
     * Limit how many MindMapNodes to delete.
     */
    limit?: number
  }

  /**
   * MindMapNode.rootOfMap
   */
  export type MindMapNode$rootOfMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    where?: MindMapWhereInput
  }

  /**
   * MindMapNode.parent
   */
  export type MindMapNode$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    where?: MindMapNodeWhereInput
  }

  /**
   * MindMapNode.children
   */
  export type MindMapNode$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
    where?: MindMapNodeWhereInput
    orderBy?: MindMapNodeOrderByWithRelationInput | MindMapNodeOrderByWithRelationInput[]
    cursor?: MindMapNodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MindMapNodeScalarFieldEnum | MindMapNodeScalarFieldEnum[]
  }

  /**
   * MindMapNode without action
   */
  export type MindMapNodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMapNode
     */
    select?: MindMapNodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMapNode
     */
    omit?: MindMapNodeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapNodeInclude<ExtArgs> | null
  }


  /**
   * Model DomainKnowledge
   */

  export type AggregateDomainKnowledge = {
    _count: DomainKnowledgeCountAggregateOutputType | null
    _avg: DomainKnowledgeAvgAggregateOutputType | null
    _sum: DomainKnowledgeSumAggregateOutputType | null
    _min: DomainKnowledgeMinAggregateOutputType | null
    _max: DomainKnowledgeMaxAggregateOutputType | null
  }

  export type DomainKnowledgeAvgAggregateOutputType = {
    version: number | null
  }

  export type DomainKnowledgeSumAggregateOutputType = {
    version: number | null
  }

  export type DomainKnowledgeMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    domain: string | null
    description: string | null
    category: $Enums.KnowledgeCategory | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type DomainKnowledgeMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    domain: string | null
    description: string | null
    category: $Enums.KnowledgeCategory | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type DomainKnowledgeCountAggregateOutputType = {
    id: number
    projectId: number
    domain: number
    description: number
    category: number
    tags: number
    version: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    userId: number
    _all: number
  }


  export type DomainKnowledgeAvgAggregateInputType = {
    version?: true
  }

  export type DomainKnowledgeSumAggregateInputType = {
    version?: true
  }

  export type DomainKnowledgeMinAggregateInputType = {
    id?: true
    projectId?: true
    domain?: true
    description?: true
    category?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type DomainKnowledgeMaxAggregateInputType = {
    id?: true
    projectId?: true
    domain?: true
    description?: true
    category?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type DomainKnowledgeCountAggregateInputType = {
    id?: true
    projectId?: true
    domain?: true
    description?: true
    category?: true
    tags?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
    _all?: true
  }

  export type DomainKnowledgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainKnowledge to aggregate.
     */
    where?: DomainKnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainKnowledges to fetch.
     */
    orderBy?: DomainKnowledgeOrderByWithRelationInput | DomainKnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainKnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainKnowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainKnowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainKnowledges
    **/
    _count?: true | DomainKnowledgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DomainKnowledgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DomainKnowledgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainKnowledgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainKnowledgeMaxAggregateInputType
  }

  export type GetDomainKnowledgeAggregateType<T extends DomainKnowledgeAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainKnowledge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainKnowledge[P]>
      : GetScalarType<T[P], AggregateDomainKnowledge[P]>
  }




  export type DomainKnowledgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainKnowledgeWhereInput
    orderBy?: DomainKnowledgeOrderByWithAggregationInput | DomainKnowledgeOrderByWithAggregationInput[]
    by: DomainKnowledgeScalarFieldEnum[] | DomainKnowledgeScalarFieldEnum
    having?: DomainKnowledgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainKnowledgeCountAggregateInputType | true
    _avg?: DomainKnowledgeAvgAggregateInputType
    _sum?: DomainKnowledgeSumAggregateInputType
    _min?: DomainKnowledgeMinAggregateInputType
    _max?: DomainKnowledgeMaxAggregateInputType
  }

  export type DomainKnowledgeGroupByOutputType = {
    id: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags: string[]
    version: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    userId: string | null
    _count: DomainKnowledgeCountAggregateOutputType | null
    _avg: DomainKnowledgeAvgAggregateOutputType | null
    _sum: DomainKnowledgeSumAggregateOutputType | null
    _min: DomainKnowledgeMinAggregateOutputType | null
    _max: DomainKnowledgeMaxAggregateOutputType | null
  }

  type GetDomainKnowledgeGroupByPayload<T extends DomainKnowledgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainKnowledgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainKnowledgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainKnowledgeGroupByOutputType[P]>
            : GetScalarType<T[P], DomainKnowledgeGroupByOutputType[P]>
        }
      >
    >


  export type DomainKnowledgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    domain?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    concepts?: boolean | DomainKnowledge$conceptsArgs<ExtArgs>
    patterns?: boolean | DomainKnowledge$patternsArgs<ExtArgs>
    bestPractices?: boolean | DomainKnowledge$bestPracticesArgs<ExtArgs>
    antiPatterns?: boolean | DomainKnowledge$antiPatternsArgs<ExtArgs>
    references?: boolean | DomainKnowledge$referencesArgs<ExtArgs>
    User?: boolean | DomainKnowledge$UserArgs<ExtArgs>
    _count?: boolean | DomainKnowledgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainKnowledge"]>

  export type DomainKnowledgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    domain?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | DomainKnowledge$UserArgs<ExtArgs>
  }, ExtArgs["result"]["domainKnowledge"]>

  export type DomainKnowledgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    domain?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | DomainKnowledge$UserArgs<ExtArgs>
  }, ExtArgs["result"]["domainKnowledge"]>

  export type DomainKnowledgeSelectScalar = {
    id?: boolean
    projectId?: boolean
    domain?: boolean
    description?: boolean
    category?: boolean
    tags?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
  }

  export type DomainKnowledgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "domain" | "description" | "category" | "tags" | "version" | "createdAt" | "updatedAt" | "deletedAt" | "userId", ExtArgs["result"]["domainKnowledge"]>
  export type DomainKnowledgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    concepts?: boolean | DomainKnowledge$conceptsArgs<ExtArgs>
    patterns?: boolean | DomainKnowledge$patternsArgs<ExtArgs>
    bestPractices?: boolean | DomainKnowledge$bestPracticesArgs<ExtArgs>
    antiPatterns?: boolean | DomainKnowledge$antiPatternsArgs<ExtArgs>
    references?: boolean | DomainKnowledge$referencesArgs<ExtArgs>
    User?: boolean | DomainKnowledge$UserArgs<ExtArgs>
    _count?: boolean | DomainKnowledgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DomainKnowledgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | DomainKnowledge$UserArgs<ExtArgs>
  }
  export type DomainKnowledgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    User?: boolean | DomainKnowledge$UserArgs<ExtArgs>
  }

  export type $DomainKnowledgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainKnowledge"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      concepts: Prisma.$DomainConceptPayload<ExtArgs>[]
      patterns: Prisma.$DomainPatternPayload<ExtArgs>[]
      bestPractices: Prisma.$DomainBestPracticePayload<ExtArgs>[]
      antiPatterns: Prisma.$DomainAntiPatternPayload<ExtArgs>[]
      references: Prisma.$DomainReferencePayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      domain: string
      description: string
      category: $Enums.KnowledgeCategory
      tags: string[]
      version: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      userId: string | null
    }, ExtArgs["result"]["domainKnowledge"]>
    composites: {}
  }

  type DomainKnowledgeGetPayload<S extends boolean | null | undefined | DomainKnowledgeDefaultArgs> = $Result.GetResult<Prisma.$DomainKnowledgePayload, S>

  type DomainKnowledgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainKnowledgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainKnowledgeCountAggregateInputType | true
    }

  export interface DomainKnowledgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainKnowledge'], meta: { name: 'DomainKnowledge' } }
    /**
     * Find zero or one DomainKnowledge that matches the filter.
     * @param {DomainKnowledgeFindUniqueArgs} args - Arguments to find a DomainKnowledge
     * @example
     * // Get one DomainKnowledge
     * const domainKnowledge = await prisma.domainKnowledge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainKnowledgeFindUniqueArgs>(args: SelectSubset<T, DomainKnowledgeFindUniqueArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainKnowledge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainKnowledgeFindUniqueOrThrowArgs} args - Arguments to find a DomainKnowledge
     * @example
     * // Get one DomainKnowledge
     * const domainKnowledge = await prisma.domainKnowledge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainKnowledgeFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainKnowledgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainKnowledge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainKnowledgeFindFirstArgs} args - Arguments to find a DomainKnowledge
     * @example
     * // Get one DomainKnowledge
     * const domainKnowledge = await prisma.domainKnowledge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainKnowledgeFindFirstArgs>(args?: SelectSubset<T, DomainKnowledgeFindFirstArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainKnowledge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainKnowledgeFindFirstOrThrowArgs} args - Arguments to find a DomainKnowledge
     * @example
     * // Get one DomainKnowledge
     * const domainKnowledge = await prisma.domainKnowledge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainKnowledgeFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainKnowledgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainKnowledges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainKnowledgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainKnowledges
     * const domainKnowledges = await prisma.domainKnowledge.findMany()
     * 
     * // Get first 10 DomainKnowledges
     * const domainKnowledges = await prisma.domainKnowledge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainKnowledgeWithIdOnly = await prisma.domainKnowledge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainKnowledgeFindManyArgs>(args?: SelectSubset<T, DomainKnowledgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainKnowledge.
     * @param {DomainKnowledgeCreateArgs} args - Arguments to create a DomainKnowledge.
     * @example
     * // Create one DomainKnowledge
     * const DomainKnowledge = await prisma.domainKnowledge.create({
     *   data: {
     *     // ... data to create a DomainKnowledge
     *   }
     * })
     * 
     */
    create<T extends DomainKnowledgeCreateArgs>(args: SelectSubset<T, DomainKnowledgeCreateArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainKnowledges.
     * @param {DomainKnowledgeCreateManyArgs} args - Arguments to create many DomainKnowledges.
     * @example
     * // Create many DomainKnowledges
     * const domainKnowledge = await prisma.domainKnowledge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainKnowledgeCreateManyArgs>(args?: SelectSubset<T, DomainKnowledgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainKnowledges and returns the data saved in the database.
     * @param {DomainKnowledgeCreateManyAndReturnArgs} args - Arguments to create many DomainKnowledges.
     * @example
     * // Create many DomainKnowledges
     * const domainKnowledge = await prisma.domainKnowledge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainKnowledges and only return the `id`
     * const domainKnowledgeWithIdOnly = await prisma.domainKnowledge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainKnowledgeCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainKnowledgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainKnowledge.
     * @param {DomainKnowledgeDeleteArgs} args - Arguments to delete one DomainKnowledge.
     * @example
     * // Delete one DomainKnowledge
     * const DomainKnowledge = await prisma.domainKnowledge.delete({
     *   where: {
     *     // ... filter to delete one DomainKnowledge
     *   }
     * })
     * 
     */
    delete<T extends DomainKnowledgeDeleteArgs>(args: SelectSubset<T, DomainKnowledgeDeleteArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainKnowledge.
     * @param {DomainKnowledgeUpdateArgs} args - Arguments to update one DomainKnowledge.
     * @example
     * // Update one DomainKnowledge
     * const domainKnowledge = await prisma.domainKnowledge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainKnowledgeUpdateArgs>(args: SelectSubset<T, DomainKnowledgeUpdateArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainKnowledges.
     * @param {DomainKnowledgeDeleteManyArgs} args - Arguments to filter DomainKnowledges to delete.
     * @example
     * // Delete a few DomainKnowledges
     * const { count } = await prisma.domainKnowledge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainKnowledgeDeleteManyArgs>(args?: SelectSubset<T, DomainKnowledgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainKnowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainKnowledgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainKnowledges
     * const domainKnowledge = await prisma.domainKnowledge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainKnowledgeUpdateManyArgs>(args: SelectSubset<T, DomainKnowledgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainKnowledges and returns the data updated in the database.
     * @param {DomainKnowledgeUpdateManyAndReturnArgs} args - Arguments to update many DomainKnowledges.
     * @example
     * // Update many DomainKnowledges
     * const domainKnowledge = await prisma.domainKnowledge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainKnowledges and only return the `id`
     * const domainKnowledgeWithIdOnly = await prisma.domainKnowledge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainKnowledgeUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainKnowledgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainKnowledge.
     * @param {DomainKnowledgeUpsertArgs} args - Arguments to update or create a DomainKnowledge.
     * @example
     * // Update or create a DomainKnowledge
     * const domainKnowledge = await prisma.domainKnowledge.upsert({
     *   create: {
     *     // ... data to create a DomainKnowledge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainKnowledge we want to update
     *   }
     * })
     */
    upsert<T extends DomainKnowledgeUpsertArgs>(args: SelectSubset<T, DomainKnowledgeUpsertArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainKnowledges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainKnowledgeCountArgs} args - Arguments to filter DomainKnowledges to count.
     * @example
     * // Count the number of DomainKnowledges
     * const count = await prisma.domainKnowledge.count({
     *   where: {
     *     // ... the filter for the DomainKnowledges we want to count
     *   }
     * })
    **/
    count<T extends DomainKnowledgeCountArgs>(
      args?: Subset<T, DomainKnowledgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainKnowledgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainKnowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainKnowledgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainKnowledgeAggregateArgs>(args: Subset<T, DomainKnowledgeAggregateArgs>): Prisma.PrismaPromise<GetDomainKnowledgeAggregateType<T>>

    /**
     * Group by DomainKnowledge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainKnowledgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainKnowledgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainKnowledgeGroupByArgs['orderBy'] }
        : { orderBy?: DomainKnowledgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainKnowledgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainKnowledgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainKnowledge model
   */
  readonly fields: DomainKnowledgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainKnowledge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainKnowledgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    concepts<T extends DomainKnowledge$conceptsArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledge$conceptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patterns<T extends DomainKnowledge$patternsArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledge$patternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bestPractices<T extends DomainKnowledge$bestPracticesArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledge$bestPracticesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    antiPatterns<T extends DomainKnowledge$antiPatternsArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledge$antiPatternsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    references<T extends DomainKnowledge$referencesArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledge$referencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends DomainKnowledge$UserArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledge$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainKnowledge model
   */
  interface DomainKnowledgeFieldRefs {
    readonly id: FieldRef<"DomainKnowledge", 'String'>
    readonly projectId: FieldRef<"DomainKnowledge", 'String'>
    readonly domain: FieldRef<"DomainKnowledge", 'String'>
    readonly description: FieldRef<"DomainKnowledge", 'String'>
    readonly category: FieldRef<"DomainKnowledge", 'KnowledgeCategory'>
    readonly tags: FieldRef<"DomainKnowledge", 'String[]'>
    readonly version: FieldRef<"DomainKnowledge", 'Int'>
    readonly createdAt: FieldRef<"DomainKnowledge", 'DateTime'>
    readonly updatedAt: FieldRef<"DomainKnowledge", 'DateTime'>
    readonly deletedAt: FieldRef<"DomainKnowledge", 'DateTime'>
    readonly userId: FieldRef<"DomainKnowledge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DomainKnowledge findUnique
   */
  export type DomainKnowledgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which DomainKnowledge to fetch.
     */
    where: DomainKnowledgeWhereUniqueInput
  }

  /**
   * DomainKnowledge findUniqueOrThrow
   */
  export type DomainKnowledgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which DomainKnowledge to fetch.
     */
    where: DomainKnowledgeWhereUniqueInput
  }

  /**
   * DomainKnowledge findFirst
   */
  export type DomainKnowledgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which DomainKnowledge to fetch.
     */
    where?: DomainKnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainKnowledges to fetch.
     */
    orderBy?: DomainKnowledgeOrderByWithRelationInput | DomainKnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainKnowledges.
     */
    cursor?: DomainKnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainKnowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainKnowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainKnowledges.
     */
    distinct?: DomainKnowledgeScalarFieldEnum | DomainKnowledgeScalarFieldEnum[]
  }

  /**
   * DomainKnowledge findFirstOrThrow
   */
  export type DomainKnowledgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which DomainKnowledge to fetch.
     */
    where?: DomainKnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainKnowledges to fetch.
     */
    orderBy?: DomainKnowledgeOrderByWithRelationInput | DomainKnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainKnowledges.
     */
    cursor?: DomainKnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainKnowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainKnowledges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainKnowledges.
     */
    distinct?: DomainKnowledgeScalarFieldEnum | DomainKnowledgeScalarFieldEnum[]
  }

  /**
   * DomainKnowledge findMany
   */
  export type DomainKnowledgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    /**
     * Filter, which DomainKnowledges to fetch.
     */
    where?: DomainKnowledgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainKnowledges to fetch.
     */
    orderBy?: DomainKnowledgeOrderByWithRelationInput | DomainKnowledgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainKnowledges.
     */
    cursor?: DomainKnowledgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainKnowledges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainKnowledges.
     */
    skip?: number
    distinct?: DomainKnowledgeScalarFieldEnum | DomainKnowledgeScalarFieldEnum[]
  }

  /**
   * DomainKnowledge create
   */
  export type DomainKnowledgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainKnowledge.
     */
    data: XOR<DomainKnowledgeCreateInput, DomainKnowledgeUncheckedCreateInput>
  }

  /**
   * DomainKnowledge createMany
   */
  export type DomainKnowledgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainKnowledges.
     */
    data: DomainKnowledgeCreateManyInput | DomainKnowledgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainKnowledge createManyAndReturn
   */
  export type DomainKnowledgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * The data used to create many DomainKnowledges.
     */
    data: DomainKnowledgeCreateManyInput | DomainKnowledgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainKnowledge update
   */
  export type DomainKnowledgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainKnowledge.
     */
    data: XOR<DomainKnowledgeUpdateInput, DomainKnowledgeUncheckedUpdateInput>
    /**
     * Choose, which DomainKnowledge to update.
     */
    where: DomainKnowledgeWhereUniqueInput
  }

  /**
   * DomainKnowledge updateMany
   */
  export type DomainKnowledgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainKnowledges.
     */
    data: XOR<DomainKnowledgeUpdateManyMutationInput, DomainKnowledgeUncheckedUpdateManyInput>
    /**
     * Filter which DomainKnowledges to update
     */
    where?: DomainKnowledgeWhereInput
    /**
     * Limit how many DomainKnowledges to update.
     */
    limit?: number
  }

  /**
   * DomainKnowledge updateManyAndReturn
   */
  export type DomainKnowledgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * The data used to update DomainKnowledges.
     */
    data: XOR<DomainKnowledgeUpdateManyMutationInput, DomainKnowledgeUncheckedUpdateManyInput>
    /**
     * Filter which DomainKnowledges to update
     */
    where?: DomainKnowledgeWhereInput
    /**
     * Limit how many DomainKnowledges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainKnowledge upsert
   */
  export type DomainKnowledgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainKnowledge to update in case it exists.
     */
    where: DomainKnowledgeWhereUniqueInput
    /**
     * In case the DomainKnowledge found by the `where` argument doesn't exist, create a new DomainKnowledge with this data.
     */
    create: XOR<DomainKnowledgeCreateInput, DomainKnowledgeUncheckedCreateInput>
    /**
     * In case the DomainKnowledge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainKnowledgeUpdateInput, DomainKnowledgeUncheckedUpdateInput>
  }

  /**
   * DomainKnowledge delete
   */
  export type DomainKnowledgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    /**
     * Filter which DomainKnowledge to delete.
     */
    where: DomainKnowledgeWhereUniqueInput
  }

  /**
   * DomainKnowledge deleteMany
   */
  export type DomainKnowledgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainKnowledges to delete
     */
    where?: DomainKnowledgeWhereInput
    /**
     * Limit how many DomainKnowledges to delete.
     */
    limit?: number
  }

  /**
   * DomainKnowledge.concepts
   */
  export type DomainKnowledge$conceptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    where?: DomainConceptWhereInput
    orderBy?: DomainConceptOrderByWithRelationInput | DomainConceptOrderByWithRelationInput[]
    cursor?: DomainConceptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainConceptScalarFieldEnum | DomainConceptScalarFieldEnum[]
  }

  /**
   * DomainKnowledge.patterns
   */
  export type DomainKnowledge$patternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    where?: DomainPatternWhereInput
    orderBy?: DomainPatternOrderByWithRelationInput | DomainPatternOrderByWithRelationInput[]
    cursor?: DomainPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainPatternScalarFieldEnum | DomainPatternScalarFieldEnum[]
  }

  /**
   * DomainKnowledge.bestPractices
   */
  export type DomainKnowledge$bestPracticesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    where?: DomainBestPracticeWhereInput
    orderBy?: DomainBestPracticeOrderByWithRelationInput | DomainBestPracticeOrderByWithRelationInput[]
    cursor?: DomainBestPracticeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainBestPracticeScalarFieldEnum | DomainBestPracticeScalarFieldEnum[]
  }

  /**
   * DomainKnowledge.antiPatterns
   */
  export type DomainKnowledge$antiPatternsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    where?: DomainAntiPatternWhereInput
    orderBy?: DomainAntiPatternOrderByWithRelationInput | DomainAntiPatternOrderByWithRelationInput[]
    cursor?: DomainAntiPatternWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainAntiPatternScalarFieldEnum | DomainAntiPatternScalarFieldEnum[]
  }

  /**
   * DomainKnowledge.references
   */
  export type DomainKnowledge$referencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    where?: DomainReferenceWhereInput
    orderBy?: DomainReferenceOrderByWithRelationInput | DomainReferenceOrderByWithRelationInput[]
    cursor?: DomainReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainReferenceScalarFieldEnum | DomainReferenceScalarFieldEnum[]
  }

  /**
   * DomainKnowledge.User
   */
  export type DomainKnowledge$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * DomainKnowledge without action
   */
  export type DomainKnowledgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
  }


  /**
   * Model DomainConcept
   */

  export type AggregateDomainConcept = {
    _count: DomainConceptCountAggregateOutputType | null
    _min: DomainConceptMinAggregateOutputType | null
    _max: DomainConceptMaxAggregateOutputType | null
  }

  export type DomainConceptMinAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    name: string | null
    definition: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainConceptMaxAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    name: string | null
    definition: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainConceptCountAggregateOutputType = {
    id: number
    domainKnowledgeId: number
    name: number
    definition: number
    examples: number
    relatedConcepts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DomainConceptMinAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    name?: true
    definition?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainConceptMaxAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    name?: true
    definition?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainConceptCountAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    name?: true
    definition?: true
    examples?: true
    relatedConcepts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DomainConceptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainConcept to aggregate.
     */
    where?: DomainConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainConcepts to fetch.
     */
    orderBy?: DomainConceptOrderByWithRelationInput | DomainConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainConcepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainConcepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainConcepts
    **/
    _count?: true | DomainConceptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainConceptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainConceptMaxAggregateInputType
  }

  export type GetDomainConceptAggregateType<T extends DomainConceptAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainConcept]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainConcept[P]>
      : GetScalarType<T[P], AggregateDomainConcept[P]>
  }




  export type DomainConceptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainConceptWhereInput
    orderBy?: DomainConceptOrderByWithAggregationInput | DomainConceptOrderByWithAggregationInput[]
    by: DomainConceptScalarFieldEnum[] | DomainConceptScalarFieldEnum
    having?: DomainConceptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainConceptCountAggregateInputType | true
    _min?: DomainConceptMinAggregateInputType
    _max?: DomainConceptMaxAggregateInputType
  }

  export type DomainConceptGroupByOutputType = {
    id: string
    domainKnowledgeId: string
    name: string
    definition: string
    examples: string[]
    relatedConcepts: string[]
    createdAt: Date
    updatedAt: Date
    _count: DomainConceptCountAggregateOutputType | null
    _min: DomainConceptMinAggregateOutputType | null
    _max: DomainConceptMaxAggregateOutputType | null
  }

  type GetDomainConceptGroupByPayload<T extends DomainConceptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainConceptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainConceptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainConceptGroupByOutputType[P]>
            : GetScalarType<T[P], DomainConceptGroupByOutputType[P]>
        }
      >
    >


  export type DomainConceptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    definition?: boolean
    examples?: boolean
    relatedConcepts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainConcept"]>

  export type DomainConceptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    definition?: boolean
    examples?: boolean
    relatedConcepts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainConcept"]>

  export type DomainConceptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    definition?: boolean
    examples?: boolean
    relatedConcepts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainConcept"]>

  export type DomainConceptSelectScalar = {
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    definition?: boolean
    examples?: boolean
    relatedConcepts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DomainConceptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainKnowledgeId" | "name" | "definition" | "examples" | "relatedConcepts" | "createdAt" | "updatedAt", ExtArgs["result"]["domainConcept"]>
  export type DomainConceptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainConceptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainConceptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }

  export type $DomainConceptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainConcept"
    objects: {
      domainKnowledge: Prisma.$DomainKnowledgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domainKnowledgeId: string
      name: string
      definition: string
      examples: string[]
      relatedConcepts: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["domainConcept"]>
    composites: {}
  }

  type DomainConceptGetPayload<S extends boolean | null | undefined | DomainConceptDefaultArgs> = $Result.GetResult<Prisma.$DomainConceptPayload, S>

  type DomainConceptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainConceptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainConceptCountAggregateInputType | true
    }

  export interface DomainConceptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainConcept'], meta: { name: 'DomainConcept' } }
    /**
     * Find zero or one DomainConcept that matches the filter.
     * @param {DomainConceptFindUniqueArgs} args - Arguments to find a DomainConcept
     * @example
     * // Get one DomainConcept
     * const domainConcept = await prisma.domainConcept.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainConceptFindUniqueArgs>(args: SelectSubset<T, DomainConceptFindUniqueArgs<ExtArgs>>): Prisma__DomainConceptClient<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainConcept that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainConceptFindUniqueOrThrowArgs} args - Arguments to find a DomainConcept
     * @example
     * // Get one DomainConcept
     * const domainConcept = await prisma.domainConcept.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainConceptFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainConceptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainConceptClient<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainConcept that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainConceptFindFirstArgs} args - Arguments to find a DomainConcept
     * @example
     * // Get one DomainConcept
     * const domainConcept = await prisma.domainConcept.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainConceptFindFirstArgs>(args?: SelectSubset<T, DomainConceptFindFirstArgs<ExtArgs>>): Prisma__DomainConceptClient<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainConcept that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainConceptFindFirstOrThrowArgs} args - Arguments to find a DomainConcept
     * @example
     * // Get one DomainConcept
     * const domainConcept = await prisma.domainConcept.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainConceptFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainConceptFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainConceptClient<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainConcepts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainConceptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainConcepts
     * const domainConcepts = await prisma.domainConcept.findMany()
     * 
     * // Get first 10 DomainConcepts
     * const domainConcepts = await prisma.domainConcept.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainConceptWithIdOnly = await prisma.domainConcept.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainConceptFindManyArgs>(args?: SelectSubset<T, DomainConceptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainConcept.
     * @param {DomainConceptCreateArgs} args - Arguments to create a DomainConcept.
     * @example
     * // Create one DomainConcept
     * const DomainConcept = await prisma.domainConcept.create({
     *   data: {
     *     // ... data to create a DomainConcept
     *   }
     * })
     * 
     */
    create<T extends DomainConceptCreateArgs>(args: SelectSubset<T, DomainConceptCreateArgs<ExtArgs>>): Prisma__DomainConceptClient<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainConcepts.
     * @param {DomainConceptCreateManyArgs} args - Arguments to create many DomainConcepts.
     * @example
     * // Create many DomainConcepts
     * const domainConcept = await prisma.domainConcept.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainConceptCreateManyArgs>(args?: SelectSubset<T, DomainConceptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainConcepts and returns the data saved in the database.
     * @param {DomainConceptCreateManyAndReturnArgs} args - Arguments to create many DomainConcepts.
     * @example
     * // Create many DomainConcepts
     * const domainConcept = await prisma.domainConcept.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainConcepts and only return the `id`
     * const domainConceptWithIdOnly = await prisma.domainConcept.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainConceptCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainConceptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainConcept.
     * @param {DomainConceptDeleteArgs} args - Arguments to delete one DomainConcept.
     * @example
     * // Delete one DomainConcept
     * const DomainConcept = await prisma.domainConcept.delete({
     *   where: {
     *     // ... filter to delete one DomainConcept
     *   }
     * })
     * 
     */
    delete<T extends DomainConceptDeleteArgs>(args: SelectSubset<T, DomainConceptDeleteArgs<ExtArgs>>): Prisma__DomainConceptClient<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainConcept.
     * @param {DomainConceptUpdateArgs} args - Arguments to update one DomainConcept.
     * @example
     * // Update one DomainConcept
     * const domainConcept = await prisma.domainConcept.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainConceptUpdateArgs>(args: SelectSubset<T, DomainConceptUpdateArgs<ExtArgs>>): Prisma__DomainConceptClient<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainConcepts.
     * @param {DomainConceptDeleteManyArgs} args - Arguments to filter DomainConcepts to delete.
     * @example
     * // Delete a few DomainConcepts
     * const { count } = await prisma.domainConcept.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainConceptDeleteManyArgs>(args?: SelectSubset<T, DomainConceptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainConcepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainConceptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainConcepts
     * const domainConcept = await prisma.domainConcept.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainConceptUpdateManyArgs>(args: SelectSubset<T, DomainConceptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainConcepts and returns the data updated in the database.
     * @param {DomainConceptUpdateManyAndReturnArgs} args - Arguments to update many DomainConcepts.
     * @example
     * // Update many DomainConcepts
     * const domainConcept = await prisma.domainConcept.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainConcepts and only return the `id`
     * const domainConceptWithIdOnly = await prisma.domainConcept.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainConceptUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainConceptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainConcept.
     * @param {DomainConceptUpsertArgs} args - Arguments to update or create a DomainConcept.
     * @example
     * // Update or create a DomainConcept
     * const domainConcept = await prisma.domainConcept.upsert({
     *   create: {
     *     // ... data to create a DomainConcept
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainConcept we want to update
     *   }
     * })
     */
    upsert<T extends DomainConceptUpsertArgs>(args: SelectSubset<T, DomainConceptUpsertArgs<ExtArgs>>): Prisma__DomainConceptClient<$Result.GetResult<Prisma.$DomainConceptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainConcepts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainConceptCountArgs} args - Arguments to filter DomainConcepts to count.
     * @example
     * // Count the number of DomainConcepts
     * const count = await prisma.domainConcept.count({
     *   where: {
     *     // ... the filter for the DomainConcepts we want to count
     *   }
     * })
    **/
    count<T extends DomainConceptCountArgs>(
      args?: Subset<T, DomainConceptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainConceptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainConcept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainConceptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainConceptAggregateArgs>(args: Subset<T, DomainConceptAggregateArgs>): Prisma.PrismaPromise<GetDomainConceptAggregateType<T>>

    /**
     * Group by DomainConcept.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainConceptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainConceptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainConceptGroupByArgs['orderBy'] }
        : { orderBy?: DomainConceptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainConceptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainConceptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainConcept model
   */
  readonly fields: DomainConceptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainConcept.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainConceptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domainKnowledge<T extends DomainKnowledgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledgeDefaultArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainConcept model
   */
  interface DomainConceptFieldRefs {
    readonly id: FieldRef<"DomainConcept", 'String'>
    readonly domainKnowledgeId: FieldRef<"DomainConcept", 'String'>
    readonly name: FieldRef<"DomainConcept", 'String'>
    readonly definition: FieldRef<"DomainConcept", 'String'>
    readonly examples: FieldRef<"DomainConcept", 'String[]'>
    readonly relatedConcepts: FieldRef<"DomainConcept", 'String[]'>
    readonly createdAt: FieldRef<"DomainConcept", 'DateTime'>
    readonly updatedAt: FieldRef<"DomainConcept", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DomainConcept findUnique
   */
  export type DomainConceptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    /**
     * Filter, which DomainConcept to fetch.
     */
    where: DomainConceptWhereUniqueInput
  }

  /**
   * DomainConcept findUniqueOrThrow
   */
  export type DomainConceptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    /**
     * Filter, which DomainConcept to fetch.
     */
    where: DomainConceptWhereUniqueInput
  }

  /**
   * DomainConcept findFirst
   */
  export type DomainConceptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    /**
     * Filter, which DomainConcept to fetch.
     */
    where?: DomainConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainConcepts to fetch.
     */
    orderBy?: DomainConceptOrderByWithRelationInput | DomainConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainConcepts.
     */
    cursor?: DomainConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainConcepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainConcepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainConcepts.
     */
    distinct?: DomainConceptScalarFieldEnum | DomainConceptScalarFieldEnum[]
  }

  /**
   * DomainConcept findFirstOrThrow
   */
  export type DomainConceptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    /**
     * Filter, which DomainConcept to fetch.
     */
    where?: DomainConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainConcepts to fetch.
     */
    orderBy?: DomainConceptOrderByWithRelationInput | DomainConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainConcepts.
     */
    cursor?: DomainConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainConcepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainConcepts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainConcepts.
     */
    distinct?: DomainConceptScalarFieldEnum | DomainConceptScalarFieldEnum[]
  }

  /**
   * DomainConcept findMany
   */
  export type DomainConceptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    /**
     * Filter, which DomainConcepts to fetch.
     */
    where?: DomainConceptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainConcepts to fetch.
     */
    orderBy?: DomainConceptOrderByWithRelationInput | DomainConceptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainConcepts.
     */
    cursor?: DomainConceptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainConcepts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainConcepts.
     */
    skip?: number
    distinct?: DomainConceptScalarFieldEnum | DomainConceptScalarFieldEnum[]
  }

  /**
   * DomainConcept create
   */
  export type DomainConceptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainConcept.
     */
    data: XOR<DomainConceptCreateInput, DomainConceptUncheckedCreateInput>
  }

  /**
   * DomainConcept createMany
   */
  export type DomainConceptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainConcepts.
     */
    data: DomainConceptCreateManyInput | DomainConceptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainConcept createManyAndReturn
   */
  export type DomainConceptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * The data used to create many DomainConcepts.
     */
    data: DomainConceptCreateManyInput | DomainConceptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainConcept update
   */
  export type DomainConceptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainConcept.
     */
    data: XOR<DomainConceptUpdateInput, DomainConceptUncheckedUpdateInput>
    /**
     * Choose, which DomainConcept to update.
     */
    where: DomainConceptWhereUniqueInput
  }

  /**
   * DomainConcept updateMany
   */
  export type DomainConceptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainConcepts.
     */
    data: XOR<DomainConceptUpdateManyMutationInput, DomainConceptUncheckedUpdateManyInput>
    /**
     * Filter which DomainConcepts to update
     */
    where?: DomainConceptWhereInput
    /**
     * Limit how many DomainConcepts to update.
     */
    limit?: number
  }

  /**
   * DomainConcept updateManyAndReturn
   */
  export type DomainConceptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * The data used to update DomainConcepts.
     */
    data: XOR<DomainConceptUpdateManyMutationInput, DomainConceptUncheckedUpdateManyInput>
    /**
     * Filter which DomainConcepts to update
     */
    where?: DomainConceptWhereInput
    /**
     * Limit how many DomainConcepts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainConcept upsert
   */
  export type DomainConceptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainConcept to update in case it exists.
     */
    where: DomainConceptWhereUniqueInput
    /**
     * In case the DomainConcept found by the `where` argument doesn't exist, create a new DomainConcept with this data.
     */
    create: XOR<DomainConceptCreateInput, DomainConceptUncheckedCreateInput>
    /**
     * In case the DomainConcept was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainConceptUpdateInput, DomainConceptUncheckedUpdateInput>
  }

  /**
   * DomainConcept delete
   */
  export type DomainConceptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
    /**
     * Filter which DomainConcept to delete.
     */
    where: DomainConceptWhereUniqueInput
  }

  /**
   * DomainConcept deleteMany
   */
  export type DomainConceptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainConcepts to delete
     */
    where?: DomainConceptWhereInput
    /**
     * Limit how many DomainConcepts to delete.
     */
    limit?: number
  }

  /**
   * DomainConcept without action
   */
  export type DomainConceptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainConcept
     */
    select?: DomainConceptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainConcept
     */
    omit?: DomainConceptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainConceptInclude<ExtArgs> | null
  }


  /**
   * Model DomainPattern
   */

  export type AggregateDomainPattern = {
    _count: DomainPatternCountAggregateOutputType | null
    _min: DomainPatternMinAggregateOutputType | null
    _max: DomainPatternMaxAggregateOutputType | null
  }

  export type DomainPatternMinAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    name: string | null
    description: string | null
    context: string | null
    solution: string | null
    consequences: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainPatternMaxAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    name: string | null
    description: string | null
    context: string | null
    solution: string | null
    consequences: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainPatternCountAggregateOutputType = {
    id: number
    domainKnowledgeId: number
    name: number
    description: number
    context: number
    solution: number
    consequences: number
    examples: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DomainPatternMinAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    name?: true
    description?: true
    context?: true
    solution?: true
    consequences?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainPatternMaxAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    name?: true
    description?: true
    context?: true
    solution?: true
    consequences?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainPatternCountAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    name?: true
    description?: true
    context?: true
    solution?: true
    consequences?: true
    examples?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DomainPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainPattern to aggregate.
     */
    where?: DomainPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainPatterns to fetch.
     */
    orderBy?: DomainPatternOrderByWithRelationInput | DomainPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainPatterns
    **/
    _count?: true | DomainPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainPatternMaxAggregateInputType
  }

  export type GetDomainPatternAggregateType<T extends DomainPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainPattern[P]>
      : GetScalarType<T[P], AggregateDomainPattern[P]>
  }




  export type DomainPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainPatternWhereInput
    orderBy?: DomainPatternOrderByWithAggregationInput | DomainPatternOrderByWithAggregationInput[]
    by: DomainPatternScalarFieldEnum[] | DomainPatternScalarFieldEnum
    having?: DomainPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainPatternCountAggregateInputType | true
    _min?: DomainPatternMinAggregateInputType
    _max?: DomainPatternMaxAggregateInputType
  }

  export type DomainPatternGroupByOutputType = {
    id: string
    domainKnowledgeId: string
    name: string
    description: string
    context: string
    solution: string
    consequences: string
    examples: string[]
    createdAt: Date
    updatedAt: Date
    _count: DomainPatternCountAggregateOutputType | null
    _min: DomainPatternMinAggregateOutputType | null
    _max: DomainPatternMaxAggregateOutputType | null
  }

  type GetDomainPatternGroupByPayload<T extends DomainPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainPatternGroupByOutputType[P]>
            : GetScalarType<T[P], DomainPatternGroupByOutputType[P]>
        }
      >
    >


  export type DomainPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    description?: boolean
    context?: boolean
    solution?: boolean
    consequences?: boolean
    examples?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainPattern"]>

  export type DomainPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    description?: boolean
    context?: boolean
    solution?: boolean
    consequences?: boolean
    examples?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainPattern"]>

  export type DomainPatternSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    description?: boolean
    context?: boolean
    solution?: boolean
    consequences?: boolean
    examples?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainPattern"]>

  export type DomainPatternSelectScalar = {
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    description?: boolean
    context?: boolean
    solution?: boolean
    consequences?: boolean
    examples?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DomainPatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainKnowledgeId" | "name" | "description" | "context" | "solution" | "consequences" | "examples" | "createdAt" | "updatedAt", ExtArgs["result"]["domainPattern"]>
  export type DomainPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainPatternIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }

  export type $DomainPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainPattern"
    objects: {
      domainKnowledge: Prisma.$DomainKnowledgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domainKnowledgeId: string
      name: string
      description: string
      context: string
      solution: string
      consequences: string
      examples: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["domainPattern"]>
    composites: {}
  }

  type DomainPatternGetPayload<S extends boolean | null | undefined | DomainPatternDefaultArgs> = $Result.GetResult<Prisma.$DomainPatternPayload, S>

  type DomainPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainPatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainPatternCountAggregateInputType | true
    }

  export interface DomainPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainPattern'], meta: { name: 'DomainPattern' } }
    /**
     * Find zero or one DomainPattern that matches the filter.
     * @param {DomainPatternFindUniqueArgs} args - Arguments to find a DomainPattern
     * @example
     * // Get one DomainPattern
     * const domainPattern = await prisma.domainPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainPatternFindUniqueArgs>(args: SelectSubset<T, DomainPatternFindUniqueArgs<ExtArgs>>): Prisma__DomainPatternClient<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainPattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainPatternFindUniqueOrThrowArgs} args - Arguments to find a DomainPattern
     * @example
     * // Get one DomainPattern
     * const domainPattern = await prisma.domainPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainPatternClient<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainPatternFindFirstArgs} args - Arguments to find a DomainPattern
     * @example
     * // Get one DomainPattern
     * const domainPattern = await prisma.domainPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainPatternFindFirstArgs>(args?: SelectSubset<T, DomainPatternFindFirstArgs<ExtArgs>>): Prisma__DomainPatternClient<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainPatternFindFirstOrThrowArgs} args - Arguments to find a DomainPattern
     * @example
     * // Get one DomainPattern
     * const domainPattern = await prisma.domainPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainPatternClient<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainPatterns
     * const domainPatterns = await prisma.domainPattern.findMany()
     * 
     * // Get first 10 DomainPatterns
     * const domainPatterns = await prisma.domainPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainPatternWithIdOnly = await prisma.domainPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainPatternFindManyArgs>(args?: SelectSubset<T, DomainPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainPattern.
     * @param {DomainPatternCreateArgs} args - Arguments to create a DomainPattern.
     * @example
     * // Create one DomainPattern
     * const DomainPattern = await prisma.domainPattern.create({
     *   data: {
     *     // ... data to create a DomainPattern
     *   }
     * })
     * 
     */
    create<T extends DomainPatternCreateArgs>(args: SelectSubset<T, DomainPatternCreateArgs<ExtArgs>>): Prisma__DomainPatternClient<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainPatterns.
     * @param {DomainPatternCreateManyArgs} args - Arguments to create many DomainPatterns.
     * @example
     * // Create many DomainPatterns
     * const domainPattern = await prisma.domainPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainPatternCreateManyArgs>(args?: SelectSubset<T, DomainPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainPatterns and returns the data saved in the database.
     * @param {DomainPatternCreateManyAndReturnArgs} args - Arguments to create many DomainPatterns.
     * @example
     * // Create many DomainPatterns
     * const domainPattern = await prisma.domainPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainPatterns and only return the `id`
     * const domainPatternWithIdOnly = await prisma.domainPattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainPattern.
     * @param {DomainPatternDeleteArgs} args - Arguments to delete one DomainPattern.
     * @example
     * // Delete one DomainPattern
     * const DomainPattern = await prisma.domainPattern.delete({
     *   where: {
     *     // ... filter to delete one DomainPattern
     *   }
     * })
     * 
     */
    delete<T extends DomainPatternDeleteArgs>(args: SelectSubset<T, DomainPatternDeleteArgs<ExtArgs>>): Prisma__DomainPatternClient<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainPattern.
     * @param {DomainPatternUpdateArgs} args - Arguments to update one DomainPattern.
     * @example
     * // Update one DomainPattern
     * const domainPattern = await prisma.domainPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainPatternUpdateArgs>(args: SelectSubset<T, DomainPatternUpdateArgs<ExtArgs>>): Prisma__DomainPatternClient<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainPatterns.
     * @param {DomainPatternDeleteManyArgs} args - Arguments to filter DomainPatterns to delete.
     * @example
     * // Delete a few DomainPatterns
     * const { count } = await prisma.domainPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainPatternDeleteManyArgs>(args?: SelectSubset<T, DomainPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainPatterns
     * const domainPattern = await prisma.domainPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainPatternUpdateManyArgs>(args: SelectSubset<T, DomainPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainPatterns and returns the data updated in the database.
     * @param {DomainPatternUpdateManyAndReturnArgs} args - Arguments to update many DomainPatterns.
     * @example
     * // Update many DomainPatterns
     * const domainPattern = await prisma.domainPattern.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainPatterns and only return the `id`
     * const domainPatternWithIdOnly = await prisma.domainPattern.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainPatternUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainPatternUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainPattern.
     * @param {DomainPatternUpsertArgs} args - Arguments to update or create a DomainPattern.
     * @example
     * // Update or create a DomainPattern
     * const domainPattern = await prisma.domainPattern.upsert({
     *   create: {
     *     // ... data to create a DomainPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainPattern we want to update
     *   }
     * })
     */
    upsert<T extends DomainPatternUpsertArgs>(args: SelectSubset<T, DomainPatternUpsertArgs<ExtArgs>>): Prisma__DomainPatternClient<$Result.GetResult<Prisma.$DomainPatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainPatternCountArgs} args - Arguments to filter DomainPatterns to count.
     * @example
     * // Count the number of DomainPatterns
     * const count = await prisma.domainPattern.count({
     *   where: {
     *     // ... the filter for the DomainPatterns we want to count
     *   }
     * })
    **/
    count<T extends DomainPatternCountArgs>(
      args?: Subset<T, DomainPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainPatternAggregateArgs>(args: Subset<T, DomainPatternAggregateArgs>): Prisma.PrismaPromise<GetDomainPatternAggregateType<T>>

    /**
     * Group by DomainPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainPatternGroupByArgs['orderBy'] }
        : { orderBy?: DomainPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainPattern model
   */
  readonly fields: DomainPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domainKnowledge<T extends DomainKnowledgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledgeDefaultArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainPattern model
   */
  interface DomainPatternFieldRefs {
    readonly id: FieldRef<"DomainPattern", 'String'>
    readonly domainKnowledgeId: FieldRef<"DomainPattern", 'String'>
    readonly name: FieldRef<"DomainPattern", 'String'>
    readonly description: FieldRef<"DomainPattern", 'String'>
    readonly context: FieldRef<"DomainPattern", 'String'>
    readonly solution: FieldRef<"DomainPattern", 'String'>
    readonly consequences: FieldRef<"DomainPattern", 'String'>
    readonly examples: FieldRef<"DomainPattern", 'String[]'>
    readonly createdAt: FieldRef<"DomainPattern", 'DateTime'>
    readonly updatedAt: FieldRef<"DomainPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DomainPattern findUnique
   */
  export type DomainPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainPattern to fetch.
     */
    where: DomainPatternWhereUniqueInput
  }

  /**
   * DomainPattern findUniqueOrThrow
   */
  export type DomainPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainPattern to fetch.
     */
    where: DomainPatternWhereUniqueInput
  }

  /**
   * DomainPattern findFirst
   */
  export type DomainPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainPattern to fetch.
     */
    where?: DomainPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainPatterns to fetch.
     */
    orderBy?: DomainPatternOrderByWithRelationInput | DomainPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainPatterns.
     */
    cursor?: DomainPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainPatterns.
     */
    distinct?: DomainPatternScalarFieldEnum | DomainPatternScalarFieldEnum[]
  }

  /**
   * DomainPattern findFirstOrThrow
   */
  export type DomainPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainPattern to fetch.
     */
    where?: DomainPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainPatterns to fetch.
     */
    orderBy?: DomainPatternOrderByWithRelationInput | DomainPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainPatterns.
     */
    cursor?: DomainPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainPatterns.
     */
    distinct?: DomainPatternScalarFieldEnum | DomainPatternScalarFieldEnum[]
  }

  /**
   * DomainPattern findMany
   */
  export type DomainPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainPatterns to fetch.
     */
    where?: DomainPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainPatterns to fetch.
     */
    orderBy?: DomainPatternOrderByWithRelationInput | DomainPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainPatterns.
     */
    cursor?: DomainPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainPatterns.
     */
    skip?: number
    distinct?: DomainPatternScalarFieldEnum | DomainPatternScalarFieldEnum[]
  }

  /**
   * DomainPattern create
   */
  export type DomainPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainPattern.
     */
    data: XOR<DomainPatternCreateInput, DomainPatternUncheckedCreateInput>
  }

  /**
   * DomainPattern createMany
   */
  export type DomainPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainPatterns.
     */
    data: DomainPatternCreateManyInput | DomainPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainPattern createManyAndReturn
   */
  export type DomainPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * The data used to create many DomainPatterns.
     */
    data: DomainPatternCreateManyInput | DomainPatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainPattern update
   */
  export type DomainPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainPattern.
     */
    data: XOR<DomainPatternUpdateInput, DomainPatternUncheckedUpdateInput>
    /**
     * Choose, which DomainPattern to update.
     */
    where: DomainPatternWhereUniqueInput
  }

  /**
   * DomainPattern updateMany
   */
  export type DomainPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainPatterns.
     */
    data: XOR<DomainPatternUpdateManyMutationInput, DomainPatternUncheckedUpdateManyInput>
    /**
     * Filter which DomainPatterns to update
     */
    where?: DomainPatternWhereInput
    /**
     * Limit how many DomainPatterns to update.
     */
    limit?: number
  }

  /**
   * DomainPattern updateManyAndReturn
   */
  export type DomainPatternUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * The data used to update DomainPatterns.
     */
    data: XOR<DomainPatternUpdateManyMutationInput, DomainPatternUncheckedUpdateManyInput>
    /**
     * Filter which DomainPatterns to update
     */
    where?: DomainPatternWhereInput
    /**
     * Limit how many DomainPatterns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainPattern upsert
   */
  export type DomainPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainPattern to update in case it exists.
     */
    where: DomainPatternWhereUniqueInput
    /**
     * In case the DomainPattern found by the `where` argument doesn't exist, create a new DomainPattern with this data.
     */
    create: XOR<DomainPatternCreateInput, DomainPatternUncheckedCreateInput>
    /**
     * In case the DomainPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainPatternUpdateInput, DomainPatternUncheckedUpdateInput>
  }

  /**
   * DomainPattern delete
   */
  export type DomainPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
    /**
     * Filter which DomainPattern to delete.
     */
    where: DomainPatternWhereUniqueInput
  }

  /**
   * DomainPattern deleteMany
   */
  export type DomainPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainPatterns to delete
     */
    where?: DomainPatternWhereInput
    /**
     * Limit how many DomainPatterns to delete.
     */
    limit?: number
  }

  /**
   * DomainPattern without action
   */
  export type DomainPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainPattern
     */
    select?: DomainPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainPattern
     */
    omit?: DomainPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainPatternInclude<ExtArgs> | null
  }


  /**
   * Model DomainBestPractice
   */

  export type AggregateDomainBestPractice = {
    _count: DomainBestPracticeCountAggregateOutputType | null
    _min: DomainBestPracticeMinAggregateOutputType | null
    _max: DomainBestPracticeMaxAggregateOutputType | null
  }

  export type DomainBestPracticeMinAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    title: string | null
    description: string | null
    rationale: string | null
    implementation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainBestPracticeMaxAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    title: string | null
    description: string | null
    rationale: string | null
    implementation: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainBestPracticeCountAggregateOutputType = {
    id: number
    domainKnowledgeId: number
    title: number
    description: number
    rationale: number
    implementation: number
    benefits: number
    considerations: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DomainBestPracticeMinAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    title?: true
    description?: true
    rationale?: true
    implementation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainBestPracticeMaxAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    title?: true
    description?: true
    rationale?: true
    implementation?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainBestPracticeCountAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    title?: true
    description?: true
    rationale?: true
    implementation?: true
    benefits?: true
    considerations?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DomainBestPracticeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainBestPractice to aggregate.
     */
    where?: DomainBestPracticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainBestPractices to fetch.
     */
    orderBy?: DomainBestPracticeOrderByWithRelationInput | DomainBestPracticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainBestPracticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainBestPractices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainBestPractices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainBestPractices
    **/
    _count?: true | DomainBestPracticeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainBestPracticeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainBestPracticeMaxAggregateInputType
  }

  export type GetDomainBestPracticeAggregateType<T extends DomainBestPracticeAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainBestPractice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainBestPractice[P]>
      : GetScalarType<T[P], AggregateDomainBestPractice[P]>
  }




  export type DomainBestPracticeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainBestPracticeWhereInput
    orderBy?: DomainBestPracticeOrderByWithAggregationInput | DomainBestPracticeOrderByWithAggregationInput[]
    by: DomainBestPracticeScalarFieldEnum[] | DomainBestPracticeScalarFieldEnum
    having?: DomainBestPracticeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainBestPracticeCountAggregateInputType | true
    _min?: DomainBestPracticeMinAggregateInputType
    _max?: DomainBestPracticeMaxAggregateInputType
  }

  export type DomainBestPracticeGroupByOutputType = {
    id: string
    domainKnowledgeId: string
    title: string
    description: string
    rationale: string
    implementation: string
    benefits: string[]
    considerations: string[]
    createdAt: Date
    updatedAt: Date
    _count: DomainBestPracticeCountAggregateOutputType | null
    _min: DomainBestPracticeMinAggregateOutputType | null
    _max: DomainBestPracticeMaxAggregateOutputType | null
  }

  type GetDomainBestPracticeGroupByPayload<T extends DomainBestPracticeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainBestPracticeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainBestPracticeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainBestPracticeGroupByOutputType[P]>
            : GetScalarType<T[P], DomainBestPracticeGroupByOutputType[P]>
        }
      >
    >


  export type DomainBestPracticeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    implementation?: boolean
    benefits?: boolean
    considerations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainBestPractice"]>

  export type DomainBestPracticeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    implementation?: boolean
    benefits?: boolean
    considerations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainBestPractice"]>

  export type DomainBestPracticeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    implementation?: boolean
    benefits?: boolean
    considerations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainBestPractice"]>

  export type DomainBestPracticeSelectScalar = {
    id?: boolean
    domainKnowledgeId?: boolean
    title?: boolean
    description?: boolean
    rationale?: boolean
    implementation?: boolean
    benefits?: boolean
    considerations?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DomainBestPracticeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainKnowledgeId" | "title" | "description" | "rationale" | "implementation" | "benefits" | "considerations" | "createdAt" | "updatedAt", ExtArgs["result"]["domainBestPractice"]>
  export type DomainBestPracticeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainBestPracticeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainBestPracticeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }

  export type $DomainBestPracticePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainBestPractice"
    objects: {
      domainKnowledge: Prisma.$DomainKnowledgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domainKnowledgeId: string
      title: string
      description: string
      rationale: string
      implementation: string
      benefits: string[]
      considerations: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["domainBestPractice"]>
    composites: {}
  }

  type DomainBestPracticeGetPayload<S extends boolean | null | undefined | DomainBestPracticeDefaultArgs> = $Result.GetResult<Prisma.$DomainBestPracticePayload, S>

  type DomainBestPracticeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainBestPracticeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainBestPracticeCountAggregateInputType | true
    }

  export interface DomainBestPracticeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainBestPractice'], meta: { name: 'DomainBestPractice' } }
    /**
     * Find zero or one DomainBestPractice that matches the filter.
     * @param {DomainBestPracticeFindUniqueArgs} args - Arguments to find a DomainBestPractice
     * @example
     * // Get one DomainBestPractice
     * const domainBestPractice = await prisma.domainBestPractice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainBestPracticeFindUniqueArgs>(args: SelectSubset<T, DomainBestPracticeFindUniqueArgs<ExtArgs>>): Prisma__DomainBestPracticeClient<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainBestPractice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainBestPracticeFindUniqueOrThrowArgs} args - Arguments to find a DomainBestPractice
     * @example
     * // Get one DomainBestPractice
     * const domainBestPractice = await prisma.domainBestPractice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainBestPracticeFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainBestPracticeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainBestPracticeClient<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainBestPractice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBestPracticeFindFirstArgs} args - Arguments to find a DomainBestPractice
     * @example
     * // Get one DomainBestPractice
     * const domainBestPractice = await prisma.domainBestPractice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainBestPracticeFindFirstArgs>(args?: SelectSubset<T, DomainBestPracticeFindFirstArgs<ExtArgs>>): Prisma__DomainBestPracticeClient<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainBestPractice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBestPracticeFindFirstOrThrowArgs} args - Arguments to find a DomainBestPractice
     * @example
     * // Get one DomainBestPractice
     * const domainBestPractice = await prisma.domainBestPractice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainBestPracticeFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainBestPracticeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainBestPracticeClient<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainBestPractices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBestPracticeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainBestPractices
     * const domainBestPractices = await prisma.domainBestPractice.findMany()
     * 
     * // Get first 10 DomainBestPractices
     * const domainBestPractices = await prisma.domainBestPractice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainBestPracticeWithIdOnly = await prisma.domainBestPractice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainBestPracticeFindManyArgs>(args?: SelectSubset<T, DomainBestPracticeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainBestPractice.
     * @param {DomainBestPracticeCreateArgs} args - Arguments to create a DomainBestPractice.
     * @example
     * // Create one DomainBestPractice
     * const DomainBestPractice = await prisma.domainBestPractice.create({
     *   data: {
     *     // ... data to create a DomainBestPractice
     *   }
     * })
     * 
     */
    create<T extends DomainBestPracticeCreateArgs>(args: SelectSubset<T, DomainBestPracticeCreateArgs<ExtArgs>>): Prisma__DomainBestPracticeClient<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainBestPractices.
     * @param {DomainBestPracticeCreateManyArgs} args - Arguments to create many DomainBestPractices.
     * @example
     * // Create many DomainBestPractices
     * const domainBestPractice = await prisma.domainBestPractice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainBestPracticeCreateManyArgs>(args?: SelectSubset<T, DomainBestPracticeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainBestPractices and returns the data saved in the database.
     * @param {DomainBestPracticeCreateManyAndReturnArgs} args - Arguments to create many DomainBestPractices.
     * @example
     * // Create many DomainBestPractices
     * const domainBestPractice = await prisma.domainBestPractice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainBestPractices and only return the `id`
     * const domainBestPracticeWithIdOnly = await prisma.domainBestPractice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainBestPracticeCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainBestPracticeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainBestPractice.
     * @param {DomainBestPracticeDeleteArgs} args - Arguments to delete one DomainBestPractice.
     * @example
     * // Delete one DomainBestPractice
     * const DomainBestPractice = await prisma.domainBestPractice.delete({
     *   where: {
     *     // ... filter to delete one DomainBestPractice
     *   }
     * })
     * 
     */
    delete<T extends DomainBestPracticeDeleteArgs>(args: SelectSubset<T, DomainBestPracticeDeleteArgs<ExtArgs>>): Prisma__DomainBestPracticeClient<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainBestPractice.
     * @param {DomainBestPracticeUpdateArgs} args - Arguments to update one DomainBestPractice.
     * @example
     * // Update one DomainBestPractice
     * const domainBestPractice = await prisma.domainBestPractice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainBestPracticeUpdateArgs>(args: SelectSubset<T, DomainBestPracticeUpdateArgs<ExtArgs>>): Prisma__DomainBestPracticeClient<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainBestPractices.
     * @param {DomainBestPracticeDeleteManyArgs} args - Arguments to filter DomainBestPractices to delete.
     * @example
     * // Delete a few DomainBestPractices
     * const { count } = await prisma.domainBestPractice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainBestPracticeDeleteManyArgs>(args?: SelectSubset<T, DomainBestPracticeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainBestPractices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBestPracticeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainBestPractices
     * const domainBestPractice = await prisma.domainBestPractice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainBestPracticeUpdateManyArgs>(args: SelectSubset<T, DomainBestPracticeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainBestPractices and returns the data updated in the database.
     * @param {DomainBestPracticeUpdateManyAndReturnArgs} args - Arguments to update many DomainBestPractices.
     * @example
     * // Update many DomainBestPractices
     * const domainBestPractice = await prisma.domainBestPractice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainBestPractices and only return the `id`
     * const domainBestPracticeWithIdOnly = await prisma.domainBestPractice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainBestPracticeUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainBestPracticeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainBestPractice.
     * @param {DomainBestPracticeUpsertArgs} args - Arguments to update or create a DomainBestPractice.
     * @example
     * // Update or create a DomainBestPractice
     * const domainBestPractice = await prisma.domainBestPractice.upsert({
     *   create: {
     *     // ... data to create a DomainBestPractice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainBestPractice we want to update
     *   }
     * })
     */
    upsert<T extends DomainBestPracticeUpsertArgs>(args: SelectSubset<T, DomainBestPracticeUpsertArgs<ExtArgs>>): Prisma__DomainBestPracticeClient<$Result.GetResult<Prisma.$DomainBestPracticePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainBestPractices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBestPracticeCountArgs} args - Arguments to filter DomainBestPractices to count.
     * @example
     * // Count the number of DomainBestPractices
     * const count = await prisma.domainBestPractice.count({
     *   where: {
     *     // ... the filter for the DomainBestPractices we want to count
     *   }
     * })
    **/
    count<T extends DomainBestPracticeCountArgs>(
      args?: Subset<T, DomainBestPracticeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainBestPracticeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainBestPractice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBestPracticeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainBestPracticeAggregateArgs>(args: Subset<T, DomainBestPracticeAggregateArgs>): Prisma.PrismaPromise<GetDomainBestPracticeAggregateType<T>>

    /**
     * Group by DomainBestPractice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainBestPracticeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainBestPracticeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainBestPracticeGroupByArgs['orderBy'] }
        : { orderBy?: DomainBestPracticeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainBestPracticeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainBestPracticeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainBestPractice model
   */
  readonly fields: DomainBestPracticeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainBestPractice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainBestPracticeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domainKnowledge<T extends DomainKnowledgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledgeDefaultArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainBestPractice model
   */
  interface DomainBestPracticeFieldRefs {
    readonly id: FieldRef<"DomainBestPractice", 'String'>
    readonly domainKnowledgeId: FieldRef<"DomainBestPractice", 'String'>
    readonly title: FieldRef<"DomainBestPractice", 'String'>
    readonly description: FieldRef<"DomainBestPractice", 'String'>
    readonly rationale: FieldRef<"DomainBestPractice", 'String'>
    readonly implementation: FieldRef<"DomainBestPractice", 'String'>
    readonly benefits: FieldRef<"DomainBestPractice", 'String[]'>
    readonly considerations: FieldRef<"DomainBestPractice", 'String[]'>
    readonly createdAt: FieldRef<"DomainBestPractice", 'DateTime'>
    readonly updatedAt: FieldRef<"DomainBestPractice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DomainBestPractice findUnique
   */
  export type DomainBestPracticeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    /**
     * Filter, which DomainBestPractice to fetch.
     */
    where: DomainBestPracticeWhereUniqueInput
  }

  /**
   * DomainBestPractice findUniqueOrThrow
   */
  export type DomainBestPracticeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    /**
     * Filter, which DomainBestPractice to fetch.
     */
    where: DomainBestPracticeWhereUniqueInput
  }

  /**
   * DomainBestPractice findFirst
   */
  export type DomainBestPracticeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    /**
     * Filter, which DomainBestPractice to fetch.
     */
    where?: DomainBestPracticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainBestPractices to fetch.
     */
    orderBy?: DomainBestPracticeOrderByWithRelationInput | DomainBestPracticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainBestPractices.
     */
    cursor?: DomainBestPracticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainBestPractices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainBestPractices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainBestPractices.
     */
    distinct?: DomainBestPracticeScalarFieldEnum | DomainBestPracticeScalarFieldEnum[]
  }

  /**
   * DomainBestPractice findFirstOrThrow
   */
  export type DomainBestPracticeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    /**
     * Filter, which DomainBestPractice to fetch.
     */
    where?: DomainBestPracticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainBestPractices to fetch.
     */
    orderBy?: DomainBestPracticeOrderByWithRelationInput | DomainBestPracticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainBestPractices.
     */
    cursor?: DomainBestPracticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainBestPractices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainBestPractices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainBestPractices.
     */
    distinct?: DomainBestPracticeScalarFieldEnum | DomainBestPracticeScalarFieldEnum[]
  }

  /**
   * DomainBestPractice findMany
   */
  export type DomainBestPracticeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    /**
     * Filter, which DomainBestPractices to fetch.
     */
    where?: DomainBestPracticeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainBestPractices to fetch.
     */
    orderBy?: DomainBestPracticeOrderByWithRelationInput | DomainBestPracticeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainBestPractices.
     */
    cursor?: DomainBestPracticeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainBestPractices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainBestPractices.
     */
    skip?: number
    distinct?: DomainBestPracticeScalarFieldEnum | DomainBestPracticeScalarFieldEnum[]
  }

  /**
   * DomainBestPractice create
   */
  export type DomainBestPracticeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainBestPractice.
     */
    data: XOR<DomainBestPracticeCreateInput, DomainBestPracticeUncheckedCreateInput>
  }

  /**
   * DomainBestPractice createMany
   */
  export type DomainBestPracticeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainBestPractices.
     */
    data: DomainBestPracticeCreateManyInput | DomainBestPracticeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainBestPractice createManyAndReturn
   */
  export type DomainBestPracticeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * The data used to create many DomainBestPractices.
     */
    data: DomainBestPracticeCreateManyInput | DomainBestPracticeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainBestPractice update
   */
  export type DomainBestPracticeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainBestPractice.
     */
    data: XOR<DomainBestPracticeUpdateInput, DomainBestPracticeUncheckedUpdateInput>
    /**
     * Choose, which DomainBestPractice to update.
     */
    where: DomainBestPracticeWhereUniqueInput
  }

  /**
   * DomainBestPractice updateMany
   */
  export type DomainBestPracticeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainBestPractices.
     */
    data: XOR<DomainBestPracticeUpdateManyMutationInput, DomainBestPracticeUncheckedUpdateManyInput>
    /**
     * Filter which DomainBestPractices to update
     */
    where?: DomainBestPracticeWhereInput
    /**
     * Limit how many DomainBestPractices to update.
     */
    limit?: number
  }

  /**
   * DomainBestPractice updateManyAndReturn
   */
  export type DomainBestPracticeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * The data used to update DomainBestPractices.
     */
    data: XOR<DomainBestPracticeUpdateManyMutationInput, DomainBestPracticeUncheckedUpdateManyInput>
    /**
     * Filter which DomainBestPractices to update
     */
    where?: DomainBestPracticeWhereInput
    /**
     * Limit how many DomainBestPractices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainBestPractice upsert
   */
  export type DomainBestPracticeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainBestPractice to update in case it exists.
     */
    where: DomainBestPracticeWhereUniqueInput
    /**
     * In case the DomainBestPractice found by the `where` argument doesn't exist, create a new DomainBestPractice with this data.
     */
    create: XOR<DomainBestPracticeCreateInput, DomainBestPracticeUncheckedCreateInput>
    /**
     * In case the DomainBestPractice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainBestPracticeUpdateInput, DomainBestPracticeUncheckedUpdateInput>
  }

  /**
   * DomainBestPractice delete
   */
  export type DomainBestPracticeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
    /**
     * Filter which DomainBestPractice to delete.
     */
    where: DomainBestPracticeWhereUniqueInput
  }

  /**
   * DomainBestPractice deleteMany
   */
  export type DomainBestPracticeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainBestPractices to delete
     */
    where?: DomainBestPracticeWhereInput
    /**
     * Limit how many DomainBestPractices to delete.
     */
    limit?: number
  }

  /**
   * DomainBestPractice without action
   */
  export type DomainBestPracticeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainBestPractice
     */
    select?: DomainBestPracticeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainBestPractice
     */
    omit?: DomainBestPracticeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainBestPracticeInclude<ExtArgs> | null
  }


  /**
   * Model DomainAntiPattern
   */

  export type AggregateDomainAntiPattern = {
    _count: DomainAntiPatternCountAggregateOutputType | null
    _min: DomainAntiPatternMinAggregateOutputType | null
    _max: DomainAntiPatternMaxAggregateOutputType | null
  }

  export type DomainAntiPatternMinAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    name: string | null
    description: string | null
    refactoring: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainAntiPatternMaxAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    name: string | null
    description: string | null
    refactoring: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DomainAntiPatternCountAggregateOutputType = {
    id: number
    domainKnowledgeId: number
    name: number
    description: number
    symptoms: number
    causes: number
    consequences: number
    refactoring: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DomainAntiPatternMinAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    name?: true
    description?: true
    refactoring?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainAntiPatternMaxAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    name?: true
    description?: true
    refactoring?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DomainAntiPatternCountAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    name?: true
    description?: true
    symptoms?: true
    causes?: true
    consequences?: true
    refactoring?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DomainAntiPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainAntiPattern to aggregate.
     */
    where?: DomainAntiPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainAntiPatterns to fetch.
     */
    orderBy?: DomainAntiPatternOrderByWithRelationInput | DomainAntiPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainAntiPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainAntiPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainAntiPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainAntiPatterns
    **/
    _count?: true | DomainAntiPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainAntiPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainAntiPatternMaxAggregateInputType
  }

  export type GetDomainAntiPatternAggregateType<T extends DomainAntiPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainAntiPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainAntiPattern[P]>
      : GetScalarType<T[P], AggregateDomainAntiPattern[P]>
  }




  export type DomainAntiPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainAntiPatternWhereInput
    orderBy?: DomainAntiPatternOrderByWithAggregationInput | DomainAntiPatternOrderByWithAggregationInput[]
    by: DomainAntiPatternScalarFieldEnum[] | DomainAntiPatternScalarFieldEnum
    having?: DomainAntiPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainAntiPatternCountAggregateInputType | true
    _min?: DomainAntiPatternMinAggregateInputType
    _max?: DomainAntiPatternMaxAggregateInputType
  }

  export type DomainAntiPatternGroupByOutputType = {
    id: string
    domainKnowledgeId: string
    name: string
    description: string
    symptoms: string[]
    causes: string[]
    consequences: string[]
    refactoring: string
    createdAt: Date
    updatedAt: Date
    _count: DomainAntiPatternCountAggregateOutputType | null
    _min: DomainAntiPatternMinAggregateOutputType | null
    _max: DomainAntiPatternMaxAggregateOutputType | null
  }

  type GetDomainAntiPatternGroupByPayload<T extends DomainAntiPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainAntiPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainAntiPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainAntiPatternGroupByOutputType[P]>
            : GetScalarType<T[P], DomainAntiPatternGroupByOutputType[P]>
        }
      >
    >


  export type DomainAntiPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    description?: boolean
    symptoms?: boolean
    causes?: boolean
    consequences?: boolean
    refactoring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainAntiPattern"]>

  export type DomainAntiPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    description?: boolean
    symptoms?: boolean
    causes?: boolean
    consequences?: boolean
    refactoring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainAntiPattern"]>

  export type DomainAntiPatternSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    description?: boolean
    symptoms?: boolean
    causes?: boolean
    consequences?: boolean
    refactoring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainAntiPattern"]>

  export type DomainAntiPatternSelectScalar = {
    id?: boolean
    domainKnowledgeId?: boolean
    name?: boolean
    description?: boolean
    symptoms?: boolean
    causes?: boolean
    consequences?: boolean
    refactoring?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DomainAntiPatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainKnowledgeId" | "name" | "description" | "symptoms" | "causes" | "consequences" | "refactoring" | "createdAt" | "updatedAt", ExtArgs["result"]["domainAntiPattern"]>
  export type DomainAntiPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainAntiPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainAntiPatternIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }

  export type $DomainAntiPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainAntiPattern"
    objects: {
      domainKnowledge: Prisma.$DomainKnowledgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domainKnowledgeId: string
      name: string
      description: string
      symptoms: string[]
      causes: string[]
      consequences: string[]
      refactoring: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["domainAntiPattern"]>
    composites: {}
  }

  type DomainAntiPatternGetPayload<S extends boolean | null | undefined | DomainAntiPatternDefaultArgs> = $Result.GetResult<Prisma.$DomainAntiPatternPayload, S>

  type DomainAntiPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainAntiPatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainAntiPatternCountAggregateInputType | true
    }

  export interface DomainAntiPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainAntiPattern'], meta: { name: 'DomainAntiPattern' } }
    /**
     * Find zero or one DomainAntiPattern that matches the filter.
     * @param {DomainAntiPatternFindUniqueArgs} args - Arguments to find a DomainAntiPattern
     * @example
     * // Get one DomainAntiPattern
     * const domainAntiPattern = await prisma.domainAntiPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainAntiPatternFindUniqueArgs>(args: SelectSubset<T, DomainAntiPatternFindUniqueArgs<ExtArgs>>): Prisma__DomainAntiPatternClient<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainAntiPattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainAntiPatternFindUniqueOrThrowArgs} args - Arguments to find a DomainAntiPattern
     * @example
     * // Get one DomainAntiPattern
     * const domainAntiPattern = await prisma.domainAntiPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainAntiPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainAntiPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainAntiPatternClient<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainAntiPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAntiPatternFindFirstArgs} args - Arguments to find a DomainAntiPattern
     * @example
     * // Get one DomainAntiPattern
     * const domainAntiPattern = await prisma.domainAntiPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainAntiPatternFindFirstArgs>(args?: SelectSubset<T, DomainAntiPatternFindFirstArgs<ExtArgs>>): Prisma__DomainAntiPatternClient<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainAntiPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAntiPatternFindFirstOrThrowArgs} args - Arguments to find a DomainAntiPattern
     * @example
     * // Get one DomainAntiPattern
     * const domainAntiPattern = await prisma.domainAntiPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainAntiPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainAntiPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainAntiPatternClient<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainAntiPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAntiPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainAntiPatterns
     * const domainAntiPatterns = await prisma.domainAntiPattern.findMany()
     * 
     * // Get first 10 DomainAntiPatterns
     * const domainAntiPatterns = await prisma.domainAntiPattern.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainAntiPatternWithIdOnly = await prisma.domainAntiPattern.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainAntiPatternFindManyArgs>(args?: SelectSubset<T, DomainAntiPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainAntiPattern.
     * @param {DomainAntiPatternCreateArgs} args - Arguments to create a DomainAntiPattern.
     * @example
     * // Create one DomainAntiPattern
     * const DomainAntiPattern = await prisma.domainAntiPattern.create({
     *   data: {
     *     // ... data to create a DomainAntiPattern
     *   }
     * })
     * 
     */
    create<T extends DomainAntiPatternCreateArgs>(args: SelectSubset<T, DomainAntiPatternCreateArgs<ExtArgs>>): Prisma__DomainAntiPatternClient<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainAntiPatterns.
     * @param {DomainAntiPatternCreateManyArgs} args - Arguments to create many DomainAntiPatterns.
     * @example
     * // Create many DomainAntiPatterns
     * const domainAntiPattern = await prisma.domainAntiPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainAntiPatternCreateManyArgs>(args?: SelectSubset<T, DomainAntiPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainAntiPatterns and returns the data saved in the database.
     * @param {DomainAntiPatternCreateManyAndReturnArgs} args - Arguments to create many DomainAntiPatterns.
     * @example
     * // Create many DomainAntiPatterns
     * const domainAntiPattern = await prisma.domainAntiPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainAntiPatterns and only return the `id`
     * const domainAntiPatternWithIdOnly = await prisma.domainAntiPattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainAntiPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainAntiPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainAntiPattern.
     * @param {DomainAntiPatternDeleteArgs} args - Arguments to delete one DomainAntiPattern.
     * @example
     * // Delete one DomainAntiPattern
     * const DomainAntiPattern = await prisma.domainAntiPattern.delete({
     *   where: {
     *     // ... filter to delete one DomainAntiPattern
     *   }
     * })
     * 
     */
    delete<T extends DomainAntiPatternDeleteArgs>(args: SelectSubset<T, DomainAntiPatternDeleteArgs<ExtArgs>>): Prisma__DomainAntiPatternClient<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainAntiPattern.
     * @param {DomainAntiPatternUpdateArgs} args - Arguments to update one DomainAntiPattern.
     * @example
     * // Update one DomainAntiPattern
     * const domainAntiPattern = await prisma.domainAntiPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainAntiPatternUpdateArgs>(args: SelectSubset<T, DomainAntiPatternUpdateArgs<ExtArgs>>): Prisma__DomainAntiPatternClient<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainAntiPatterns.
     * @param {DomainAntiPatternDeleteManyArgs} args - Arguments to filter DomainAntiPatterns to delete.
     * @example
     * // Delete a few DomainAntiPatterns
     * const { count } = await prisma.domainAntiPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainAntiPatternDeleteManyArgs>(args?: SelectSubset<T, DomainAntiPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainAntiPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAntiPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainAntiPatterns
     * const domainAntiPattern = await prisma.domainAntiPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainAntiPatternUpdateManyArgs>(args: SelectSubset<T, DomainAntiPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainAntiPatterns and returns the data updated in the database.
     * @param {DomainAntiPatternUpdateManyAndReturnArgs} args - Arguments to update many DomainAntiPatterns.
     * @example
     * // Update many DomainAntiPatterns
     * const domainAntiPattern = await prisma.domainAntiPattern.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainAntiPatterns and only return the `id`
     * const domainAntiPatternWithIdOnly = await prisma.domainAntiPattern.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainAntiPatternUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainAntiPatternUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainAntiPattern.
     * @param {DomainAntiPatternUpsertArgs} args - Arguments to update or create a DomainAntiPattern.
     * @example
     * // Update or create a DomainAntiPattern
     * const domainAntiPattern = await prisma.domainAntiPattern.upsert({
     *   create: {
     *     // ... data to create a DomainAntiPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainAntiPattern we want to update
     *   }
     * })
     */
    upsert<T extends DomainAntiPatternUpsertArgs>(args: SelectSubset<T, DomainAntiPatternUpsertArgs<ExtArgs>>): Prisma__DomainAntiPatternClient<$Result.GetResult<Prisma.$DomainAntiPatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainAntiPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAntiPatternCountArgs} args - Arguments to filter DomainAntiPatterns to count.
     * @example
     * // Count the number of DomainAntiPatterns
     * const count = await prisma.domainAntiPattern.count({
     *   where: {
     *     // ... the filter for the DomainAntiPatterns we want to count
     *   }
     * })
    **/
    count<T extends DomainAntiPatternCountArgs>(
      args?: Subset<T, DomainAntiPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainAntiPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainAntiPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAntiPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainAntiPatternAggregateArgs>(args: Subset<T, DomainAntiPatternAggregateArgs>): Prisma.PrismaPromise<GetDomainAntiPatternAggregateType<T>>

    /**
     * Group by DomainAntiPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainAntiPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainAntiPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainAntiPatternGroupByArgs['orderBy'] }
        : { orderBy?: DomainAntiPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainAntiPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainAntiPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainAntiPattern model
   */
  readonly fields: DomainAntiPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainAntiPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainAntiPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domainKnowledge<T extends DomainKnowledgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledgeDefaultArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainAntiPattern model
   */
  interface DomainAntiPatternFieldRefs {
    readonly id: FieldRef<"DomainAntiPattern", 'String'>
    readonly domainKnowledgeId: FieldRef<"DomainAntiPattern", 'String'>
    readonly name: FieldRef<"DomainAntiPattern", 'String'>
    readonly description: FieldRef<"DomainAntiPattern", 'String'>
    readonly symptoms: FieldRef<"DomainAntiPattern", 'String[]'>
    readonly causes: FieldRef<"DomainAntiPattern", 'String[]'>
    readonly consequences: FieldRef<"DomainAntiPattern", 'String[]'>
    readonly refactoring: FieldRef<"DomainAntiPattern", 'String'>
    readonly createdAt: FieldRef<"DomainAntiPattern", 'DateTime'>
    readonly updatedAt: FieldRef<"DomainAntiPattern", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DomainAntiPattern findUnique
   */
  export type DomainAntiPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainAntiPattern to fetch.
     */
    where: DomainAntiPatternWhereUniqueInput
  }

  /**
   * DomainAntiPattern findUniqueOrThrow
   */
  export type DomainAntiPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainAntiPattern to fetch.
     */
    where: DomainAntiPatternWhereUniqueInput
  }

  /**
   * DomainAntiPattern findFirst
   */
  export type DomainAntiPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainAntiPattern to fetch.
     */
    where?: DomainAntiPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainAntiPatterns to fetch.
     */
    orderBy?: DomainAntiPatternOrderByWithRelationInput | DomainAntiPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainAntiPatterns.
     */
    cursor?: DomainAntiPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainAntiPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainAntiPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainAntiPatterns.
     */
    distinct?: DomainAntiPatternScalarFieldEnum | DomainAntiPatternScalarFieldEnum[]
  }

  /**
   * DomainAntiPattern findFirstOrThrow
   */
  export type DomainAntiPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainAntiPattern to fetch.
     */
    where?: DomainAntiPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainAntiPatterns to fetch.
     */
    orderBy?: DomainAntiPatternOrderByWithRelationInput | DomainAntiPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainAntiPatterns.
     */
    cursor?: DomainAntiPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainAntiPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainAntiPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainAntiPatterns.
     */
    distinct?: DomainAntiPatternScalarFieldEnum | DomainAntiPatternScalarFieldEnum[]
  }

  /**
   * DomainAntiPattern findMany
   */
  export type DomainAntiPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    /**
     * Filter, which DomainAntiPatterns to fetch.
     */
    where?: DomainAntiPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainAntiPatterns to fetch.
     */
    orderBy?: DomainAntiPatternOrderByWithRelationInput | DomainAntiPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainAntiPatterns.
     */
    cursor?: DomainAntiPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainAntiPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainAntiPatterns.
     */
    skip?: number
    distinct?: DomainAntiPatternScalarFieldEnum | DomainAntiPatternScalarFieldEnum[]
  }

  /**
   * DomainAntiPattern create
   */
  export type DomainAntiPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainAntiPattern.
     */
    data: XOR<DomainAntiPatternCreateInput, DomainAntiPatternUncheckedCreateInput>
  }

  /**
   * DomainAntiPattern createMany
   */
  export type DomainAntiPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainAntiPatterns.
     */
    data: DomainAntiPatternCreateManyInput | DomainAntiPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainAntiPattern createManyAndReturn
   */
  export type DomainAntiPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * The data used to create many DomainAntiPatterns.
     */
    data: DomainAntiPatternCreateManyInput | DomainAntiPatternCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainAntiPattern update
   */
  export type DomainAntiPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainAntiPattern.
     */
    data: XOR<DomainAntiPatternUpdateInput, DomainAntiPatternUncheckedUpdateInput>
    /**
     * Choose, which DomainAntiPattern to update.
     */
    where: DomainAntiPatternWhereUniqueInput
  }

  /**
   * DomainAntiPattern updateMany
   */
  export type DomainAntiPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainAntiPatterns.
     */
    data: XOR<DomainAntiPatternUpdateManyMutationInput, DomainAntiPatternUncheckedUpdateManyInput>
    /**
     * Filter which DomainAntiPatterns to update
     */
    where?: DomainAntiPatternWhereInput
    /**
     * Limit how many DomainAntiPatterns to update.
     */
    limit?: number
  }

  /**
   * DomainAntiPattern updateManyAndReturn
   */
  export type DomainAntiPatternUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * The data used to update DomainAntiPatterns.
     */
    data: XOR<DomainAntiPatternUpdateManyMutationInput, DomainAntiPatternUncheckedUpdateManyInput>
    /**
     * Filter which DomainAntiPatterns to update
     */
    where?: DomainAntiPatternWhereInput
    /**
     * Limit how many DomainAntiPatterns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainAntiPattern upsert
   */
  export type DomainAntiPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainAntiPattern to update in case it exists.
     */
    where: DomainAntiPatternWhereUniqueInput
    /**
     * In case the DomainAntiPattern found by the `where` argument doesn't exist, create a new DomainAntiPattern with this data.
     */
    create: XOR<DomainAntiPatternCreateInput, DomainAntiPatternUncheckedCreateInput>
    /**
     * In case the DomainAntiPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainAntiPatternUpdateInput, DomainAntiPatternUncheckedUpdateInput>
  }

  /**
   * DomainAntiPattern delete
   */
  export type DomainAntiPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
    /**
     * Filter which DomainAntiPattern to delete.
     */
    where: DomainAntiPatternWhereUniqueInput
  }

  /**
   * DomainAntiPattern deleteMany
   */
  export type DomainAntiPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainAntiPatterns to delete
     */
    where?: DomainAntiPatternWhereInput
    /**
     * Limit how many DomainAntiPatterns to delete.
     */
    limit?: number
  }

  /**
   * DomainAntiPattern without action
   */
  export type DomainAntiPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainAntiPattern
     */
    select?: DomainAntiPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainAntiPattern
     */
    omit?: DomainAntiPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainAntiPatternInclude<ExtArgs> | null
  }


  /**
   * Model DomainReference
   */

  export type AggregateDomainReference = {
    _count: DomainReferenceCountAggregateOutputType | null
    _min: DomainReferenceMinAggregateOutputType | null
    _max: DomainReferenceMaxAggregateOutputType | null
  }

  export type DomainReferenceMinAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    title: string | null
    type: string | null
    url: string | null
    author: string | null
    publishDate: Date | null
    summary: string | null
    createdAt: Date | null
  }

  export type DomainReferenceMaxAggregateOutputType = {
    id: string | null
    domainKnowledgeId: string | null
    title: string | null
    type: string | null
    url: string | null
    author: string | null
    publishDate: Date | null
    summary: string | null
    createdAt: Date | null
  }

  export type DomainReferenceCountAggregateOutputType = {
    id: number
    domainKnowledgeId: number
    title: number
    type: number
    url: number
    author: number
    publishDate: number
    summary: number
    createdAt: number
    _all: number
  }


  export type DomainReferenceMinAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    title?: true
    type?: true
    url?: true
    author?: true
    publishDate?: true
    summary?: true
    createdAt?: true
  }

  export type DomainReferenceMaxAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    title?: true
    type?: true
    url?: true
    author?: true
    publishDate?: true
    summary?: true
    createdAt?: true
  }

  export type DomainReferenceCountAggregateInputType = {
    id?: true
    domainKnowledgeId?: true
    title?: true
    type?: true
    url?: true
    author?: true
    publishDate?: true
    summary?: true
    createdAt?: true
    _all?: true
  }

  export type DomainReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainReference to aggregate.
     */
    where?: DomainReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainReferences to fetch.
     */
    orderBy?: DomainReferenceOrderByWithRelationInput | DomainReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DomainReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DomainReferences
    **/
    _count?: true | DomainReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DomainReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DomainReferenceMaxAggregateInputType
  }

  export type GetDomainReferenceAggregateType<T extends DomainReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateDomainReference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDomainReference[P]>
      : GetScalarType<T[P], AggregateDomainReference[P]>
  }




  export type DomainReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DomainReferenceWhereInput
    orderBy?: DomainReferenceOrderByWithAggregationInput | DomainReferenceOrderByWithAggregationInput[]
    by: DomainReferenceScalarFieldEnum[] | DomainReferenceScalarFieldEnum
    having?: DomainReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DomainReferenceCountAggregateInputType | true
    _min?: DomainReferenceMinAggregateInputType
    _max?: DomainReferenceMaxAggregateInputType
  }

  export type DomainReferenceGroupByOutputType = {
    id: string
    domainKnowledgeId: string
    title: string
    type: string
    url: string | null
    author: string | null
    publishDate: Date | null
    summary: string | null
    createdAt: Date
    _count: DomainReferenceCountAggregateOutputType | null
    _min: DomainReferenceMinAggregateOutputType | null
    _max: DomainReferenceMaxAggregateOutputType | null
  }

  type GetDomainReferenceGroupByPayload<T extends DomainReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DomainReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DomainReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DomainReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], DomainReferenceGroupByOutputType[P]>
        }
      >
    >


  export type DomainReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    title?: boolean
    type?: boolean
    url?: boolean
    author?: boolean
    publishDate?: boolean
    summary?: boolean
    createdAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainReference"]>

  export type DomainReferenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    title?: boolean
    type?: boolean
    url?: boolean
    author?: boolean
    publishDate?: boolean
    summary?: boolean
    createdAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainReference"]>

  export type DomainReferenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    domainKnowledgeId?: boolean
    title?: boolean
    type?: boolean
    url?: boolean
    author?: boolean
    publishDate?: boolean
    summary?: boolean
    createdAt?: boolean
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["domainReference"]>

  export type DomainReferenceSelectScalar = {
    id?: boolean
    domainKnowledgeId?: boolean
    title?: boolean
    type?: boolean
    url?: boolean
    author?: boolean
    publishDate?: boolean
    summary?: boolean
    createdAt?: boolean
  }

  export type DomainReferenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "domainKnowledgeId" | "title" | "type" | "url" | "author" | "publishDate" | "summary" | "createdAt", ExtArgs["result"]["domainReference"]>
  export type DomainReferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainReferenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }
  export type DomainReferenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domainKnowledge?: boolean | DomainKnowledgeDefaultArgs<ExtArgs>
  }

  export type $DomainReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DomainReference"
    objects: {
      domainKnowledge: Prisma.$DomainKnowledgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      domainKnowledgeId: string
      title: string
      type: string
      url: string | null
      author: string | null
      publishDate: Date | null
      summary: string | null
      createdAt: Date
    }, ExtArgs["result"]["domainReference"]>
    composites: {}
  }

  type DomainReferenceGetPayload<S extends boolean | null | undefined | DomainReferenceDefaultArgs> = $Result.GetResult<Prisma.$DomainReferencePayload, S>

  type DomainReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DomainReferenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DomainReferenceCountAggregateInputType | true
    }

  export interface DomainReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DomainReference'], meta: { name: 'DomainReference' } }
    /**
     * Find zero or one DomainReference that matches the filter.
     * @param {DomainReferenceFindUniqueArgs} args - Arguments to find a DomainReference
     * @example
     * // Get one DomainReference
     * const domainReference = await prisma.domainReference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DomainReferenceFindUniqueArgs>(args: SelectSubset<T, DomainReferenceFindUniqueArgs<ExtArgs>>): Prisma__DomainReferenceClient<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DomainReference that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DomainReferenceFindUniqueOrThrowArgs} args - Arguments to find a DomainReference
     * @example
     * // Get one DomainReference
     * const domainReference = await prisma.domainReference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DomainReferenceFindUniqueOrThrowArgs>(args: SelectSubset<T, DomainReferenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DomainReferenceClient<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainReference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReferenceFindFirstArgs} args - Arguments to find a DomainReference
     * @example
     * // Get one DomainReference
     * const domainReference = await prisma.domainReference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DomainReferenceFindFirstArgs>(args?: SelectSubset<T, DomainReferenceFindFirstArgs<ExtArgs>>): Prisma__DomainReferenceClient<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DomainReference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReferenceFindFirstOrThrowArgs} args - Arguments to find a DomainReference
     * @example
     * // Get one DomainReference
     * const domainReference = await prisma.domainReference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DomainReferenceFindFirstOrThrowArgs>(args?: SelectSubset<T, DomainReferenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DomainReferenceClient<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DomainReferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReferenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DomainReferences
     * const domainReferences = await prisma.domainReference.findMany()
     * 
     * // Get first 10 DomainReferences
     * const domainReferences = await prisma.domainReference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const domainReferenceWithIdOnly = await prisma.domainReference.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DomainReferenceFindManyArgs>(args?: SelectSubset<T, DomainReferenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DomainReference.
     * @param {DomainReferenceCreateArgs} args - Arguments to create a DomainReference.
     * @example
     * // Create one DomainReference
     * const DomainReference = await prisma.domainReference.create({
     *   data: {
     *     // ... data to create a DomainReference
     *   }
     * })
     * 
     */
    create<T extends DomainReferenceCreateArgs>(args: SelectSubset<T, DomainReferenceCreateArgs<ExtArgs>>): Prisma__DomainReferenceClient<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DomainReferences.
     * @param {DomainReferenceCreateManyArgs} args - Arguments to create many DomainReferences.
     * @example
     * // Create many DomainReferences
     * const domainReference = await prisma.domainReference.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DomainReferenceCreateManyArgs>(args?: SelectSubset<T, DomainReferenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DomainReferences and returns the data saved in the database.
     * @param {DomainReferenceCreateManyAndReturnArgs} args - Arguments to create many DomainReferences.
     * @example
     * // Create many DomainReferences
     * const domainReference = await prisma.domainReference.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DomainReferences and only return the `id`
     * const domainReferenceWithIdOnly = await prisma.domainReference.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DomainReferenceCreateManyAndReturnArgs>(args?: SelectSubset<T, DomainReferenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DomainReference.
     * @param {DomainReferenceDeleteArgs} args - Arguments to delete one DomainReference.
     * @example
     * // Delete one DomainReference
     * const DomainReference = await prisma.domainReference.delete({
     *   where: {
     *     // ... filter to delete one DomainReference
     *   }
     * })
     * 
     */
    delete<T extends DomainReferenceDeleteArgs>(args: SelectSubset<T, DomainReferenceDeleteArgs<ExtArgs>>): Prisma__DomainReferenceClient<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DomainReference.
     * @param {DomainReferenceUpdateArgs} args - Arguments to update one DomainReference.
     * @example
     * // Update one DomainReference
     * const domainReference = await prisma.domainReference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DomainReferenceUpdateArgs>(args: SelectSubset<T, DomainReferenceUpdateArgs<ExtArgs>>): Prisma__DomainReferenceClient<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DomainReferences.
     * @param {DomainReferenceDeleteManyArgs} args - Arguments to filter DomainReferences to delete.
     * @example
     * // Delete a few DomainReferences
     * const { count } = await prisma.domainReference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DomainReferenceDeleteManyArgs>(args?: SelectSubset<T, DomainReferenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DomainReferences
     * const domainReference = await prisma.domainReference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DomainReferenceUpdateManyArgs>(args: SelectSubset<T, DomainReferenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DomainReferences and returns the data updated in the database.
     * @param {DomainReferenceUpdateManyAndReturnArgs} args - Arguments to update many DomainReferences.
     * @example
     * // Update many DomainReferences
     * const domainReference = await prisma.domainReference.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DomainReferences and only return the `id`
     * const domainReferenceWithIdOnly = await prisma.domainReference.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DomainReferenceUpdateManyAndReturnArgs>(args: SelectSubset<T, DomainReferenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DomainReference.
     * @param {DomainReferenceUpsertArgs} args - Arguments to update or create a DomainReference.
     * @example
     * // Update or create a DomainReference
     * const domainReference = await prisma.domainReference.upsert({
     *   create: {
     *     // ... data to create a DomainReference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DomainReference we want to update
     *   }
     * })
     */
    upsert<T extends DomainReferenceUpsertArgs>(args: SelectSubset<T, DomainReferenceUpsertArgs<ExtArgs>>): Prisma__DomainReferenceClient<$Result.GetResult<Prisma.$DomainReferencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DomainReferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReferenceCountArgs} args - Arguments to filter DomainReferences to count.
     * @example
     * // Count the number of DomainReferences
     * const count = await prisma.domainReference.count({
     *   where: {
     *     // ... the filter for the DomainReferences we want to count
     *   }
     * })
    **/
    count<T extends DomainReferenceCountArgs>(
      args?: Subset<T, DomainReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DomainReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DomainReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DomainReferenceAggregateArgs>(args: Subset<T, DomainReferenceAggregateArgs>): Prisma.PrismaPromise<GetDomainReferenceAggregateType<T>>

    /**
     * Group by DomainReference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DomainReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DomainReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DomainReferenceGroupByArgs['orderBy'] }
        : { orderBy?: DomainReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DomainReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDomainReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DomainReference model
   */
  readonly fields: DomainReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DomainReference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DomainReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domainKnowledge<T extends DomainKnowledgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DomainKnowledgeDefaultArgs<ExtArgs>>): Prisma__DomainKnowledgeClient<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DomainReference model
   */
  interface DomainReferenceFieldRefs {
    readonly id: FieldRef<"DomainReference", 'String'>
    readonly domainKnowledgeId: FieldRef<"DomainReference", 'String'>
    readonly title: FieldRef<"DomainReference", 'String'>
    readonly type: FieldRef<"DomainReference", 'String'>
    readonly url: FieldRef<"DomainReference", 'String'>
    readonly author: FieldRef<"DomainReference", 'String'>
    readonly publishDate: FieldRef<"DomainReference", 'DateTime'>
    readonly summary: FieldRef<"DomainReference", 'String'>
    readonly createdAt: FieldRef<"DomainReference", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DomainReference findUnique
   */
  export type DomainReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DomainReference to fetch.
     */
    where: DomainReferenceWhereUniqueInput
  }

  /**
   * DomainReference findUniqueOrThrow
   */
  export type DomainReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DomainReference to fetch.
     */
    where: DomainReferenceWhereUniqueInput
  }

  /**
   * DomainReference findFirst
   */
  export type DomainReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DomainReference to fetch.
     */
    where?: DomainReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainReferences to fetch.
     */
    orderBy?: DomainReferenceOrderByWithRelationInput | DomainReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainReferences.
     */
    cursor?: DomainReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainReferences.
     */
    distinct?: DomainReferenceScalarFieldEnum | DomainReferenceScalarFieldEnum[]
  }

  /**
   * DomainReference findFirstOrThrow
   */
  export type DomainReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DomainReference to fetch.
     */
    where?: DomainReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainReferences to fetch.
     */
    orderBy?: DomainReferenceOrderByWithRelationInput | DomainReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DomainReferences.
     */
    cursor?: DomainReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainReferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DomainReferences.
     */
    distinct?: DomainReferenceScalarFieldEnum | DomainReferenceScalarFieldEnum[]
  }

  /**
   * DomainReference findMany
   */
  export type DomainReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    /**
     * Filter, which DomainReferences to fetch.
     */
    where?: DomainReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DomainReferences to fetch.
     */
    orderBy?: DomainReferenceOrderByWithRelationInput | DomainReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DomainReferences.
     */
    cursor?: DomainReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DomainReferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DomainReferences.
     */
    skip?: number
    distinct?: DomainReferenceScalarFieldEnum | DomainReferenceScalarFieldEnum[]
  }

  /**
   * DomainReference create
   */
  export type DomainReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a DomainReference.
     */
    data: XOR<DomainReferenceCreateInput, DomainReferenceUncheckedCreateInput>
  }

  /**
   * DomainReference createMany
   */
  export type DomainReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DomainReferences.
     */
    data: DomainReferenceCreateManyInput | DomainReferenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DomainReference createManyAndReturn
   */
  export type DomainReferenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * The data used to create many DomainReferences.
     */
    data: DomainReferenceCreateManyInput | DomainReferenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainReference update
   */
  export type DomainReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a DomainReference.
     */
    data: XOR<DomainReferenceUpdateInput, DomainReferenceUncheckedUpdateInput>
    /**
     * Choose, which DomainReference to update.
     */
    where: DomainReferenceWhereUniqueInput
  }

  /**
   * DomainReference updateMany
   */
  export type DomainReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DomainReferences.
     */
    data: XOR<DomainReferenceUpdateManyMutationInput, DomainReferenceUncheckedUpdateManyInput>
    /**
     * Filter which DomainReferences to update
     */
    where?: DomainReferenceWhereInput
    /**
     * Limit how many DomainReferences to update.
     */
    limit?: number
  }

  /**
   * DomainReference updateManyAndReturn
   */
  export type DomainReferenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * The data used to update DomainReferences.
     */
    data: XOR<DomainReferenceUpdateManyMutationInput, DomainReferenceUncheckedUpdateManyInput>
    /**
     * Filter which DomainReferences to update
     */
    where?: DomainReferenceWhereInput
    /**
     * Limit how many DomainReferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DomainReference upsert
   */
  export type DomainReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the DomainReference to update in case it exists.
     */
    where: DomainReferenceWhereUniqueInput
    /**
     * In case the DomainReference found by the `where` argument doesn't exist, create a new DomainReference with this data.
     */
    create: XOR<DomainReferenceCreateInput, DomainReferenceUncheckedCreateInput>
    /**
     * In case the DomainReference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DomainReferenceUpdateInput, DomainReferenceUncheckedUpdateInput>
  }

  /**
   * DomainReference delete
   */
  export type DomainReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
    /**
     * Filter which DomainReference to delete.
     */
    where: DomainReferenceWhereUniqueInput
  }

  /**
   * DomainReference deleteMany
   */
  export type DomainReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DomainReferences to delete
     */
    where?: DomainReferenceWhereInput
    /**
     * Limit how many DomainReferences to delete.
     */
    limit?: number
  }

  /**
   * DomainReference without action
   */
  export type DomainReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainReference
     */
    select?: DomainReferenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainReference
     */
    omit?: DomainReferenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainReferenceInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdBy: string | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    createdBy: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    createdBy?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    createdBy: string | null
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    creator?: boolean | Project$creatorArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    documentation?: boolean | Project$documentationArgs<ExtArgs>
    MindMap?: boolean | Project$MindMapArgs<ExtArgs>
    Sprint?: boolean | Project$SprintArgs<ExtArgs>
    Requirement?: boolean | Project$RequirementArgs<ExtArgs>
    DomainKnowledge?: boolean | Project$DomainKnowledgeArgs<ExtArgs>
    SystemArchitecture?: boolean | Project$SystemArchitectureArgs<ExtArgs>
    roadmaps?: boolean | Project$roadmapsArgs<ExtArgs>
    ApiDesign?: boolean | Project$ApiDesignArgs<ExtArgs>
    team?: boolean | Project$teamArgs<ExtArgs>
    Agent?: boolean | Project$AgentArgs<ExtArgs>
    AgentWorklog?: boolean | Project$AgentWorklogArgs<ExtArgs>
    DatabaseSchema?: boolean | Project$DatabaseSchemaArgs<ExtArgs>
    RequirementQuestion?: boolean | Project$RequirementQuestionArgs<ExtArgs>
    RequirementAttachment?: boolean | Project$RequirementAttachmentArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "createdBy", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Project$creatorArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    documentation?: boolean | Project$documentationArgs<ExtArgs>
    MindMap?: boolean | Project$MindMapArgs<ExtArgs>
    Sprint?: boolean | Project$SprintArgs<ExtArgs>
    Requirement?: boolean | Project$RequirementArgs<ExtArgs>
    DomainKnowledge?: boolean | Project$DomainKnowledgeArgs<ExtArgs>
    SystemArchitecture?: boolean | Project$SystemArchitectureArgs<ExtArgs>
    roadmaps?: boolean | Project$roadmapsArgs<ExtArgs>
    ApiDesign?: boolean | Project$ApiDesignArgs<ExtArgs>
    team?: boolean | Project$teamArgs<ExtArgs>
    Agent?: boolean | Project$AgentArgs<ExtArgs>
    AgentWorklog?: boolean | Project$AgentWorklogArgs<ExtArgs>
    DatabaseSchema?: boolean | Project$DatabaseSchemaArgs<ExtArgs>
    RequirementQuestion?: boolean | Project$RequirementQuestionArgs<ExtArgs>
    RequirementAttachment?: boolean | Project$RequirementAttachmentArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Project$creatorArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      documentation: Prisma.$DocumentationPayload<ExtArgs>[]
      MindMap: Prisma.$MindMapPayload<ExtArgs>[]
      Sprint: Prisma.$SprintPayload<ExtArgs>[]
      Requirement: Prisma.$RequirementPayload<ExtArgs>[]
      DomainKnowledge: Prisma.$DomainKnowledgePayload<ExtArgs>[]
      SystemArchitecture: Prisma.$SystemArchitecturePayload<ExtArgs>[]
      roadmaps: Prisma.$RoadmapPayload<ExtArgs>[]
      ApiDesign: Prisma.$ApiDesignPayload<ExtArgs>[]
      team: Prisma.$TeamPayload<ExtArgs>[]
      Agent: Prisma.$AgentPayload<ExtArgs>[]
      AgentWorklog: Prisma.$AgentWorklogPayload<ExtArgs>[]
      DatabaseSchema: Prisma.$DatabaseSchemaPayload<ExtArgs>[]
      RequirementQuestion: Prisma.$RequirementQuestionPayload<ExtArgs>[]
      RequirementAttachment: Prisma.$RequirementAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      createdBy: string | null
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Project$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Project$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentation<T extends Project$documentationArgs<ExtArgs> = {}>(args?: Subset<T, Project$documentationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MindMap<T extends Project$MindMapArgs<ExtArgs> = {}>(args?: Subset<T, Project$MindMapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Sprint<T extends Project$SprintArgs<ExtArgs> = {}>(args?: Subset<T, Project$SprintArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Requirement<T extends Project$RequirementArgs<ExtArgs> = {}>(args?: Subset<T, Project$RequirementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DomainKnowledge<T extends Project$DomainKnowledgeArgs<ExtArgs> = {}>(args?: Subset<T, Project$DomainKnowledgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    SystemArchitecture<T extends Project$SystemArchitectureArgs<ExtArgs> = {}>(args?: Subset<T, Project$SystemArchitectureArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemArchitecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmaps<T extends Project$roadmapsArgs<ExtArgs> = {}>(args?: Subset<T, Project$roadmapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ApiDesign<T extends Project$ApiDesignArgs<ExtArgs> = {}>(args?: Subset<T, Project$ApiDesignArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiDesignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    team<T extends Project$teamArgs<ExtArgs> = {}>(args?: Subset<T, Project$teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Agent<T extends Project$AgentArgs<ExtArgs> = {}>(args?: Subset<T, Project$AgentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AgentWorklog<T extends Project$AgentWorklogArgs<ExtArgs> = {}>(args?: Subset<T, Project$AgentWorklogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DatabaseSchema<T extends Project$DatabaseSchemaArgs<ExtArgs> = {}>(args?: Subset<T, Project$DatabaseSchemaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RequirementQuestion<T extends Project$RequirementQuestionArgs<ExtArgs> = {}>(args?: Subset<T, Project$RequirementQuestionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RequirementAttachment<T extends Project$RequirementAttachmentArgs<ExtArgs> = {}>(args?: Subset<T, Project$RequirementAttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
    readonly createdBy: FieldRef<"Project", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.creator
   */
  export type Project$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project.documentation
   */
  export type Project$documentationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    where?: DocumentationWhereInput
    orderBy?: DocumentationOrderByWithRelationInput | DocumentationOrderByWithRelationInput[]
    cursor?: DocumentationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentationScalarFieldEnum | DocumentationScalarFieldEnum[]
  }

  /**
   * Project.MindMap
   */
  export type Project$MindMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    where?: MindMapWhereInput
    orderBy?: MindMapOrderByWithRelationInput | MindMapOrderByWithRelationInput[]
    cursor?: MindMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MindMapScalarFieldEnum | MindMapScalarFieldEnum[]
  }

  /**
   * Project.Sprint
   */
  export type Project$SprintArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    cursor?: SprintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Project.Requirement
   */
  export type Project$RequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    cursor?: RequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Project.DomainKnowledge
   */
  export type Project$DomainKnowledgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    where?: DomainKnowledgeWhereInput
    orderBy?: DomainKnowledgeOrderByWithRelationInput | DomainKnowledgeOrderByWithRelationInput[]
    cursor?: DomainKnowledgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainKnowledgeScalarFieldEnum | DomainKnowledgeScalarFieldEnum[]
  }

  /**
   * Project.SystemArchitecture
   */
  export type Project$SystemArchitectureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemArchitecture
     */
    select?: SystemArchitectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemArchitecture
     */
    omit?: SystemArchitectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemArchitectureInclude<ExtArgs> | null
    where?: SystemArchitectureWhereInput
    orderBy?: SystemArchitectureOrderByWithRelationInput | SystemArchitectureOrderByWithRelationInput[]
    cursor?: SystemArchitectureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemArchitectureScalarFieldEnum | SystemArchitectureScalarFieldEnum[]
  }

  /**
   * Project.roadmaps
   */
  export type Project$roadmapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    where?: RoadmapWhereInput
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    cursor?: RoadmapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Project.ApiDesign
   */
  export type Project$ApiDesignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiDesign
     */
    select?: ApiDesignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiDesign
     */
    omit?: ApiDesignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiDesignInclude<ExtArgs> | null
    where?: ApiDesignWhereInput
    orderBy?: ApiDesignOrderByWithRelationInput | ApiDesignOrderByWithRelationInput[]
    cursor?: ApiDesignWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiDesignScalarFieldEnum | ApiDesignScalarFieldEnum[]
  }

  /**
   * Project.team
   */
  export type Project$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Project.Agent
   */
  export type Project$AgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Project.AgentWorklog
   */
  export type Project$AgentWorklogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    where?: AgentWorklogWhereInput
    orderBy?: AgentWorklogOrderByWithRelationInput | AgentWorklogOrderByWithRelationInput[]
    cursor?: AgentWorklogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentWorklogScalarFieldEnum | AgentWorklogScalarFieldEnum[]
  }

  /**
   * Project.DatabaseSchema
   */
  export type Project$DatabaseSchemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    where?: DatabaseSchemaWhereInput
    orderBy?: DatabaseSchemaOrderByWithRelationInput | DatabaseSchemaOrderByWithRelationInput[]
    cursor?: DatabaseSchemaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatabaseSchemaScalarFieldEnum | DatabaseSchemaScalarFieldEnum[]
  }

  /**
   * Project.RequirementQuestion
   */
  export type Project$RequirementQuestionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    where?: RequirementQuestionWhereInput
    orderBy?: RequirementQuestionOrderByWithRelationInput | RequirementQuestionOrderByWithRelationInput[]
    cursor?: RequirementQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementQuestionScalarFieldEnum | RequirementQuestionScalarFieldEnum[]
  }

  /**
   * Project.RequirementAttachment
   */
  export type Project$RequirementAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    where?: RequirementAttachmentWhereInput
    orderBy?: RequirementAttachmentOrderByWithRelationInput | RequirementAttachmentOrderByWithRelationInput[]
    cursor?: RequirementAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementAttachmentScalarFieldEnum | RequirementAttachmentScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Requirement
   */

  export type AggregateRequirement = {
    _count: RequirementCountAggregateOutputType | null
    _avg: RequirementAvgAggregateOutputType | null
    _sum: RequirementSumAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  export type RequirementAvgAggregateOutputType = {
    version: number | null
  }

  export type RequirementSumAggregateOutputType = {
    version: number | null
  }

  export type RequirementMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    content: string | null
    type: $Enums.RequirementType | null
    priority: $Enums.RequirementPriority | null
    status: $Enums.RequirementStatus | null
    source: $Enums.RequirementSource | null
    parentId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type RequirementMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    title: string | null
    content: string | null
    type: $Enums.RequirementType | null
    priority: $Enums.RequirementPriority | null
    status: $Enums.RequirementStatus | null
    source: $Enums.RequirementSource | null
    parentId: string | null
    version: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    userId: string | null
  }

  export type RequirementCountAggregateOutputType = {
    id: number
    projectId: number
    title: number
    content: number
    type: number
    priority: number
    status: number
    source: number
    parentId: number
    version: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    userId: number
    _all: number
  }


  export type RequirementAvgAggregateInputType = {
    version?: true
  }

  export type RequirementSumAggregateInputType = {
    version?: true
  }

  export type RequirementMinAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    type?: true
    priority?: true
    status?: true
    source?: true
    parentId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type RequirementMaxAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    type?: true
    priority?: true
    status?: true
    source?: true
    parentId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
  }

  export type RequirementCountAggregateInputType = {
    id?: true
    projectId?: true
    title?: true
    content?: true
    type?: true
    priority?: true
    status?: true
    source?: true
    parentId?: true
    version?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    userId?: true
    _all?: true
  }

  export type RequirementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requirement to aggregate.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requirements
    **/
    _count?: true | RequirementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequirementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequirementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequirementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequirementMaxAggregateInputType
  }

  export type GetRequirementAggregateType<T extends RequirementAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirement[P]>
      : GetScalarType<T[P], AggregateRequirement[P]>
  }




  export type RequirementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithAggregationInput | RequirementOrderByWithAggregationInput[]
    by: RequirementScalarFieldEnum[] | RequirementScalarFieldEnum
    having?: RequirementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequirementCountAggregateInputType | true
    _avg?: RequirementAvgAggregateInputType
    _sum?: RequirementSumAggregateInputType
    _min?: RequirementMinAggregateInputType
    _max?: RequirementMaxAggregateInputType
  }

  export type RequirementGroupByOutputType = {
    id: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId: string | null
    version: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    userId: string | null
    _count: RequirementCountAggregateOutputType | null
    _avg: RequirementAvgAggregateOutputType | null
    _sum: RequirementSumAggregateOutputType | null
    _min: RequirementMinAggregateOutputType | null
    _max: RequirementMaxAggregateOutputType | null
  }

  type GetRequirementGroupByPayload<T extends RequirementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequirementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequirementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementGroupByOutputType[P]>
        }
      >
    >


  export type RequirementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    source?: boolean
    parentId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Requirement$parentArgs<ExtArgs>
    children?: boolean | Requirement$childrenArgs<ExtArgs>
    questions?: boolean | Requirement$questionsArgs<ExtArgs>
    attachments?: boolean | Requirement$attachmentsArgs<ExtArgs>
    User?: boolean | Requirement$UserArgs<ExtArgs>
    _count?: boolean | RequirementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    source?: boolean
    parentId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Requirement$parentArgs<ExtArgs>
    User?: boolean | Requirement$UserArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    source?: boolean
    parentId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Requirement$parentArgs<ExtArgs>
    User?: boolean | Requirement$UserArgs<ExtArgs>
  }, ExtArgs["result"]["requirement"]>

  export type RequirementSelectScalar = {
    id?: boolean
    projectId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    source?: boolean
    parentId?: boolean
    version?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userId?: boolean
  }

  export type RequirementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "title" | "content" | "type" | "priority" | "status" | "source" | "parentId" | "version" | "createdAt" | "updatedAt" | "deletedAt" | "userId", ExtArgs["result"]["requirement"]>
  export type RequirementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Requirement$parentArgs<ExtArgs>
    children?: boolean | Requirement$childrenArgs<ExtArgs>
    questions?: boolean | Requirement$questionsArgs<ExtArgs>
    attachments?: boolean | Requirement$attachmentsArgs<ExtArgs>
    User?: boolean | Requirement$UserArgs<ExtArgs>
    _count?: boolean | RequirementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequirementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Requirement$parentArgs<ExtArgs>
    User?: boolean | Requirement$UserArgs<ExtArgs>
  }
  export type RequirementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    parent?: boolean | Requirement$parentArgs<ExtArgs>
    User?: boolean | Requirement$UserArgs<ExtArgs>
  }

  export type $RequirementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Requirement"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      parent: Prisma.$RequirementPayload<ExtArgs> | null
      children: Prisma.$RequirementPayload<ExtArgs>[]
      questions: Prisma.$RequirementQuestionPayload<ExtArgs>[]
      attachments: Prisma.$RequirementAttachmentPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      title: string
      content: string
      type: $Enums.RequirementType
      priority: $Enums.RequirementPriority
      status: $Enums.RequirementStatus
      source: $Enums.RequirementSource
      parentId: string | null
      version: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      userId: string | null
    }, ExtArgs["result"]["requirement"]>
    composites: {}
  }

  type RequirementGetPayload<S extends boolean | null | undefined | RequirementDefaultArgs> = $Result.GetResult<Prisma.$RequirementPayload, S>

  type RequirementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequirementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequirementCountAggregateInputType | true
    }

  export interface RequirementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Requirement'], meta: { name: 'Requirement' } }
    /**
     * Find zero or one Requirement that matches the filter.
     * @param {RequirementFindUniqueArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequirementFindUniqueArgs>(args: SelectSubset<T, RequirementFindUniqueArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Requirement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequirementFindUniqueOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequirementFindUniqueOrThrowArgs>(args: SelectSubset<T, RequirementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequirementFindFirstArgs>(args?: SelectSubset<T, RequirementFindFirstArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requirement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindFirstOrThrowArgs} args - Arguments to find a Requirement
     * @example
     * // Get one Requirement
     * const requirement = await prisma.requirement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequirementFindFirstOrThrowArgs>(args?: SelectSubset<T, RequirementFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requirements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requirements
     * const requirements = await prisma.requirement.findMany()
     * 
     * // Get first 10 Requirements
     * const requirements = await prisma.requirement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirementWithIdOnly = await prisma.requirement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequirementFindManyArgs>(args?: SelectSubset<T, RequirementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Requirement.
     * @param {RequirementCreateArgs} args - Arguments to create a Requirement.
     * @example
     * // Create one Requirement
     * const Requirement = await prisma.requirement.create({
     *   data: {
     *     // ... data to create a Requirement
     *   }
     * })
     * 
     */
    create<T extends RequirementCreateArgs>(args: SelectSubset<T, RequirementCreateArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requirements.
     * @param {RequirementCreateManyArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequirementCreateManyArgs>(args?: SelectSubset<T, RequirementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requirements and returns the data saved in the database.
     * @param {RequirementCreateManyAndReturnArgs} args - Arguments to create many Requirements.
     * @example
     * // Create many Requirements
     * const requirement = await prisma.requirement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequirementCreateManyAndReturnArgs>(args?: SelectSubset<T, RequirementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Requirement.
     * @param {RequirementDeleteArgs} args - Arguments to delete one Requirement.
     * @example
     * // Delete one Requirement
     * const Requirement = await prisma.requirement.delete({
     *   where: {
     *     // ... filter to delete one Requirement
     *   }
     * })
     * 
     */
    delete<T extends RequirementDeleteArgs>(args: SelectSubset<T, RequirementDeleteArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Requirement.
     * @param {RequirementUpdateArgs} args - Arguments to update one Requirement.
     * @example
     * // Update one Requirement
     * const requirement = await prisma.requirement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequirementUpdateArgs>(args: SelectSubset<T, RequirementUpdateArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requirements.
     * @param {RequirementDeleteManyArgs} args - Arguments to filter Requirements to delete.
     * @example
     * // Delete a few Requirements
     * const { count } = await prisma.requirement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequirementDeleteManyArgs>(args?: SelectSubset<T, RequirementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequirementUpdateManyArgs>(args: SelectSubset<T, RequirementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requirements and returns the data updated in the database.
     * @param {RequirementUpdateManyAndReturnArgs} args - Arguments to update many Requirements.
     * @example
     * // Update many Requirements
     * const requirement = await prisma.requirement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requirements and only return the `id`
     * const requirementWithIdOnly = await prisma.requirement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequirementUpdateManyAndReturnArgs>(args: SelectSubset<T, RequirementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Requirement.
     * @param {RequirementUpsertArgs} args - Arguments to update or create a Requirement.
     * @example
     * // Update or create a Requirement
     * const requirement = await prisma.requirement.upsert({
     *   create: {
     *     // ... data to create a Requirement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requirement we want to update
     *   }
     * })
     */
    upsert<T extends RequirementUpsertArgs>(args: SelectSubset<T, RequirementUpsertArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requirements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementCountArgs} args - Arguments to filter Requirements to count.
     * @example
     * // Count the number of Requirements
     * const count = await prisma.requirement.count({
     *   where: {
     *     // ... the filter for the Requirements we want to count
     *   }
     * })
    **/
    count<T extends RequirementCountArgs>(
      args?: Subset<T, RequirementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequirementAggregateArgs>(args: Subset<T, RequirementAggregateArgs>): Prisma.PrismaPromise<GetRequirementAggregateType<T>>

    /**
     * Group by Requirement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequirementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequirementGroupByArgs['orderBy'] }
        : { orderBy?: RequirementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequirementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Requirement model
   */
  readonly fields: RequirementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Requirement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequirementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Requirement$parentArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$parentArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Requirement$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends Requirement$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Requirement$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends Requirement$UserArgs<ExtArgs> = {}>(args?: Subset<T, Requirement$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Requirement model
   */
  interface RequirementFieldRefs {
    readonly id: FieldRef<"Requirement", 'String'>
    readonly projectId: FieldRef<"Requirement", 'String'>
    readonly title: FieldRef<"Requirement", 'String'>
    readonly content: FieldRef<"Requirement", 'String'>
    readonly type: FieldRef<"Requirement", 'RequirementType'>
    readonly priority: FieldRef<"Requirement", 'RequirementPriority'>
    readonly status: FieldRef<"Requirement", 'RequirementStatus'>
    readonly source: FieldRef<"Requirement", 'RequirementSource'>
    readonly parentId: FieldRef<"Requirement", 'String'>
    readonly version: FieldRef<"Requirement", 'Int'>
    readonly createdAt: FieldRef<"Requirement", 'DateTime'>
    readonly updatedAt: FieldRef<"Requirement", 'DateTime'>
    readonly deletedAt: FieldRef<"Requirement", 'DateTime'>
    readonly userId: FieldRef<"Requirement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Requirement findUnique
   */
  export type RequirementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement findUniqueOrThrow
   */
  export type RequirementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement findFirst
   */
  export type RequirementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement findFirstOrThrow
   */
  export type RequirementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirement to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requirements.
     */
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement findMany
   */
  export type RequirementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter, which Requirements to fetch.
     */
    where?: RequirementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requirements to fetch.
     */
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requirements.
     */
    cursor?: RequirementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requirements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requirements.
     */
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement create
   */
  export type RequirementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The data needed to create a Requirement.
     */
    data: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
  }

  /**
   * Requirement createMany
   */
  export type RequirementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Requirement createManyAndReturn
   */
  export type RequirementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * The data used to create many Requirements.
     */
    data: RequirementCreateManyInput | RequirementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requirement update
   */
  export type RequirementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The data needed to update a Requirement.
     */
    data: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
    /**
     * Choose, which Requirement to update.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement updateMany
   */
  export type RequirementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requirements.
     */
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyInput>
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to update.
     */
    limit?: number
  }

  /**
   * Requirement updateManyAndReturn
   */
  export type RequirementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * The data used to update Requirements.
     */
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyInput>
    /**
     * Filter which Requirements to update
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requirement upsert
   */
  export type RequirementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * The filter to search for the Requirement to update in case it exists.
     */
    where: RequirementWhereUniqueInput
    /**
     * In case the Requirement found by the `where` argument doesn't exist, create a new Requirement with this data.
     */
    create: XOR<RequirementCreateInput, RequirementUncheckedCreateInput>
    /**
     * In case the Requirement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequirementUpdateInput, RequirementUncheckedUpdateInput>
  }

  /**
   * Requirement delete
   */
  export type RequirementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    /**
     * Filter which Requirement to delete.
     */
    where: RequirementWhereUniqueInput
  }

  /**
   * Requirement deleteMany
   */
  export type RequirementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requirements to delete
     */
    where?: RequirementWhereInput
    /**
     * Limit how many Requirements to delete.
     */
    limit?: number
  }

  /**
   * Requirement.parent
   */
  export type Requirement$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
  }

  /**
   * Requirement.children
   */
  export type Requirement$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    cursor?: RequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * Requirement.questions
   */
  export type Requirement$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    where?: RequirementQuestionWhereInput
    orderBy?: RequirementQuestionOrderByWithRelationInput | RequirementQuestionOrderByWithRelationInput[]
    cursor?: RequirementQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementQuestionScalarFieldEnum | RequirementQuestionScalarFieldEnum[]
  }

  /**
   * Requirement.attachments
   */
  export type Requirement$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    where?: RequirementAttachmentWhereInput
    orderBy?: RequirementAttachmentOrderByWithRelationInput | RequirementAttachmentOrderByWithRelationInput[]
    cursor?: RequirementAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementAttachmentScalarFieldEnum | RequirementAttachmentScalarFieldEnum[]
  }

  /**
   * Requirement.User
   */
  export type Requirement$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Requirement without action
   */
  export type RequirementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
  }


  /**
   * Model RequirementQuestion
   */

  export type AggregateRequirementQuestion = {
    _count: RequirementQuestionCountAggregateOutputType | null
    _min: RequirementQuestionMinAggregateOutputType | null
    _max: RequirementQuestionMaxAggregateOutputType | null
  }

  export type RequirementQuestionMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    requirementId: string | null
    question: string | null
    answer: string | null
    status: $Enums.QuestionStatus | null
    priority: $Enums.QuestionPriority | null
    clarified: boolean | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    answeredAt: Date | null
  }

  export type RequirementQuestionMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    requirementId: string | null
    question: string | null
    answer: string | null
    status: $Enums.QuestionStatus | null
    priority: $Enums.QuestionPriority | null
    clarified: boolean | null
    agentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    answeredAt: Date | null
  }

  export type RequirementQuestionCountAggregateOutputType = {
    id: number
    projectId: number
    requirementId: number
    question: number
    answer: number
    status: number
    priority: number
    clarified: number
    agentId: number
    createdAt: number
    updatedAt: number
    answeredAt: number
    _all: number
  }


  export type RequirementQuestionMinAggregateInputType = {
    id?: true
    projectId?: true
    requirementId?: true
    question?: true
    answer?: true
    status?: true
    priority?: true
    clarified?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    answeredAt?: true
  }

  export type RequirementQuestionMaxAggregateInputType = {
    id?: true
    projectId?: true
    requirementId?: true
    question?: true
    answer?: true
    status?: true
    priority?: true
    clarified?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    answeredAt?: true
  }

  export type RequirementQuestionCountAggregateInputType = {
    id?: true
    projectId?: true
    requirementId?: true
    question?: true
    answer?: true
    status?: true
    priority?: true
    clarified?: true
    agentId?: true
    createdAt?: true
    updatedAt?: true
    answeredAt?: true
    _all?: true
  }

  export type RequirementQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequirementQuestion to aggregate.
     */
    where?: RequirementQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementQuestions to fetch.
     */
    orderBy?: RequirementQuestionOrderByWithRelationInput | RequirementQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequirementQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequirementQuestions
    **/
    _count?: true | RequirementQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequirementQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequirementQuestionMaxAggregateInputType
  }

  export type GetRequirementQuestionAggregateType<T extends RequirementQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirementQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirementQuestion[P]>
      : GetScalarType<T[P], AggregateRequirementQuestion[P]>
  }




  export type RequirementQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementQuestionWhereInput
    orderBy?: RequirementQuestionOrderByWithAggregationInput | RequirementQuestionOrderByWithAggregationInput[]
    by: RequirementQuestionScalarFieldEnum[] | RequirementQuestionScalarFieldEnum
    having?: RequirementQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequirementQuestionCountAggregateInputType | true
    _min?: RequirementQuestionMinAggregateInputType
    _max?: RequirementQuestionMaxAggregateInputType
  }

  export type RequirementQuestionGroupByOutputType = {
    id: string
    projectId: string
    requirementId: string
    question: string
    answer: string | null
    status: $Enums.QuestionStatus
    priority: $Enums.QuestionPriority
    clarified: boolean
    agentId: string
    createdAt: Date
    updatedAt: Date
    answeredAt: Date | null
    _count: RequirementQuestionCountAggregateOutputType | null
    _min: RequirementQuestionMinAggregateOutputType | null
    _max: RequirementQuestionMaxAggregateOutputType | null
  }

  type GetRequirementQuestionGroupByPayload<T extends RequirementQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequirementQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequirementQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementQuestionGroupByOutputType[P]>
        }
      >
    >


  export type RequirementQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    requirementId?: boolean
    question?: boolean
    answer?: boolean
    status?: boolean
    priority?: boolean
    clarified?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answeredAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirementQuestion"]>

  export type RequirementQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    requirementId?: boolean
    question?: boolean
    answer?: boolean
    status?: boolean
    priority?: boolean
    clarified?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answeredAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirementQuestion"]>

  export type RequirementQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    requirementId?: boolean
    question?: boolean
    answer?: boolean
    status?: boolean
    priority?: boolean
    clarified?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answeredAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requirementQuestion"]>

  export type RequirementQuestionSelectScalar = {
    id?: boolean
    projectId?: boolean
    requirementId?: boolean
    question?: boolean
    answer?: boolean
    status?: boolean
    priority?: boolean
    clarified?: boolean
    agentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    answeredAt?: boolean
  }

  export type RequirementQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "requirementId" | "question" | "answer" | "status" | "priority" | "clarified" | "agentId" | "createdAt" | "updatedAt" | "answeredAt", ExtArgs["result"]["requirementQuestion"]>
  export type RequirementQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type RequirementQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }
  export type RequirementQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    agent?: boolean | AgentDefaultArgs<ExtArgs>
  }

  export type $RequirementQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequirementQuestion"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      requirement: Prisma.$RequirementPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      requirementId: string
      question: string
      answer: string | null
      status: $Enums.QuestionStatus
      priority: $Enums.QuestionPriority
      clarified: boolean
      agentId: string
      createdAt: Date
      updatedAt: Date
      answeredAt: Date | null
    }, ExtArgs["result"]["requirementQuestion"]>
    composites: {}
  }

  type RequirementQuestionGetPayload<S extends boolean | null | undefined | RequirementQuestionDefaultArgs> = $Result.GetResult<Prisma.$RequirementQuestionPayload, S>

  type RequirementQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequirementQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequirementQuestionCountAggregateInputType | true
    }

  export interface RequirementQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequirementQuestion'], meta: { name: 'RequirementQuestion' } }
    /**
     * Find zero or one RequirementQuestion that matches the filter.
     * @param {RequirementQuestionFindUniqueArgs} args - Arguments to find a RequirementQuestion
     * @example
     * // Get one RequirementQuestion
     * const requirementQuestion = await prisma.requirementQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequirementQuestionFindUniqueArgs>(args: SelectSubset<T, RequirementQuestionFindUniqueArgs<ExtArgs>>): Prisma__RequirementQuestionClient<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequirementQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequirementQuestionFindUniqueOrThrowArgs} args - Arguments to find a RequirementQuestion
     * @example
     * // Get one RequirementQuestion
     * const requirementQuestion = await prisma.requirementQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequirementQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, RequirementQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequirementQuestionClient<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequirementQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementQuestionFindFirstArgs} args - Arguments to find a RequirementQuestion
     * @example
     * // Get one RequirementQuestion
     * const requirementQuestion = await prisma.requirementQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequirementQuestionFindFirstArgs>(args?: SelectSubset<T, RequirementQuestionFindFirstArgs<ExtArgs>>): Prisma__RequirementQuestionClient<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequirementQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementQuestionFindFirstOrThrowArgs} args - Arguments to find a RequirementQuestion
     * @example
     * // Get one RequirementQuestion
     * const requirementQuestion = await prisma.requirementQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequirementQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, RequirementQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequirementQuestionClient<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequirementQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequirementQuestions
     * const requirementQuestions = await prisma.requirementQuestion.findMany()
     * 
     * // Get first 10 RequirementQuestions
     * const requirementQuestions = await prisma.requirementQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirementQuestionWithIdOnly = await prisma.requirementQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequirementQuestionFindManyArgs>(args?: SelectSubset<T, RequirementQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequirementQuestion.
     * @param {RequirementQuestionCreateArgs} args - Arguments to create a RequirementQuestion.
     * @example
     * // Create one RequirementQuestion
     * const RequirementQuestion = await prisma.requirementQuestion.create({
     *   data: {
     *     // ... data to create a RequirementQuestion
     *   }
     * })
     * 
     */
    create<T extends RequirementQuestionCreateArgs>(args: SelectSubset<T, RequirementQuestionCreateArgs<ExtArgs>>): Prisma__RequirementQuestionClient<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequirementQuestions.
     * @param {RequirementQuestionCreateManyArgs} args - Arguments to create many RequirementQuestions.
     * @example
     * // Create many RequirementQuestions
     * const requirementQuestion = await prisma.requirementQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequirementQuestionCreateManyArgs>(args?: SelectSubset<T, RequirementQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequirementQuestions and returns the data saved in the database.
     * @param {RequirementQuestionCreateManyAndReturnArgs} args - Arguments to create many RequirementQuestions.
     * @example
     * // Create many RequirementQuestions
     * const requirementQuestion = await prisma.requirementQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequirementQuestions and only return the `id`
     * const requirementQuestionWithIdOnly = await prisma.requirementQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequirementQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, RequirementQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequirementQuestion.
     * @param {RequirementQuestionDeleteArgs} args - Arguments to delete one RequirementQuestion.
     * @example
     * // Delete one RequirementQuestion
     * const RequirementQuestion = await prisma.requirementQuestion.delete({
     *   where: {
     *     // ... filter to delete one RequirementQuestion
     *   }
     * })
     * 
     */
    delete<T extends RequirementQuestionDeleteArgs>(args: SelectSubset<T, RequirementQuestionDeleteArgs<ExtArgs>>): Prisma__RequirementQuestionClient<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequirementQuestion.
     * @param {RequirementQuestionUpdateArgs} args - Arguments to update one RequirementQuestion.
     * @example
     * // Update one RequirementQuestion
     * const requirementQuestion = await prisma.requirementQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequirementQuestionUpdateArgs>(args: SelectSubset<T, RequirementQuestionUpdateArgs<ExtArgs>>): Prisma__RequirementQuestionClient<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequirementQuestions.
     * @param {RequirementQuestionDeleteManyArgs} args - Arguments to filter RequirementQuestions to delete.
     * @example
     * // Delete a few RequirementQuestions
     * const { count } = await prisma.requirementQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequirementQuestionDeleteManyArgs>(args?: SelectSubset<T, RequirementQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequirementQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequirementQuestions
     * const requirementQuestion = await prisma.requirementQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequirementQuestionUpdateManyArgs>(args: SelectSubset<T, RequirementQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequirementQuestions and returns the data updated in the database.
     * @param {RequirementQuestionUpdateManyAndReturnArgs} args - Arguments to update many RequirementQuestions.
     * @example
     * // Update many RequirementQuestions
     * const requirementQuestion = await prisma.requirementQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequirementQuestions and only return the `id`
     * const requirementQuestionWithIdOnly = await prisma.requirementQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequirementQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, RequirementQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequirementQuestion.
     * @param {RequirementQuestionUpsertArgs} args - Arguments to update or create a RequirementQuestion.
     * @example
     * // Update or create a RequirementQuestion
     * const requirementQuestion = await prisma.requirementQuestion.upsert({
     *   create: {
     *     // ... data to create a RequirementQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequirementQuestion we want to update
     *   }
     * })
     */
    upsert<T extends RequirementQuestionUpsertArgs>(args: SelectSubset<T, RequirementQuestionUpsertArgs<ExtArgs>>): Prisma__RequirementQuestionClient<$Result.GetResult<Prisma.$RequirementQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequirementQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementQuestionCountArgs} args - Arguments to filter RequirementQuestions to count.
     * @example
     * // Count the number of RequirementQuestions
     * const count = await prisma.requirementQuestion.count({
     *   where: {
     *     // ... the filter for the RequirementQuestions we want to count
     *   }
     * })
    **/
    count<T extends RequirementQuestionCountArgs>(
      args?: Subset<T, RequirementQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequirementQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequirementQuestionAggregateArgs>(args: Subset<T, RequirementQuestionAggregateArgs>): Prisma.PrismaPromise<GetRequirementQuestionAggregateType<T>>

    /**
     * Group by RequirementQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequirementQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequirementQuestionGroupByArgs['orderBy'] }
        : { orderBy?: RequirementQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequirementQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirementQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequirementQuestion model
   */
  readonly fields: RequirementQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequirementQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequirementQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requirement<T extends RequirementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequirementDefaultArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequirementQuestion model
   */
  interface RequirementQuestionFieldRefs {
    readonly id: FieldRef<"RequirementQuestion", 'String'>
    readonly projectId: FieldRef<"RequirementQuestion", 'String'>
    readonly requirementId: FieldRef<"RequirementQuestion", 'String'>
    readonly question: FieldRef<"RequirementQuestion", 'String'>
    readonly answer: FieldRef<"RequirementQuestion", 'String'>
    readonly status: FieldRef<"RequirementQuestion", 'QuestionStatus'>
    readonly priority: FieldRef<"RequirementQuestion", 'QuestionPriority'>
    readonly clarified: FieldRef<"RequirementQuestion", 'Boolean'>
    readonly agentId: FieldRef<"RequirementQuestion", 'String'>
    readonly createdAt: FieldRef<"RequirementQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"RequirementQuestion", 'DateTime'>
    readonly answeredAt: FieldRef<"RequirementQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RequirementQuestion findUnique
   */
  export type RequirementQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    /**
     * Filter, which RequirementQuestion to fetch.
     */
    where: RequirementQuestionWhereUniqueInput
  }

  /**
   * RequirementQuestion findUniqueOrThrow
   */
  export type RequirementQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    /**
     * Filter, which RequirementQuestion to fetch.
     */
    where: RequirementQuestionWhereUniqueInput
  }

  /**
   * RequirementQuestion findFirst
   */
  export type RequirementQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    /**
     * Filter, which RequirementQuestion to fetch.
     */
    where?: RequirementQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementQuestions to fetch.
     */
    orderBy?: RequirementQuestionOrderByWithRelationInput | RequirementQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequirementQuestions.
     */
    cursor?: RequirementQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequirementQuestions.
     */
    distinct?: RequirementQuestionScalarFieldEnum | RequirementQuestionScalarFieldEnum[]
  }

  /**
   * RequirementQuestion findFirstOrThrow
   */
  export type RequirementQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    /**
     * Filter, which RequirementQuestion to fetch.
     */
    where?: RequirementQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementQuestions to fetch.
     */
    orderBy?: RequirementQuestionOrderByWithRelationInput | RequirementQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequirementQuestions.
     */
    cursor?: RequirementQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequirementQuestions.
     */
    distinct?: RequirementQuestionScalarFieldEnum | RequirementQuestionScalarFieldEnum[]
  }

  /**
   * RequirementQuestion findMany
   */
  export type RequirementQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    /**
     * Filter, which RequirementQuestions to fetch.
     */
    where?: RequirementQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementQuestions to fetch.
     */
    orderBy?: RequirementQuestionOrderByWithRelationInput | RequirementQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequirementQuestions.
     */
    cursor?: RequirementQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementQuestions.
     */
    skip?: number
    distinct?: RequirementQuestionScalarFieldEnum | RequirementQuestionScalarFieldEnum[]
  }

  /**
   * RequirementQuestion create
   */
  export type RequirementQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a RequirementQuestion.
     */
    data: XOR<RequirementQuestionCreateInput, RequirementQuestionUncheckedCreateInput>
  }

  /**
   * RequirementQuestion createMany
   */
  export type RequirementQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequirementQuestions.
     */
    data: RequirementQuestionCreateManyInput | RequirementQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequirementQuestion createManyAndReturn
   */
  export type RequirementQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many RequirementQuestions.
     */
    data: RequirementQuestionCreateManyInput | RequirementQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequirementQuestion update
   */
  export type RequirementQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a RequirementQuestion.
     */
    data: XOR<RequirementQuestionUpdateInput, RequirementQuestionUncheckedUpdateInput>
    /**
     * Choose, which RequirementQuestion to update.
     */
    where: RequirementQuestionWhereUniqueInput
  }

  /**
   * RequirementQuestion updateMany
   */
  export type RequirementQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequirementQuestions.
     */
    data: XOR<RequirementQuestionUpdateManyMutationInput, RequirementQuestionUncheckedUpdateManyInput>
    /**
     * Filter which RequirementQuestions to update
     */
    where?: RequirementQuestionWhereInput
    /**
     * Limit how many RequirementQuestions to update.
     */
    limit?: number
  }

  /**
   * RequirementQuestion updateManyAndReturn
   */
  export type RequirementQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * The data used to update RequirementQuestions.
     */
    data: XOR<RequirementQuestionUpdateManyMutationInput, RequirementQuestionUncheckedUpdateManyInput>
    /**
     * Filter which RequirementQuestions to update
     */
    where?: RequirementQuestionWhereInput
    /**
     * Limit how many RequirementQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequirementQuestion upsert
   */
  export type RequirementQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the RequirementQuestion to update in case it exists.
     */
    where: RequirementQuestionWhereUniqueInput
    /**
     * In case the RequirementQuestion found by the `where` argument doesn't exist, create a new RequirementQuestion with this data.
     */
    create: XOR<RequirementQuestionCreateInput, RequirementQuestionUncheckedCreateInput>
    /**
     * In case the RequirementQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequirementQuestionUpdateInput, RequirementQuestionUncheckedUpdateInput>
  }

  /**
   * RequirementQuestion delete
   */
  export type RequirementQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
    /**
     * Filter which RequirementQuestion to delete.
     */
    where: RequirementQuestionWhereUniqueInput
  }

  /**
   * RequirementQuestion deleteMany
   */
  export type RequirementQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequirementQuestions to delete
     */
    where?: RequirementQuestionWhereInput
    /**
     * Limit how many RequirementQuestions to delete.
     */
    limit?: number
  }

  /**
   * RequirementQuestion without action
   */
  export type RequirementQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementQuestion
     */
    select?: RequirementQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementQuestion
     */
    omit?: RequirementQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementQuestionInclude<ExtArgs> | null
  }


  /**
   * Model RequirementAttachment
   */

  export type AggregateRequirementAttachment = {
    _count: RequirementAttachmentCountAggregateOutputType | null
    _avg: RequirementAttachmentAvgAggregateOutputType | null
    _sum: RequirementAttachmentSumAggregateOutputType | null
    _min: RequirementAttachmentMinAggregateOutputType | null
    _max: RequirementAttachmentMaxAggregateOutputType | null
  }

  export type RequirementAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type RequirementAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type RequirementAttachmentMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    requirementId: string | null
    fileName: string | null
    fileUrl: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type RequirementAttachmentMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    requirementId: string | null
    fileName: string | null
    fileUrl: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type RequirementAttachmentCountAggregateOutputType = {
    id: number
    projectId: number
    requirementId: number
    fileName: number
    fileUrl: number
    fileSize: number
    mimeType: number
    createdAt: number
    userId: number
    _all: number
  }


  export type RequirementAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type RequirementAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type RequirementAttachmentMinAggregateInputType = {
    id?: true
    projectId?: true
    requirementId?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    userId?: true
  }

  export type RequirementAttachmentMaxAggregateInputType = {
    id?: true
    projectId?: true
    requirementId?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    userId?: true
  }

  export type RequirementAttachmentCountAggregateInputType = {
    id?: true
    projectId?: true
    requirementId?: true
    fileName?: true
    fileUrl?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type RequirementAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequirementAttachment to aggregate.
     */
    where?: RequirementAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementAttachments to fetch.
     */
    orderBy?: RequirementAttachmentOrderByWithRelationInput | RequirementAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequirementAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RequirementAttachments
    **/
    _count?: true | RequirementAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequirementAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequirementAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequirementAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequirementAttachmentMaxAggregateInputType
  }

  export type GetRequirementAttachmentAggregateType<T extends RequirementAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRequirementAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequirementAttachment[P]>
      : GetScalarType<T[P], AggregateRequirementAttachment[P]>
  }




  export type RequirementAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequirementAttachmentWhereInput
    orderBy?: RequirementAttachmentOrderByWithAggregationInput | RequirementAttachmentOrderByWithAggregationInput[]
    by: RequirementAttachmentScalarFieldEnum[] | RequirementAttachmentScalarFieldEnum
    having?: RequirementAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequirementAttachmentCountAggregateInputType | true
    _avg?: RequirementAttachmentAvgAggregateInputType
    _sum?: RequirementAttachmentSumAggregateInputType
    _min?: RequirementAttachmentMinAggregateInputType
    _max?: RequirementAttachmentMaxAggregateInputType
  }

  export type RequirementAttachmentGroupByOutputType = {
    id: string
    projectId: string
    requirementId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt: Date
    userId: string | null
    _count: RequirementAttachmentCountAggregateOutputType | null
    _avg: RequirementAttachmentAvgAggregateOutputType | null
    _sum: RequirementAttachmentSumAggregateOutputType | null
    _min: RequirementAttachmentMinAggregateOutputType | null
    _max: RequirementAttachmentMaxAggregateOutputType | null
  }

  type GetRequirementAttachmentGroupByPayload<T extends RequirementAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequirementAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequirementAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequirementAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], RequirementAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type RequirementAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    requirementId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    User?: boolean | RequirementAttachment$UserArgs<ExtArgs>
  }, ExtArgs["result"]["requirementAttachment"]>

  export type RequirementAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    requirementId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    User?: boolean | RequirementAttachment$UserArgs<ExtArgs>
  }, ExtArgs["result"]["requirementAttachment"]>

  export type RequirementAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    requirementId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    userId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    User?: boolean | RequirementAttachment$UserArgs<ExtArgs>
  }, ExtArgs["result"]["requirementAttachment"]>

  export type RequirementAttachmentSelectScalar = {
    id?: boolean
    projectId?: boolean
    requirementId?: boolean
    fileName?: boolean
    fileUrl?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type RequirementAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "requirementId" | "fileName" | "fileUrl" | "fileSize" | "mimeType" | "createdAt" | "userId", ExtArgs["result"]["requirementAttachment"]>
  export type RequirementAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    User?: boolean | RequirementAttachment$UserArgs<ExtArgs>
  }
  export type RequirementAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    User?: boolean | RequirementAttachment$UserArgs<ExtArgs>
  }
  export type RequirementAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    requirement?: boolean | RequirementDefaultArgs<ExtArgs>
    User?: boolean | RequirementAttachment$UserArgs<ExtArgs>
  }

  export type $RequirementAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RequirementAttachment"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      requirement: Prisma.$RequirementPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      requirementId: string
      fileName: string
      fileUrl: string
      fileSize: number
      mimeType: string
      createdAt: Date
      userId: string | null
    }, ExtArgs["result"]["requirementAttachment"]>
    composites: {}
  }

  type RequirementAttachmentGetPayload<S extends boolean | null | undefined | RequirementAttachmentDefaultArgs> = $Result.GetResult<Prisma.$RequirementAttachmentPayload, S>

  type RequirementAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequirementAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequirementAttachmentCountAggregateInputType | true
    }

  export interface RequirementAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RequirementAttachment'], meta: { name: 'RequirementAttachment' } }
    /**
     * Find zero or one RequirementAttachment that matches the filter.
     * @param {RequirementAttachmentFindUniqueArgs} args - Arguments to find a RequirementAttachment
     * @example
     * // Get one RequirementAttachment
     * const requirementAttachment = await prisma.requirementAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequirementAttachmentFindUniqueArgs>(args: SelectSubset<T, RequirementAttachmentFindUniqueArgs<ExtArgs>>): Prisma__RequirementAttachmentClient<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RequirementAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequirementAttachmentFindUniqueOrThrowArgs} args - Arguments to find a RequirementAttachment
     * @example
     * // Get one RequirementAttachment
     * const requirementAttachment = await prisma.requirementAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequirementAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RequirementAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequirementAttachmentClient<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequirementAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAttachmentFindFirstArgs} args - Arguments to find a RequirementAttachment
     * @example
     * // Get one RequirementAttachment
     * const requirementAttachment = await prisma.requirementAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequirementAttachmentFindFirstArgs>(args?: SelectSubset<T, RequirementAttachmentFindFirstArgs<ExtArgs>>): Prisma__RequirementAttachmentClient<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RequirementAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAttachmentFindFirstOrThrowArgs} args - Arguments to find a RequirementAttachment
     * @example
     * // Get one RequirementAttachment
     * const requirementAttachment = await prisma.requirementAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequirementAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RequirementAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequirementAttachmentClient<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RequirementAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RequirementAttachments
     * const requirementAttachments = await prisma.requirementAttachment.findMany()
     * 
     * // Get first 10 RequirementAttachments
     * const requirementAttachments = await prisma.requirementAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requirementAttachmentWithIdOnly = await prisma.requirementAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequirementAttachmentFindManyArgs>(args?: SelectSubset<T, RequirementAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RequirementAttachment.
     * @param {RequirementAttachmentCreateArgs} args - Arguments to create a RequirementAttachment.
     * @example
     * // Create one RequirementAttachment
     * const RequirementAttachment = await prisma.requirementAttachment.create({
     *   data: {
     *     // ... data to create a RequirementAttachment
     *   }
     * })
     * 
     */
    create<T extends RequirementAttachmentCreateArgs>(args: SelectSubset<T, RequirementAttachmentCreateArgs<ExtArgs>>): Prisma__RequirementAttachmentClient<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RequirementAttachments.
     * @param {RequirementAttachmentCreateManyArgs} args - Arguments to create many RequirementAttachments.
     * @example
     * // Create many RequirementAttachments
     * const requirementAttachment = await prisma.requirementAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequirementAttachmentCreateManyArgs>(args?: SelectSubset<T, RequirementAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RequirementAttachments and returns the data saved in the database.
     * @param {RequirementAttachmentCreateManyAndReturnArgs} args - Arguments to create many RequirementAttachments.
     * @example
     * // Create many RequirementAttachments
     * const requirementAttachment = await prisma.requirementAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RequirementAttachments and only return the `id`
     * const requirementAttachmentWithIdOnly = await prisma.requirementAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequirementAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RequirementAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RequirementAttachment.
     * @param {RequirementAttachmentDeleteArgs} args - Arguments to delete one RequirementAttachment.
     * @example
     * // Delete one RequirementAttachment
     * const RequirementAttachment = await prisma.requirementAttachment.delete({
     *   where: {
     *     // ... filter to delete one RequirementAttachment
     *   }
     * })
     * 
     */
    delete<T extends RequirementAttachmentDeleteArgs>(args: SelectSubset<T, RequirementAttachmentDeleteArgs<ExtArgs>>): Prisma__RequirementAttachmentClient<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RequirementAttachment.
     * @param {RequirementAttachmentUpdateArgs} args - Arguments to update one RequirementAttachment.
     * @example
     * // Update one RequirementAttachment
     * const requirementAttachment = await prisma.requirementAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequirementAttachmentUpdateArgs>(args: SelectSubset<T, RequirementAttachmentUpdateArgs<ExtArgs>>): Prisma__RequirementAttachmentClient<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RequirementAttachments.
     * @param {RequirementAttachmentDeleteManyArgs} args - Arguments to filter RequirementAttachments to delete.
     * @example
     * // Delete a few RequirementAttachments
     * const { count } = await prisma.requirementAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequirementAttachmentDeleteManyArgs>(args?: SelectSubset<T, RequirementAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequirementAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RequirementAttachments
     * const requirementAttachment = await prisma.requirementAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequirementAttachmentUpdateManyArgs>(args: SelectSubset<T, RequirementAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RequirementAttachments and returns the data updated in the database.
     * @param {RequirementAttachmentUpdateManyAndReturnArgs} args - Arguments to update many RequirementAttachments.
     * @example
     * // Update many RequirementAttachments
     * const requirementAttachment = await prisma.requirementAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RequirementAttachments and only return the `id`
     * const requirementAttachmentWithIdOnly = await prisma.requirementAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequirementAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, RequirementAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RequirementAttachment.
     * @param {RequirementAttachmentUpsertArgs} args - Arguments to update or create a RequirementAttachment.
     * @example
     * // Update or create a RequirementAttachment
     * const requirementAttachment = await prisma.requirementAttachment.upsert({
     *   create: {
     *     // ... data to create a RequirementAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RequirementAttachment we want to update
     *   }
     * })
     */
    upsert<T extends RequirementAttachmentUpsertArgs>(args: SelectSubset<T, RequirementAttachmentUpsertArgs<ExtArgs>>): Prisma__RequirementAttachmentClient<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RequirementAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAttachmentCountArgs} args - Arguments to filter RequirementAttachments to count.
     * @example
     * // Count the number of RequirementAttachments
     * const count = await prisma.requirementAttachment.count({
     *   where: {
     *     // ... the filter for the RequirementAttachments we want to count
     *   }
     * })
    **/
    count<T extends RequirementAttachmentCountArgs>(
      args?: Subset<T, RequirementAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequirementAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RequirementAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequirementAttachmentAggregateArgs>(args: Subset<T, RequirementAttachmentAggregateArgs>): Prisma.PrismaPromise<GetRequirementAttachmentAggregateType<T>>

    /**
     * Group by RequirementAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequirementAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequirementAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequirementAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: RequirementAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequirementAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequirementAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RequirementAttachment model
   */
  readonly fields: RequirementAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RequirementAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequirementAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    requirement<T extends RequirementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequirementDefaultArgs<ExtArgs>>): Prisma__RequirementClient<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends RequirementAttachment$UserArgs<ExtArgs> = {}>(args?: Subset<T, RequirementAttachment$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RequirementAttachment model
   */
  interface RequirementAttachmentFieldRefs {
    readonly id: FieldRef<"RequirementAttachment", 'String'>
    readonly projectId: FieldRef<"RequirementAttachment", 'String'>
    readonly requirementId: FieldRef<"RequirementAttachment", 'String'>
    readonly fileName: FieldRef<"RequirementAttachment", 'String'>
    readonly fileUrl: FieldRef<"RequirementAttachment", 'String'>
    readonly fileSize: FieldRef<"RequirementAttachment", 'Int'>
    readonly mimeType: FieldRef<"RequirementAttachment", 'String'>
    readonly createdAt: FieldRef<"RequirementAttachment", 'DateTime'>
    readonly userId: FieldRef<"RequirementAttachment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RequirementAttachment findUnique
   */
  export type RequirementAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementAttachment to fetch.
     */
    where: RequirementAttachmentWhereUniqueInput
  }

  /**
   * RequirementAttachment findUniqueOrThrow
   */
  export type RequirementAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementAttachment to fetch.
     */
    where: RequirementAttachmentWhereUniqueInput
  }

  /**
   * RequirementAttachment findFirst
   */
  export type RequirementAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementAttachment to fetch.
     */
    where?: RequirementAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementAttachments to fetch.
     */
    orderBy?: RequirementAttachmentOrderByWithRelationInput | RequirementAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequirementAttachments.
     */
    cursor?: RequirementAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequirementAttachments.
     */
    distinct?: RequirementAttachmentScalarFieldEnum | RequirementAttachmentScalarFieldEnum[]
  }

  /**
   * RequirementAttachment findFirstOrThrow
   */
  export type RequirementAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementAttachment to fetch.
     */
    where?: RequirementAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementAttachments to fetch.
     */
    orderBy?: RequirementAttachmentOrderByWithRelationInput | RequirementAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RequirementAttachments.
     */
    cursor?: RequirementAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RequirementAttachments.
     */
    distinct?: RequirementAttachmentScalarFieldEnum | RequirementAttachmentScalarFieldEnum[]
  }

  /**
   * RequirementAttachment findMany
   */
  export type RequirementAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which RequirementAttachments to fetch.
     */
    where?: RequirementAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RequirementAttachments to fetch.
     */
    orderBy?: RequirementAttachmentOrderByWithRelationInput | RequirementAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RequirementAttachments.
     */
    cursor?: RequirementAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RequirementAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RequirementAttachments.
     */
    skip?: number
    distinct?: RequirementAttachmentScalarFieldEnum | RequirementAttachmentScalarFieldEnum[]
  }

  /**
   * RequirementAttachment create
   */
  export type RequirementAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RequirementAttachment.
     */
    data: XOR<RequirementAttachmentCreateInput, RequirementAttachmentUncheckedCreateInput>
  }

  /**
   * RequirementAttachment createMany
   */
  export type RequirementAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RequirementAttachments.
     */
    data: RequirementAttachmentCreateManyInput | RequirementAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RequirementAttachment createManyAndReturn
   */
  export type RequirementAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many RequirementAttachments.
     */
    data: RequirementAttachmentCreateManyInput | RequirementAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequirementAttachment update
   */
  export type RequirementAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RequirementAttachment.
     */
    data: XOR<RequirementAttachmentUpdateInput, RequirementAttachmentUncheckedUpdateInput>
    /**
     * Choose, which RequirementAttachment to update.
     */
    where: RequirementAttachmentWhereUniqueInput
  }

  /**
   * RequirementAttachment updateMany
   */
  export type RequirementAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RequirementAttachments.
     */
    data: XOR<RequirementAttachmentUpdateManyMutationInput, RequirementAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which RequirementAttachments to update
     */
    where?: RequirementAttachmentWhereInput
    /**
     * Limit how many RequirementAttachments to update.
     */
    limit?: number
  }

  /**
   * RequirementAttachment updateManyAndReturn
   */
  export type RequirementAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update RequirementAttachments.
     */
    data: XOR<RequirementAttachmentUpdateManyMutationInput, RequirementAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which RequirementAttachments to update
     */
    where?: RequirementAttachmentWhereInput
    /**
     * Limit how many RequirementAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RequirementAttachment upsert
   */
  export type RequirementAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RequirementAttachment to update in case it exists.
     */
    where: RequirementAttachmentWhereUniqueInput
    /**
     * In case the RequirementAttachment found by the `where` argument doesn't exist, create a new RequirementAttachment with this data.
     */
    create: XOR<RequirementAttachmentCreateInput, RequirementAttachmentUncheckedCreateInput>
    /**
     * In case the RequirementAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequirementAttachmentUpdateInput, RequirementAttachmentUncheckedUpdateInput>
  }

  /**
   * RequirementAttachment delete
   */
  export type RequirementAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    /**
     * Filter which RequirementAttachment to delete.
     */
    where: RequirementAttachmentWhereUniqueInput
  }

  /**
   * RequirementAttachment deleteMany
   */
  export type RequirementAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RequirementAttachments to delete
     */
    where?: RequirementAttachmentWhereInput
    /**
     * Limit how many RequirementAttachments to delete.
     */
    limit?: number
  }

  /**
   * RequirementAttachment.User
   */
  export type RequirementAttachment$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RequirementAttachment without action
   */
  export type RequirementAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model Roadmap
   */

  export type AggregateRoadmap = {
    _count: RoadmapCountAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  export type RoadmapMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    startDate: number
    endDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoadmapMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    startDate?: true
    endDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoadmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmap to aggregate.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roadmaps
    **/
    _count?: true | RoadmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapMaxAggregateInputType
  }

  export type GetRoadmapAggregateType<T extends RoadmapAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmap[P]>
      : GetScalarType<T[P], AggregateRoadmap[P]>
  }




  export type RoadmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapWhereInput
    orderBy?: RoadmapOrderByWithAggregationInput | RoadmapOrderByWithAggregationInput[]
    by: RoadmapScalarFieldEnum[] | RoadmapScalarFieldEnum
    having?: RoadmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapCountAggregateInputType | true
    _min?: RoadmapMinAggregateInputType
    _max?: RoadmapMaxAggregateInputType
  }

  export type RoadmapGroupByOutputType = {
    id: string
    projectId: string
    name: string
    description: string | null
    startDate: Date
    endDate: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: RoadmapCountAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  type GetRoadmapGroupByPayload<T extends RoadmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    milestones?: boolean | Roadmap$milestonesArgs<ExtArgs>
    versions?: boolean | Roadmap$versionsArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoadmapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "description" | "startDate" | "endDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["roadmap"]>
  export type RoadmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    milestones?: boolean | Roadmap$milestonesArgs<ExtArgs>
    versions?: boolean | Roadmap$versionsArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadmapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type RoadmapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $RoadmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roadmap"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      milestones: Prisma.$MilestonePayload<ExtArgs>[]
      versions: Prisma.$VersionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      description: string | null
      startDate: Date
      endDate: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roadmap"]>
    composites: {}
  }

  type RoadmapGetPayload<S extends boolean | null | undefined | RoadmapDefaultArgs> = $Result.GetResult<Prisma.$RoadmapPayload, S>

  type RoadmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoadmapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapCountAggregateInputType | true
    }

  export interface RoadmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roadmap'], meta: { name: 'Roadmap' } }
    /**
     * Find zero or one Roadmap that matches the filter.
     * @param {RoadmapFindUniqueArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapFindUniqueArgs>(args: SelectSubset<T, RoadmapFindUniqueArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roadmap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoadmapFindUniqueOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roadmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapFindFirstArgs>(args?: SelectSubset<T, RoadmapFindFirstArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roadmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roadmaps
     * const roadmaps = await prisma.roadmap.findMany()
     * 
     * // Get first 10 Roadmaps
     * const roadmaps = await prisma.roadmap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapFindManyArgs>(args?: SelectSubset<T, RoadmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roadmap.
     * @param {RoadmapCreateArgs} args - Arguments to create a Roadmap.
     * @example
     * // Create one Roadmap
     * const Roadmap = await prisma.roadmap.create({
     *   data: {
     *     // ... data to create a Roadmap
     *   }
     * })
     * 
     */
    create<T extends RoadmapCreateArgs>(args: SelectSubset<T, RoadmapCreateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roadmaps.
     * @param {RoadmapCreateManyArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapCreateManyArgs>(args?: SelectSubset<T, RoadmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roadmaps and returns the data saved in the database.
     * @param {RoadmapCreateManyAndReturnArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roadmaps and only return the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roadmap.
     * @param {RoadmapDeleteArgs} args - Arguments to delete one Roadmap.
     * @example
     * // Delete one Roadmap
     * const Roadmap = await prisma.roadmap.delete({
     *   where: {
     *     // ... filter to delete one Roadmap
     *   }
     * })
     * 
     */
    delete<T extends RoadmapDeleteArgs>(args: SelectSubset<T, RoadmapDeleteArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roadmap.
     * @param {RoadmapUpdateArgs} args - Arguments to update one Roadmap.
     * @example
     * // Update one Roadmap
     * const roadmap = await prisma.roadmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapUpdateArgs>(args: SelectSubset<T, RoadmapUpdateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roadmaps.
     * @param {RoadmapDeleteManyArgs} args - Arguments to filter Roadmaps to delete.
     * @example
     * // Delete a few Roadmaps
     * const { count } = await prisma.roadmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapDeleteManyArgs>(args?: SelectSubset<T, RoadmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roadmaps
     * const roadmap = await prisma.roadmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapUpdateManyArgs>(args: SelectSubset<T, RoadmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps and returns the data updated in the database.
     * @param {RoadmapUpdateManyAndReturnArgs} args - Arguments to update many Roadmaps.
     * @example
     * // Update many Roadmaps
     * const roadmap = await prisma.roadmap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roadmaps and only return the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoadmapUpdateManyAndReturnArgs>(args: SelectSubset<T, RoadmapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roadmap.
     * @param {RoadmapUpsertArgs} args - Arguments to update or create a Roadmap.
     * @example
     * // Update or create a Roadmap
     * const roadmap = await prisma.roadmap.upsert({
     *   create: {
     *     // ... data to create a Roadmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roadmap we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapUpsertArgs>(args: SelectSubset<T, RoadmapUpsertArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapCountArgs} args - Arguments to filter Roadmaps to count.
     * @example
     * // Count the number of Roadmaps
     * const count = await prisma.roadmap.count({
     *   where: {
     *     // ... the filter for the Roadmaps we want to count
     *   }
     * })
    **/
    count<T extends RoadmapCountArgs>(
      args?: Subset<T, RoadmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapAggregateArgs>(args: Subset<T, RoadmapAggregateArgs>): Prisma.PrismaPromise<GetRoadmapAggregateType<T>>

    /**
     * Group by Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roadmap model
   */
  readonly fields: RoadmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roadmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    milestones<T extends Roadmap$milestonesArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$milestonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    versions<T extends Roadmap$versionsArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$versionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roadmap model
   */
  interface RoadmapFieldRefs {
    readonly id: FieldRef<"Roadmap", 'String'>
    readonly projectId: FieldRef<"Roadmap", 'String'>
    readonly name: FieldRef<"Roadmap", 'String'>
    readonly description: FieldRef<"Roadmap", 'String'>
    readonly startDate: FieldRef<"Roadmap", 'DateTime'>
    readonly endDate: FieldRef<"Roadmap", 'DateTime'>
    readonly status: FieldRef<"Roadmap", 'String'>
    readonly createdAt: FieldRef<"Roadmap", 'DateTime'>
    readonly updatedAt: FieldRef<"Roadmap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Roadmap findUnique
   */
  export type RoadmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findUniqueOrThrow
   */
  export type RoadmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findFirst
   */
  export type RoadmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findFirstOrThrow
   */
  export type RoadmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findMany
   */
  export type RoadmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmaps to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap create
   */
  export type RoadmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to create a Roadmap.
     */
    data: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
  }

  /**
   * Roadmap createMany
   */
  export type RoadmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roadmap createManyAndReturn
   */
  export type RoadmapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Roadmap update
   */
  export type RoadmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to update a Roadmap.
     */
    data: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
    /**
     * Choose, which Roadmap to update.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap updateMany
   */
  export type RoadmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roadmaps.
     */
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyInput>
    /**
     * Filter which Roadmaps to update
     */
    where?: RoadmapWhereInput
    /**
     * Limit how many Roadmaps to update.
     */
    limit?: number
  }

  /**
   * Roadmap updateManyAndReturn
   */
  export type RoadmapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * The data used to update Roadmaps.
     */
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyInput>
    /**
     * Filter which Roadmaps to update
     */
    where?: RoadmapWhereInput
    /**
     * Limit how many Roadmaps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Roadmap upsert
   */
  export type RoadmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The filter to search for the Roadmap to update in case it exists.
     */
    where: RoadmapWhereUniqueInput
    /**
     * In case the Roadmap found by the `where` argument doesn't exist, create a new Roadmap with this data.
     */
    create: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
    /**
     * In case the Roadmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
  }

  /**
   * Roadmap delete
   */
  export type RoadmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter which Roadmap to delete.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap deleteMany
   */
  export type RoadmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmaps to delete
     */
    where?: RoadmapWhereInput
    /**
     * Limit how many Roadmaps to delete.
     */
    limit?: number
  }

  /**
   * Roadmap.milestones
   */
  export type Roadmap$milestonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    cursor?: MilestoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Roadmap.versions
   */
  export type Roadmap$versionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    where?: VersionWhereInput
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    cursor?: VersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Roadmap without action
   */
  export type RoadmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
  }


  /**
   * Model Milestone
   */

  export type AggregateMilestone = {
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  export type MilestoneMinAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    name: string | null
    description: string | null
    targetDate: Date | null
    status: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MilestoneMaxAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    name: string | null
    description: string | null
    targetDate: Date | null
    status: string | null
    priority: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MilestoneCountAggregateOutputType = {
    id: number
    roadmapId: number
    name: number
    description: number
    targetDate: number
    status: number
    priority: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MilestoneMinAggregateInputType = {
    id?: true
    roadmapId?: true
    name?: true
    description?: true
    targetDate?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MilestoneMaxAggregateInputType = {
    id?: true
    roadmapId?: true
    name?: true
    description?: true
    targetDate?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MilestoneCountAggregateInputType = {
    id?: true
    roadmapId?: true
    name?: true
    description?: true
    targetDate?: true
    status?: true
    priority?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MilestoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestone to aggregate.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Milestones
    **/
    _count?: true | MilestoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MilestoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MilestoneMaxAggregateInputType
  }

  export type GetMilestoneAggregateType<T extends MilestoneAggregateArgs> = {
        [P in keyof T & keyof AggregateMilestone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMilestone[P]>
      : GetScalarType<T[P], AggregateMilestone[P]>
  }




  export type MilestoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MilestoneWhereInput
    orderBy?: MilestoneOrderByWithAggregationInput | MilestoneOrderByWithAggregationInput[]
    by: MilestoneScalarFieldEnum[] | MilestoneScalarFieldEnum
    having?: MilestoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MilestoneCountAggregateInputType | true
    _min?: MilestoneMinAggregateInputType
    _max?: MilestoneMaxAggregateInputType
  }

  export type MilestoneGroupByOutputType = {
    id: string
    roadmapId: string
    name: string
    description: string | null
    targetDate: Date
    status: string
    priority: string
    createdAt: Date
    updatedAt: Date
    _count: MilestoneCountAggregateOutputType | null
    _min: MilestoneMinAggregateOutputType | null
    _max: MilestoneMaxAggregateOutputType | null
  }

  type GetMilestoneGroupByPayload<T extends MilestoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MilestoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MilestoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
            : GetScalarType<T[P], MilestoneGroupByOutputType[P]>
        }
      >
    >


  export type MilestoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    name?: boolean
    description?: boolean
    targetDate?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    features?: boolean | Milestone$featuresArgs<ExtArgs>
    _count?: boolean | MilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    name?: boolean
    description?: boolean
    targetDate?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    name?: boolean
    description?: boolean
    targetDate?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["milestone"]>

  export type MilestoneSelectScalar = {
    id?: boolean
    roadmapId?: boolean
    name?: boolean
    description?: boolean
    targetDate?: boolean
    status?: boolean
    priority?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MilestoneOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roadmapId" | "name" | "description" | "targetDate" | "status" | "priority" | "createdAt" | "updatedAt", ExtArgs["result"]["milestone"]>
  export type MilestoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    features?: boolean | Milestone$featuresArgs<ExtArgs>
    _count?: boolean | MilestoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }
  export type MilestoneIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }

  export type $MilestonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Milestone"
    objects: {
      roadmap: Prisma.$RoadmapPayload<ExtArgs>
      features: Prisma.$FeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roadmapId: string
      name: string
      description: string | null
      targetDate: Date
      status: string
      priority: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["milestone"]>
    composites: {}
  }

  type MilestoneGetPayload<S extends boolean | null | undefined | MilestoneDefaultArgs> = $Result.GetResult<Prisma.$MilestonePayload, S>

  type MilestoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MilestoneFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MilestoneCountAggregateInputType | true
    }

  export interface MilestoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Milestone'], meta: { name: 'Milestone' } }
    /**
     * Find zero or one Milestone that matches the filter.
     * @param {MilestoneFindUniqueArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MilestoneFindUniqueArgs>(args: SelectSubset<T, MilestoneFindUniqueArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Milestone that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MilestoneFindUniqueOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MilestoneFindUniqueOrThrowArgs>(args: SelectSubset<T, MilestoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MilestoneFindFirstArgs>(args?: SelectSubset<T, MilestoneFindFirstArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Milestone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindFirstOrThrowArgs} args - Arguments to find a Milestone
     * @example
     * // Get one Milestone
     * const milestone = await prisma.milestone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MilestoneFindFirstOrThrowArgs>(args?: SelectSubset<T, MilestoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Milestones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Milestones
     * const milestones = await prisma.milestone.findMany()
     * 
     * // Get first 10 Milestones
     * const milestones = await prisma.milestone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const milestoneWithIdOnly = await prisma.milestone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MilestoneFindManyArgs>(args?: SelectSubset<T, MilestoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Milestone.
     * @param {MilestoneCreateArgs} args - Arguments to create a Milestone.
     * @example
     * // Create one Milestone
     * const Milestone = await prisma.milestone.create({
     *   data: {
     *     // ... data to create a Milestone
     *   }
     * })
     * 
     */
    create<T extends MilestoneCreateArgs>(args: SelectSubset<T, MilestoneCreateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Milestones.
     * @param {MilestoneCreateManyArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MilestoneCreateManyArgs>(args?: SelectSubset<T, MilestoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Milestones and returns the data saved in the database.
     * @param {MilestoneCreateManyAndReturnArgs} args - Arguments to create many Milestones.
     * @example
     * // Create many Milestones
     * const milestone = await prisma.milestone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MilestoneCreateManyAndReturnArgs>(args?: SelectSubset<T, MilestoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Milestone.
     * @param {MilestoneDeleteArgs} args - Arguments to delete one Milestone.
     * @example
     * // Delete one Milestone
     * const Milestone = await prisma.milestone.delete({
     *   where: {
     *     // ... filter to delete one Milestone
     *   }
     * })
     * 
     */
    delete<T extends MilestoneDeleteArgs>(args: SelectSubset<T, MilestoneDeleteArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Milestone.
     * @param {MilestoneUpdateArgs} args - Arguments to update one Milestone.
     * @example
     * // Update one Milestone
     * const milestone = await prisma.milestone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MilestoneUpdateArgs>(args: SelectSubset<T, MilestoneUpdateArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Milestones.
     * @param {MilestoneDeleteManyArgs} args - Arguments to filter Milestones to delete.
     * @example
     * // Delete a few Milestones
     * const { count } = await prisma.milestone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MilestoneDeleteManyArgs>(args?: SelectSubset<T, MilestoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MilestoneUpdateManyArgs>(args: SelectSubset<T, MilestoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Milestones and returns the data updated in the database.
     * @param {MilestoneUpdateManyAndReturnArgs} args - Arguments to update many Milestones.
     * @example
     * // Update many Milestones
     * const milestone = await prisma.milestone.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Milestones and only return the `id`
     * const milestoneWithIdOnly = await prisma.milestone.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MilestoneUpdateManyAndReturnArgs>(args: SelectSubset<T, MilestoneUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Milestone.
     * @param {MilestoneUpsertArgs} args - Arguments to update or create a Milestone.
     * @example
     * // Update or create a Milestone
     * const milestone = await prisma.milestone.upsert({
     *   create: {
     *     // ... data to create a Milestone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Milestone we want to update
     *   }
     * })
     */
    upsert<T extends MilestoneUpsertArgs>(args: SelectSubset<T, MilestoneUpsertArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Milestones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneCountArgs} args - Arguments to filter Milestones to count.
     * @example
     * // Count the number of Milestones
     * const count = await prisma.milestone.count({
     *   where: {
     *     // ... the filter for the Milestones we want to count
     *   }
     * })
    **/
    count<T extends MilestoneCountArgs>(
      args?: Subset<T, MilestoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MilestoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MilestoneAggregateArgs>(args: Subset<T, MilestoneAggregateArgs>): Prisma.PrismaPromise<GetMilestoneAggregateType<T>>

    /**
     * Group by Milestone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MilestoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MilestoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MilestoneGroupByArgs['orderBy'] }
        : { orderBy?: MilestoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MilestoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMilestoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Milestone model
   */
  readonly fields: MilestoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Milestone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MilestoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roadmap<T extends RoadmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapDefaultArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    features<T extends Milestone$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Milestone$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Milestone model
   */
  interface MilestoneFieldRefs {
    readonly id: FieldRef<"Milestone", 'String'>
    readonly roadmapId: FieldRef<"Milestone", 'String'>
    readonly name: FieldRef<"Milestone", 'String'>
    readonly description: FieldRef<"Milestone", 'String'>
    readonly targetDate: FieldRef<"Milestone", 'DateTime'>
    readonly status: FieldRef<"Milestone", 'String'>
    readonly priority: FieldRef<"Milestone", 'String'>
    readonly createdAt: FieldRef<"Milestone", 'DateTime'>
    readonly updatedAt: FieldRef<"Milestone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Milestone findUnique
   */
  export type MilestoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findUniqueOrThrow
   */
  export type MilestoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone findFirst
   */
  export type MilestoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findFirstOrThrow
   */
  export type MilestoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestone to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Milestones.
     */
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone findMany
   */
  export type MilestoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter, which Milestones to fetch.
     */
    where?: MilestoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Milestones to fetch.
     */
    orderBy?: MilestoneOrderByWithRelationInput | MilestoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Milestones.
     */
    cursor?: MilestoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Milestones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Milestones.
     */
    skip?: number
    distinct?: MilestoneScalarFieldEnum | MilestoneScalarFieldEnum[]
  }

  /**
   * Milestone create
   */
  export type MilestoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Milestone.
     */
    data: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
  }

  /**
   * Milestone createMany
   */
  export type MilestoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Milestone createManyAndReturn
   */
  export type MilestoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to create many Milestones.
     */
    data: MilestoneCreateManyInput | MilestoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone update
   */
  export type MilestoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Milestone.
     */
    data: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
    /**
     * Choose, which Milestone to update.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone updateMany
   */
  export type MilestoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
  }

  /**
   * Milestone updateManyAndReturn
   */
  export type MilestoneUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * The data used to update Milestones.
     */
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyInput>
    /**
     * Filter which Milestones to update
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Milestone upsert
   */
  export type MilestoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Milestone to update in case it exists.
     */
    where: MilestoneWhereUniqueInput
    /**
     * In case the Milestone found by the `where` argument doesn't exist, create a new Milestone with this data.
     */
    create: XOR<MilestoneCreateInput, MilestoneUncheckedCreateInput>
    /**
     * In case the Milestone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MilestoneUpdateInput, MilestoneUncheckedUpdateInput>
  }

  /**
   * Milestone delete
   */
  export type MilestoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    /**
     * Filter which Milestone to delete.
     */
    where: MilestoneWhereUniqueInput
  }

  /**
   * Milestone deleteMany
   */
  export type MilestoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Milestones to delete
     */
    where?: MilestoneWhereInput
    /**
     * Limit how many Milestones to delete.
     */
    limit?: number
  }

  /**
   * Milestone.features
   */
  export type Milestone$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    cursor?: FeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Milestone without action
   */
  export type MilestoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
  }


  /**
   * Model Version
   */

  export type AggregateVersion = {
    _count: VersionCountAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  export type VersionMinAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    name: string | null
    description: string | null
    releaseDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VersionMaxAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    name: string | null
    description: string | null
    releaseDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VersionCountAggregateOutputType = {
    id: number
    roadmapId: number
    name: number
    description: number
    releaseDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VersionMinAggregateInputType = {
    id?: true
    roadmapId?: true
    name?: true
    description?: true
    releaseDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VersionMaxAggregateInputType = {
    id?: true
    roadmapId?: true
    name?: true
    description?: true
    releaseDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VersionCountAggregateInputType = {
    id?: true
    roadmapId?: true
    name?: true
    description?: true
    releaseDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VersionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Version to aggregate.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Versions
    **/
    _count?: true | VersionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VersionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VersionMaxAggregateInputType
  }

  export type GetVersionAggregateType<T extends VersionAggregateArgs> = {
        [P in keyof T & keyof AggregateVersion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVersion[P]>
      : GetScalarType<T[P], AggregateVersion[P]>
  }




  export type VersionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VersionWhereInput
    orderBy?: VersionOrderByWithAggregationInput | VersionOrderByWithAggregationInput[]
    by: VersionScalarFieldEnum[] | VersionScalarFieldEnum
    having?: VersionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VersionCountAggregateInputType | true
    _min?: VersionMinAggregateInputType
    _max?: VersionMaxAggregateInputType
  }

  export type VersionGroupByOutputType = {
    id: string
    roadmapId: string
    name: string
    description: string | null
    releaseDate: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: VersionCountAggregateOutputType | null
    _min: VersionMinAggregateOutputType | null
    _max: VersionMaxAggregateOutputType | null
  }

  type GetVersionGroupByPayload<T extends VersionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VersionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VersionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VersionGroupByOutputType[P]>
            : GetScalarType<T[P], VersionGroupByOutputType[P]>
        }
      >
    >


  export type VersionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    name?: boolean
    description?: boolean
    releaseDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    features?: boolean | Version$featuresArgs<ExtArgs>
    _count?: boolean | VersionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["version"]>

  export type VersionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    name?: boolean
    description?: boolean
    releaseDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["version"]>

  export type VersionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    name?: boolean
    description?: boolean
    releaseDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["version"]>

  export type VersionSelectScalar = {
    id?: boolean
    roadmapId?: boolean
    name?: boolean
    description?: boolean
    releaseDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VersionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roadmapId" | "name" | "description" | "releaseDate" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["version"]>
  export type VersionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    features?: boolean | Version$featuresArgs<ExtArgs>
    _count?: boolean | VersionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VersionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }
  export type VersionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }

  export type $VersionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Version"
    objects: {
      roadmap: Prisma.$RoadmapPayload<ExtArgs>
      features: Prisma.$FeaturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roadmapId: string
      name: string
      description: string | null
      releaseDate: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["version"]>
    composites: {}
  }

  type VersionGetPayload<S extends boolean | null | undefined | VersionDefaultArgs> = $Result.GetResult<Prisma.$VersionPayload, S>

  type VersionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VersionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VersionCountAggregateInputType | true
    }

  export interface VersionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Version'], meta: { name: 'Version' } }
    /**
     * Find zero or one Version that matches the filter.
     * @param {VersionFindUniqueArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VersionFindUniqueArgs>(args: SelectSubset<T, VersionFindUniqueArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Version that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VersionFindUniqueOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VersionFindUniqueOrThrowArgs>(args: SelectSubset<T, VersionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Version that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VersionFindFirstArgs>(args?: SelectSubset<T, VersionFindFirstArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Version that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindFirstOrThrowArgs} args - Arguments to find a Version
     * @example
     * // Get one Version
     * const version = await prisma.version.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VersionFindFirstOrThrowArgs>(args?: SelectSubset<T, VersionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Versions
     * const versions = await prisma.version.findMany()
     * 
     * // Get first 10 Versions
     * const versions = await prisma.version.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const versionWithIdOnly = await prisma.version.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VersionFindManyArgs>(args?: SelectSubset<T, VersionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Version.
     * @param {VersionCreateArgs} args - Arguments to create a Version.
     * @example
     * // Create one Version
     * const Version = await prisma.version.create({
     *   data: {
     *     // ... data to create a Version
     *   }
     * })
     * 
     */
    create<T extends VersionCreateArgs>(args: SelectSubset<T, VersionCreateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Versions.
     * @param {VersionCreateManyArgs} args - Arguments to create many Versions.
     * @example
     * // Create many Versions
     * const version = await prisma.version.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VersionCreateManyArgs>(args?: SelectSubset<T, VersionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Versions and returns the data saved in the database.
     * @param {VersionCreateManyAndReturnArgs} args - Arguments to create many Versions.
     * @example
     * // Create many Versions
     * const version = await prisma.version.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Versions and only return the `id`
     * const versionWithIdOnly = await prisma.version.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VersionCreateManyAndReturnArgs>(args?: SelectSubset<T, VersionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Version.
     * @param {VersionDeleteArgs} args - Arguments to delete one Version.
     * @example
     * // Delete one Version
     * const Version = await prisma.version.delete({
     *   where: {
     *     // ... filter to delete one Version
     *   }
     * })
     * 
     */
    delete<T extends VersionDeleteArgs>(args: SelectSubset<T, VersionDeleteArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Version.
     * @param {VersionUpdateArgs} args - Arguments to update one Version.
     * @example
     * // Update one Version
     * const version = await prisma.version.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VersionUpdateArgs>(args: SelectSubset<T, VersionUpdateArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Versions.
     * @param {VersionDeleteManyArgs} args - Arguments to filter Versions to delete.
     * @example
     * // Delete a few Versions
     * const { count } = await prisma.version.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VersionDeleteManyArgs>(args?: SelectSubset<T, VersionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Versions
     * const version = await prisma.version.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VersionUpdateManyArgs>(args: SelectSubset<T, VersionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Versions and returns the data updated in the database.
     * @param {VersionUpdateManyAndReturnArgs} args - Arguments to update many Versions.
     * @example
     * // Update many Versions
     * const version = await prisma.version.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Versions and only return the `id`
     * const versionWithIdOnly = await prisma.version.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VersionUpdateManyAndReturnArgs>(args: SelectSubset<T, VersionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Version.
     * @param {VersionUpsertArgs} args - Arguments to update or create a Version.
     * @example
     * // Update or create a Version
     * const version = await prisma.version.upsert({
     *   create: {
     *     // ... data to create a Version
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Version we want to update
     *   }
     * })
     */
    upsert<T extends VersionUpsertArgs>(args: SelectSubset<T, VersionUpsertArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionCountArgs} args - Arguments to filter Versions to count.
     * @example
     * // Count the number of Versions
     * const count = await prisma.version.count({
     *   where: {
     *     // ... the filter for the Versions we want to count
     *   }
     * })
    **/
    count<T extends VersionCountArgs>(
      args?: Subset<T, VersionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VersionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VersionAggregateArgs>(args: Subset<T, VersionAggregateArgs>): Prisma.PrismaPromise<GetVersionAggregateType<T>>

    /**
     * Group by Version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VersionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VersionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VersionGroupByArgs['orderBy'] }
        : { orderBy?: VersionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VersionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVersionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Version model
   */
  readonly fields: VersionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Version.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VersionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roadmap<T extends RoadmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapDefaultArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    features<T extends Version$featuresArgs<ExtArgs> = {}>(args?: Subset<T, Version$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Version model
   */
  interface VersionFieldRefs {
    readonly id: FieldRef<"Version", 'String'>
    readonly roadmapId: FieldRef<"Version", 'String'>
    readonly name: FieldRef<"Version", 'String'>
    readonly description: FieldRef<"Version", 'String'>
    readonly releaseDate: FieldRef<"Version", 'DateTime'>
    readonly status: FieldRef<"Version", 'String'>
    readonly createdAt: FieldRef<"Version", 'DateTime'>
    readonly updatedAt: FieldRef<"Version", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Version findUnique
   */
  export type VersionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findUniqueOrThrow
   */
  export type VersionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version findFirst
   */
  export type VersionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findFirstOrThrow
   */
  export type VersionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Version to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Versions.
     */
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version findMany
   */
  export type VersionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter, which Versions to fetch.
     */
    where?: VersionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Versions to fetch.
     */
    orderBy?: VersionOrderByWithRelationInput | VersionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Versions.
     */
    cursor?: VersionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Versions.
     */
    skip?: number
    distinct?: VersionScalarFieldEnum | VersionScalarFieldEnum[]
  }

  /**
   * Version create
   */
  export type VersionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The data needed to create a Version.
     */
    data: XOR<VersionCreateInput, VersionUncheckedCreateInput>
  }

  /**
   * Version createMany
   */
  export type VersionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Versions.
     */
    data: VersionCreateManyInput | VersionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Version createManyAndReturn
   */
  export type VersionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * The data used to create many Versions.
     */
    data: VersionCreateManyInput | VersionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Version update
   */
  export type VersionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The data needed to update a Version.
     */
    data: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
    /**
     * Choose, which Version to update.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version updateMany
   */
  export type VersionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Versions.
     */
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyInput>
    /**
     * Filter which Versions to update
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to update.
     */
    limit?: number
  }

  /**
   * Version updateManyAndReturn
   */
  export type VersionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * The data used to update Versions.
     */
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyInput>
    /**
     * Filter which Versions to update
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Version upsert
   */
  export type VersionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * The filter to search for the Version to update in case it exists.
     */
    where: VersionWhereUniqueInput
    /**
     * In case the Version found by the `where` argument doesn't exist, create a new Version with this data.
     */
    create: XOR<VersionCreateInput, VersionUncheckedCreateInput>
    /**
     * In case the Version was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VersionUpdateInput, VersionUncheckedUpdateInput>
  }

  /**
   * Version delete
   */
  export type VersionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    /**
     * Filter which Version to delete.
     */
    where: VersionWhereUniqueInput
  }

  /**
   * Version deleteMany
   */
  export type VersionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Versions to delete
     */
    where?: VersionWhereInput
    /**
     * Limit how many Versions to delete.
     */
    limit?: number
  }

  /**
   * Version.features
   */
  export type Version$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    cursor?: FeatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Version without action
   */
  export type VersionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
  }


  /**
   * Model Feature
   */

  export type AggregateFeature = {
    _count: FeatureCountAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  export type FeatureMinAggregateOutputType = {
    id: string | null
    milestoneId: string | null
    versionId: string | null
    name: string | null
    description: string | null
    status: string | null
    priority: string | null
    effort: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureMaxAggregateOutputType = {
    id: string | null
    milestoneId: string | null
    versionId: string | null
    name: string | null
    description: string | null
    status: string | null
    priority: string | null
    effort: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeatureCountAggregateOutputType = {
    id: number
    milestoneId: number
    versionId: number
    name: number
    description: number
    status: number
    priority: number
    effort: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeatureMinAggregateInputType = {
    id?: true
    milestoneId?: true
    versionId?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    effort?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureMaxAggregateInputType = {
    id?: true
    milestoneId?: true
    versionId?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    effort?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeatureCountAggregateInputType = {
    id?: true
    milestoneId?: true
    versionId?: true
    name?: true
    description?: true
    status?: true
    priority?: true
    effort?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feature to aggregate.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Features
    **/
    _count?: true | FeatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeatureMaxAggregateInputType
  }

  export type GetFeatureAggregateType<T extends FeatureAggregateArgs> = {
        [P in keyof T & keyof AggregateFeature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeature[P]>
      : GetScalarType<T[P], AggregateFeature[P]>
  }




  export type FeatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeatureWhereInput
    orderBy?: FeatureOrderByWithAggregationInput | FeatureOrderByWithAggregationInput[]
    by: FeatureScalarFieldEnum[] | FeatureScalarFieldEnum
    having?: FeatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeatureCountAggregateInputType | true
    _min?: FeatureMinAggregateInputType
    _max?: FeatureMaxAggregateInputType
  }

  export type FeatureGroupByOutputType = {
    id: string
    milestoneId: string | null
    versionId: string | null
    name: string
    description: string | null
    status: string
    priority: string
    effort: string | null
    createdAt: Date
    updatedAt: Date
    _count: FeatureCountAggregateOutputType | null
    _min: FeatureMinAggregateOutputType | null
    _max: FeatureMaxAggregateOutputType | null
  }

  type GetFeatureGroupByPayload<T extends FeatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeatureGroupByOutputType[P]>
            : GetScalarType<T[P], FeatureGroupByOutputType[P]>
        }
      >
    >


  export type FeatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    milestoneId?: boolean
    versionId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    effort?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestone?: boolean | Feature$milestoneArgs<ExtArgs>
    version?: boolean | Feature$versionArgs<ExtArgs>
    tasks?: boolean | Feature$tasksArgs<ExtArgs>
    _count?: boolean | FeatureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    milestoneId?: boolean
    versionId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    effort?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestone?: boolean | Feature$milestoneArgs<ExtArgs>
    version?: boolean | Feature$versionArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    milestoneId?: boolean
    versionId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    effort?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    milestone?: boolean | Feature$milestoneArgs<ExtArgs>
    version?: boolean | Feature$versionArgs<ExtArgs>
  }, ExtArgs["result"]["feature"]>

  export type FeatureSelectScalar = {
    id?: boolean
    milestoneId?: boolean
    versionId?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    effort?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "milestoneId" | "versionId" | "name" | "description" | "status" | "priority" | "effort" | "createdAt" | "updatedAt", ExtArgs["result"]["feature"]>
  export type FeatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestone?: boolean | Feature$milestoneArgs<ExtArgs>
    version?: boolean | Feature$versionArgs<ExtArgs>
    tasks?: boolean | Feature$tasksArgs<ExtArgs>
    _count?: boolean | FeatureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestone?: boolean | Feature$milestoneArgs<ExtArgs>
    version?: boolean | Feature$versionArgs<ExtArgs>
  }
  export type FeatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    milestone?: boolean | Feature$milestoneArgs<ExtArgs>
    version?: boolean | Feature$versionArgs<ExtArgs>
  }

  export type $FeaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Feature"
    objects: {
      milestone: Prisma.$MilestonePayload<ExtArgs> | null
      version: Prisma.$VersionPayload<ExtArgs> | null
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      milestoneId: string | null
      versionId: string | null
      name: string
      description: string | null
      status: string
      priority: string
      effort: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feature"]>
    composites: {}
  }

  type FeatureGetPayload<S extends boolean | null | undefined | FeatureDefaultArgs> = $Result.GetResult<Prisma.$FeaturePayload, S>

  type FeatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FeatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeatureCountAggregateInputType | true
    }

  export interface FeatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feature'], meta: { name: 'Feature' } }
    /**
     * Find zero or one Feature that matches the filter.
     * @param {FeatureFindUniqueArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeatureFindUniqueArgs>(args: SelectSubset<T, FeatureFindUniqueArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FeatureFindUniqueOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeatureFindUniqueOrThrowArgs>(args: SelectSubset<T, FeatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeatureFindFirstArgs>(args?: SelectSubset<T, FeatureFindFirstArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindFirstOrThrowArgs} args - Arguments to find a Feature
     * @example
     * // Get one Feature
     * const feature = await prisma.feature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeatureFindFirstOrThrowArgs>(args?: SelectSubset<T, FeatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.feature.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.feature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featureWithIdOnly = await prisma.feature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeatureFindManyArgs>(args?: SelectSubset<T, FeatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feature.
     * @param {FeatureCreateArgs} args - Arguments to create a Feature.
     * @example
     * // Create one Feature
     * const Feature = await prisma.feature.create({
     *   data: {
     *     // ... data to create a Feature
     *   }
     * })
     * 
     */
    create<T extends FeatureCreateArgs>(args: SelectSubset<T, FeatureCreateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Features.
     * @param {FeatureCreateManyArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeatureCreateManyArgs>(args?: SelectSubset<T, FeatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Features and returns the data saved in the database.
     * @param {FeatureCreateManyAndReturnArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const feature = await prisma.feature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeatureCreateManyAndReturnArgs>(args?: SelectSubset<T, FeatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feature.
     * @param {FeatureDeleteArgs} args - Arguments to delete one Feature.
     * @example
     * // Delete one Feature
     * const Feature = await prisma.feature.delete({
     *   where: {
     *     // ... filter to delete one Feature
     *   }
     * })
     * 
     */
    delete<T extends FeatureDeleteArgs>(args: SelectSubset<T, FeatureDeleteArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feature.
     * @param {FeatureUpdateArgs} args - Arguments to update one Feature.
     * @example
     * // Update one Feature
     * const feature = await prisma.feature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeatureUpdateArgs>(args: SelectSubset<T, FeatureUpdateArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Features.
     * @param {FeatureDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.feature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeatureDeleteManyArgs>(args?: SelectSubset<T, FeatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeatureUpdateManyArgs>(args: SelectSubset<T, FeatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features and returns the data updated in the database.
     * @param {FeatureUpdateManyAndReturnArgs} args - Arguments to update many Features.
     * @example
     * // Update many Features
     * const feature = await prisma.feature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Features and only return the `id`
     * const featureWithIdOnly = await prisma.feature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FeatureUpdateManyAndReturnArgs>(args: SelectSubset<T, FeatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feature.
     * @param {FeatureUpsertArgs} args - Arguments to update or create a Feature.
     * @example
     * // Update or create a Feature
     * const feature = await prisma.feature.upsert({
     *   create: {
     *     // ... data to create a Feature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feature we want to update
     *   }
     * })
     */
    upsert<T extends FeatureUpsertArgs>(args: SelectSubset<T, FeatureUpsertArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.feature.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends FeatureCountArgs>(
      args?: Subset<T, FeatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeatureAggregateArgs>(args: Subset<T, FeatureAggregateArgs>): Prisma.PrismaPromise<GetFeatureAggregateType<T>>

    /**
     * Group by Feature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeatureGroupByArgs['orderBy'] }
        : { orderBy?: FeatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feature model
   */
  readonly fields: FeatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    milestone<T extends Feature$milestoneArgs<ExtArgs> = {}>(args?: Subset<T, Feature$milestoneArgs<ExtArgs>>): Prisma__MilestoneClient<$Result.GetResult<Prisma.$MilestonePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    version<T extends Feature$versionArgs<ExtArgs> = {}>(args?: Subset<T, Feature$versionArgs<ExtArgs>>): Prisma__VersionClient<$Result.GetResult<Prisma.$VersionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Feature$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Feature$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Feature model
   */
  interface FeatureFieldRefs {
    readonly id: FieldRef<"Feature", 'String'>
    readonly milestoneId: FieldRef<"Feature", 'String'>
    readonly versionId: FieldRef<"Feature", 'String'>
    readonly name: FieldRef<"Feature", 'String'>
    readonly description: FieldRef<"Feature", 'String'>
    readonly status: FieldRef<"Feature", 'String'>
    readonly priority: FieldRef<"Feature", 'String'>
    readonly effort: FieldRef<"Feature", 'String'>
    readonly createdAt: FieldRef<"Feature", 'DateTime'>
    readonly updatedAt: FieldRef<"Feature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Feature findUnique
   */
  export type FeatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findUniqueOrThrow
   */
  export type FeatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature findFirst
   */
  export type FeatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findFirstOrThrow
   */
  export type FeatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Feature to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Features.
     */
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature findMany
   */
  export type FeatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter, which Features to fetch.
     */
    where?: FeatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Features to fetch.
     */
    orderBy?: FeatureOrderByWithRelationInput | FeatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Features.
     */
    cursor?: FeatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Features.
     */
    skip?: number
    distinct?: FeatureScalarFieldEnum | FeatureScalarFieldEnum[]
  }

  /**
   * Feature create
   */
  export type FeatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to create a Feature.
     */
    data: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
  }

  /**
   * Feature createMany
   */
  export type FeatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Feature createManyAndReturn
   */
  export type FeatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to create many Features.
     */
    data: FeatureCreateManyInput | FeatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feature update
   */
  export type FeatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The data needed to update a Feature.
     */
    data: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
    /**
     * Choose, which Feature to update.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature updateMany
   */
  export type FeatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
  }

  /**
   * Feature updateManyAndReturn
   */
  export type FeatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * The data used to update Features.
     */
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyInput>
    /**
     * Filter which Features to update
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Feature upsert
   */
  export type FeatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * The filter to search for the Feature to update in case it exists.
     */
    where: FeatureWhereUniqueInput
    /**
     * In case the Feature found by the `where` argument doesn't exist, create a new Feature with this data.
     */
    create: XOR<FeatureCreateInput, FeatureUncheckedCreateInput>
    /**
     * In case the Feature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeatureUpdateInput, FeatureUncheckedUpdateInput>
  }

  /**
   * Feature delete
   */
  export type FeatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    /**
     * Filter which Feature to delete.
     */
    where: FeatureWhereUniqueInput
  }

  /**
   * Feature deleteMany
   */
  export type FeatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Features to delete
     */
    where?: FeatureWhereInput
    /**
     * Limit how many Features to delete.
     */
    limit?: number
  }

  /**
   * Feature.milestone
   */
  export type Feature$milestoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Milestone
     */
    select?: MilestoneSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Milestone
     */
    omit?: MilestoneOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MilestoneInclude<ExtArgs> | null
    where?: MilestoneWhereInput
  }

  /**
   * Feature.version
   */
  export type Feature$versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Version
     */
    select?: VersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Version
     */
    omit?: VersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VersionInclude<ExtArgs> | null
    where?: VersionWhereInput
  }

  /**
   * Feature.tasks
   */
  export type Feature$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Feature without action
   */
  export type FeatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
  }


  /**
   * Model Sprint
   */

  export type AggregateSprint = {
    _count: SprintCountAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  export type SprintMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    goal: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SprintMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    startDate: Date | null
    endDate: Date | null
    goal: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SprintCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    startDate: number
    endDate: number
    goal: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SprintMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    startDate?: true
    endDate?: true
    goal?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SprintMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    startDate?: true
    endDate?: true
    goal?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SprintCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    startDate?: true
    endDate?: true
    goal?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SprintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprint to aggregate.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sprints
    **/
    _count?: true | SprintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SprintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SprintMaxAggregateInputType
  }

  export type GetSprintAggregateType<T extends SprintAggregateArgs> = {
        [P in keyof T & keyof AggregateSprint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSprint[P]>
      : GetScalarType<T[P], AggregateSprint[P]>
  }




  export type SprintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SprintWhereInput
    orderBy?: SprintOrderByWithAggregationInput | SprintOrderByWithAggregationInput[]
    by: SprintScalarFieldEnum[] | SprintScalarFieldEnum
    having?: SprintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SprintCountAggregateInputType | true
    _min?: SprintMinAggregateInputType
    _max?: SprintMaxAggregateInputType
  }

  export type SprintGroupByOutputType = {
    id: string
    projectId: string
    name: string
    startDate: Date
    endDate: Date
    goal: string
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SprintCountAggregateOutputType | null
    _min: SprintMinAggregateOutputType | null
    _max: SprintMaxAggregateOutputType | null
  }

  type GetSprintGroupByPayload<T extends SprintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SprintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SprintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SprintGroupByOutputType[P]>
            : GetScalarType<T[P], SprintGroupByOutputType[P]>
        }
      >
    >


  export type SprintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    goal?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    Task?: boolean | Sprint$TaskArgs<ExtArgs>
    _count?: boolean | SprintCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    goal?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    goal?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sprint"]>

  export type SprintSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    startDate?: boolean
    endDate?: boolean
    goal?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SprintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "startDate" | "endDate" | "goal" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["sprint"]>
  export type SprintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    Task?: boolean | Sprint$TaskArgs<ExtArgs>
    _count?: boolean | SprintCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SprintIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type SprintIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $SprintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sprint"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      Task: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      startDate: Date
      endDate: Date
      goal: string
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sprint"]>
    composites: {}
  }

  type SprintGetPayload<S extends boolean | null | undefined | SprintDefaultArgs> = $Result.GetResult<Prisma.$SprintPayload, S>

  type SprintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SprintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SprintCountAggregateInputType | true
    }

  export interface SprintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sprint'], meta: { name: 'Sprint' } }
    /**
     * Find zero or one Sprint that matches the filter.
     * @param {SprintFindUniqueArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SprintFindUniqueArgs>(args: SelectSubset<T, SprintFindUniqueArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sprint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SprintFindUniqueOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SprintFindUniqueOrThrowArgs>(args: SelectSubset<T, SprintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sprint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SprintFindFirstArgs>(args?: SelectSubset<T, SprintFindFirstArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sprint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindFirstOrThrowArgs} args - Arguments to find a Sprint
     * @example
     * // Get one Sprint
     * const sprint = await prisma.sprint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SprintFindFirstOrThrowArgs>(args?: SelectSubset<T, SprintFindFirstOrThrowArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sprints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sprints
     * const sprints = await prisma.sprint.findMany()
     * 
     * // Get first 10 Sprints
     * const sprints = await prisma.sprint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sprintWithIdOnly = await prisma.sprint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SprintFindManyArgs>(args?: SelectSubset<T, SprintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sprint.
     * @param {SprintCreateArgs} args - Arguments to create a Sprint.
     * @example
     * // Create one Sprint
     * const Sprint = await prisma.sprint.create({
     *   data: {
     *     // ... data to create a Sprint
     *   }
     * })
     * 
     */
    create<T extends SprintCreateArgs>(args: SelectSubset<T, SprintCreateArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sprints.
     * @param {SprintCreateManyArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SprintCreateManyArgs>(args?: SelectSubset<T, SprintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sprints and returns the data saved in the database.
     * @param {SprintCreateManyAndReturnArgs} args - Arguments to create many Sprints.
     * @example
     * // Create many Sprints
     * const sprint = await prisma.sprint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sprints and only return the `id`
     * const sprintWithIdOnly = await prisma.sprint.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SprintCreateManyAndReturnArgs>(args?: SelectSubset<T, SprintCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sprint.
     * @param {SprintDeleteArgs} args - Arguments to delete one Sprint.
     * @example
     * // Delete one Sprint
     * const Sprint = await prisma.sprint.delete({
     *   where: {
     *     // ... filter to delete one Sprint
     *   }
     * })
     * 
     */
    delete<T extends SprintDeleteArgs>(args: SelectSubset<T, SprintDeleteArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sprint.
     * @param {SprintUpdateArgs} args - Arguments to update one Sprint.
     * @example
     * // Update one Sprint
     * const sprint = await prisma.sprint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SprintUpdateArgs>(args: SelectSubset<T, SprintUpdateArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sprints.
     * @param {SprintDeleteManyArgs} args - Arguments to filter Sprints to delete.
     * @example
     * // Delete a few Sprints
     * const { count } = await prisma.sprint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SprintDeleteManyArgs>(args?: SelectSubset<T, SprintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sprints
     * const sprint = await prisma.sprint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SprintUpdateManyArgs>(args: SelectSubset<T, SprintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sprints and returns the data updated in the database.
     * @param {SprintUpdateManyAndReturnArgs} args - Arguments to update many Sprints.
     * @example
     * // Update many Sprints
     * const sprint = await prisma.sprint.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sprints and only return the `id`
     * const sprintWithIdOnly = await prisma.sprint.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SprintUpdateManyAndReturnArgs>(args: SelectSubset<T, SprintUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sprint.
     * @param {SprintUpsertArgs} args - Arguments to update or create a Sprint.
     * @example
     * // Update or create a Sprint
     * const sprint = await prisma.sprint.upsert({
     *   create: {
     *     // ... data to create a Sprint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sprint we want to update
     *   }
     * })
     */
    upsert<T extends SprintUpsertArgs>(args: SelectSubset<T, SprintUpsertArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sprints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintCountArgs} args - Arguments to filter Sprints to count.
     * @example
     * // Count the number of Sprints
     * const count = await prisma.sprint.count({
     *   where: {
     *     // ... the filter for the Sprints we want to count
     *   }
     * })
    **/
    count<T extends SprintCountArgs>(
      args?: Subset<T, SprintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SprintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SprintAggregateArgs>(args: Subset<T, SprintAggregateArgs>): Prisma.PrismaPromise<GetSprintAggregateType<T>>

    /**
     * Group by Sprint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SprintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SprintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SprintGroupByArgs['orderBy'] }
        : { orderBy?: SprintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SprintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSprintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sprint model
   */
  readonly fields: SprintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sprint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SprintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Task<T extends Sprint$TaskArgs<ExtArgs> = {}>(args?: Subset<T, Sprint$TaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sprint model
   */
  interface SprintFieldRefs {
    readonly id: FieldRef<"Sprint", 'String'>
    readonly projectId: FieldRef<"Sprint", 'String'>
    readonly name: FieldRef<"Sprint", 'String'>
    readonly startDate: FieldRef<"Sprint", 'DateTime'>
    readonly endDate: FieldRef<"Sprint", 'DateTime'>
    readonly goal: FieldRef<"Sprint", 'String'>
    readonly status: FieldRef<"Sprint", 'String'>
    readonly createdAt: FieldRef<"Sprint", 'DateTime'>
    readonly updatedAt: FieldRef<"Sprint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sprint findUnique
   */
  export type SprintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findUniqueOrThrow
   */
  export type SprintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint findFirst
   */
  export type SprintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findFirstOrThrow
   */
  export type SprintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprint to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sprints.
     */
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint findMany
   */
  export type SprintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter, which Sprints to fetch.
     */
    where?: SprintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sprints to fetch.
     */
    orderBy?: SprintOrderByWithRelationInput | SprintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sprints.
     */
    cursor?: SprintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sprints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sprints.
     */
    skip?: number
    distinct?: SprintScalarFieldEnum | SprintScalarFieldEnum[]
  }

  /**
   * Sprint create
   */
  export type SprintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to create a Sprint.
     */
    data: XOR<SprintCreateInput, SprintUncheckedCreateInput>
  }

  /**
   * Sprint createMany
   */
  export type SprintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sprint createManyAndReturn
   */
  export type SprintCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * The data used to create many Sprints.
     */
    data: SprintCreateManyInput | SprintCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sprint update
   */
  export type SprintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The data needed to update a Sprint.
     */
    data: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
    /**
     * Choose, which Sprint to update.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint updateMany
   */
  export type SprintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sprints.
     */
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyInput>
    /**
     * Filter which Sprints to update
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to update.
     */
    limit?: number
  }

  /**
   * Sprint updateManyAndReturn
   */
  export type SprintUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * The data used to update Sprints.
     */
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyInput>
    /**
     * Filter which Sprints to update
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sprint upsert
   */
  export type SprintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * The filter to search for the Sprint to update in case it exists.
     */
    where: SprintWhereUniqueInput
    /**
     * In case the Sprint found by the `where` argument doesn't exist, create a new Sprint with this data.
     */
    create: XOR<SprintCreateInput, SprintUncheckedCreateInput>
    /**
     * In case the Sprint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SprintUpdateInput, SprintUncheckedUpdateInput>
  }

  /**
   * Sprint delete
   */
  export type SprintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
    /**
     * Filter which Sprint to delete.
     */
    where: SprintWhereUniqueInput
  }

  /**
   * Sprint deleteMany
   */
  export type SprintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sprints to delete
     */
    where?: SprintWhereInput
    /**
     * Limit how many Sprints to delete.
     */
    limit?: number
  }

  /**
   * Sprint.Task
   */
  export type Sprint$TaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Sprint without action
   */
  export type SprintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sprint
     */
    select?: SprintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sprint
     */
    omit?: SprintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SprintInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    sprintId: string | null
    teamId: string | null
    title: string | null
    content: string | null
    status: string | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    featureId: string | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    sprintId: string | null
    teamId: string | null
    title: string | null
    content: string | null
    status: string | null
    dueDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    featureId: string | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    projectId: number
    sprintId: number
    teamId: number
    title: number
    content: number
    status: number
    dueDate: number
    createdAt: number
    updatedAt: number
    featureId: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    projectId?: true
    sprintId?: true
    teamId?: true
    title?: true
    content?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    featureId?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    projectId?: true
    sprintId?: true
    teamId?: true
    title?: true
    content?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    featureId?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    projectId?: true
    sprintId?: true
    teamId?: true
    title?: true
    content?: true
    status?: true
    dueDate?: true
    createdAt?: true
    updatedAt?: true
    featureId?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    projectId: string
    sprintId: string
    teamId: string
    title: string
    content: string | null
    status: string
    dueDate: Date | null
    createdAt: Date
    updatedAt: Date
    featureId: string | null
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    sprintId?: boolean
    teamId?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featureId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    feature?: boolean | Task$featureArgs<ExtArgs>
    AgentTask?: boolean | Task$AgentTaskArgs<ExtArgs>
    AgentWorklog?: boolean | Task$AgentWorklogArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    sprintId?: boolean
    teamId?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featureId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    feature?: boolean | Task$featureArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    sprintId?: boolean
    teamId?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featureId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    feature?: boolean | Task$featureArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    projectId?: boolean
    sprintId?: boolean
    teamId?: boolean
    title?: boolean
    content?: boolean
    status?: boolean
    dueDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    featureId?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "sprintId" | "teamId" | "title" | "content" | "status" | "dueDate" | "createdAt" | "updatedAt" | "featureId", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    feature?: boolean | Task$featureArgs<ExtArgs>
    AgentTask?: boolean | Task$AgentTaskArgs<ExtArgs>
    AgentWorklog?: boolean | Task$AgentWorklogArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    feature?: boolean | Task$featureArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    sprint?: boolean | SprintDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    feature?: boolean | Task$featureArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      sprint: Prisma.$SprintPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      feature: Prisma.$FeaturePayload<ExtArgs> | null
      AgentTask: Prisma.$AgentTaskPayload<ExtArgs>[]
      AgentWorklog: Prisma.$AgentWorklogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      sprintId: string
      teamId: string
      title: string
      content: string | null
      status: string
      dueDate: Date | null
      createdAt: Date
      updatedAt: Date
      featureId: string | null
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sprint<T extends SprintDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SprintDefaultArgs<ExtArgs>>): Prisma__SprintClient<$Result.GetResult<Prisma.$SprintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    feature<T extends Task$featureArgs<ExtArgs> = {}>(args?: Subset<T, Task$featureArgs<ExtArgs>>): Prisma__FeatureClient<$Result.GetResult<Prisma.$FeaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    AgentTask<T extends Task$AgentTaskArgs<ExtArgs> = {}>(args?: Subset<T, Task$AgentTaskArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentTaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    AgentWorklog<T extends Task$AgentWorklogArgs<ExtArgs> = {}>(args?: Subset<T, Task$AgentWorklogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentWorklogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly sprintId: FieldRef<"Task", 'String'>
    readonly teamId: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly content: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly dueDate: FieldRef<"Task", 'DateTime'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly featureId: FieldRef<"Task", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.feature
   */
  export type Task$featureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feature
     */
    select?: FeatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Feature
     */
    omit?: FeatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeatureInclude<ExtArgs> | null
    where?: FeatureWhereInput
  }

  /**
   * Task.AgentTask
   */
  export type Task$AgentTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentTask
     */
    select?: AgentTaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentTask
     */
    omit?: AgentTaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentTaskInclude<ExtArgs> | null
    where?: AgentTaskWhereInput
    orderBy?: AgentTaskOrderByWithRelationInput | AgentTaskOrderByWithRelationInput[]
    cursor?: AgentTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentTaskScalarFieldEnum | AgentTaskScalarFieldEnum[]
  }

  /**
   * Task.AgentWorklog
   */
  export type Task$AgentWorklogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentWorklog
     */
    select?: AgentWorklogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AgentWorklog
     */
    omit?: AgentWorklogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentWorklogInclude<ExtArgs> | null
    where?: AgentWorklogWhereInput
    orderBy?: AgentWorklogOrderByWithRelationInput | AgentWorklogOrderByWithRelationInput[]
    cursor?: AgentWorklogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentWorklogScalarFieldEnum | AgentWorklogScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    projectId: string
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Team$tasksArgs<ExtArgs>
    agents?: boolean | Team$agentsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tasks?: boolean | Team$tasksArgs<ExtArgs>
    agents?: boolean | Team$agentsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      agents: Prisma.$AgentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      projectId: string
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends Team$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Team$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    agents<T extends Team$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Team$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
    readonly projectId: FieldRef<"Team", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.tasks
   */
  export type Team$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Team.agents
   */
  export type Team$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    name: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    name: string | null
    avatar: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    name: number
    avatar: number
    role: number
    isActive: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    name?: true
    avatar?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    name?: true
    avatar?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    name?: true
    avatar?: true
    role?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    password: string
    name: string | null
    avatar: string | null
    role: $Enums.UserRole
    isActive: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    avatar?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projects?: boolean | User$projectsArgs<ExtArgs>
    projectMembers?: boolean | User$projectMembersArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    DomainKnowledge?: boolean | User$DomainKnowledgeArgs<ExtArgs>
    DatabaseSchema?: boolean | User$DatabaseSchemaArgs<ExtArgs>
    Requirement?: boolean | User$RequirementArgs<ExtArgs>
    RequirementAttachment?: boolean | User$RequirementAttachmentArgs<ExtArgs>
    Documentation?: boolean | User$DocumentationArgs<ExtArgs>
    DocumentVersion?: boolean | User$DocumentVersionArgs<ExtArgs>
    DocumentComment?: boolean | User$DocumentCommentArgs<ExtArgs>
    DocumentAttachment?: boolean | User$DocumentAttachmentArgs<ExtArgs>
    MindMap?: boolean | User$MindMapArgs<ExtArgs>
    ArchitectureChangeHistory?: boolean | User$ArchitectureChangeHistoryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    avatar?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    avatar?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    name?: boolean
    avatar?: boolean
    role?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "password" | "name" | "avatar" | "role" | "isActive" | "lastLoginAt" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | User$projectsArgs<ExtArgs>
    projectMembers?: boolean | User$projectMembersArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    DomainKnowledge?: boolean | User$DomainKnowledgeArgs<ExtArgs>
    DatabaseSchema?: boolean | User$DatabaseSchemaArgs<ExtArgs>
    Requirement?: boolean | User$RequirementArgs<ExtArgs>
    RequirementAttachment?: boolean | User$RequirementAttachmentArgs<ExtArgs>
    Documentation?: boolean | User$DocumentationArgs<ExtArgs>
    DocumentVersion?: boolean | User$DocumentVersionArgs<ExtArgs>
    DocumentComment?: boolean | User$DocumentCommentArgs<ExtArgs>
    DocumentAttachment?: boolean | User$DocumentAttachmentArgs<ExtArgs>
    MindMap?: boolean | User$MindMapArgs<ExtArgs>
    ArchitectureChangeHistory?: boolean | User$ArchitectureChangeHistoryArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      projectMembers: Prisma.$ProjectMemberPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      DomainKnowledge: Prisma.$DomainKnowledgePayload<ExtArgs>[]
      DatabaseSchema: Prisma.$DatabaseSchemaPayload<ExtArgs>[]
      Requirement: Prisma.$RequirementPayload<ExtArgs>[]
      RequirementAttachment: Prisma.$RequirementAttachmentPayload<ExtArgs>[]
      Documentation: Prisma.$DocumentationPayload<ExtArgs>[]
      DocumentVersion: Prisma.$DocumentVersionPayload<ExtArgs>[]
      DocumentComment: Prisma.$DocumentCommentPayload<ExtArgs>[]
      DocumentAttachment: Prisma.$DocumentAttachmentPayload<ExtArgs>[]
      MindMap: Prisma.$MindMapPayload<ExtArgs>[]
      ArchitectureChangeHistory: Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      password: string
      name: string | null
      avatar: string | null
      role: $Enums.UserRole
      isActive: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectMembers<T extends User$projectMembersArgs<ExtArgs> = {}>(args?: Subset<T, User$projectMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DomainKnowledge<T extends User$DomainKnowledgeArgs<ExtArgs> = {}>(args?: Subset<T, User$DomainKnowledgeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DomainKnowledgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DatabaseSchema<T extends User$DatabaseSchemaArgs<ExtArgs> = {}>(args?: Subset<T, User$DatabaseSchemaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DatabaseSchemaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Requirement<T extends User$RequirementArgs<ExtArgs> = {}>(args?: Subset<T, User$RequirementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RequirementAttachment<T extends User$RequirementAttachmentArgs<ExtArgs> = {}>(args?: Subset<T, User$RequirementAttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequirementAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Documentation<T extends User$DocumentationArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DocumentVersion<T extends User$DocumentVersionArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentVersionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentVersionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DocumentComment<T extends User$DocumentCommentArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentCommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    DocumentAttachment<T extends User$DocumentAttachmentArgs<ExtArgs> = {}>(args?: Subset<T, User$DocumentAttachmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MindMap<T extends User$MindMapArgs<ExtArgs> = {}>(args?: Subset<T, User$MindMapArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MindMapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ArchitectureChangeHistory<T extends User$ArchitectureChangeHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$ArchitectureChangeHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArchitectureChangeHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.projectMembers
   */
  export type User$projectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.DomainKnowledge
   */
  export type User$DomainKnowledgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DomainKnowledge
     */
    select?: DomainKnowledgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DomainKnowledge
     */
    omit?: DomainKnowledgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DomainKnowledgeInclude<ExtArgs> | null
    where?: DomainKnowledgeWhereInput
    orderBy?: DomainKnowledgeOrderByWithRelationInput | DomainKnowledgeOrderByWithRelationInput[]
    cursor?: DomainKnowledgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DomainKnowledgeScalarFieldEnum | DomainKnowledgeScalarFieldEnum[]
  }

  /**
   * User.DatabaseSchema
   */
  export type User$DatabaseSchemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DatabaseSchema
     */
    select?: DatabaseSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DatabaseSchema
     */
    omit?: DatabaseSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DatabaseSchemaInclude<ExtArgs> | null
    where?: DatabaseSchemaWhereInput
    orderBy?: DatabaseSchemaOrderByWithRelationInput | DatabaseSchemaOrderByWithRelationInput[]
    cursor?: DatabaseSchemaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DatabaseSchemaScalarFieldEnum | DatabaseSchemaScalarFieldEnum[]
  }

  /**
   * User.Requirement
   */
  export type User$RequirementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requirement
     */
    select?: RequirementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requirement
     */
    omit?: RequirementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementInclude<ExtArgs> | null
    where?: RequirementWhereInput
    orderBy?: RequirementOrderByWithRelationInput | RequirementOrderByWithRelationInput[]
    cursor?: RequirementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementScalarFieldEnum | RequirementScalarFieldEnum[]
  }

  /**
   * User.RequirementAttachment
   */
  export type User$RequirementAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequirementAttachment
     */
    select?: RequirementAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RequirementAttachment
     */
    omit?: RequirementAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequirementAttachmentInclude<ExtArgs> | null
    where?: RequirementAttachmentWhereInput
    orderBy?: RequirementAttachmentOrderByWithRelationInput | RequirementAttachmentOrderByWithRelationInput[]
    cursor?: RequirementAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequirementAttachmentScalarFieldEnum | RequirementAttachmentScalarFieldEnum[]
  }

  /**
   * User.Documentation
   */
  export type User$DocumentationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documentation
     */
    select?: DocumentationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Documentation
     */
    omit?: DocumentationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentationInclude<ExtArgs> | null
    where?: DocumentationWhereInput
    orderBy?: DocumentationOrderByWithRelationInput | DocumentationOrderByWithRelationInput[]
    cursor?: DocumentationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentationScalarFieldEnum | DocumentationScalarFieldEnum[]
  }

  /**
   * User.DocumentVersion
   */
  export type User$DocumentVersionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentVersion
     */
    select?: DocumentVersionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentVersion
     */
    omit?: DocumentVersionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentVersionInclude<ExtArgs> | null
    where?: DocumentVersionWhereInput
    orderBy?: DocumentVersionOrderByWithRelationInput | DocumentVersionOrderByWithRelationInput[]
    cursor?: DocumentVersionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentVersionScalarFieldEnum | DocumentVersionScalarFieldEnum[]
  }

  /**
   * User.DocumentComment
   */
  export type User$DocumentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentComment
     */
    select?: DocumentCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentComment
     */
    omit?: DocumentCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentCommentInclude<ExtArgs> | null
    where?: DocumentCommentWhereInput
    orderBy?: DocumentCommentOrderByWithRelationInput | DocumentCommentOrderByWithRelationInput[]
    cursor?: DocumentCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentCommentScalarFieldEnum | DocumentCommentScalarFieldEnum[]
  }

  /**
   * User.DocumentAttachment
   */
  export type User$DocumentAttachmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentAttachment
     */
    select?: DocumentAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentAttachment
     */
    omit?: DocumentAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentAttachmentInclude<ExtArgs> | null
    where?: DocumentAttachmentWhereInput
    orderBy?: DocumentAttachmentOrderByWithRelationInput | DocumentAttachmentOrderByWithRelationInput[]
    cursor?: DocumentAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentAttachmentScalarFieldEnum | DocumentAttachmentScalarFieldEnum[]
  }

  /**
   * User.MindMap
   */
  export type User$MindMapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MindMap
     */
    select?: MindMapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MindMap
     */
    omit?: MindMapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MindMapInclude<ExtArgs> | null
    where?: MindMapWhereInput
    orderBy?: MindMapOrderByWithRelationInput | MindMapOrderByWithRelationInput[]
    cursor?: MindMapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MindMapScalarFieldEnum | MindMapScalarFieldEnum[]
  }

  /**
   * User.ArchitectureChangeHistory
   */
  export type User$ArchitectureChangeHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArchitectureChangeHistory
     */
    select?: ArchitectureChangeHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArchitectureChangeHistory
     */
    omit?: ArchitectureChangeHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArchitectureChangeHistoryInclude<ExtArgs> | null
    where?: ArchitectureChangeHistoryWhereInput
    orderBy?: ArchitectureChangeHistoryOrderByWithRelationInput | ArchitectureChangeHistoryOrderByWithRelationInput[]
    cursor?: ArchitectureChangeHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArchitectureChangeHistoryScalarFieldEnum | ArchitectureChangeHistoryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    ipAddress: number
    userAgent: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "ipAddress" | "userAgent" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      ipAddress: string | null
      userAgent: string | null
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly token: FieldRef<"Session", 'String'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: $Enums.ProjectRole | null
    joinedAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    userId: string | null
    role: $Enums.ProjectRole | null
    joinedAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    userId: number
    role: number
    permissions: number
    joinedAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
    updatedAt?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    joinedAt?: true
    updatedAt?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    userId?: true
    role?: true
    permissions?: true
    joinedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: string
    projectId: string
    userId: string
    role: $Enums.ProjectRole
    permissions: string[]
    joinedAt: Date
    updatedAt: Date
    _count: ProjectMemberCountAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    userId?: boolean
    role?: boolean
    permissions?: boolean
    joinedAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "userId" | "role" | "permissions" | "joinedAt" | "updatedAt", ExtArgs["result"]["projectMember"]>
  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      userId: string
      role: $Enums.ProjectRole
      permissions: string[]
      joinedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {ProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'String'>
    readonly projectId: FieldRef<"ProjectMember", 'String'>
    readonly userId: FieldRef<"ProjectMember", 'String'>
    readonly role: FieldRef<"ProjectMember", 'ProjectRole'>
    readonly permissions: FieldRef<"ProjectMember", 'String[]'>
    readonly joinedAt: FieldRef<"ProjectMember", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectMember updateManyAndReturn
   */
  export type ProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "details" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AgentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    teamId: 'teamId',
    name: 'name',
    description: 'description',
    workPrompt: 'workPrompt',
    responsibilities: 'responsibilities',
    skills: 'skills',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const AgentTaskScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    taskId: 'taskId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentTaskScalarFieldEnum = (typeof AgentTaskScalarFieldEnum)[keyof typeof AgentTaskScalarFieldEnum]


  export const AgentActivityScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    body: 'body',
    action: 'action',
    details: 'details',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentActivityScalarFieldEnum = (typeof AgentActivityScalarFieldEnum)[keyof typeof AgentActivityScalarFieldEnum]


  export const AgentWorklogScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    agentId: 'agentId',
    taskId: 'taskId',
    workType: 'workType',
    summarize: 'summarize',
    nextPlan: 'nextPlan',
    content: 'content',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentWorklogScalarFieldEnum = (typeof AgentWorklogScalarFieldEnum)[keyof typeof AgentWorklogScalarFieldEnum]


  export const AgentPromptTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    responsibility: 'responsibility',
    prompt: 'prompt',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentPromptTemplateScalarFieldEnum = (typeof AgentPromptTemplateScalarFieldEnum)[keyof typeof AgentPromptTemplateScalarFieldEnum]


  export const ApiDesignScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    apiName: 'apiName',
    apiPath: 'apiPath',
    apiMethod: 'apiMethod',
    apiVersion: 'apiVersion',
    platform: 'platform',
    module: 'module',
    apiDescription: 'apiDescription',
    businessLogic: 'businessLogic',
    apiContentType: 'apiContentType',
    requestHeaders: 'requestHeaders',
    requestParams: 'requestParams',
    requestBody: 'requestBody',
    responseHeaders: 'responseHeaders',
    responseBody: 'responseBody',
    authentication: 'authentication',
    authDetails: 'authDetails',
    permissions: 'permissions',
    rateLimit: 'rateLimit',
    timeout: 'timeout',
    maxPayloadSize: 'maxPayloadSize',
    status: 'status',
    deprecated: 'deprecated',
    deprecationDate: 'deprecationDate',
    sunsetDate: 'sunsetDate',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ApiDesignScalarFieldEnum = (typeof ApiDesignScalarFieldEnum)[keyof typeof ApiDesignScalarFieldEnum]


  export const ApiExampleScalarFieldEnum: {
    id: 'id',
    apiDesignId: 'apiDesignId',
    name: 'name',
    description: 'description',
    requestUrl: 'requestUrl',
    requestHeaders: 'requestHeaders',
    requestParams: 'requestParams',
    requestBody: 'requestBody',
    responseStatus: 'responseStatus',
    responseHeaders: 'responseHeaders',
    responseBody: 'responseBody',
    notes: 'notes',
    isSuccess: 'isSuccess',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiExampleScalarFieldEnum = (typeof ApiExampleScalarFieldEnum)[keyof typeof ApiExampleScalarFieldEnum]


  export const ApiErrorCodeScalarFieldEnum: {
    id: 'id',
    apiDesignId: 'apiDesignId',
    code: 'code',
    httpStatus: 'httpStatus',
    message: 'message',
    description: 'description',
    solution: 'solution',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiErrorCodeScalarFieldEnum = (typeof ApiErrorCodeScalarFieldEnum)[keyof typeof ApiErrorCodeScalarFieldEnum]


  export const SystemArchitectureScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    overview: 'overview',
    version: 'version',
    status: 'status',
    platforms: 'platforms',
    components: 'components',
    technologies: 'technologies',
    diagrams: 'diagrams',
    notes: 'notes',
    versionNumber: 'versionNumber',
    previousVersionId: 'previousVersionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SystemArchitectureScalarFieldEnum = (typeof SystemArchitectureScalarFieldEnum)[keyof typeof SystemArchitectureScalarFieldEnum]


  export const PlatformArchitectureScalarFieldEnum: {
    id: 'id',
    systemArchitectureId: 'systemArchitectureId',
    platform: 'platform',
    displayName: 'displayName',
    description: 'description',
    frontend: 'frontend',
    backend: 'backend',
    infrastructure: 'infrastructure',
    technologies: 'technologies',
    components: 'components',
    dependencies: 'dependencies',
    deploymentStrategy: 'deploymentStrategy',
    scalingStrategy: 'scalingStrategy',
    diagrams: 'diagrams',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformArchitectureScalarFieldEnum = (typeof PlatformArchitectureScalarFieldEnum)[keyof typeof PlatformArchitectureScalarFieldEnum]


  export const ArchitectureChangeHistoryScalarFieldEnum: {
    id: 'id',
    architectureId: 'architectureId',
    changeType: 'changeType',
    changeDescription: 'changeDescription',
    changeReason: 'changeReason',
    impact: 'impact',
    beforeChange: 'beforeChange',
    afterChange: 'afterChange',
    changedAt: 'changedAt',
    userId: 'userId'
  };

  export type ArchitectureChangeHistoryScalarFieldEnum = (typeof ArchitectureChangeHistoryScalarFieldEnum)[keyof typeof ArchitectureChangeHistoryScalarFieldEnum]


  export const DatabaseSchemaScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    schemaName: 'schemaName',
    engine: 'engine',
    charset: 'charset',
    collation: 'collation',
    description: 'description',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    userId: 'userId'
  };

  export type DatabaseSchemaScalarFieldEnum = (typeof DatabaseSchemaScalarFieldEnum)[keyof typeof DatabaseSchemaScalarFieldEnum]


  export const DatabaseTableScalarFieldEnum: {
    id: 'id',
    schemaId: 'schemaId',
    tableName: 'tableName',
    displayName: 'displayName',
    description: 'description',
    engine: 'engine',
    charset: 'charset',
    collation: 'collation',
    autoIncrement: 'autoIncrement',
    comment: 'comment',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DatabaseTableScalarFieldEnum = (typeof DatabaseTableScalarFieldEnum)[keyof typeof DatabaseTableScalarFieldEnum]


  export const TableColumnScalarFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    columnName: 'columnName',
    displayName: 'displayName',
    columnType: 'columnType',
    length: 'length',
    precision: 'precision',
    scale: 'scale',
    isPrimaryKey: 'isPrimaryKey',
    isNullable: 'isNullable',
    isUnique: 'isUnique',
    isAutoIncrement: 'isAutoIncrement',
    defaultValue: 'defaultValue',
    comment: 'comment',
    enumValues: 'enumValues',
    isForeignKey: 'isForeignKey',
    referencedTable: 'referencedTable',
    referencedColumn: 'referencedColumn',
    onDelete: 'onDelete',
    onUpdate: 'onUpdate',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TableColumnScalarFieldEnum = (typeof TableColumnScalarFieldEnum)[keyof typeof TableColumnScalarFieldEnum]


  export const DatabaseIndexScalarFieldEnum: {
    id: 'id',
    tableId: 'tableId',
    indexName: 'indexName',
    indexType: 'indexType',
    columns: 'columns',
    isUnique: 'isUnique',
    comment: 'comment',
    algorithm: 'algorithm',
    lockOption: 'lockOption',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DatabaseIndexScalarFieldEnum = (typeof DatabaseIndexScalarFieldEnum)[keyof typeof DatabaseIndexScalarFieldEnum]


  export const DatabaseRelationScalarFieldEnum: {
    id: 'id',
    schemaId: 'schemaId',
    relationName: 'relationName',
    relationType: 'relationType',
    sourceTableId: 'sourceTableId',
    sourceColumns: 'sourceColumns',
    targetTableId: 'targetTableId',
    targetColumns: 'targetColumns',
    onDelete: 'onDelete',
    onUpdate: 'onUpdate',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DatabaseRelationScalarFieldEnum = (typeof DatabaseRelationScalarFieldEnum)[keyof typeof DatabaseRelationScalarFieldEnum]


  export const DocumentationScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    content: 'content',
    summary: 'summary',
    type: 'type',
    status: 'status',
    visibility: 'visibility',
    category: 'category',
    url: 'url',
    version: 'version',
    versionNumber: 'versionNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt',
    deletedAt: 'deletedAt',
    userId: 'userId'
  };

  export type DocumentationScalarFieldEnum = (typeof DocumentationScalarFieldEnum)[keyof typeof DocumentationScalarFieldEnum]


  export const DocumentVersionScalarFieldEnum: {
    id: 'id',
    documentationId: 'documentationId',
    version: 'version',
    content: 'content',
    changeLog: 'changeLog',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type DocumentVersionScalarFieldEnum = (typeof DocumentVersionScalarFieldEnum)[keyof typeof DocumentVersionScalarFieldEnum]


  export const DocumentTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentTagScalarFieldEnum = (typeof DocumentTagScalarFieldEnum)[keyof typeof DocumentTagScalarFieldEnum]


  export const DocumentCommentScalarFieldEnum: {
    id: 'id',
    documentationId: 'documentationId',
    content: 'content',
    parentId: 'parentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId'
  };

  export type DocumentCommentScalarFieldEnum = (typeof DocumentCommentScalarFieldEnum)[keyof typeof DocumentCommentScalarFieldEnum]


  export const DocumentAttachmentScalarFieldEnum: {
    id: 'id',
    documentationId: 'documentationId',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type DocumentAttachmentScalarFieldEnum = (typeof DocumentAttachmentScalarFieldEnum)[keyof typeof DocumentAttachmentScalarFieldEnum]


  export const MindMapScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    description: 'description',
    overview: 'overview',
    nodeId: 'nodeId',
    theme: 'theme',
    layout: 'layout',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    userId: 'userId'
  };

  export type MindMapScalarFieldEnum = (typeof MindMapScalarFieldEnum)[keyof typeof MindMapScalarFieldEnum]


  export const MindMapNodeScalarFieldEnum: {
    id: 'id',
    mindMapId: 'mindMapId',
    content: 'content',
    note: 'note',
    nodeType: 'nodeType',
    parentId: 'parentId',
    position: 'position',
    expanded: 'expanded',
    style: 'style',
    link: 'link',
    icon: 'icon',
    priority: 'priority',
    progress: 'progress',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MindMapNodeScalarFieldEnum = (typeof MindMapNodeScalarFieldEnum)[keyof typeof MindMapNodeScalarFieldEnum]


  export const DomainKnowledgeScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    domain: 'domain',
    description: 'description',
    category: 'category',
    tags: 'tags',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    userId: 'userId'
  };

  export type DomainKnowledgeScalarFieldEnum = (typeof DomainKnowledgeScalarFieldEnum)[keyof typeof DomainKnowledgeScalarFieldEnum]


  export const DomainConceptScalarFieldEnum: {
    id: 'id',
    domainKnowledgeId: 'domainKnowledgeId',
    name: 'name',
    definition: 'definition',
    examples: 'examples',
    relatedConcepts: 'relatedConcepts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DomainConceptScalarFieldEnum = (typeof DomainConceptScalarFieldEnum)[keyof typeof DomainConceptScalarFieldEnum]


  export const DomainPatternScalarFieldEnum: {
    id: 'id',
    domainKnowledgeId: 'domainKnowledgeId',
    name: 'name',
    description: 'description',
    context: 'context',
    solution: 'solution',
    consequences: 'consequences',
    examples: 'examples',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DomainPatternScalarFieldEnum = (typeof DomainPatternScalarFieldEnum)[keyof typeof DomainPatternScalarFieldEnum]


  export const DomainBestPracticeScalarFieldEnum: {
    id: 'id',
    domainKnowledgeId: 'domainKnowledgeId',
    title: 'title',
    description: 'description',
    rationale: 'rationale',
    implementation: 'implementation',
    benefits: 'benefits',
    considerations: 'considerations',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DomainBestPracticeScalarFieldEnum = (typeof DomainBestPracticeScalarFieldEnum)[keyof typeof DomainBestPracticeScalarFieldEnum]


  export const DomainAntiPatternScalarFieldEnum: {
    id: 'id',
    domainKnowledgeId: 'domainKnowledgeId',
    name: 'name',
    description: 'description',
    symptoms: 'symptoms',
    causes: 'causes',
    consequences: 'consequences',
    refactoring: 'refactoring',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DomainAntiPatternScalarFieldEnum = (typeof DomainAntiPatternScalarFieldEnum)[keyof typeof DomainAntiPatternScalarFieldEnum]


  export const DomainReferenceScalarFieldEnum: {
    id: 'id',
    domainKnowledgeId: 'domainKnowledgeId',
    title: 'title',
    type: 'type',
    url: 'url',
    author: 'author',
    publishDate: 'publishDate',
    summary: 'summary',
    createdAt: 'createdAt'
  };

  export type DomainReferenceScalarFieldEnum = (typeof DomainReferenceScalarFieldEnum)[keyof typeof DomainReferenceScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdBy: 'createdBy'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const RequirementScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    title: 'title',
    content: 'content',
    type: 'type',
    priority: 'priority',
    status: 'status',
    source: 'source',
    parentId: 'parentId',
    version: 'version',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    userId: 'userId'
  };

  export type RequirementScalarFieldEnum = (typeof RequirementScalarFieldEnum)[keyof typeof RequirementScalarFieldEnum]


  export const RequirementQuestionScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    requirementId: 'requirementId',
    question: 'question',
    answer: 'answer',
    status: 'status',
    priority: 'priority',
    clarified: 'clarified',
    agentId: 'agentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    answeredAt: 'answeredAt'
  };

  export type RequirementQuestionScalarFieldEnum = (typeof RequirementQuestionScalarFieldEnum)[keyof typeof RequirementQuestionScalarFieldEnum]


  export const RequirementAttachmentScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    requirementId: 'requirementId',
    fileName: 'fileName',
    fileUrl: 'fileUrl',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type RequirementAttachmentScalarFieldEnum = (typeof RequirementAttachmentScalarFieldEnum)[keyof typeof RequirementAttachmentScalarFieldEnum]


  export const RoadmapScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoadmapScalarFieldEnum = (typeof RoadmapScalarFieldEnum)[keyof typeof RoadmapScalarFieldEnum]


  export const MilestoneScalarFieldEnum: {
    id: 'id',
    roadmapId: 'roadmapId',
    name: 'name',
    description: 'description',
    targetDate: 'targetDate',
    status: 'status',
    priority: 'priority',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MilestoneScalarFieldEnum = (typeof MilestoneScalarFieldEnum)[keyof typeof MilestoneScalarFieldEnum]


  export const VersionScalarFieldEnum: {
    id: 'id',
    roadmapId: 'roadmapId',
    name: 'name',
    description: 'description',
    releaseDate: 'releaseDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VersionScalarFieldEnum = (typeof VersionScalarFieldEnum)[keyof typeof VersionScalarFieldEnum]


  export const FeatureScalarFieldEnum: {
    id: 'id',
    milestoneId: 'milestoneId',
    versionId: 'versionId',
    name: 'name',
    description: 'description',
    status: 'status',
    priority: 'priority',
    effort: 'effort',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeatureScalarFieldEnum = (typeof FeatureScalarFieldEnum)[keyof typeof FeatureScalarFieldEnum]


  export const SprintScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    startDate: 'startDate',
    endDate: 'endDate',
    goal: 'goal',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SprintScalarFieldEnum = (typeof SprintScalarFieldEnum)[keyof typeof SprintScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    sprintId: 'sprintId',
    teamId: 'teamId',
    title: 'title',
    content: 'content',
    status: 'status',
    dueDate: 'dueDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    featureId: 'featureId'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    name: 'name',
    avatar: 'avatar',
    role: 'role',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    userId: 'userId',
    role: 'role',
    permissions: 'permissions',
    joinedAt: 'joinedAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ApiMethod'
   */
  export type EnumApiMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiMethod'>
    


  /**
   * Reference to a field of type 'ApiMethod[]'
   */
  export type ListEnumApiMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiMethod[]'>
    


  /**
   * Reference to a field of type 'ApiContentType'
   */
  export type EnumApiContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiContentType'>
    


  /**
   * Reference to a field of type 'ApiContentType[]'
   */
  export type ListEnumApiContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiContentType[]'>
    


  /**
   * Reference to a field of type 'ApiAuthType'
   */
  export type EnumApiAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiAuthType'>
    


  /**
   * Reference to a field of type 'ApiAuthType[]'
   */
  export type ListEnumApiAuthTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiAuthType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ApiStatus'
   */
  export type EnumApiStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiStatus'>
    


  /**
   * Reference to a field of type 'ApiStatus[]'
   */
  export type ListEnumApiStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiStatus[]'>
    


  /**
   * Reference to a field of type 'ArchitectureStatus'
   */
  export type EnumArchitectureStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArchitectureStatus'>
    


  /**
   * Reference to a field of type 'ArchitectureStatus[]'
   */
  export type ListEnumArchitectureStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArchitectureStatus[]'>
    


  /**
   * Reference to a field of type 'DatabaseEngine'
   */
  export type EnumDatabaseEngineFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatabaseEngine'>
    


  /**
   * Reference to a field of type 'DatabaseEngine[]'
   */
  export type ListEnumDatabaseEngineFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DatabaseEngine[]'>
    


  /**
   * Reference to a field of type 'ColumnType'
   */
  export type EnumColumnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ColumnType'>
    


  /**
   * Reference to a field of type 'ColumnType[]'
   */
  export type ListEnumColumnTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ColumnType[]'>
    


  /**
   * Reference to a field of type 'IndexType'
   */
  export type EnumIndexTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndexType'>
    


  /**
   * Reference to a field of type 'IndexType[]'
   */
  export type ListEnumIndexTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IndexType[]'>
    


  /**
   * Reference to a field of type 'RelationType'
   */
  export type EnumRelationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationType'>
    


  /**
   * Reference to a field of type 'RelationType[]'
   */
  export type ListEnumRelationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationType[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentVisibility'
   */
  export type EnumDocumentVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentVisibility'>
    


  /**
   * Reference to a field of type 'DocumentVisibility[]'
   */
  export type ListEnumDocumentVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentVisibility[]'>
    


  /**
   * Reference to a field of type 'NodeType'
   */
  export type EnumNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeType'>
    


  /**
   * Reference to a field of type 'NodeType[]'
   */
  export type ListEnumNodeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NodeType[]'>
    


  /**
   * Reference to a field of type 'KnowledgeCategory'
   */
  export type EnumKnowledgeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeCategory'>
    


  /**
   * Reference to a field of type 'KnowledgeCategory[]'
   */
  export type ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KnowledgeCategory[]'>
    


  /**
   * Reference to a field of type 'RequirementType'
   */
  export type EnumRequirementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementType'>
    


  /**
   * Reference to a field of type 'RequirementType[]'
   */
  export type ListEnumRequirementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementType[]'>
    


  /**
   * Reference to a field of type 'RequirementPriority'
   */
  export type EnumRequirementPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementPriority'>
    


  /**
   * Reference to a field of type 'RequirementPriority[]'
   */
  export type ListEnumRequirementPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementPriority[]'>
    


  /**
   * Reference to a field of type 'RequirementStatus'
   */
  export type EnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus'>
    


  /**
   * Reference to a field of type 'RequirementStatus[]'
   */
  export type ListEnumRequirementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementStatus[]'>
    


  /**
   * Reference to a field of type 'RequirementSource'
   */
  export type EnumRequirementSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementSource'>
    


  /**
   * Reference to a field of type 'RequirementSource[]'
   */
  export type ListEnumRequirementSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RequirementSource[]'>
    


  /**
   * Reference to a field of type 'QuestionStatus'
   */
  export type EnumQuestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionStatus'>
    


  /**
   * Reference to a field of type 'QuestionStatus[]'
   */
  export type ListEnumQuestionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionStatus[]'>
    


  /**
   * Reference to a field of type 'QuestionPriority'
   */
  export type EnumQuestionPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionPriority'>
    


  /**
   * Reference to a field of type 'QuestionPriority[]'
   */
  export type ListEnumQuestionPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionPriority[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'ProjectRole'
   */
  export type EnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole'>
    


  /**
   * Reference to a field of type 'ProjectRole[]'
   */
  export type ListEnumProjectRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectRole[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    projectId?: StringFilter<"Agent"> | string
    teamId?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    workPrompt?: StringNullableFilter<"Agent"> | string | null
    responsibilities?: StringNullableListFilter<"Agent">
    skills?: StringNullableListFilter<"Agent">
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    AgentActivity?: AgentActivityListRelationFilter
    AgentTask?: AgentTaskListRelationFilter
    AgentWorklog?: AgentWorklogListRelationFilter
    RequirementQuestion?: RequirementQuestionListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    workPrompt?: SortOrderInput | SortOrder
    responsibilities?: SortOrder
    skills?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    AgentActivity?: AgentActivityOrderByRelationAggregateInput
    AgentTask?: AgentTaskOrderByRelationAggregateInput
    AgentWorklog?: AgentWorklogOrderByRelationAggregateInput
    RequirementQuestion?: RequirementQuestionOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    projectId?: StringFilter<"Agent"> | string
    teamId?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    workPrompt?: StringNullableFilter<"Agent"> | string | null
    responsibilities?: StringNullableListFilter<"Agent">
    skills?: StringNullableListFilter<"Agent">
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    AgentActivity?: AgentActivityListRelationFilter
    AgentTask?: AgentTaskListRelationFilter
    AgentWorklog?: AgentWorklogListRelationFilter
    RequirementQuestion?: RequirementQuestionListRelationFilter
  }, "id">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    workPrompt?: SortOrderInput | SortOrder
    responsibilities?: SortOrder
    skills?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    projectId?: StringWithAggregatesFilter<"Agent"> | string
    teamId?: StringWithAggregatesFilter<"Agent"> | string
    name?: StringWithAggregatesFilter<"Agent"> | string
    description?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    workPrompt?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    responsibilities?: StringNullableListFilter<"Agent">
    skills?: StringNullableListFilter<"Agent">
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type AgentTaskWhereInput = {
    AND?: AgentTaskWhereInput | AgentTaskWhereInput[]
    OR?: AgentTaskWhereInput[]
    NOT?: AgentTaskWhereInput | AgentTaskWhereInput[]
    id?: StringFilter<"AgentTask"> | string
    agentId?: StringFilter<"AgentTask"> | string
    taskId?: StringFilter<"AgentTask"> | string
    createdAt?: DateTimeFilter<"AgentTask"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTask"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type AgentTaskOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type AgentTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentTaskWhereInput | AgentTaskWhereInput[]
    OR?: AgentTaskWhereInput[]
    NOT?: AgentTaskWhereInput | AgentTaskWhereInput[]
    agentId?: StringFilter<"AgentTask"> | string
    taskId?: StringFilter<"AgentTask"> | string
    createdAt?: DateTimeFilter<"AgentTask"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTask"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id">

  export type AgentTaskOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentTaskCountOrderByAggregateInput
    _max?: AgentTaskMaxOrderByAggregateInput
    _min?: AgentTaskMinOrderByAggregateInput
  }

  export type AgentTaskScalarWhereWithAggregatesInput = {
    AND?: AgentTaskScalarWhereWithAggregatesInput | AgentTaskScalarWhereWithAggregatesInput[]
    OR?: AgentTaskScalarWhereWithAggregatesInput[]
    NOT?: AgentTaskScalarWhereWithAggregatesInput | AgentTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentTask"> | string
    agentId?: StringWithAggregatesFilter<"AgentTask"> | string
    taskId?: StringWithAggregatesFilter<"AgentTask"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AgentTask"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentTask"> | Date | string
  }

  export type AgentActivityWhereInput = {
    AND?: AgentActivityWhereInput | AgentActivityWhereInput[]
    OR?: AgentActivityWhereInput[]
    NOT?: AgentActivityWhereInput | AgentActivityWhereInput[]
    id?: StringFilter<"AgentActivity"> | string
    agentId?: StringFilter<"AgentActivity"> | string
    body?: StringFilter<"AgentActivity"> | string
    action?: StringFilter<"AgentActivity"> | string
    details?: JsonNullableFilter<"AgentActivity">
    createdAt?: DateTimeFilter<"AgentActivity"> | Date | string
    updatedAt?: DateTimeFilter<"AgentActivity"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type AgentActivityOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    body?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agent?: AgentOrderByWithRelationInput
  }

  export type AgentActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentActivityWhereInput | AgentActivityWhereInput[]
    OR?: AgentActivityWhereInput[]
    NOT?: AgentActivityWhereInput | AgentActivityWhereInput[]
    agentId?: StringFilter<"AgentActivity"> | string
    body?: StringFilter<"AgentActivity"> | string
    action?: StringFilter<"AgentActivity"> | string
    details?: JsonNullableFilter<"AgentActivity">
    createdAt?: DateTimeFilter<"AgentActivity"> | Date | string
    updatedAt?: DateTimeFilter<"AgentActivity"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type AgentActivityOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    body?: SortOrder
    action?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentActivityCountOrderByAggregateInput
    _max?: AgentActivityMaxOrderByAggregateInput
    _min?: AgentActivityMinOrderByAggregateInput
  }

  export type AgentActivityScalarWhereWithAggregatesInput = {
    AND?: AgentActivityScalarWhereWithAggregatesInput | AgentActivityScalarWhereWithAggregatesInput[]
    OR?: AgentActivityScalarWhereWithAggregatesInput[]
    NOT?: AgentActivityScalarWhereWithAggregatesInput | AgentActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentActivity"> | string
    agentId?: StringWithAggregatesFilter<"AgentActivity"> | string
    body?: StringWithAggregatesFilter<"AgentActivity"> | string
    action?: StringWithAggregatesFilter<"AgentActivity"> | string
    details?: JsonNullableWithAggregatesFilter<"AgentActivity">
    createdAt?: DateTimeWithAggregatesFilter<"AgentActivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentActivity"> | Date | string
  }

  export type AgentWorklogWhereInput = {
    AND?: AgentWorklogWhereInput | AgentWorklogWhereInput[]
    OR?: AgentWorklogWhereInput[]
    NOT?: AgentWorklogWhereInput | AgentWorklogWhereInput[]
    id?: StringFilter<"AgentWorklog"> | string
    projectId?: StringFilter<"AgentWorklog"> | string
    agentId?: StringFilter<"AgentWorklog"> | string
    taskId?: StringFilter<"AgentWorklog"> | string
    workType?: StringFilter<"AgentWorklog"> | string
    summarize?: StringNullableFilter<"AgentWorklog"> | string | null
    nextPlan?: StringNullableFilter<"AgentWorklog"> | string | null
    content?: StringNullableFilter<"AgentWorklog"> | string | null
    metadata?: JsonNullableFilter<"AgentWorklog">
    createdAt?: DateTimeFilter<"AgentWorklog"> | Date | string
    updatedAt?: DateTimeFilter<"AgentWorklog"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type AgentWorklogOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    workType?: SortOrder
    summarize?: SortOrderInput | SortOrder
    nextPlan?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type AgentWorklogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentWorklogWhereInput | AgentWorklogWhereInput[]
    OR?: AgentWorklogWhereInput[]
    NOT?: AgentWorklogWhereInput | AgentWorklogWhereInput[]
    projectId?: StringFilter<"AgentWorklog"> | string
    agentId?: StringFilter<"AgentWorklog"> | string
    taskId?: StringFilter<"AgentWorklog"> | string
    workType?: StringFilter<"AgentWorklog"> | string
    summarize?: StringNullableFilter<"AgentWorklog"> | string | null
    nextPlan?: StringNullableFilter<"AgentWorklog"> | string | null
    content?: StringNullableFilter<"AgentWorklog"> | string | null
    metadata?: JsonNullableFilter<"AgentWorklog">
    createdAt?: DateTimeFilter<"AgentWorklog"> | Date | string
    updatedAt?: DateTimeFilter<"AgentWorklog"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id">

  export type AgentWorklogOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    workType?: SortOrder
    summarize?: SortOrderInput | SortOrder
    nextPlan?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentWorklogCountOrderByAggregateInput
    _max?: AgentWorklogMaxOrderByAggregateInput
    _min?: AgentWorklogMinOrderByAggregateInput
  }

  export type AgentWorklogScalarWhereWithAggregatesInput = {
    AND?: AgentWorklogScalarWhereWithAggregatesInput | AgentWorklogScalarWhereWithAggregatesInput[]
    OR?: AgentWorklogScalarWhereWithAggregatesInput[]
    NOT?: AgentWorklogScalarWhereWithAggregatesInput | AgentWorklogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentWorklog"> | string
    projectId?: StringWithAggregatesFilter<"AgentWorklog"> | string
    agentId?: StringWithAggregatesFilter<"AgentWorklog"> | string
    taskId?: StringWithAggregatesFilter<"AgentWorklog"> | string
    workType?: StringWithAggregatesFilter<"AgentWorklog"> | string
    summarize?: StringNullableWithAggregatesFilter<"AgentWorklog"> | string | null
    nextPlan?: StringNullableWithAggregatesFilter<"AgentWorklog"> | string | null
    content?: StringNullableWithAggregatesFilter<"AgentWorklog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AgentWorklog">
    createdAt?: DateTimeWithAggregatesFilter<"AgentWorklog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentWorklog"> | Date | string
  }

  export type AgentPromptTemplateWhereInput = {
    AND?: AgentPromptTemplateWhereInput | AgentPromptTemplateWhereInput[]
    OR?: AgentPromptTemplateWhereInput[]
    NOT?: AgentPromptTemplateWhereInput | AgentPromptTemplateWhereInput[]
    id?: StringFilter<"AgentPromptTemplate"> | string
    name?: StringFilter<"AgentPromptTemplate"> | string
    responsibility?: StringFilter<"AgentPromptTemplate"> | string
    prompt?: StringFilter<"AgentPromptTemplate"> | string
    description?: StringNullableFilter<"AgentPromptTemplate"> | string | null
    isActive?: BoolFilter<"AgentPromptTemplate"> | boolean
    createdAt?: DateTimeFilter<"AgentPromptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AgentPromptTemplate"> | Date | string
  }

  export type AgentPromptTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    responsibility?: SortOrder
    prompt?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentPromptTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentPromptTemplateWhereInput | AgentPromptTemplateWhereInput[]
    OR?: AgentPromptTemplateWhereInput[]
    NOT?: AgentPromptTemplateWhereInput | AgentPromptTemplateWhereInput[]
    name?: StringFilter<"AgentPromptTemplate"> | string
    responsibility?: StringFilter<"AgentPromptTemplate"> | string
    prompt?: StringFilter<"AgentPromptTemplate"> | string
    description?: StringNullableFilter<"AgentPromptTemplate"> | string | null
    isActive?: BoolFilter<"AgentPromptTemplate"> | boolean
    createdAt?: DateTimeFilter<"AgentPromptTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"AgentPromptTemplate"> | Date | string
  }, "id">

  export type AgentPromptTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    responsibility?: SortOrder
    prompt?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentPromptTemplateCountOrderByAggregateInput
    _max?: AgentPromptTemplateMaxOrderByAggregateInput
    _min?: AgentPromptTemplateMinOrderByAggregateInput
  }

  export type AgentPromptTemplateScalarWhereWithAggregatesInput = {
    AND?: AgentPromptTemplateScalarWhereWithAggregatesInput | AgentPromptTemplateScalarWhereWithAggregatesInput[]
    OR?: AgentPromptTemplateScalarWhereWithAggregatesInput[]
    NOT?: AgentPromptTemplateScalarWhereWithAggregatesInput | AgentPromptTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AgentPromptTemplate"> | string
    name?: StringWithAggregatesFilter<"AgentPromptTemplate"> | string
    responsibility?: StringWithAggregatesFilter<"AgentPromptTemplate"> | string
    prompt?: StringWithAggregatesFilter<"AgentPromptTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"AgentPromptTemplate"> | string | null
    isActive?: BoolWithAggregatesFilter<"AgentPromptTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"AgentPromptTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AgentPromptTemplate"> | Date | string
  }

  export type ApiDesignWhereInput = {
    AND?: ApiDesignWhereInput | ApiDesignWhereInput[]
    OR?: ApiDesignWhereInput[]
    NOT?: ApiDesignWhereInput | ApiDesignWhereInput[]
    id?: StringFilter<"ApiDesign"> | string
    projectId?: StringFilter<"ApiDesign"> | string
    apiName?: StringFilter<"ApiDesign"> | string
    apiPath?: StringFilter<"ApiDesign"> | string
    apiMethod?: EnumApiMethodFilter<"ApiDesign"> | $Enums.ApiMethod
    apiVersion?: StringFilter<"ApiDesign"> | string
    platform?: StringFilter<"ApiDesign"> | string
    module?: StringNullableFilter<"ApiDesign"> | string | null
    apiDescription?: StringFilter<"ApiDesign"> | string
    businessLogic?: StringNullableFilter<"ApiDesign"> | string | null
    apiContentType?: EnumApiContentTypeFilter<"ApiDesign"> | $Enums.ApiContentType
    requestHeaders?: JsonNullableFilter<"ApiDesign">
    requestParams?: JsonNullableFilter<"ApiDesign">
    requestBody?: JsonNullableFilter<"ApiDesign">
    responseHeaders?: JsonNullableFilter<"ApiDesign">
    responseBody?: JsonNullableFilter<"ApiDesign">
    authentication?: EnumApiAuthTypeFilter<"ApiDesign"> | $Enums.ApiAuthType
    authDetails?: JsonNullableFilter<"ApiDesign">
    permissions?: StringNullableListFilter<"ApiDesign">
    rateLimit?: IntNullableFilter<"ApiDesign"> | number | null
    timeout?: IntNullableFilter<"ApiDesign"> | number | null
    maxPayloadSize?: IntNullableFilter<"ApiDesign"> | number | null
    status?: EnumApiStatusFilter<"ApiDesign"> | $Enums.ApiStatus
    deprecated?: BoolFilter<"ApiDesign"> | boolean
    deprecationDate?: DateTimeNullableFilter<"ApiDesign"> | Date | string | null
    sunsetDate?: DateTimeNullableFilter<"ApiDesign"> | Date | string | null
    version?: IntFilter<"ApiDesign"> | number
    createdAt?: DateTimeFilter<"ApiDesign"> | Date | string
    updatedAt?: DateTimeFilter<"ApiDesign"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ApiDesign"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    examples?: ApiExampleListRelationFilter
    errorCodes?: ApiErrorCodeListRelationFilter
  }

  export type ApiDesignOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    apiName?: SortOrder
    apiPath?: SortOrder
    apiMethod?: SortOrder
    apiVersion?: SortOrder
    platform?: SortOrder
    module?: SortOrderInput | SortOrder
    apiDescription?: SortOrder
    businessLogic?: SortOrderInput | SortOrder
    apiContentType?: SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    requestParams?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    authentication?: SortOrder
    authDetails?: SortOrderInput | SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    timeout?: SortOrderInput | SortOrder
    maxPayloadSize?: SortOrderInput | SortOrder
    status?: SortOrder
    deprecated?: SortOrder
    deprecationDate?: SortOrderInput | SortOrder
    sunsetDate?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    examples?: ApiExampleOrderByRelationAggregateInput
    errorCodes?: ApiErrorCodeOrderByRelationAggregateInput
  }

  export type ApiDesignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    apiPath_apiMethod_apiVersion?: ApiDesignApiPathApiMethodApiVersionCompoundUniqueInput
    AND?: ApiDesignWhereInput | ApiDesignWhereInput[]
    OR?: ApiDesignWhereInput[]
    NOT?: ApiDesignWhereInput | ApiDesignWhereInput[]
    projectId?: StringFilter<"ApiDesign"> | string
    apiName?: StringFilter<"ApiDesign"> | string
    apiPath?: StringFilter<"ApiDesign"> | string
    apiMethod?: EnumApiMethodFilter<"ApiDesign"> | $Enums.ApiMethod
    apiVersion?: StringFilter<"ApiDesign"> | string
    platform?: StringFilter<"ApiDesign"> | string
    module?: StringNullableFilter<"ApiDesign"> | string | null
    apiDescription?: StringFilter<"ApiDesign"> | string
    businessLogic?: StringNullableFilter<"ApiDesign"> | string | null
    apiContentType?: EnumApiContentTypeFilter<"ApiDesign"> | $Enums.ApiContentType
    requestHeaders?: JsonNullableFilter<"ApiDesign">
    requestParams?: JsonNullableFilter<"ApiDesign">
    requestBody?: JsonNullableFilter<"ApiDesign">
    responseHeaders?: JsonNullableFilter<"ApiDesign">
    responseBody?: JsonNullableFilter<"ApiDesign">
    authentication?: EnumApiAuthTypeFilter<"ApiDesign"> | $Enums.ApiAuthType
    authDetails?: JsonNullableFilter<"ApiDesign">
    permissions?: StringNullableListFilter<"ApiDesign">
    rateLimit?: IntNullableFilter<"ApiDesign"> | number | null
    timeout?: IntNullableFilter<"ApiDesign"> | number | null
    maxPayloadSize?: IntNullableFilter<"ApiDesign"> | number | null
    status?: EnumApiStatusFilter<"ApiDesign"> | $Enums.ApiStatus
    deprecated?: BoolFilter<"ApiDesign"> | boolean
    deprecationDate?: DateTimeNullableFilter<"ApiDesign"> | Date | string | null
    sunsetDate?: DateTimeNullableFilter<"ApiDesign"> | Date | string | null
    version?: IntFilter<"ApiDesign"> | number
    createdAt?: DateTimeFilter<"ApiDesign"> | Date | string
    updatedAt?: DateTimeFilter<"ApiDesign"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ApiDesign"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    examples?: ApiExampleListRelationFilter
    errorCodes?: ApiErrorCodeListRelationFilter
  }, "id" | "apiPath_apiMethod_apiVersion">

  export type ApiDesignOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    apiName?: SortOrder
    apiPath?: SortOrder
    apiMethod?: SortOrder
    apiVersion?: SortOrder
    platform?: SortOrder
    module?: SortOrderInput | SortOrder
    apiDescription?: SortOrder
    businessLogic?: SortOrderInput | SortOrder
    apiContentType?: SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    requestParams?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    authentication?: SortOrder
    authDetails?: SortOrderInput | SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrderInput | SortOrder
    timeout?: SortOrderInput | SortOrder
    maxPayloadSize?: SortOrderInput | SortOrder
    status?: SortOrder
    deprecated?: SortOrder
    deprecationDate?: SortOrderInput | SortOrder
    sunsetDate?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ApiDesignCountOrderByAggregateInput
    _avg?: ApiDesignAvgOrderByAggregateInput
    _max?: ApiDesignMaxOrderByAggregateInput
    _min?: ApiDesignMinOrderByAggregateInput
    _sum?: ApiDesignSumOrderByAggregateInput
  }

  export type ApiDesignScalarWhereWithAggregatesInput = {
    AND?: ApiDesignScalarWhereWithAggregatesInput | ApiDesignScalarWhereWithAggregatesInput[]
    OR?: ApiDesignScalarWhereWithAggregatesInput[]
    NOT?: ApiDesignScalarWhereWithAggregatesInput | ApiDesignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiDesign"> | string
    projectId?: StringWithAggregatesFilter<"ApiDesign"> | string
    apiName?: StringWithAggregatesFilter<"ApiDesign"> | string
    apiPath?: StringWithAggregatesFilter<"ApiDesign"> | string
    apiMethod?: EnumApiMethodWithAggregatesFilter<"ApiDesign"> | $Enums.ApiMethod
    apiVersion?: StringWithAggregatesFilter<"ApiDesign"> | string
    platform?: StringWithAggregatesFilter<"ApiDesign"> | string
    module?: StringNullableWithAggregatesFilter<"ApiDesign"> | string | null
    apiDescription?: StringWithAggregatesFilter<"ApiDesign"> | string
    businessLogic?: StringNullableWithAggregatesFilter<"ApiDesign"> | string | null
    apiContentType?: EnumApiContentTypeWithAggregatesFilter<"ApiDesign"> | $Enums.ApiContentType
    requestHeaders?: JsonNullableWithAggregatesFilter<"ApiDesign">
    requestParams?: JsonNullableWithAggregatesFilter<"ApiDesign">
    requestBody?: JsonNullableWithAggregatesFilter<"ApiDesign">
    responseHeaders?: JsonNullableWithAggregatesFilter<"ApiDesign">
    responseBody?: JsonNullableWithAggregatesFilter<"ApiDesign">
    authentication?: EnumApiAuthTypeWithAggregatesFilter<"ApiDesign"> | $Enums.ApiAuthType
    authDetails?: JsonNullableWithAggregatesFilter<"ApiDesign">
    permissions?: StringNullableListFilter<"ApiDesign">
    rateLimit?: IntNullableWithAggregatesFilter<"ApiDesign"> | number | null
    timeout?: IntNullableWithAggregatesFilter<"ApiDesign"> | number | null
    maxPayloadSize?: IntNullableWithAggregatesFilter<"ApiDesign"> | number | null
    status?: EnumApiStatusWithAggregatesFilter<"ApiDesign"> | $Enums.ApiStatus
    deprecated?: BoolWithAggregatesFilter<"ApiDesign"> | boolean
    deprecationDate?: DateTimeNullableWithAggregatesFilter<"ApiDesign"> | Date | string | null
    sunsetDate?: DateTimeNullableWithAggregatesFilter<"ApiDesign"> | Date | string | null
    version?: IntWithAggregatesFilter<"ApiDesign"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ApiDesign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiDesign"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ApiDesign"> | Date | string | null
  }

  export type ApiExampleWhereInput = {
    AND?: ApiExampleWhereInput | ApiExampleWhereInput[]
    OR?: ApiExampleWhereInput[]
    NOT?: ApiExampleWhereInput | ApiExampleWhereInput[]
    id?: StringFilter<"ApiExample"> | string
    apiDesignId?: StringFilter<"ApiExample"> | string
    name?: StringFilter<"ApiExample"> | string
    description?: StringFilter<"ApiExample"> | string
    requestUrl?: StringFilter<"ApiExample"> | string
    requestHeaders?: JsonNullableFilter<"ApiExample">
    requestParams?: JsonNullableFilter<"ApiExample">
    requestBody?: JsonNullableFilter<"ApiExample">
    responseStatus?: IntFilter<"ApiExample"> | number
    responseHeaders?: JsonNullableFilter<"ApiExample">
    responseBody?: JsonNullableFilter<"ApiExample">
    notes?: StringNullableFilter<"ApiExample"> | string | null
    isSuccess?: BoolFilter<"ApiExample"> | boolean
    createdAt?: DateTimeFilter<"ApiExample"> | Date | string
    updatedAt?: DateTimeFilter<"ApiExample"> | Date | string
    apiDesign?: XOR<ApiDesignScalarRelationFilter, ApiDesignWhereInput>
  }

  export type ApiExampleOrderByWithRelationInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requestUrl?: SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    requestParams?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseStatus?: SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiDesign?: ApiDesignOrderByWithRelationInput
  }

  export type ApiExampleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApiExampleWhereInput | ApiExampleWhereInput[]
    OR?: ApiExampleWhereInput[]
    NOT?: ApiExampleWhereInput | ApiExampleWhereInput[]
    apiDesignId?: StringFilter<"ApiExample"> | string
    name?: StringFilter<"ApiExample"> | string
    description?: StringFilter<"ApiExample"> | string
    requestUrl?: StringFilter<"ApiExample"> | string
    requestHeaders?: JsonNullableFilter<"ApiExample">
    requestParams?: JsonNullableFilter<"ApiExample">
    requestBody?: JsonNullableFilter<"ApiExample">
    responseStatus?: IntFilter<"ApiExample"> | number
    responseHeaders?: JsonNullableFilter<"ApiExample">
    responseBody?: JsonNullableFilter<"ApiExample">
    notes?: StringNullableFilter<"ApiExample"> | string | null
    isSuccess?: BoolFilter<"ApiExample"> | boolean
    createdAt?: DateTimeFilter<"ApiExample"> | Date | string
    updatedAt?: DateTimeFilter<"ApiExample"> | Date | string
    apiDesign?: XOR<ApiDesignScalarRelationFilter, ApiDesignWhereInput>
  }, "id">

  export type ApiExampleOrderByWithAggregationInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requestUrl?: SortOrder
    requestHeaders?: SortOrderInput | SortOrder
    requestParams?: SortOrderInput | SortOrder
    requestBody?: SortOrderInput | SortOrder
    responseStatus?: SortOrder
    responseHeaders?: SortOrderInput | SortOrder
    responseBody?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiExampleCountOrderByAggregateInput
    _avg?: ApiExampleAvgOrderByAggregateInput
    _max?: ApiExampleMaxOrderByAggregateInput
    _min?: ApiExampleMinOrderByAggregateInput
    _sum?: ApiExampleSumOrderByAggregateInput
  }

  export type ApiExampleScalarWhereWithAggregatesInput = {
    AND?: ApiExampleScalarWhereWithAggregatesInput | ApiExampleScalarWhereWithAggregatesInput[]
    OR?: ApiExampleScalarWhereWithAggregatesInput[]
    NOT?: ApiExampleScalarWhereWithAggregatesInput | ApiExampleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiExample"> | string
    apiDesignId?: StringWithAggregatesFilter<"ApiExample"> | string
    name?: StringWithAggregatesFilter<"ApiExample"> | string
    description?: StringWithAggregatesFilter<"ApiExample"> | string
    requestUrl?: StringWithAggregatesFilter<"ApiExample"> | string
    requestHeaders?: JsonNullableWithAggregatesFilter<"ApiExample">
    requestParams?: JsonNullableWithAggregatesFilter<"ApiExample">
    requestBody?: JsonNullableWithAggregatesFilter<"ApiExample">
    responseStatus?: IntWithAggregatesFilter<"ApiExample"> | number
    responseHeaders?: JsonNullableWithAggregatesFilter<"ApiExample">
    responseBody?: JsonNullableWithAggregatesFilter<"ApiExample">
    notes?: StringNullableWithAggregatesFilter<"ApiExample"> | string | null
    isSuccess?: BoolWithAggregatesFilter<"ApiExample"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApiExample"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiExample"> | Date | string
  }

  export type ApiErrorCodeWhereInput = {
    AND?: ApiErrorCodeWhereInput | ApiErrorCodeWhereInput[]
    OR?: ApiErrorCodeWhereInput[]
    NOT?: ApiErrorCodeWhereInput | ApiErrorCodeWhereInput[]
    id?: StringFilter<"ApiErrorCode"> | string
    apiDesignId?: StringFilter<"ApiErrorCode"> | string
    code?: StringFilter<"ApiErrorCode"> | string
    httpStatus?: IntFilter<"ApiErrorCode"> | number
    message?: StringFilter<"ApiErrorCode"> | string
    description?: StringFilter<"ApiErrorCode"> | string
    solution?: StringNullableFilter<"ApiErrorCode"> | string | null
    createdAt?: DateTimeFilter<"ApiErrorCode"> | Date | string
    updatedAt?: DateTimeFilter<"ApiErrorCode"> | Date | string
    apiDesign?: XOR<ApiDesignScalarRelationFilter, ApiDesignWhereInput>
  }

  export type ApiErrorCodeOrderByWithRelationInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    code?: SortOrder
    httpStatus?: SortOrder
    message?: SortOrder
    description?: SortOrder
    solution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apiDesign?: ApiDesignOrderByWithRelationInput
  }

  export type ApiErrorCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    apiDesignId_code?: ApiErrorCodeApiDesignIdCodeCompoundUniqueInput
    AND?: ApiErrorCodeWhereInput | ApiErrorCodeWhereInput[]
    OR?: ApiErrorCodeWhereInput[]
    NOT?: ApiErrorCodeWhereInput | ApiErrorCodeWhereInput[]
    apiDesignId?: StringFilter<"ApiErrorCode"> | string
    code?: StringFilter<"ApiErrorCode"> | string
    httpStatus?: IntFilter<"ApiErrorCode"> | number
    message?: StringFilter<"ApiErrorCode"> | string
    description?: StringFilter<"ApiErrorCode"> | string
    solution?: StringNullableFilter<"ApiErrorCode"> | string | null
    createdAt?: DateTimeFilter<"ApiErrorCode"> | Date | string
    updatedAt?: DateTimeFilter<"ApiErrorCode"> | Date | string
    apiDesign?: XOR<ApiDesignScalarRelationFilter, ApiDesignWhereInput>
  }, "id" | "apiDesignId_code">

  export type ApiErrorCodeOrderByWithAggregationInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    code?: SortOrder
    httpStatus?: SortOrder
    message?: SortOrder
    description?: SortOrder
    solution?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiErrorCodeCountOrderByAggregateInput
    _avg?: ApiErrorCodeAvgOrderByAggregateInput
    _max?: ApiErrorCodeMaxOrderByAggregateInput
    _min?: ApiErrorCodeMinOrderByAggregateInput
    _sum?: ApiErrorCodeSumOrderByAggregateInput
  }

  export type ApiErrorCodeScalarWhereWithAggregatesInput = {
    AND?: ApiErrorCodeScalarWhereWithAggregatesInput | ApiErrorCodeScalarWhereWithAggregatesInput[]
    OR?: ApiErrorCodeScalarWhereWithAggregatesInput[]
    NOT?: ApiErrorCodeScalarWhereWithAggregatesInput | ApiErrorCodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiErrorCode"> | string
    apiDesignId?: StringWithAggregatesFilter<"ApiErrorCode"> | string
    code?: StringWithAggregatesFilter<"ApiErrorCode"> | string
    httpStatus?: IntWithAggregatesFilter<"ApiErrorCode"> | number
    message?: StringWithAggregatesFilter<"ApiErrorCode"> | string
    description?: StringWithAggregatesFilter<"ApiErrorCode"> | string
    solution?: StringNullableWithAggregatesFilter<"ApiErrorCode"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApiErrorCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiErrorCode"> | Date | string
  }

  export type SystemArchitectureWhereInput = {
    AND?: SystemArchitectureWhereInput | SystemArchitectureWhereInput[]
    OR?: SystemArchitectureWhereInput[]
    NOT?: SystemArchitectureWhereInput | SystemArchitectureWhereInput[]
    id?: StringFilter<"SystemArchitecture"> | string
    projectId?: StringFilter<"SystemArchitecture"> | string
    name?: StringFilter<"SystemArchitecture"> | string
    overview?: StringFilter<"SystemArchitecture"> | string
    version?: StringFilter<"SystemArchitecture"> | string
    status?: EnumArchitectureStatusFilter<"SystemArchitecture"> | $Enums.ArchitectureStatus
    platforms?: StringNullableListFilter<"SystemArchitecture">
    components?: StringNullableListFilter<"SystemArchitecture">
    technologies?: StringNullableListFilter<"SystemArchitecture">
    diagrams?: StringNullableFilter<"SystemArchitecture"> | string | null
    notes?: StringNullableFilter<"SystemArchitecture"> | string | null
    versionNumber?: IntFilter<"SystemArchitecture"> | number
    previousVersionId?: StringNullableFilter<"SystemArchitecture"> | string | null
    createdAt?: DateTimeFilter<"SystemArchitecture"> | Date | string
    updatedAt?: DateTimeFilter<"SystemArchitecture"> | Date | string
    deletedAt?: DateTimeNullableFilter<"SystemArchitecture"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    platformArchitectures?: PlatformArchitectureListRelationFilter
    changeHistories?: ArchitectureChangeHistoryListRelationFilter
    previousVersion?: XOR<SystemArchitectureNullableScalarRelationFilter, SystemArchitectureWhereInput> | null
    nextVersions?: SystemArchitectureListRelationFilter
  }

  export type SystemArchitectureOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    version?: SortOrder
    status?: SortOrder
    platforms?: SortOrder
    components?: SortOrder
    technologies?: SortOrder
    diagrams?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    versionNumber?: SortOrder
    previousVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    platformArchitectures?: PlatformArchitectureOrderByRelationAggregateInput
    changeHistories?: ArchitectureChangeHistoryOrderByRelationAggregateInput
    previousVersion?: SystemArchitectureOrderByWithRelationInput
    nextVersions?: SystemArchitectureOrderByRelationAggregateInput
  }

  export type SystemArchitectureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemArchitectureWhereInput | SystemArchitectureWhereInput[]
    OR?: SystemArchitectureWhereInput[]
    NOT?: SystemArchitectureWhereInput | SystemArchitectureWhereInput[]
    projectId?: StringFilter<"SystemArchitecture"> | string
    name?: StringFilter<"SystemArchitecture"> | string
    overview?: StringFilter<"SystemArchitecture"> | string
    version?: StringFilter<"SystemArchitecture"> | string
    status?: EnumArchitectureStatusFilter<"SystemArchitecture"> | $Enums.ArchitectureStatus
    platforms?: StringNullableListFilter<"SystemArchitecture">
    components?: StringNullableListFilter<"SystemArchitecture">
    technologies?: StringNullableListFilter<"SystemArchitecture">
    diagrams?: StringNullableFilter<"SystemArchitecture"> | string | null
    notes?: StringNullableFilter<"SystemArchitecture"> | string | null
    versionNumber?: IntFilter<"SystemArchitecture"> | number
    previousVersionId?: StringNullableFilter<"SystemArchitecture"> | string | null
    createdAt?: DateTimeFilter<"SystemArchitecture"> | Date | string
    updatedAt?: DateTimeFilter<"SystemArchitecture"> | Date | string
    deletedAt?: DateTimeNullableFilter<"SystemArchitecture"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    platformArchitectures?: PlatformArchitectureListRelationFilter
    changeHistories?: ArchitectureChangeHistoryListRelationFilter
    previousVersion?: XOR<SystemArchitectureNullableScalarRelationFilter, SystemArchitectureWhereInput> | null
    nextVersions?: SystemArchitectureListRelationFilter
  }, "id">

  export type SystemArchitectureOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    version?: SortOrder
    status?: SortOrder
    platforms?: SortOrder
    components?: SortOrder
    technologies?: SortOrder
    diagrams?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    versionNumber?: SortOrder
    previousVersionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SystemArchitectureCountOrderByAggregateInput
    _avg?: SystemArchitectureAvgOrderByAggregateInput
    _max?: SystemArchitectureMaxOrderByAggregateInput
    _min?: SystemArchitectureMinOrderByAggregateInput
    _sum?: SystemArchitectureSumOrderByAggregateInput
  }

  export type SystemArchitectureScalarWhereWithAggregatesInput = {
    AND?: SystemArchitectureScalarWhereWithAggregatesInput | SystemArchitectureScalarWhereWithAggregatesInput[]
    OR?: SystemArchitectureScalarWhereWithAggregatesInput[]
    NOT?: SystemArchitectureScalarWhereWithAggregatesInput | SystemArchitectureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemArchitecture"> | string
    projectId?: StringWithAggregatesFilter<"SystemArchitecture"> | string
    name?: StringWithAggregatesFilter<"SystemArchitecture"> | string
    overview?: StringWithAggregatesFilter<"SystemArchitecture"> | string
    version?: StringWithAggregatesFilter<"SystemArchitecture"> | string
    status?: EnumArchitectureStatusWithAggregatesFilter<"SystemArchitecture"> | $Enums.ArchitectureStatus
    platforms?: StringNullableListFilter<"SystemArchitecture">
    components?: StringNullableListFilter<"SystemArchitecture">
    technologies?: StringNullableListFilter<"SystemArchitecture">
    diagrams?: StringNullableWithAggregatesFilter<"SystemArchitecture"> | string | null
    notes?: StringNullableWithAggregatesFilter<"SystemArchitecture"> | string | null
    versionNumber?: IntWithAggregatesFilter<"SystemArchitecture"> | number
    previousVersionId?: StringNullableWithAggregatesFilter<"SystemArchitecture"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemArchitecture"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemArchitecture"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"SystemArchitecture"> | Date | string | null
  }

  export type PlatformArchitectureWhereInput = {
    AND?: PlatformArchitectureWhereInput | PlatformArchitectureWhereInput[]
    OR?: PlatformArchitectureWhereInput[]
    NOT?: PlatformArchitectureWhereInput | PlatformArchitectureWhereInput[]
    id?: StringFilter<"PlatformArchitecture"> | string
    systemArchitectureId?: StringFilter<"PlatformArchitecture"> | string
    platform?: StringFilter<"PlatformArchitecture"> | string
    displayName?: StringFilter<"PlatformArchitecture"> | string
    description?: StringFilter<"PlatformArchitecture"> | string
    frontend?: JsonNullableFilter<"PlatformArchitecture">
    backend?: JsonNullableFilter<"PlatformArchitecture">
    infrastructure?: JsonNullableFilter<"PlatformArchitecture">
    technologies?: StringNullableListFilter<"PlatformArchitecture">
    components?: StringNullableListFilter<"PlatformArchitecture">
    dependencies?: JsonNullableFilter<"PlatformArchitecture">
    deploymentStrategy?: StringNullableFilter<"PlatformArchitecture"> | string | null
    scalingStrategy?: StringNullableFilter<"PlatformArchitecture"> | string | null
    diagrams?: StringNullableFilter<"PlatformArchitecture"> | string | null
    notes?: StringNullableFilter<"PlatformArchitecture"> | string | null
    createdAt?: DateTimeFilter<"PlatformArchitecture"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformArchitecture"> | Date | string
    systemArchitecture?: XOR<SystemArchitectureScalarRelationFilter, SystemArchitectureWhereInput>
  }

  export type PlatformArchitectureOrderByWithRelationInput = {
    id?: SortOrder
    systemArchitectureId?: SortOrder
    platform?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    frontend?: SortOrderInput | SortOrder
    backend?: SortOrderInput | SortOrder
    infrastructure?: SortOrderInput | SortOrder
    technologies?: SortOrder
    components?: SortOrder
    dependencies?: SortOrderInput | SortOrder
    deploymentStrategy?: SortOrderInput | SortOrder
    scalingStrategy?: SortOrderInput | SortOrder
    diagrams?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    systemArchitecture?: SystemArchitectureOrderByWithRelationInput
  }

  export type PlatformArchitectureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlatformArchitectureWhereInput | PlatformArchitectureWhereInput[]
    OR?: PlatformArchitectureWhereInput[]
    NOT?: PlatformArchitectureWhereInput | PlatformArchitectureWhereInput[]
    systemArchitectureId?: StringFilter<"PlatformArchitecture"> | string
    platform?: StringFilter<"PlatformArchitecture"> | string
    displayName?: StringFilter<"PlatformArchitecture"> | string
    description?: StringFilter<"PlatformArchitecture"> | string
    frontend?: JsonNullableFilter<"PlatformArchitecture">
    backend?: JsonNullableFilter<"PlatformArchitecture">
    infrastructure?: JsonNullableFilter<"PlatformArchitecture">
    technologies?: StringNullableListFilter<"PlatformArchitecture">
    components?: StringNullableListFilter<"PlatformArchitecture">
    dependencies?: JsonNullableFilter<"PlatformArchitecture">
    deploymentStrategy?: StringNullableFilter<"PlatformArchitecture"> | string | null
    scalingStrategy?: StringNullableFilter<"PlatformArchitecture"> | string | null
    diagrams?: StringNullableFilter<"PlatformArchitecture"> | string | null
    notes?: StringNullableFilter<"PlatformArchitecture"> | string | null
    createdAt?: DateTimeFilter<"PlatformArchitecture"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformArchitecture"> | Date | string
    systemArchitecture?: XOR<SystemArchitectureScalarRelationFilter, SystemArchitectureWhereInput>
  }, "id">

  export type PlatformArchitectureOrderByWithAggregationInput = {
    id?: SortOrder
    systemArchitectureId?: SortOrder
    platform?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    frontend?: SortOrderInput | SortOrder
    backend?: SortOrderInput | SortOrder
    infrastructure?: SortOrderInput | SortOrder
    technologies?: SortOrder
    components?: SortOrder
    dependencies?: SortOrderInput | SortOrder
    deploymentStrategy?: SortOrderInput | SortOrder
    scalingStrategy?: SortOrderInput | SortOrder
    diagrams?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformArchitectureCountOrderByAggregateInput
    _max?: PlatformArchitectureMaxOrderByAggregateInput
    _min?: PlatformArchitectureMinOrderByAggregateInput
  }

  export type PlatformArchitectureScalarWhereWithAggregatesInput = {
    AND?: PlatformArchitectureScalarWhereWithAggregatesInput | PlatformArchitectureScalarWhereWithAggregatesInput[]
    OR?: PlatformArchitectureScalarWhereWithAggregatesInput[]
    NOT?: PlatformArchitectureScalarWhereWithAggregatesInput | PlatformArchitectureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlatformArchitecture"> | string
    systemArchitectureId?: StringWithAggregatesFilter<"PlatformArchitecture"> | string
    platform?: StringWithAggregatesFilter<"PlatformArchitecture"> | string
    displayName?: StringWithAggregatesFilter<"PlatformArchitecture"> | string
    description?: StringWithAggregatesFilter<"PlatformArchitecture"> | string
    frontend?: JsonNullableWithAggregatesFilter<"PlatformArchitecture">
    backend?: JsonNullableWithAggregatesFilter<"PlatformArchitecture">
    infrastructure?: JsonNullableWithAggregatesFilter<"PlatformArchitecture">
    technologies?: StringNullableListFilter<"PlatformArchitecture">
    components?: StringNullableListFilter<"PlatformArchitecture">
    dependencies?: JsonNullableWithAggregatesFilter<"PlatformArchitecture">
    deploymentStrategy?: StringNullableWithAggregatesFilter<"PlatformArchitecture"> | string | null
    scalingStrategy?: StringNullableWithAggregatesFilter<"PlatformArchitecture"> | string | null
    diagrams?: StringNullableWithAggregatesFilter<"PlatformArchitecture"> | string | null
    notes?: StringNullableWithAggregatesFilter<"PlatformArchitecture"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PlatformArchitecture"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlatformArchitecture"> | Date | string
  }

  export type ArchitectureChangeHistoryWhereInput = {
    AND?: ArchitectureChangeHistoryWhereInput | ArchitectureChangeHistoryWhereInput[]
    OR?: ArchitectureChangeHistoryWhereInput[]
    NOT?: ArchitectureChangeHistoryWhereInput | ArchitectureChangeHistoryWhereInput[]
    id?: StringFilter<"ArchitectureChangeHistory"> | string
    architectureId?: StringFilter<"ArchitectureChangeHistory"> | string
    changeType?: StringFilter<"ArchitectureChangeHistory"> | string
    changeDescription?: StringFilter<"ArchitectureChangeHistory"> | string
    changeReason?: StringFilter<"ArchitectureChangeHistory"> | string
    impact?: StringNullableFilter<"ArchitectureChangeHistory"> | string | null
    beforeChange?: JsonNullableFilter<"ArchitectureChangeHistory">
    afterChange?: JsonNullableFilter<"ArchitectureChangeHistory">
    changedAt?: DateTimeFilter<"ArchitectureChangeHistory"> | Date | string
    userId?: StringNullableFilter<"ArchitectureChangeHistory"> | string | null
    architecture?: XOR<SystemArchitectureScalarRelationFilter, SystemArchitectureWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ArchitectureChangeHistoryOrderByWithRelationInput = {
    id?: SortOrder
    architectureId?: SortOrder
    changeType?: SortOrder
    changeDescription?: SortOrder
    changeReason?: SortOrder
    impact?: SortOrderInput | SortOrder
    beforeChange?: SortOrderInput | SortOrder
    afterChange?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    architecture?: SystemArchitectureOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type ArchitectureChangeHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArchitectureChangeHistoryWhereInput | ArchitectureChangeHistoryWhereInput[]
    OR?: ArchitectureChangeHistoryWhereInput[]
    NOT?: ArchitectureChangeHistoryWhereInput | ArchitectureChangeHistoryWhereInput[]
    architectureId?: StringFilter<"ArchitectureChangeHistory"> | string
    changeType?: StringFilter<"ArchitectureChangeHistory"> | string
    changeDescription?: StringFilter<"ArchitectureChangeHistory"> | string
    changeReason?: StringFilter<"ArchitectureChangeHistory"> | string
    impact?: StringNullableFilter<"ArchitectureChangeHistory"> | string | null
    beforeChange?: JsonNullableFilter<"ArchitectureChangeHistory">
    afterChange?: JsonNullableFilter<"ArchitectureChangeHistory">
    changedAt?: DateTimeFilter<"ArchitectureChangeHistory"> | Date | string
    userId?: StringNullableFilter<"ArchitectureChangeHistory"> | string | null
    architecture?: XOR<SystemArchitectureScalarRelationFilter, SystemArchitectureWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type ArchitectureChangeHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    architectureId?: SortOrder
    changeType?: SortOrder
    changeDescription?: SortOrder
    changeReason?: SortOrder
    impact?: SortOrderInput | SortOrder
    beforeChange?: SortOrderInput | SortOrder
    afterChange?: SortOrderInput | SortOrder
    changedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: ArchitectureChangeHistoryCountOrderByAggregateInput
    _max?: ArchitectureChangeHistoryMaxOrderByAggregateInput
    _min?: ArchitectureChangeHistoryMinOrderByAggregateInput
  }

  export type ArchitectureChangeHistoryScalarWhereWithAggregatesInput = {
    AND?: ArchitectureChangeHistoryScalarWhereWithAggregatesInput | ArchitectureChangeHistoryScalarWhereWithAggregatesInput[]
    OR?: ArchitectureChangeHistoryScalarWhereWithAggregatesInput[]
    NOT?: ArchitectureChangeHistoryScalarWhereWithAggregatesInput | ArchitectureChangeHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArchitectureChangeHistory"> | string
    architectureId?: StringWithAggregatesFilter<"ArchitectureChangeHistory"> | string
    changeType?: StringWithAggregatesFilter<"ArchitectureChangeHistory"> | string
    changeDescription?: StringWithAggregatesFilter<"ArchitectureChangeHistory"> | string
    changeReason?: StringWithAggregatesFilter<"ArchitectureChangeHistory"> | string
    impact?: StringNullableWithAggregatesFilter<"ArchitectureChangeHistory"> | string | null
    beforeChange?: JsonNullableWithAggregatesFilter<"ArchitectureChangeHistory">
    afterChange?: JsonNullableWithAggregatesFilter<"ArchitectureChangeHistory">
    changedAt?: DateTimeWithAggregatesFilter<"ArchitectureChangeHistory"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"ArchitectureChangeHistory"> | string | null
  }

  export type DatabaseSchemaWhereInput = {
    AND?: DatabaseSchemaWhereInput | DatabaseSchemaWhereInput[]
    OR?: DatabaseSchemaWhereInput[]
    NOT?: DatabaseSchemaWhereInput | DatabaseSchemaWhereInput[]
    id?: StringFilter<"DatabaseSchema"> | string
    projectId?: StringFilter<"DatabaseSchema"> | string
    schemaName?: StringFilter<"DatabaseSchema"> | string
    engine?: EnumDatabaseEngineFilter<"DatabaseSchema"> | $Enums.DatabaseEngine
    charset?: StringFilter<"DatabaseSchema"> | string
    collation?: StringFilter<"DatabaseSchema"> | string
    description?: StringNullableFilter<"DatabaseSchema"> | string | null
    version?: IntFilter<"DatabaseSchema"> | number
    createdAt?: DateTimeFilter<"DatabaseSchema"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseSchema"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DatabaseSchema"> | Date | string | null
    userId?: StringNullableFilter<"DatabaseSchema"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tables?: DatabaseTableListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DatabaseSchemaOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    schemaName?: SortOrder
    engine?: SortOrder
    charset?: SortOrder
    collation?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    tables?: DatabaseTableOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type DatabaseSchemaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_schemaName?: DatabaseSchemaProjectIdSchemaNameCompoundUniqueInput
    AND?: DatabaseSchemaWhereInput | DatabaseSchemaWhereInput[]
    OR?: DatabaseSchemaWhereInput[]
    NOT?: DatabaseSchemaWhereInput | DatabaseSchemaWhereInput[]
    projectId?: StringFilter<"DatabaseSchema"> | string
    schemaName?: StringFilter<"DatabaseSchema"> | string
    engine?: EnumDatabaseEngineFilter<"DatabaseSchema"> | $Enums.DatabaseEngine
    charset?: StringFilter<"DatabaseSchema"> | string
    collation?: StringFilter<"DatabaseSchema"> | string
    description?: StringNullableFilter<"DatabaseSchema"> | string | null
    version?: IntFilter<"DatabaseSchema"> | number
    createdAt?: DateTimeFilter<"DatabaseSchema"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseSchema"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DatabaseSchema"> | Date | string | null
    userId?: StringNullableFilter<"DatabaseSchema"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tables?: DatabaseTableListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "projectId_schemaName">

  export type DatabaseSchemaOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    schemaName?: SortOrder
    engine?: SortOrder
    charset?: SortOrder
    collation?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: DatabaseSchemaCountOrderByAggregateInput
    _avg?: DatabaseSchemaAvgOrderByAggregateInput
    _max?: DatabaseSchemaMaxOrderByAggregateInput
    _min?: DatabaseSchemaMinOrderByAggregateInput
    _sum?: DatabaseSchemaSumOrderByAggregateInput
  }

  export type DatabaseSchemaScalarWhereWithAggregatesInput = {
    AND?: DatabaseSchemaScalarWhereWithAggregatesInput | DatabaseSchemaScalarWhereWithAggregatesInput[]
    OR?: DatabaseSchemaScalarWhereWithAggregatesInput[]
    NOT?: DatabaseSchemaScalarWhereWithAggregatesInput | DatabaseSchemaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DatabaseSchema"> | string
    projectId?: StringWithAggregatesFilter<"DatabaseSchema"> | string
    schemaName?: StringWithAggregatesFilter<"DatabaseSchema"> | string
    engine?: EnumDatabaseEngineWithAggregatesFilter<"DatabaseSchema"> | $Enums.DatabaseEngine
    charset?: StringWithAggregatesFilter<"DatabaseSchema"> | string
    collation?: StringWithAggregatesFilter<"DatabaseSchema"> | string
    description?: StringNullableWithAggregatesFilter<"DatabaseSchema"> | string | null
    version?: IntWithAggregatesFilter<"DatabaseSchema"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DatabaseSchema"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DatabaseSchema"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"DatabaseSchema"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"DatabaseSchema"> | string | null
  }

  export type DatabaseTableWhereInput = {
    AND?: DatabaseTableWhereInput | DatabaseTableWhereInput[]
    OR?: DatabaseTableWhereInput[]
    NOT?: DatabaseTableWhereInput | DatabaseTableWhereInput[]
    id?: StringFilter<"DatabaseTable"> | string
    schemaId?: StringFilter<"DatabaseTable"> | string
    tableName?: StringFilter<"DatabaseTable"> | string
    displayName?: StringFilter<"DatabaseTable"> | string
    description?: StringNullableFilter<"DatabaseTable"> | string | null
    engine?: StringNullableFilter<"DatabaseTable"> | string | null
    charset?: StringNullableFilter<"DatabaseTable"> | string | null
    collation?: StringNullableFilter<"DatabaseTable"> | string | null
    autoIncrement?: IntNullableFilter<"DatabaseTable"> | number | null
    comment?: StringNullableFilter<"DatabaseTable"> | string | null
    createdAt?: DateTimeFilter<"DatabaseTable"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseTable"> | Date | string
    schema?: XOR<DatabaseSchemaScalarRelationFilter, DatabaseSchemaWhereInput>
    columns?: TableColumnListRelationFilter
    indexes?: DatabaseIndexListRelationFilter
    sourceRelations?: DatabaseRelationListRelationFilter
    targetRelations?: DatabaseRelationListRelationFilter
  }

  export type DatabaseTableOrderByWithRelationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    tableName?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    engine?: SortOrderInput | SortOrder
    charset?: SortOrderInput | SortOrder
    collation?: SortOrderInput | SortOrder
    autoIncrement?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    schema?: DatabaseSchemaOrderByWithRelationInput
    columns?: TableColumnOrderByRelationAggregateInput
    indexes?: DatabaseIndexOrderByRelationAggregateInput
    sourceRelations?: DatabaseRelationOrderByRelationAggregateInput
    targetRelations?: DatabaseRelationOrderByRelationAggregateInput
  }

  export type DatabaseTableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    schemaId_tableName?: DatabaseTableSchemaIdTableNameCompoundUniqueInput
    AND?: DatabaseTableWhereInput | DatabaseTableWhereInput[]
    OR?: DatabaseTableWhereInput[]
    NOT?: DatabaseTableWhereInput | DatabaseTableWhereInput[]
    schemaId?: StringFilter<"DatabaseTable"> | string
    tableName?: StringFilter<"DatabaseTable"> | string
    displayName?: StringFilter<"DatabaseTable"> | string
    description?: StringNullableFilter<"DatabaseTable"> | string | null
    engine?: StringNullableFilter<"DatabaseTable"> | string | null
    charset?: StringNullableFilter<"DatabaseTable"> | string | null
    collation?: StringNullableFilter<"DatabaseTable"> | string | null
    autoIncrement?: IntNullableFilter<"DatabaseTable"> | number | null
    comment?: StringNullableFilter<"DatabaseTable"> | string | null
    createdAt?: DateTimeFilter<"DatabaseTable"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseTable"> | Date | string
    schema?: XOR<DatabaseSchemaScalarRelationFilter, DatabaseSchemaWhereInput>
    columns?: TableColumnListRelationFilter
    indexes?: DatabaseIndexListRelationFilter
    sourceRelations?: DatabaseRelationListRelationFilter
    targetRelations?: DatabaseRelationListRelationFilter
  }, "id" | "schemaId_tableName">

  export type DatabaseTableOrderByWithAggregationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    tableName?: SortOrder
    displayName?: SortOrder
    description?: SortOrderInput | SortOrder
    engine?: SortOrderInput | SortOrder
    charset?: SortOrderInput | SortOrder
    collation?: SortOrderInput | SortOrder
    autoIncrement?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DatabaseTableCountOrderByAggregateInput
    _avg?: DatabaseTableAvgOrderByAggregateInput
    _max?: DatabaseTableMaxOrderByAggregateInput
    _min?: DatabaseTableMinOrderByAggregateInput
    _sum?: DatabaseTableSumOrderByAggregateInput
  }

  export type DatabaseTableScalarWhereWithAggregatesInput = {
    AND?: DatabaseTableScalarWhereWithAggregatesInput | DatabaseTableScalarWhereWithAggregatesInput[]
    OR?: DatabaseTableScalarWhereWithAggregatesInput[]
    NOT?: DatabaseTableScalarWhereWithAggregatesInput | DatabaseTableScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DatabaseTable"> | string
    schemaId?: StringWithAggregatesFilter<"DatabaseTable"> | string
    tableName?: StringWithAggregatesFilter<"DatabaseTable"> | string
    displayName?: StringWithAggregatesFilter<"DatabaseTable"> | string
    description?: StringNullableWithAggregatesFilter<"DatabaseTable"> | string | null
    engine?: StringNullableWithAggregatesFilter<"DatabaseTable"> | string | null
    charset?: StringNullableWithAggregatesFilter<"DatabaseTable"> | string | null
    collation?: StringNullableWithAggregatesFilter<"DatabaseTable"> | string | null
    autoIncrement?: IntNullableWithAggregatesFilter<"DatabaseTable"> | number | null
    comment?: StringNullableWithAggregatesFilter<"DatabaseTable"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DatabaseTable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DatabaseTable"> | Date | string
  }

  export type TableColumnWhereInput = {
    AND?: TableColumnWhereInput | TableColumnWhereInput[]
    OR?: TableColumnWhereInput[]
    NOT?: TableColumnWhereInput | TableColumnWhereInput[]
    id?: StringFilter<"TableColumn"> | string
    tableId?: StringFilter<"TableColumn"> | string
    columnName?: StringFilter<"TableColumn"> | string
    displayName?: StringFilter<"TableColumn"> | string
    columnType?: EnumColumnTypeFilter<"TableColumn"> | $Enums.ColumnType
    length?: IntNullableFilter<"TableColumn"> | number | null
    precision?: IntNullableFilter<"TableColumn"> | number | null
    scale?: IntNullableFilter<"TableColumn"> | number | null
    isPrimaryKey?: BoolFilter<"TableColumn"> | boolean
    isNullable?: BoolFilter<"TableColumn"> | boolean
    isUnique?: BoolFilter<"TableColumn"> | boolean
    isAutoIncrement?: BoolFilter<"TableColumn"> | boolean
    defaultValue?: StringNullableFilter<"TableColumn"> | string | null
    comment?: StringNullableFilter<"TableColumn"> | string | null
    enumValues?: StringNullableListFilter<"TableColumn">
    isForeignKey?: BoolFilter<"TableColumn"> | boolean
    referencedTable?: StringNullableFilter<"TableColumn"> | string | null
    referencedColumn?: StringNullableFilter<"TableColumn"> | string | null
    onDelete?: StringNullableFilter<"TableColumn"> | string | null
    onUpdate?: StringNullableFilter<"TableColumn"> | string | null
    position?: IntFilter<"TableColumn"> | number
    createdAt?: DateTimeFilter<"TableColumn"> | Date | string
    updatedAt?: DateTimeFilter<"TableColumn"> | Date | string
    table?: XOR<DatabaseTableScalarRelationFilter, DatabaseTableWhereInput>
  }

  export type TableColumnOrderByWithRelationInput = {
    id?: SortOrder
    tableId?: SortOrder
    columnName?: SortOrder
    displayName?: SortOrder
    columnType?: SortOrder
    length?: SortOrderInput | SortOrder
    precision?: SortOrderInput | SortOrder
    scale?: SortOrderInput | SortOrder
    isPrimaryKey?: SortOrder
    isNullable?: SortOrder
    isUnique?: SortOrder
    isAutoIncrement?: SortOrder
    defaultValue?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    enumValues?: SortOrder
    isForeignKey?: SortOrder
    referencedTable?: SortOrderInput | SortOrder
    referencedColumn?: SortOrderInput | SortOrder
    onDelete?: SortOrderInput | SortOrder
    onUpdate?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    table?: DatabaseTableOrderByWithRelationInput
  }

  export type TableColumnWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tableId_columnName?: TableColumnTableIdColumnNameCompoundUniqueInput
    AND?: TableColumnWhereInput | TableColumnWhereInput[]
    OR?: TableColumnWhereInput[]
    NOT?: TableColumnWhereInput | TableColumnWhereInput[]
    tableId?: StringFilter<"TableColumn"> | string
    columnName?: StringFilter<"TableColumn"> | string
    displayName?: StringFilter<"TableColumn"> | string
    columnType?: EnumColumnTypeFilter<"TableColumn"> | $Enums.ColumnType
    length?: IntNullableFilter<"TableColumn"> | number | null
    precision?: IntNullableFilter<"TableColumn"> | number | null
    scale?: IntNullableFilter<"TableColumn"> | number | null
    isPrimaryKey?: BoolFilter<"TableColumn"> | boolean
    isNullable?: BoolFilter<"TableColumn"> | boolean
    isUnique?: BoolFilter<"TableColumn"> | boolean
    isAutoIncrement?: BoolFilter<"TableColumn"> | boolean
    defaultValue?: StringNullableFilter<"TableColumn"> | string | null
    comment?: StringNullableFilter<"TableColumn"> | string | null
    enumValues?: StringNullableListFilter<"TableColumn">
    isForeignKey?: BoolFilter<"TableColumn"> | boolean
    referencedTable?: StringNullableFilter<"TableColumn"> | string | null
    referencedColumn?: StringNullableFilter<"TableColumn"> | string | null
    onDelete?: StringNullableFilter<"TableColumn"> | string | null
    onUpdate?: StringNullableFilter<"TableColumn"> | string | null
    position?: IntFilter<"TableColumn"> | number
    createdAt?: DateTimeFilter<"TableColumn"> | Date | string
    updatedAt?: DateTimeFilter<"TableColumn"> | Date | string
    table?: XOR<DatabaseTableScalarRelationFilter, DatabaseTableWhereInput>
  }, "id" | "tableId_columnName">

  export type TableColumnOrderByWithAggregationInput = {
    id?: SortOrder
    tableId?: SortOrder
    columnName?: SortOrder
    displayName?: SortOrder
    columnType?: SortOrder
    length?: SortOrderInput | SortOrder
    precision?: SortOrderInput | SortOrder
    scale?: SortOrderInput | SortOrder
    isPrimaryKey?: SortOrder
    isNullable?: SortOrder
    isUnique?: SortOrder
    isAutoIncrement?: SortOrder
    defaultValue?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    enumValues?: SortOrder
    isForeignKey?: SortOrder
    referencedTable?: SortOrderInput | SortOrder
    referencedColumn?: SortOrderInput | SortOrder
    onDelete?: SortOrderInput | SortOrder
    onUpdate?: SortOrderInput | SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TableColumnCountOrderByAggregateInput
    _avg?: TableColumnAvgOrderByAggregateInput
    _max?: TableColumnMaxOrderByAggregateInput
    _min?: TableColumnMinOrderByAggregateInput
    _sum?: TableColumnSumOrderByAggregateInput
  }

  export type TableColumnScalarWhereWithAggregatesInput = {
    AND?: TableColumnScalarWhereWithAggregatesInput | TableColumnScalarWhereWithAggregatesInput[]
    OR?: TableColumnScalarWhereWithAggregatesInput[]
    NOT?: TableColumnScalarWhereWithAggregatesInput | TableColumnScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TableColumn"> | string
    tableId?: StringWithAggregatesFilter<"TableColumn"> | string
    columnName?: StringWithAggregatesFilter<"TableColumn"> | string
    displayName?: StringWithAggregatesFilter<"TableColumn"> | string
    columnType?: EnumColumnTypeWithAggregatesFilter<"TableColumn"> | $Enums.ColumnType
    length?: IntNullableWithAggregatesFilter<"TableColumn"> | number | null
    precision?: IntNullableWithAggregatesFilter<"TableColumn"> | number | null
    scale?: IntNullableWithAggregatesFilter<"TableColumn"> | number | null
    isPrimaryKey?: BoolWithAggregatesFilter<"TableColumn"> | boolean
    isNullable?: BoolWithAggregatesFilter<"TableColumn"> | boolean
    isUnique?: BoolWithAggregatesFilter<"TableColumn"> | boolean
    isAutoIncrement?: BoolWithAggregatesFilter<"TableColumn"> | boolean
    defaultValue?: StringNullableWithAggregatesFilter<"TableColumn"> | string | null
    comment?: StringNullableWithAggregatesFilter<"TableColumn"> | string | null
    enumValues?: StringNullableListFilter<"TableColumn">
    isForeignKey?: BoolWithAggregatesFilter<"TableColumn"> | boolean
    referencedTable?: StringNullableWithAggregatesFilter<"TableColumn"> | string | null
    referencedColumn?: StringNullableWithAggregatesFilter<"TableColumn"> | string | null
    onDelete?: StringNullableWithAggregatesFilter<"TableColumn"> | string | null
    onUpdate?: StringNullableWithAggregatesFilter<"TableColumn"> | string | null
    position?: IntWithAggregatesFilter<"TableColumn"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TableColumn"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TableColumn"> | Date | string
  }

  export type DatabaseIndexWhereInput = {
    AND?: DatabaseIndexWhereInput | DatabaseIndexWhereInput[]
    OR?: DatabaseIndexWhereInput[]
    NOT?: DatabaseIndexWhereInput | DatabaseIndexWhereInput[]
    id?: StringFilter<"DatabaseIndex"> | string
    tableId?: StringFilter<"DatabaseIndex"> | string
    indexName?: StringFilter<"DatabaseIndex"> | string
    indexType?: EnumIndexTypeFilter<"DatabaseIndex"> | $Enums.IndexType
    columns?: StringNullableListFilter<"DatabaseIndex">
    isUnique?: BoolFilter<"DatabaseIndex"> | boolean
    comment?: StringNullableFilter<"DatabaseIndex"> | string | null
    algorithm?: StringNullableFilter<"DatabaseIndex"> | string | null
    lockOption?: StringNullableFilter<"DatabaseIndex"> | string | null
    createdAt?: DateTimeFilter<"DatabaseIndex"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseIndex"> | Date | string
    table?: XOR<DatabaseTableScalarRelationFilter, DatabaseTableWhereInput>
  }

  export type DatabaseIndexOrderByWithRelationInput = {
    id?: SortOrder
    tableId?: SortOrder
    indexName?: SortOrder
    indexType?: SortOrder
    columns?: SortOrder
    isUnique?: SortOrder
    comment?: SortOrderInput | SortOrder
    algorithm?: SortOrderInput | SortOrder
    lockOption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    table?: DatabaseTableOrderByWithRelationInput
  }

  export type DatabaseIndexWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tableId_indexName?: DatabaseIndexTableIdIndexNameCompoundUniqueInput
    AND?: DatabaseIndexWhereInput | DatabaseIndexWhereInput[]
    OR?: DatabaseIndexWhereInput[]
    NOT?: DatabaseIndexWhereInput | DatabaseIndexWhereInput[]
    tableId?: StringFilter<"DatabaseIndex"> | string
    indexName?: StringFilter<"DatabaseIndex"> | string
    indexType?: EnumIndexTypeFilter<"DatabaseIndex"> | $Enums.IndexType
    columns?: StringNullableListFilter<"DatabaseIndex">
    isUnique?: BoolFilter<"DatabaseIndex"> | boolean
    comment?: StringNullableFilter<"DatabaseIndex"> | string | null
    algorithm?: StringNullableFilter<"DatabaseIndex"> | string | null
    lockOption?: StringNullableFilter<"DatabaseIndex"> | string | null
    createdAt?: DateTimeFilter<"DatabaseIndex"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseIndex"> | Date | string
    table?: XOR<DatabaseTableScalarRelationFilter, DatabaseTableWhereInput>
  }, "id" | "tableId_indexName">

  export type DatabaseIndexOrderByWithAggregationInput = {
    id?: SortOrder
    tableId?: SortOrder
    indexName?: SortOrder
    indexType?: SortOrder
    columns?: SortOrder
    isUnique?: SortOrder
    comment?: SortOrderInput | SortOrder
    algorithm?: SortOrderInput | SortOrder
    lockOption?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DatabaseIndexCountOrderByAggregateInput
    _max?: DatabaseIndexMaxOrderByAggregateInput
    _min?: DatabaseIndexMinOrderByAggregateInput
  }

  export type DatabaseIndexScalarWhereWithAggregatesInput = {
    AND?: DatabaseIndexScalarWhereWithAggregatesInput | DatabaseIndexScalarWhereWithAggregatesInput[]
    OR?: DatabaseIndexScalarWhereWithAggregatesInput[]
    NOT?: DatabaseIndexScalarWhereWithAggregatesInput | DatabaseIndexScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DatabaseIndex"> | string
    tableId?: StringWithAggregatesFilter<"DatabaseIndex"> | string
    indexName?: StringWithAggregatesFilter<"DatabaseIndex"> | string
    indexType?: EnumIndexTypeWithAggregatesFilter<"DatabaseIndex"> | $Enums.IndexType
    columns?: StringNullableListFilter<"DatabaseIndex">
    isUnique?: BoolWithAggregatesFilter<"DatabaseIndex"> | boolean
    comment?: StringNullableWithAggregatesFilter<"DatabaseIndex"> | string | null
    algorithm?: StringNullableWithAggregatesFilter<"DatabaseIndex"> | string | null
    lockOption?: StringNullableWithAggregatesFilter<"DatabaseIndex"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DatabaseIndex"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DatabaseIndex"> | Date | string
  }

  export type DatabaseRelationWhereInput = {
    AND?: DatabaseRelationWhereInput | DatabaseRelationWhereInput[]
    OR?: DatabaseRelationWhereInput[]
    NOT?: DatabaseRelationWhereInput | DatabaseRelationWhereInput[]
    id?: StringFilter<"DatabaseRelation"> | string
    schemaId?: StringFilter<"DatabaseRelation"> | string
    relationName?: StringFilter<"DatabaseRelation"> | string
    relationType?: EnumRelationTypeFilter<"DatabaseRelation"> | $Enums.RelationType
    sourceTableId?: StringFilter<"DatabaseRelation"> | string
    sourceColumns?: StringNullableListFilter<"DatabaseRelation">
    targetTableId?: StringFilter<"DatabaseRelation"> | string
    targetColumns?: StringNullableListFilter<"DatabaseRelation">
    onDelete?: StringNullableFilter<"DatabaseRelation"> | string | null
    onUpdate?: StringNullableFilter<"DatabaseRelation"> | string | null
    description?: StringNullableFilter<"DatabaseRelation"> | string | null
    createdAt?: DateTimeFilter<"DatabaseRelation"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseRelation"> | Date | string
    sourceTable?: XOR<DatabaseTableScalarRelationFilter, DatabaseTableWhereInput>
    targetTable?: XOR<DatabaseTableScalarRelationFilter, DatabaseTableWhereInput>
  }

  export type DatabaseRelationOrderByWithRelationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    relationName?: SortOrder
    relationType?: SortOrder
    sourceTableId?: SortOrder
    sourceColumns?: SortOrder
    targetTableId?: SortOrder
    targetColumns?: SortOrder
    onDelete?: SortOrderInput | SortOrder
    onUpdate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceTable?: DatabaseTableOrderByWithRelationInput
    targetTable?: DatabaseTableOrderByWithRelationInput
  }

  export type DatabaseRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DatabaseRelationWhereInput | DatabaseRelationWhereInput[]
    OR?: DatabaseRelationWhereInput[]
    NOT?: DatabaseRelationWhereInput | DatabaseRelationWhereInput[]
    schemaId?: StringFilter<"DatabaseRelation"> | string
    relationName?: StringFilter<"DatabaseRelation"> | string
    relationType?: EnumRelationTypeFilter<"DatabaseRelation"> | $Enums.RelationType
    sourceTableId?: StringFilter<"DatabaseRelation"> | string
    sourceColumns?: StringNullableListFilter<"DatabaseRelation">
    targetTableId?: StringFilter<"DatabaseRelation"> | string
    targetColumns?: StringNullableListFilter<"DatabaseRelation">
    onDelete?: StringNullableFilter<"DatabaseRelation"> | string | null
    onUpdate?: StringNullableFilter<"DatabaseRelation"> | string | null
    description?: StringNullableFilter<"DatabaseRelation"> | string | null
    createdAt?: DateTimeFilter<"DatabaseRelation"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseRelation"> | Date | string
    sourceTable?: XOR<DatabaseTableScalarRelationFilter, DatabaseTableWhereInput>
    targetTable?: XOR<DatabaseTableScalarRelationFilter, DatabaseTableWhereInput>
  }, "id">

  export type DatabaseRelationOrderByWithAggregationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    relationName?: SortOrder
    relationType?: SortOrder
    sourceTableId?: SortOrder
    sourceColumns?: SortOrder
    targetTableId?: SortOrder
    targetColumns?: SortOrder
    onDelete?: SortOrderInput | SortOrder
    onUpdate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DatabaseRelationCountOrderByAggregateInput
    _max?: DatabaseRelationMaxOrderByAggregateInput
    _min?: DatabaseRelationMinOrderByAggregateInput
  }

  export type DatabaseRelationScalarWhereWithAggregatesInput = {
    AND?: DatabaseRelationScalarWhereWithAggregatesInput | DatabaseRelationScalarWhereWithAggregatesInput[]
    OR?: DatabaseRelationScalarWhereWithAggregatesInput[]
    NOT?: DatabaseRelationScalarWhereWithAggregatesInput | DatabaseRelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DatabaseRelation"> | string
    schemaId?: StringWithAggregatesFilter<"DatabaseRelation"> | string
    relationName?: StringWithAggregatesFilter<"DatabaseRelation"> | string
    relationType?: EnumRelationTypeWithAggregatesFilter<"DatabaseRelation"> | $Enums.RelationType
    sourceTableId?: StringWithAggregatesFilter<"DatabaseRelation"> | string
    sourceColumns?: StringNullableListFilter<"DatabaseRelation">
    targetTableId?: StringWithAggregatesFilter<"DatabaseRelation"> | string
    targetColumns?: StringNullableListFilter<"DatabaseRelation">
    onDelete?: StringNullableWithAggregatesFilter<"DatabaseRelation"> | string | null
    onUpdate?: StringNullableWithAggregatesFilter<"DatabaseRelation"> | string | null
    description?: StringNullableWithAggregatesFilter<"DatabaseRelation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DatabaseRelation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DatabaseRelation"> | Date | string
  }

  export type DocumentationWhereInput = {
    AND?: DocumentationWhereInput | DocumentationWhereInput[]
    OR?: DocumentationWhereInput[]
    NOT?: DocumentationWhereInput | DocumentationWhereInput[]
    id?: StringFilter<"Documentation"> | string
    projectId?: StringFilter<"Documentation"> | string
    title?: StringFilter<"Documentation"> | string
    content?: StringFilter<"Documentation"> | string
    summary?: StringNullableFilter<"Documentation"> | string | null
    type?: EnumDocumentTypeFilter<"Documentation"> | $Enums.DocumentType
    status?: EnumDocumentStatusFilter<"Documentation"> | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFilter<"Documentation"> | $Enums.DocumentVisibility
    category?: StringNullableFilter<"Documentation"> | string | null
    url?: StringNullableFilter<"Documentation"> | string | null
    version?: StringFilter<"Documentation"> | string
    versionNumber?: IntFilter<"Documentation"> | number
    createdAt?: DateTimeFilter<"Documentation"> | Date | string
    updatedAt?: DateTimeFilter<"Documentation"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Documentation"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Documentation"> | Date | string | null
    userId?: StringNullableFilter<"Documentation"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tags?: DocumentTagListRelationFilter
    versions?: DocumentVersionListRelationFilter
    comments?: DocumentCommentListRelationFilter
    attachments?: DocumentAttachmentListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DocumentationOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    version?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    tags?: DocumentTagOrderByRelationAggregateInput
    versions?: DocumentVersionOrderByRelationAggregateInput
    comments?: DocumentCommentOrderByRelationAggregateInput
    attachments?: DocumentAttachmentOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type DocumentationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentationWhereInput | DocumentationWhereInput[]
    OR?: DocumentationWhereInput[]
    NOT?: DocumentationWhereInput | DocumentationWhereInput[]
    projectId?: StringFilter<"Documentation"> | string
    title?: StringFilter<"Documentation"> | string
    content?: StringFilter<"Documentation"> | string
    summary?: StringNullableFilter<"Documentation"> | string | null
    type?: EnumDocumentTypeFilter<"Documentation"> | $Enums.DocumentType
    status?: EnumDocumentStatusFilter<"Documentation"> | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFilter<"Documentation"> | $Enums.DocumentVisibility
    category?: StringNullableFilter<"Documentation"> | string | null
    url?: StringNullableFilter<"Documentation"> | string | null
    version?: StringFilter<"Documentation"> | string
    versionNumber?: IntFilter<"Documentation"> | number
    createdAt?: DateTimeFilter<"Documentation"> | Date | string
    updatedAt?: DateTimeFilter<"Documentation"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Documentation"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Documentation"> | Date | string | null
    userId?: StringNullableFilter<"Documentation"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tags?: DocumentTagListRelationFilter
    versions?: DocumentVersionListRelationFilter
    comments?: DocumentCommentListRelationFilter
    attachments?: DocumentAttachmentListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DocumentationOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    version?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: DocumentationCountOrderByAggregateInput
    _avg?: DocumentationAvgOrderByAggregateInput
    _max?: DocumentationMaxOrderByAggregateInput
    _min?: DocumentationMinOrderByAggregateInput
    _sum?: DocumentationSumOrderByAggregateInput
  }

  export type DocumentationScalarWhereWithAggregatesInput = {
    AND?: DocumentationScalarWhereWithAggregatesInput | DocumentationScalarWhereWithAggregatesInput[]
    OR?: DocumentationScalarWhereWithAggregatesInput[]
    NOT?: DocumentationScalarWhereWithAggregatesInput | DocumentationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Documentation"> | string
    projectId?: StringWithAggregatesFilter<"Documentation"> | string
    title?: StringWithAggregatesFilter<"Documentation"> | string
    content?: StringWithAggregatesFilter<"Documentation"> | string
    summary?: StringNullableWithAggregatesFilter<"Documentation"> | string | null
    type?: EnumDocumentTypeWithAggregatesFilter<"Documentation"> | $Enums.DocumentType
    status?: EnumDocumentStatusWithAggregatesFilter<"Documentation"> | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityWithAggregatesFilter<"Documentation"> | $Enums.DocumentVisibility
    category?: StringNullableWithAggregatesFilter<"Documentation"> | string | null
    url?: StringNullableWithAggregatesFilter<"Documentation"> | string | null
    version?: StringWithAggregatesFilter<"Documentation"> | string
    versionNumber?: IntWithAggregatesFilter<"Documentation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Documentation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Documentation"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Documentation"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Documentation"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"Documentation"> | string | null
  }

  export type DocumentVersionWhereInput = {
    AND?: DocumentVersionWhereInput | DocumentVersionWhereInput[]
    OR?: DocumentVersionWhereInput[]
    NOT?: DocumentVersionWhereInput | DocumentVersionWhereInput[]
    id?: StringFilter<"DocumentVersion"> | string
    documentationId?: StringFilter<"DocumentVersion"> | string
    version?: StringFilter<"DocumentVersion"> | string
    content?: StringFilter<"DocumentVersion"> | string
    changeLog?: StringFilter<"DocumentVersion"> | string
    createdAt?: DateTimeFilter<"DocumentVersion"> | Date | string
    userId?: StringNullableFilter<"DocumentVersion"> | string | null
    documentation?: XOR<DocumentationScalarRelationFilter, DocumentationWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DocumentVersionOrderByWithRelationInput = {
    id?: SortOrder
    documentationId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    changeLog?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    documentation?: DocumentationOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type DocumentVersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentVersionWhereInput | DocumentVersionWhereInput[]
    OR?: DocumentVersionWhereInput[]
    NOT?: DocumentVersionWhereInput | DocumentVersionWhereInput[]
    documentationId?: StringFilter<"DocumentVersion"> | string
    version?: StringFilter<"DocumentVersion"> | string
    content?: StringFilter<"DocumentVersion"> | string
    changeLog?: StringFilter<"DocumentVersion"> | string
    createdAt?: DateTimeFilter<"DocumentVersion"> | Date | string
    userId?: StringNullableFilter<"DocumentVersion"> | string | null
    documentation?: XOR<DocumentationScalarRelationFilter, DocumentationWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DocumentVersionOrderByWithAggregationInput = {
    id?: SortOrder
    documentationId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    changeLog?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: DocumentVersionCountOrderByAggregateInput
    _max?: DocumentVersionMaxOrderByAggregateInput
    _min?: DocumentVersionMinOrderByAggregateInput
  }

  export type DocumentVersionScalarWhereWithAggregatesInput = {
    AND?: DocumentVersionScalarWhereWithAggregatesInput | DocumentVersionScalarWhereWithAggregatesInput[]
    OR?: DocumentVersionScalarWhereWithAggregatesInput[]
    NOT?: DocumentVersionScalarWhereWithAggregatesInput | DocumentVersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentVersion"> | string
    documentationId?: StringWithAggregatesFilter<"DocumentVersion"> | string
    version?: StringWithAggregatesFilter<"DocumentVersion"> | string
    content?: StringWithAggregatesFilter<"DocumentVersion"> | string
    changeLog?: StringWithAggregatesFilter<"DocumentVersion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentVersion"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"DocumentVersion"> | string | null
  }

  export type DocumentTagWhereInput = {
    AND?: DocumentTagWhereInput | DocumentTagWhereInput[]
    OR?: DocumentTagWhereInput[]
    NOT?: DocumentTagWhereInput | DocumentTagWhereInput[]
    id?: StringFilter<"DocumentTag"> | string
    name?: StringFilter<"DocumentTag"> | string
    description?: StringNullableFilter<"DocumentTag"> | string | null
    color?: StringNullableFilter<"DocumentTag"> | string | null
    createdAt?: DateTimeFilter<"DocumentTag"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentTag"> | Date | string
    documentations?: DocumentationListRelationFilter
  }

  export type DocumentTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    documentations?: DocumentationOrderByRelationAggregateInput
  }

  export type DocumentTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DocumentTagWhereInput | DocumentTagWhereInput[]
    OR?: DocumentTagWhereInput[]
    NOT?: DocumentTagWhereInput | DocumentTagWhereInput[]
    description?: StringNullableFilter<"DocumentTag"> | string | null
    color?: StringNullableFilter<"DocumentTag"> | string | null
    createdAt?: DateTimeFilter<"DocumentTag"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentTag"> | Date | string
    documentations?: DocumentationListRelationFilter
  }, "id" | "name">

  export type DocumentTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentTagCountOrderByAggregateInput
    _max?: DocumentTagMaxOrderByAggregateInput
    _min?: DocumentTagMinOrderByAggregateInput
  }

  export type DocumentTagScalarWhereWithAggregatesInput = {
    AND?: DocumentTagScalarWhereWithAggregatesInput | DocumentTagScalarWhereWithAggregatesInput[]
    OR?: DocumentTagScalarWhereWithAggregatesInput[]
    NOT?: DocumentTagScalarWhereWithAggregatesInput | DocumentTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentTag"> | string
    name?: StringWithAggregatesFilter<"DocumentTag"> | string
    description?: StringNullableWithAggregatesFilter<"DocumentTag"> | string | null
    color?: StringNullableWithAggregatesFilter<"DocumentTag"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentTag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentTag"> | Date | string
  }

  export type DocumentCommentWhereInput = {
    AND?: DocumentCommentWhereInput | DocumentCommentWhereInput[]
    OR?: DocumentCommentWhereInput[]
    NOT?: DocumentCommentWhereInput | DocumentCommentWhereInput[]
    id?: StringFilter<"DocumentComment"> | string
    documentationId?: StringFilter<"DocumentComment"> | string
    content?: StringFilter<"DocumentComment"> | string
    parentId?: StringNullableFilter<"DocumentComment"> | string | null
    createdAt?: DateTimeFilter<"DocumentComment"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentComment"> | Date | string
    userId?: StringNullableFilter<"DocumentComment"> | string | null
    documentation?: XOR<DocumentationScalarRelationFilter, DocumentationWhereInput>
    parent?: XOR<DocumentCommentNullableScalarRelationFilter, DocumentCommentWhereInput> | null
    replies?: DocumentCommentListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DocumentCommentOrderByWithRelationInput = {
    id?: SortOrder
    documentationId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    documentation?: DocumentationOrderByWithRelationInput
    parent?: DocumentCommentOrderByWithRelationInput
    replies?: DocumentCommentOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type DocumentCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentCommentWhereInput | DocumentCommentWhereInput[]
    OR?: DocumentCommentWhereInput[]
    NOT?: DocumentCommentWhereInput | DocumentCommentWhereInput[]
    documentationId?: StringFilter<"DocumentComment"> | string
    content?: StringFilter<"DocumentComment"> | string
    parentId?: StringNullableFilter<"DocumentComment"> | string | null
    createdAt?: DateTimeFilter<"DocumentComment"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentComment"> | Date | string
    userId?: StringNullableFilter<"DocumentComment"> | string | null
    documentation?: XOR<DocumentationScalarRelationFilter, DocumentationWhereInput>
    parent?: XOR<DocumentCommentNullableScalarRelationFilter, DocumentCommentWhereInput> | null
    replies?: DocumentCommentListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DocumentCommentOrderByWithAggregationInput = {
    id?: SortOrder
    documentationId?: SortOrder
    content?: SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: DocumentCommentCountOrderByAggregateInput
    _max?: DocumentCommentMaxOrderByAggregateInput
    _min?: DocumentCommentMinOrderByAggregateInput
  }

  export type DocumentCommentScalarWhereWithAggregatesInput = {
    AND?: DocumentCommentScalarWhereWithAggregatesInput | DocumentCommentScalarWhereWithAggregatesInput[]
    OR?: DocumentCommentScalarWhereWithAggregatesInput[]
    NOT?: DocumentCommentScalarWhereWithAggregatesInput | DocumentCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentComment"> | string
    documentationId?: StringWithAggregatesFilter<"DocumentComment"> | string
    content?: StringWithAggregatesFilter<"DocumentComment"> | string
    parentId?: StringNullableWithAggregatesFilter<"DocumentComment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DocumentComment"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"DocumentComment"> | string | null
  }

  export type DocumentAttachmentWhereInput = {
    AND?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    OR?: DocumentAttachmentWhereInput[]
    NOT?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    id?: StringFilter<"DocumentAttachment"> | string
    documentationId?: StringFilter<"DocumentAttachment"> | string
    fileName?: StringFilter<"DocumentAttachment"> | string
    fileUrl?: StringFilter<"DocumentAttachment"> | string
    fileSize?: IntFilter<"DocumentAttachment"> | number
    mimeType?: StringFilter<"DocumentAttachment"> | string
    createdAt?: DateTimeFilter<"DocumentAttachment"> | Date | string
    userId?: StringNullableFilter<"DocumentAttachment"> | string | null
    documentation?: XOR<DocumentationScalarRelationFilter, DocumentationWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DocumentAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    documentationId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    documentation?: DocumentationOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type DocumentAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    OR?: DocumentAttachmentWhereInput[]
    NOT?: DocumentAttachmentWhereInput | DocumentAttachmentWhereInput[]
    documentationId?: StringFilter<"DocumentAttachment"> | string
    fileName?: StringFilter<"DocumentAttachment"> | string
    fileUrl?: StringFilter<"DocumentAttachment"> | string
    fileSize?: IntFilter<"DocumentAttachment"> | number
    mimeType?: StringFilter<"DocumentAttachment"> | string
    createdAt?: DateTimeFilter<"DocumentAttachment"> | Date | string
    userId?: StringNullableFilter<"DocumentAttachment"> | string | null
    documentation?: XOR<DocumentationScalarRelationFilter, DocumentationWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DocumentAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    documentationId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: DocumentAttachmentCountOrderByAggregateInput
    _avg?: DocumentAttachmentAvgOrderByAggregateInput
    _max?: DocumentAttachmentMaxOrderByAggregateInput
    _min?: DocumentAttachmentMinOrderByAggregateInput
    _sum?: DocumentAttachmentSumOrderByAggregateInput
  }

  export type DocumentAttachmentScalarWhereWithAggregatesInput = {
    AND?: DocumentAttachmentScalarWhereWithAggregatesInput | DocumentAttachmentScalarWhereWithAggregatesInput[]
    OR?: DocumentAttachmentScalarWhereWithAggregatesInput[]
    NOT?: DocumentAttachmentScalarWhereWithAggregatesInput | DocumentAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    documentationId?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    fileName?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    fileUrl?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"DocumentAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"DocumentAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DocumentAttachment"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"DocumentAttachment"> | string | null
  }

  export type MindMapWhereInput = {
    AND?: MindMapWhereInput | MindMapWhereInput[]
    OR?: MindMapWhereInput[]
    NOT?: MindMapWhereInput | MindMapWhereInput[]
    id?: StringFilter<"MindMap"> | string
    projectId?: StringFilter<"MindMap"> | string
    title?: StringFilter<"MindMap"> | string
    description?: StringNullableFilter<"MindMap"> | string | null
    overview?: StringFilter<"MindMap"> | string
    nodeId?: StringNullableFilter<"MindMap"> | string | null
    theme?: JsonNullableFilter<"MindMap">
    layout?: StringFilter<"MindMap"> | string
    version?: IntFilter<"MindMap"> | number
    createdAt?: DateTimeFilter<"MindMap"> | Date | string
    updatedAt?: DateTimeFilter<"MindMap"> | Date | string
    deletedAt?: DateTimeNullableFilter<"MindMap"> | Date | string | null
    userId?: StringNullableFilter<"MindMap"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    rootNode?: XOR<MindMapNodeNullableScalarRelationFilter, MindMapNodeWhereInput> | null
    nodes?: MindMapNodeListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MindMapOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    overview?: SortOrder
    nodeId?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    layout?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    rootNode?: MindMapNodeOrderByWithRelationInput
    nodes?: MindMapNodeOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type MindMapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    nodeId?: string
    AND?: MindMapWhereInput | MindMapWhereInput[]
    OR?: MindMapWhereInput[]
    NOT?: MindMapWhereInput | MindMapWhereInput[]
    projectId?: StringFilter<"MindMap"> | string
    title?: StringFilter<"MindMap"> | string
    description?: StringNullableFilter<"MindMap"> | string | null
    overview?: StringFilter<"MindMap"> | string
    theme?: JsonNullableFilter<"MindMap">
    layout?: StringFilter<"MindMap"> | string
    version?: IntFilter<"MindMap"> | number
    createdAt?: DateTimeFilter<"MindMap"> | Date | string
    updatedAt?: DateTimeFilter<"MindMap"> | Date | string
    deletedAt?: DateTimeNullableFilter<"MindMap"> | Date | string | null
    userId?: StringNullableFilter<"MindMap"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    rootNode?: XOR<MindMapNodeNullableScalarRelationFilter, MindMapNodeWhereInput> | null
    nodes?: MindMapNodeListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "nodeId">

  export type MindMapOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    overview?: SortOrder
    nodeId?: SortOrderInput | SortOrder
    theme?: SortOrderInput | SortOrder
    layout?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: MindMapCountOrderByAggregateInput
    _avg?: MindMapAvgOrderByAggregateInput
    _max?: MindMapMaxOrderByAggregateInput
    _min?: MindMapMinOrderByAggregateInput
    _sum?: MindMapSumOrderByAggregateInput
  }

  export type MindMapScalarWhereWithAggregatesInput = {
    AND?: MindMapScalarWhereWithAggregatesInput | MindMapScalarWhereWithAggregatesInput[]
    OR?: MindMapScalarWhereWithAggregatesInput[]
    NOT?: MindMapScalarWhereWithAggregatesInput | MindMapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MindMap"> | string
    projectId?: StringWithAggregatesFilter<"MindMap"> | string
    title?: StringWithAggregatesFilter<"MindMap"> | string
    description?: StringNullableWithAggregatesFilter<"MindMap"> | string | null
    overview?: StringWithAggregatesFilter<"MindMap"> | string
    nodeId?: StringNullableWithAggregatesFilter<"MindMap"> | string | null
    theme?: JsonNullableWithAggregatesFilter<"MindMap">
    layout?: StringWithAggregatesFilter<"MindMap"> | string
    version?: IntWithAggregatesFilter<"MindMap"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MindMap"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MindMap"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"MindMap"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"MindMap"> | string | null
  }

  export type MindMapNodeWhereInput = {
    AND?: MindMapNodeWhereInput | MindMapNodeWhereInput[]
    OR?: MindMapNodeWhereInput[]
    NOT?: MindMapNodeWhereInput | MindMapNodeWhereInput[]
    id?: StringFilter<"MindMapNode"> | string
    mindMapId?: StringFilter<"MindMapNode"> | string
    content?: StringFilter<"MindMapNode"> | string
    note?: StringNullableFilter<"MindMapNode"> | string | null
    nodeType?: EnumNodeTypeFilter<"MindMapNode"> | $Enums.NodeType
    parentId?: StringNullableFilter<"MindMapNode"> | string | null
    position?: IntFilter<"MindMapNode"> | number
    expanded?: BoolFilter<"MindMapNode"> | boolean
    style?: JsonNullableFilter<"MindMapNode">
    link?: StringNullableFilter<"MindMapNode"> | string | null
    icon?: StringNullableFilter<"MindMapNode"> | string | null
    priority?: IntNullableFilter<"MindMapNode"> | number | null
    progress?: IntNullableFilter<"MindMapNode"> | number | null
    createdAt?: DateTimeFilter<"MindMapNode"> | Date | string
    updatedAt?: DateTimeFilter<"MindMapNode"> | Date | string
    mindMap?: XOR<MindMapScalarRelationFilter, MindMapWhereInput>
    rootOfMap?: XOR<MindMapNullableScalarRelationFilter, MindMapWhereInput> | null
    parent?: XOR<MindMapNodeNullableScalarRelationFilter, MindMapNodeWhereInput> | null
    children?: MindMapNodeListRelationFilter
  }

  export type MindMapNodeOrderByWithRelationInput = {
    id?: SortOrder
    mindMapId?: SortOrder
    content?: SortOrder
    note?: SortOrderInput | SortOrder
    nodeType?: SortOrder
    parentId?: SortOrderInput | SortOrder
    position?: SortOrder
    expanded?: SortOrder
    style?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    mindMap?: MindMapOrderByWithRelationInput
    rootOfMap?: MindMapOrderByWithRelationInput
    parent?: MindMapNodeOrderByWithRelationInput
    children?: MindMapNodeOrderByRelationAggregateInput
  }

  export type MindMapNodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MindMapNodeWhereInput | MindMapNodeWhereInput[]
    OR?: MindMapNodeWhereInput[]
    NOT?: MindMapNodeWhereInput | MindMapNodeWhereInput[]
    mindMapId?: StringFilter<"MindMapNode"> | string
    content?: StringFilter<"MindMapNode"> | string
    note?: StringNullableFilter<"MindMapNode"> | string | null
    nodeType?: EnumNodeTypeFilter<"MindMapNode"> | $Enums.NodeType
    parentId?: StringNullableFilter<"MindMapNode"> | string | null
    position?: IntFilter<"MindMapNode"> | number
    expanded?: BoolFilter<"MindMapNode"> | boolean
    style?: JsonNullableFilter<"MindMapNode">
    link?: StringNullableFilter<"MindMapNode"> | string | null
    icon?: StringNullableFilter<"MindMapNode"> | string | null
    priority?: IntNullableFilter<"MindMapNode"> | number | null
    progress?: IntNullableFilter<"MindMapNode"> | number | null
    createdAt?: DateTimeFilter<"MindMapNode"> | Date | string
    updatedAt?: DateTimeFilter<"MindMapNode"> | Date | string
    mindMap?: XOR<MindMapScalarRelationFilter, MindMapWhereInput>
    rootOfMap?: XOR<MindMapNullableScalarRelationFilter, MindMapWhereInput> | null
    parent?: XOR<MindMapNodeNullableScalarRelationFilter, MindMapNodeWhereInput> | null
    children?: MindMapNodeListRelationFilter
  }, "id">

  export type MindMapNodeOrderByWithAggregationInput = {
    id?: SortOrder
    mindMapId?: SortOrder
    content?: SortOrder
    note?: SortOrderInput | SortOrder
    nodeType?: SortOrder
    parentId?: SortOrderInput | SortOrder
    position?: SortOrder
    expanded?: SortOrder
    style?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    priority?: SortOrderInput | SortOrder
    progress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MindMapNodeCountOrderByAggregateInput
    _avg?: MindMapNodeAvgOrderByAggregateInput
    _max?: MindMapNodeMaxOrderByAggregateInput
    _min?: MindMapNodeMinOrderByAggregateInput
    _sum?: MindMapNodeSumOrderByAggregateInput
  }

  export type MindMapNodeScalarWhereWithAggregatesInput = {
    AND?: MindMapNodeScalarWhereWithAggregatesInput | MindMapNodeScalarWhereWithAggregatesInput[]
    OR?: MindMapNodeScalarWhereWithAggregatesInput[]
    NOT?: MindMapNodeScalarWhereWithAggregatesInput | MindMapNodeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MindMapNode"> | string
    mindMapId?: StringWithAggregatesFilter<"MindMapNode"> | string
    content?: StringWithAggregatesFilter<"MindMapNode"> | string
    note?: StringNullableWithAggregatesFilter<"MindMapNode"> | string | null
    nodeType?: EnumNodeTypeWithAggregatesFilter<"MindMapNode"> | $Enums.NodeType
    parentId?: StringNullableWithAggregatesFilter<"MindMapNode"> | string | null
    position?: IntWithAggregatesFilter<"MindMapNode"> | number
    expanded?: BoolWithAggregatesFilter<"MindMapNode"> | boolean
    style?: JsonNullableWithAggregatesFilter<"MindMapNode">
    link?: StringNullableWithAggregatesFilter<"MindMapNode"> | string | null
    icon?: StringNullableWithAggregatesFilter<"MindMapNode"> | string | null
    priority?: IntNullableWithAggregatesFilter<"MindMapNode"> | number | null
    progress?: IntNullableWithAggregatesFilter<"MindMapNode"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"MindMapNode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MindMapNode"> | Date | string
  }

  export type DomainKnowledgeWhereInput = {
    AND?: DomainKnowledgeWhereInput | DomainKnowledgeWhereInput[]
    OR?: DomainKnowledgeWhereInput[]
    NOT?: DomainKnowledgeWhereInput | DomainKnowledgeWhereInput[]
    id?: StringFilter<"DomainKnowledge"> | string
    projectId?: StringFilter<"DomainKnowledge"> | string
    domain?: StringFilter<"DomainKnowledge"> | string
    description?: StringFilter<"DomainKnowledge"> | string
    category?: EnumKnowledgeCategoryFilter<"DomainKnowledge"> | $Enums.KnowledgeCategory
    tags?: StringNullableListFilter<"DomainKnowledge">
    version?: IntFilter<"DomainKnowledge"> | number
    createdAt?: DateTimeFilter<"DomainKnowledge"> | Date | string
    updatedAt?: DateTimeFilter<"DomainKnowledge"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DomainKnowledge"> | Date | string | null
    userId?: StringNullableFilter<"DomainKnowledge"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    concepts?: DomainConceptListRelationFilter
    patterns?: DomainPatternListRelationFilter
    bestPractices?: DomainBestPracticeListRelationFilter
    antiPatterns?: DomainAntiPatternListRelationFilter
    references?: DomainReferenceListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type DomainKnowledgeOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    domain?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    concepts?: DomainConceptOrderByRelationAggregateInput
    patterns?: DomainPatternOrderByRelationAggregateInput
    bestPractices?: DomainBestPracticeOrderByRelationAggregateInput
    antiPatterns?: DomainAntiPatternOrderByRelationAggregateInput
    references?: DomainReferenceOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type DomainKnowledgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DomainKnowledgeWhereInput | DomainKnowledgeWhereInput[]
    OR?: DomainKnowledgeWhereInput[]
    NOT?: DomainKnowledgeWhereInput | DomainKnowledgeWhereInput[]
    projectId?: StringFilter<"DomainKnowledge"> | string
    domain?: StringFilter<"DomainKnowledge"> | string
    description?: StringFilter<"DomainKnowledge"> | string
    category?: EnumKnowledgeCategoryFilter<"DomainKnowledge"> | $Enums.KnowledgeCategory
    tags?: StringNullableListFilter<"DomainKnowledge">
    version?: IntFilter<"DomainKnowledge"> | number
    createdAt?: DateTimeFilter<"DomainKnowledge"> | Date | string
    updatedAt?: DateTimeFilter<"DomainKnowledge"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DomainKnowledge"> | Date | string | null
    userId?: StringNullableFilter<"DomainKnowledge"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    concepts?: DomainConceptListRelationFilter
    patterns?: DomainPatternListRelationFilter
    bestPractices?: DomainBestPracticeListRelationFilter
    antiPatterns?: DomainAntiPatternListRelationFilter
    references?: DomainReferenceListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type DomainKnowledgeOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    domain?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: DomainKnowledgeCountOrderByAggregateInput
    _avg?: DomainKnowledgeAvgOrderByAggregateInput
    _max?: DomainKnowledgeMaxOrderByAggregateInput
    _min?: DomainKnowledgeMinOrderByAggregateInput
    _sum?: DomainKnowledgeSumOrderByAggregateInput
  }

  export type DomainKnowledgeScalarWhereWithAggregatesInput = {
    AND?: DomainKnowledgeScalarWhereWithAggregatesInput | DomainKnowledgeScalarWhereWithAggregatesInput[]
    OR?: DomainKnowledgeScalarWhereWithAggregatesInput[]
    NOT?: DomainKnowledgeScalarWhereWithAggregatesInput | DomainKnowledgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DomainKnowledge"> | string
    projectId?: StringWithAggregatesFilter<"DomainKnowledge"> | string
    domain?: StringWithAggregatesFilter<"DomainKnowledge"> | string
    description?: StringWithAggregatesFilter<"DomainKnowledge"> | string
    category?: EnumKnowledgeCategoryWithAggregatesFilter<"DomainKnowledge"> | $Enums.KnowledgeCategory
    tags?: StringNullableListFilter<"DomainKnowledge">
    version?: IntWithAggregatesFilter<"DomainKnowledge"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DomainKnowledge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DomainKnowledge"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"DomainKnowledge"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"DomainKnowledge"> | string | null
  }

  export type DomainConceptWhereInput = {
    AND?: DomainConceptWhereInput | DomainConceptWhereInput[]
    OR?: DomainConceptWhereInput[]
    NOT?: DomainConceptWhereInput | DomainConceptWhereInput[]
    id?: StringFilter<"DomainConcept"> | string
    domainKnowledgeId?: StringFilter<"DomainConcept"> | string
    name?: StringFilter<"DomainConcept"> | string
    definition?: StringFilter<"DomainConcept"> | string
    examples?: StringNullableListFilter<"DomainConcept">
    relatedConcepts?: StringNullableListFilter<"DomainConcept">
    createdAt?: DateTimeFilter<"DomainConcept"> | Date | string
    updatedAt?: DateTimeFilter<"DomainConcept"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }

  export type DomainConceptOrderByWithRelationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    examples?: SortOrder
    relatedConcepts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainKnowledge?: DomainKnowledgeOrderByWithRelationInput
  }

  export type DomainConceptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DomainConceptWhereInput | DomainConceptWhereInput[]
    OR?: DomainConceptWhereInput[]
    NOT?: DomainConceptWhereInput | DomainConceptWhereInput[]
    domainKnowledgeId?: StringFilter<"DomainConcept"> | string
    name?: StringFilter<"DomainConcept"> | string
    definition?: StringFilter<"DomainConcept"> | string
    examples?: StringNullableListFilter<"DomainConcept">
    relatedConcepts?: StringNullableListFilter<"DomainConcept">
    createdAt?: DateTimeFilter<"DomainConcept"> | Date | string
    updatedAt?: DateTimeFilter<"DomainConcept"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }, "id">

  export type DomainConceptOrderByWithAggregationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    examples?: SortOrder
    relatedConcepts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DomainConceptCountOrderByAggregateInput
    _max?: DomainConceptMaxOrderByAggregateInput
    _min?: DomainConceptMinOrderByAggregateInput
  }

  export type DomainConceptScalarWhereWithAggregatesInput = {
    AND?: DomainConceptScalarWhereWithAggregatesInput | DomainConceptScalarWhereWithAggregatesInput[]
    OR?: DomainConceptScalarWhereWithAggregatesInput[]
    NOT?: DomainConceptScalarWhereWithAggregatesInput | DomainConceptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DomainConcept"> | string
    domainKnowledgeId?: StringWithAggregatesFilter<"DomainConcept"> | string
    name?: StringWithAggregatesFilter<"DomainConcept"> | string
    definition?: StringWithAggregatesFilter<"DomainConcept"> | string
    examples?: StringNullableListFilter<"DomainConcept">
    relatedConcepts?: StringNullableListFilter<"DomainConcept">
    createdAt?: DateTimeWithAggregatesFilter<"DomainConcept"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DomainConcept"> | Date | string
  }

  export type DomainPatternWhereInput = {
    AND?: DomainPatternWhereInput | DomainPatternWhereInput[]
    OR?: DomainPatternWhereInput[]
    NOT?: DomainPatternWhereInput | DomainPatternWhereInput[]
    id?: StringFilter<"DomainPattern"> | string
    domainKnowledgeId?: StringFilter<"DomainPattern"> | string
    name?: StringFilter<"DomainPattern"> | string
    description?: StringFilter<"DomainPattern"> | string
    context?: StringFilter<"DomainPattern"> | string
    solution?: StringFilter<"DomainPattern"> | string
    consequences?: StringFilter<"DomainPattern"> | string
    examples?: StringNullableListFilter<"DomainPattern">
    createdAt?: DateTimeFilter<"DomainPattern"> | Date | string
    updatedAt?: DateTimeFilter<"DomainPattern"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }

  export type DomainPatternOrderByWithRelationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    context?: SortOrder
    solution?: SortOrder
    consequences?: SortOrder
    examples?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainKnowledge?: DomainKnowledgeOrderByWithRelationInput
  }

  export type DomainPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DomainPatternWhereInput | DomainPatternWhereInput[]
    OR?: DomainPatternWhereInput[]
    NOT?: DomainPatternWhereInput | DomainPatternWhereInput[]
    domainKnowledgeId?: StringFilter<"DomainPattern"> | string
    name?: StringFilter<"DomainPattern"> | string
    description?: StringFilter<"DomainPattern"> | string
    context?: StringFilter<"DomainPattern"> | string
    solution?: StringFilter<"DomainPattern"> | string
    consequences?: StringFilter<"DomainPattern"> | string
    examples?: StringNullableListFilter<"DomainPattern">
    createdAt?: DateTimeFilter<"DomainPattern"> | Date | string
    updatedAt?: DateTimeFilter<"DomainPattern"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }, "id">

  export type DomainPatternOrderByWithAggregationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    context?: SortOrder
    solution?: SortOrder
    consequences?: SortOrder
    examples?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DomainPatternCountOrderByAggregateInput
    _max?: DomainPatternMaxOrderByAggregateInput
    _min?: DomainPatternMinOrderByAggregateInput
  }

  export type DomainPatternScalarWhereWithAggregatesInput = {
    AND?: DomainPatternScalarWhereWithAggregatesInput | DomainPatternScalarWhereWithAggregatesInput[]
    OR?: DomainPatternScalarWhereWithAggregatesInput[]
    NOT?: DomainPatternScalarWhereWithAggregatesInput | DomainPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DomainPattern"> | string
    domainKnowledgeId?: StringWithAggregatesFilter<"DomainPattern"> | string
    name?: StringWithAggregatesFilter<"DomainPattern"> | string
    description?: StringWithAggregatesFilter<"DomainPattern"> | string
    context?: StringWithAggregatesFilter<"DomainPattern"> | string
    solution?: StringWithAggregatesFilter<"DomainPattern"> | string
    consequences?: StringWithAggregatesFilter<"DomainPattern"> | string
    examples?: StringNullableListFilter<"DomainPattern">
    createdAt?: DateTimeWithAggregatesFilter<"DomainPattern"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DomainPattern"> | Date | string
  }

  export type DomainBestPracticeWhereInput = {
    AND?: DomainBestPracticeWhereInput | DomainBestPracticeWhereInput[]
    OR?: DomainBestPracticeWhereInput[]
    NOT?: DomainBestPracticeWhereInput | DomainBestPracticeWhereInput[]
    id?: StringFilter<"DomainBestPractice"> | string
    domainKnowledgeId?: StringFilter<"DomainBestPractice"> | string
    title?: StringFilter<"DomainBestPractice"> | string
    description?: StringFilter<"DomainBestPractice"> | string
    rationale?: StringFilter<"DomainBestPractice"> | string
    implementation?: StringFilter<"DomainBestPractice"> | string
    benefits?: StringNullableListFilter<"DomainBestPractice">
    considerations?: StringNullableListFilter<"DomainBestPractice">
    createdAt?: DateTimeFilter<"DomainBestPractice"> | Date | string
    updatedAt?: DateTimeFilter<"DomainBestPractice"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }

  export type DomainBestPracticeOrderByWithRelationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    implementation?: SortOrder
    benefits?: SortOrder
    considerations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainKnowledge?: DomainKnowledgeOrderByWithRelationInput
  }

  export type DomainBestPracticeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DomainBestPracticeWhereInput | DomainBestPracticeWhereInput[]
    OR?: DomainBestPracticeWhereInput[]
    NOT?: DomainBestPracticeWhereInput | DomainBestPracticeWhereInput[]
    domainKnowledgeId?: StringFilter<"DomainBestPractice"> | string
    title?: StringFilter<"DomainBestPractice"> | string
    description?: StringFilter<"DomainBestPractice"> | string
    rationale?: StringFilter<"DomainBestPractice"> | string
    implementation?: StringFilter<"DomainBestPractice"> | string
    benefits?: StringNullableListFilter<"DomainBestPractice">
    considerations?: StringNullableListFilter<"DomainBestPractice">
    createdAt?: DateTimeFilter<"DomainBestPractice"> | Date | string
    updatedAt?: DateTimeFilter<"DomainBestPractice"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }, "id">

  export type DomainBestPracticeOrderByWithAggregationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    implementation?: SortOrder
    benefits?: SortOrder
    considerations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DomainBestPracticeCountOrderByAggregateInput
    _max?: DomainBestPracticeMaxOrderByAggregateInput
    _min?: DomainBestPracticeMinOrderByAggregateInput
  }

  export type DomainBestPracticeScalarWhereWithAggregatesInput = {
    AND?: DomainBestPracticeScalarWhereWithAggregatesInput | DomainBestPracticeScalarWhereWithAggregatesInput[]
    OR?: DomainBestPracticeScalarWhereWithAggregatesInput[]
    NOT?: DomainBestPracticeScalarWhereWithAggregatesInput | DomainBestPracticeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DomainBestPractice"> | string
    domainKnowledgeId?: StringWithAggregatesFilter<"DomainBestPractice"> | string
    title?: StringWithAggregatesFilter<"DomainBestPractice"> | string
    description?: StringWithAggregatesFilter<"DomainBestPractice"> | string
    rationale?: StringWithAggregatesFilter<"DomainBestPractice"> | string
    implementation?: StringWithAggregatesFilter<"DomainBestPractice"> | string
    benefits?: StringNullableListFilter<"DomainBestPractice">
    considerations?: StringNullableListFilter<"DomainBestPractice">
    createdAt?: DateTimeWithAggregatesFilter<"DomainBestPractice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DomainBestPractice"> | Date | string
  }

  export type DomainAntiPatternWhereInput = {
    AND?: DomainAntiPatternWhereInput | DomainAntiPatternWhereInput[]
    OR?: DomainAntiPatternWhereInput[]
    NOT?: DomainAntiPatternWhereInput | DomainAntiPatternWhereInput[]
    id?: StringFilter<"DomainAntiPattern"> | string
    domainKnowledgeId?: StringFilter<"DomainAntiPattern"> | string
    name?: StringFilter<"DomainAntiPattern"> | string
    description?: StringFilter<"DomainAntiPattern"> | string
    symptoms?: StringNullableListFilter<"DomainAntiPattern">
    causes?: StringNullableListFilter<"DomainAntiPattern">
    consequences?: StringNullableListFilter<"DomainAntiPattern">
    refactoring?: StringFilter<"DomainAntiPattern"> | string
    createdAt?: DateTimeFilter<"DomainAntiPattern"> | Date | string
    updatedAt?: DateTimeFilter<"DomainAntiPattern"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }

  export type DomainAntiPatternOrderByWithRelationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symptoms?: SortOrder
    causes?: SortOrder
    consequences?: SortOrder
    refactoring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    domainKnowledge?: DomainKnowledgeOrderByWithRelationInput
  }

  export type DomainAntiPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DomainAntiPatternWhereInput | DomainAntiPatternWhereInput[]
    OR?: DomainAntiPatternWhereInput[]
    NOT?: DomainAntiPatternWhereInput | DomainAntiPatternWhereInput[]
    domainKnowledgeId?: StringFilter<"DomainAntiPattern"> | string
    name?: StringFilter<"DomainAntiPattern"> | string
    description?: StringFilter<"DomainAntiPattern"> | string
    symptoms?: StringNullableListFilter<"DomainAntiPattern">
    causes?: StringNullableListFilter<"DomainAntiPattern">
    consequences?: StringNullableListFilter<"DomainAntiPattern">
    refactoring?: StringFilter<"DomainAntiPattern"> | string
    createdAt?: DateTimeFilter<"DomainAntiPattern"> | Date | string
    updatedAt?: DateTimeFilter<"DomainAntiPattern"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }, "id">

  export type DomainAntiPatternOrderByWithAggregationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symptoms?: SortOrder
    causes?: SortOrder
    consequences?: SortOrder
    refactoring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DomainAntiPatternCountOrderByAggregateInput
    _max?: DomainAntiPatternMaxOrderByAggregateInput
    _min?: DomainAntiPatternMinOrderByAggregateInput
  }

  export type DomainAntiPatternScalarWhereWithAggregatesInput = {
    AND?: DomainAntiPatternScalarWhereWithAggregatesInput | DomainAntiPatternScalarWhereWithAggregatesInput[]
    OR?: DomainAntiPatternScalarWhereWithAggregatesInput[]
    NOT?: DomainAntiPatternScalarWhereWithAggregatesInput | DomainAntiPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DomainAntiPattern"> | string
    domainKnowledgeId?: StringWithAggregatesFilter<"DomainAntiPattern"> | string
    name?: StringWithAggregatesFilter<"DomainAntiPattern"> | string
    description?: StringWithAggregatesFilter<"DomainAntiPattern"> | string
    symptoms?: StringNullableListFilter<"DomainAntiPattern">
    causes?: StringNullableListFilter<"DomainAntiPattern">
    consequences?: StringNullableListFilter<"DomainAntiPattern">
    refactoring?: StringWithAggregatesFilter<"DomainAntiPattern"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DomainAntiPattern"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DomainAntiPattern"> | Date | string
  }

  export type DomainReferenceWhereInput = {
    AND?: DomainReferenceWhereInput | DomainReferenceWhereInput[]
    OR?: DomainReferenceWhereInput[]
    NOT?: DomainReferenceWhereInput | DomainReferenceWhereInput[]
    id?: StringFilter<"DomainReference"> | string
    domainKnowledgeId?: StringFilter<"DomainReference"> | string
    title?: StringFilter<"DomainReference"> | string
    type?: StringFilter<"DomainReference"> | string
    url?: StringNullableFilter<"DomainReference"> | string | null
    author?: StringNullableFilter<"DomainReference"> | string | null
    publishDate?: DateTimeNullableFilter<"DomainReference"> | Date | string | null
    summary?: StringNullableFilter<"DomainReference"> | string | null
    createdAt?: DateTimeFilter<"DomainReference"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }

  export type DomainReferenceOrderByWithRelationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    url?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    publishDate?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    domainKnowledge?: DomainKnowledgeOrderByWithRelationInput
  }

  export type DomainReferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DomainReferenceWhereInput | DomainReferenceWhereInput[]
    OR?: DomainReferenceWhereInput[]
    NOT?: DomainReferenceWhereInput | DomainReferenceWhereInput[]
    domainKnowledgeId?: StringFilter<"DomainReference"> | string
    title?: StringFilter<"DomainReference"> | string
    type?: StringFilter<"DomainReference"> | string
    url?: StringNullableFilter<"DomainReference"> | string | null
    author?: StringNullableFilter<"DomainReference"> | string | null
    publishDate?: DateTimeNullableFilter<"DomainReference"> | Date | string | null
    summary?: StringNullableFilter<"DomainReference"> | string | null
    createdAt?: DateTimeFilter<"DomainReference"> | Date | string
    domainKnowledge?: XOR<DomainKnowledgeScalarRelationFilter, DomainKnowledgeWhereInput>
  }, "id">

  export type DomainReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    url?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    publishDate?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DomainReferenceCountOrderByAggregateInput
    _max?: DomainReferenceMaxOrderByAggregateInput
    _min?: DomainReferenceMinOrderByAggregateInput
  }

  export type DomainReferenceScalarWhereWithAggregatesInput = {
    AND?: DomainReferenceScalarWhereWithAggregatesInput | DomainReferenceScalarWhereWithAggregatesInput[]
    OR?: DomainReferenceScalarWhereWithAggregatesInput[]
    NOT?: DomainReferenceScalarWhereWithAggregatesInput | DomainReferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DomainReference"> | string
    domainKnowledgeId?: StringWithAggregatesFilter<"DomainReference"> | string
    title?: StringWithAggregatesFilter<"DomainReference"> | string
    type?: StringWithAggregatesFilter<"DomainReference"> | string
    url?: StringNullableWithAggregatesFilter<"DomainReference"> | string | null
    author?: StringNullableWithAggregatesFilter<"DomainReference"> | string | null
    publishDate?: DateTimeNullableWithAggregatesFilter<"DomainReference"> | Date | string | null
    summary?: StringNullableWithAggregatesFilter<"DomainReference"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DomainReference"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: StringNullableFilter<"Project"> | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: ProjectMemberListRelationFilter
    tasks?: TaskListRelationFilter
    documentation?: DocumentationListRelationFilter
    MindMap?: MindMapListRelationFilter
    Sprint?: SprintListRelationFilter
    Requirement?: RequirementListRelationFilter
    DomainKnowledge?: DomainKnowledgeListRelationFilter
    SystemArchitecture?: SystemArchitectureListRelationFilter
    roadmaps?: RoadmapListRelationFilter
    ApiDesign?: ApiDesignListRelationFilter
    team?: TeamListRelationFilter
    Agent?: AgentListRelationFilter
    AgentWorklog?: AgentWorklogListRelationFilter
    DatabaseSchema?: DatabaseSchemaListRelationFilter
    RequirementQuestion?: RequirementQuestionListRelationFilter
    RequirementAttachment?: RequirementAttachmentListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    documentation?: DocumentationOrderByRelationAggregateInput
    MindMap?: MindMapOrderByRelationAggregateInput
    Sprint?: SprintOrderByRelationAggregateInput
    Requirement?: RequirementOrderByRelationAggregateInput
    DomainKnowledge?: DomainKnowledgeOrderByRelationAggregateInput
    SystemArchitecture?: SystemArchitectureOrderByRelationAggregateInput
    roadmaps?: RoadmapOrderByRelationAggregateInput
    ApiDesign?: ApiDesignOrderByRelationAggregateInput
    team?: TeamOrderByRelationAggregateInput
    Agent?: AgentOrderByRelationAggregateInput
    AgentWorklog?: AgentWorklogOrderByRelationAggregateInput
    DatabaseSchema?: DatabaseSchemaOrderByRelationAggregateInput
    RequirementQuestion?: RequirementQuestionOrderByRelationAggregateInput
    RequirementAttachment?: RequirementAttachmentOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: StringNullableFilter<"Project"> | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    members?: ProjectMemberListRelationFilter
    tasks?: TaskListRelationFilter
    documentation?: DocumentationListRelationFilter
    MindMap?: MindMapListRelationFilter
    Sprint?: SprintListRelationFilter
    Requirement?: RequirementListRelationFilter
    DomainKnowledge?: DomainKnowledgeListRelationFilter
    SystemArchitecture?: SystemArchitectureListRelationFilter
    roadmaps?: RoadmapListRelationFilter
    ApiDesign?: ApiDesignListRelationFilter
    team?: TeamListRelationFilter
    Agent?: AgentListRelationFilter
    AgentWorklog?: AgentWorklogListRelationFilter
    DatabaseSchema?: DatabaseSchemaListRelationFilter
    RequirementQuestion?: RequirementQuestionListRelationFilter
    RequirementAttachment?: RequirementAttachmentListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    createdBy?: StringNullableWithAggregatesFilter<"Project"> | string | null
  }

  export type RequirementWhereInput = {
    AND?: RequirementWhereInput | RequirementWhereInput[]
    OR?: RequirementWhereInput[]
    NOT?: RequirementWhereInput | RequirementWhereInput[]
    id?: StringFilter<"Requirement"> | string
    projectId?: StringFilter<"Requirement"> | string
    title?: StringFilter<"Requirement"> | string
    content?: StringFilter<"Requirement"> | string
    type?: EnumRequirementTypeFilter<"Requirement"> | $Enums.RequirementType
    priority?: EnumRequirementPriorityFilter<"Requirement"> | $Enums.RequirementPriority
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    source?: EnumRequirementSourceFilter<"Requirement"> | $Enums.RequirementSource
    parentId?: StringNullableFilter<"Requirement"> | string | null
    version?: IntFilter<"Requirement"> | number
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    userId?: StringNullableFilter<"Requirement"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    parent?: XOR<RequirementNullableScalarRelationFilter, RequirementWhereInput> | null
    children?: RequirementListRelationFilter
    questions?: RequirementQuestionListRelationFilter
    attachments?: RequirementAttachmentListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type RequirementOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    source?: SortOrder
    parentId?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    parent?: RequirementOrderByWithRelationInput
    children?: RequirementOrderByRelationAggregateInput
    questions?: RequirementQuestionOrderByRelationAggregateInput
    attachments?: RequirementAttachmentOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
  }

  export type RequirementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequirementWhereInput | RequirementWhereInput[]
    OR?: RequirementWhereInput[]
    NOT?: RequirementWhereInput | RequirementWhereInput[]
    projectId?: StringFilter<"Requirement"> | string
    title?: StringFilter<"Requirement"> | string
    content?: StringFilter<"Requirement"> | string
    type?: EnumRequirementTypeFilter<"Requirement"> | $Enums.RequirementType
    priority?: EnumRequirementPriorityFilter<"Requirement"> | $Enums.RequirementPriority
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    source?: EnumRequirementSourceFilter<"Requirement"> | $Enums.RequirementSource
    parentId?: StringNullableFilter<"Requirement"> | string | null
    version?: IntFilter<"Requirement"> | number
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    userId?: StringNullableFilter<"Requirement"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    parent?: XOR<RequirementNullableScalarRelationFilter, RequirementWhereInput> | null
    children?: RequirementListRelationFilter
    questions?: RequirementQuestionListRelationFilter
    attachments?: RequirementAttachmentListRelationFilter
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type RequirementOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    source?: SortOrder
    parentId?: SortOrderInput | SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: RequirementCountOrderByAggregateInput
    _avg?: RequirementAvgOrderByAggregateInput
    _max?: RequirementMaxOrderByAggregateInput
    _min?: RequirementMinOrderByAggregateInput
    _sum?: RequirementSumOrderByAggregateInput
  }

  export type RequirementScalarWhereWithAggregatesInput = {
    AND?: RequirementScalarWhereWithAggregatesInput | RequirementScalarWhereWithAggregatesInput[]
    OR?: RequirementScalarWhereWithAggregatesInput[]
    NOT?: RequirementScalarWhereWithAggregatesInput | RequirementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Requirement"> | string
    projectId?: StringWithAggregatesFilter<"Requirement"> | string
    title?: StringWithAggregatesFilter<"Requirement"> | string
    content?: StringWithAggregatesFilter<"Requirement"> | string
    type?: EnumRequirementTypeWithAggregatesFilter<"Requirement"> | $Enums.RequirementType
    priority?: EnumRequirementPriorityWithAggregatesFilter<"Requirement"> | $Enums.RequirementPriority
    status?: EnumRequirementStatusWithAggregatesFilter<"Requirement"> | $Enums.RequirementStatus
    source?: EnumRequirementSourceWithAggregatesFilter<"Requirement"> | $Enums.RequirementSource
    parentId?: StringNullableWithAggregatesFilter<"Requirement"> | string | null
    version?: IntWithAggregatesFilter<"Requirement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Requirement"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Requirement"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"Requirement"> | string | null
  }

  export type RequirementQuestionWhereInput = {
    AND?: RequirementQuestionWhereInput | RequirementQuestionWhereInput[]
    OR?: RequirementQuestionWhereInput[]
    NOT?: RequirementQuestionWhereInput | RequirementQuestionWhereInput[]
    id?: StringFilter<"RequirementQuestion"> | string
    projectId?: StringFilter<"RequirementQuestion"> | string
    requirementId?: StringFilter<"RequirementQuestion"> | string
    question?: StringFilter<"RequirementQuestion"> | string
    answer?: StringNullableFilter<"RequirementQuestion"> | string | null
    status?: EnumQuestionStatusFilter<"RequirementQuestion"> | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFilter<"RequirementQuestion"> | $Enums.QuestionPriority
    clarified?: BoolFilter<"RequirementQuestion"> | boolean
    agentId?: StringFilter<"RequirementQuestion"> | string
    createdAt?: DateTimeFilter<"RequirementQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"RequirementQuestion"> | Date | string
    answeredAt?: DateTimeNullableFilter<"RequirementQuestion"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }

  export type RequirementQuestionOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    question?: SortOrder
    answer?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    clarified?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answeredAt?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    requirement?: RequirementOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type RequirementQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequirementQuestionWhereInput | RequirementQuestionWhereInput[]
    OR?: RequirementQuestionWhereInput[]
    NOT?: RequirementQuestionWhereInput | RequirementQuestionWhereInput[]
    projectId?: StringFilter<"RequirementQuestion"> | string
    requirementId?: StringFilter<"RequirementQuestion"> | string
    question?: StringFilter<"RequirementQuestion"> | string
    answer?: StringNullableFilter<"RequirementQuestion"> | string | null
    status?: EnumQuestionStatusFilter<"RequirementQuestion"> | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFilter<"RequirementQuestion"> | $Enums.QuestionPriority
    clarified?: BoolFilter<"RequirementQuestion"> | boolean
    agentId?: StringFilter<"RequirementQuestion"> | string
    createdAt?: DateTimeFilter<"RequirementQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"RequirementQuestion"> | Date | string
    answeredAt?: DateTimeNullableFilter<"RequirementQuestion"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
  }, "id">

  export type RequirementQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    question?: SortOrder
    answer?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    clarified?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answeredAt?: SortOrderInput | SortOrder
    _count?: RequirementQuestionCountOrderByAggregateInput
    _max?: RequirementQuestionMaxOrderByAggregateInput
    _min?: RequirementQuestionMinOrderByAggregateInput
  }

  export type RequirementQuestionScalarWhereWithAggregatesInput = {
    AND?: RequirementQuestionScalarWhereWithAggregatesInput | RequirementQuestionScalarWhereWithAggregatesInput[]
    OR?: RequirementQuestionScalarWhereWithAggregatesInput[]
    NOT?: RequirementQuestionScalarWhereWithAggregatesInput | RequirementQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequirementQuestion"> | string
    projectId?: StringWithAggregatesFilter<"RequirementQuestion"> | string
    requirementId?: StringWithAggregatesFilter<"RequirementQuestion"> | string
    question?: StringWithAggregatesFilter<"RequirementQuestion"> | string
    answer?: StringNullableWithAggregatesFilter<"RequirementQuestion"> | string | null
    status?: EnumQuestionStatusWithAggregatesFilter<"RequirementQuestion"> | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityWithAggregatesFilter<"RequirementQuestion"> | $Enums.QuestionPriority
    clarified?: BoolWithAggregatesFilter<"RequirementQuestion"> | boolean
    agentId?: StringWithAggregatesFilter<"RequirementQuestion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RequirementQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RequirementQuestion"> | Date | string
    answeredAt?: DateTimeNullableWithAggregatesFilter<"RequirementQuestion"> | Date | string | null
  }

  export type RequirementAttachmentWhereInput = {
    AND?: RequirementAttachmentWhereInput | RequirementAttachmentWhereInput[]
    OR?: RequirementAttachmentWhereInput[]
    NOT?: RequirementAttachmentWhereInput | RequirementAttachmentWhereInput[]
    id?: StringFilter<"RequirementAttachment"> | string
    projectId?: StringFilter<"RequirementAttachment"> | string
    requirementId?: StringFilter<"RequirementAttachment"> | string
    fileName?: StringFilter<"RequirementAttachment"> | string
    fileUrl?: StringFilter<"RequirementAttachment"> | string
    fileSize?: IntFilter<"RequirementAttachment"> | number
    mimeType?: StringFilter<"RequirementAttachment"> | string
    createdAt?: DateTimeFilter<"RequirementAttachment"> | Date | string
    userId?: StringNullableFilter<"RequirementAttachment"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type RequirementAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    requirement?: RequirementOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type RequirementAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RequirementAttachmentWhereInput | RequirementAttachmentWhereInput[]
    OR?: RequirementAttachmentWhereInput[]
    NOT?: RequirementAttachmentWhereInput | RequirementAttachmentWhereInput[]
    projectId?: StringFilter<"RequirementAttachment"> | string
    requirementId?: StringFilter<"RequirementAttachment"> | string
    fileName?: StringFilter<"RequirementAttachment"> | string
    fileUrl?: StringFilter<"RequirementAttachment"> | string
    fileSize?: IntFilter<"RequirementAttachment"> | number
    mimeType?: StringFilter<"RequirementAttachment"> | string
    createdAt?: DateTimeFilter<"RequirementAttachment"> | Date | string
    userId?: StringNullableFilter<"RequirementAttachment"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    requirement?: XOR<RequirementScalarRelationFilter, RequirementWhereInput>
    User?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type RequirementAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrderInput | SortOrder
    _count?: RequirementAttachmentCountOrderByAggregateInput
    _avg?: RequirementAttachmentAvgOrderByAggregateInput
    _max?: RequirementAttachmentMaxOrderByAggregateInput
    _min?: RequirementAttachmentMinOrderByAggregateInput
    _sum?: RequirementAttachmentSumOrderByAggregateInput
  }

  export type RequirementAttachmentScalarWhereWithAggregatesInput = {
    AND?: RequirementAttachmentScalarWhereWithAggregatesInput | RequirementAttachmentScalarWhereWithAggregatesInput[]
    OR?: RequirementAttachmentScalarWhereWithAggregatesInput[]
    NOT?: RequirementAttachmentScalarWhereWithAggregatesInput | RequirementAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RequirementAttachment"> | string
    projectId?: StringWithAggregatesFilter<"RequirementAttachment"> | string
    requirementId?: StringWithAggregatesFilter<"RequirementAttachment"> | string
    fileName?: StringWithAggregatesFilter<"RequirementAttachment"> | string
    fileUrl?: StringWithAggregatesFilter<"RequirementAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"RequirementAttachment"> | number
    mimeType?: StringWithAggregatesFilter<"RequirementAttachment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RequirementAttachment"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"RequirementAttachment"> | string | null
  }

  export type RoadmapWhereInput = {
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    id?: StringFilter<"Roadmap"> | string
    projectId?: StringFilter<"Roadmap"> | string
    name?: StringFilter<"Roadmap"> | string
    description?: StringNullableFilter<"Roadmap"> | string | null
    startDate?: DateTimeFilter<"Roadmap"> | Date | string
    endDate?: DateTimeFilter<"Roadmap"> | Date | string
    status?: StringFilter<"Roadmap"> | string
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    milestones?: MilestoneListRelationFilter
    versions?: VersionListRelationFilter
  }

  export type RoadmapOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    milestones?: MilestoneOrderByRelationAggregateInput
    versions?: VersionOrderByRelationAggregateInput
  }

  export type RoadmapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    projectId?: StringFilter<"Roadmap"> | string
    name?: StringFilter<"Roadmap"> | string
    description?: StringNullableFilter<"Roadmap"> | string | null
    startDate?: DateTimeFilter<"Roadmap"> | Date | string
    endDate?: DateTimeFilter<"Roadmap"> | Date | string
    status?: StringFilter<"Roadmap"> | string
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    milestones?: MilestoneListRelationFilter
    versions?: VersionListRelationFilter
  }, "id">

  export type RoadmapOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoadmapCountOrderByAggregateInput
    _max?: RoadmapMaxOrderByAggregateInput
    _min?: RoadmapMinOrderByAggregateInput
  }

  export type RoadmapScalarWhereWithAggregatesInput = {
    AND?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    OR?: RoadmapScalarWhereWithAggregatesInput[]
    NOT?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Roadmap"> | string
    projectId?: StringWithAggregatesFilter<"Roadmap"> | string
    name?: StringWithAggregatesFilter<"Roadmap"> | string
    description?: StringNullableWithAggregatesFilter<"Roadmap"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
    status?: StringWithAggregatesFilter<"Roadmap"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
  }

  export type MilestoneWhereInput = {
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    id?: StringFilter<"Milestone"> | string
    roadmapId?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    targetDate?: DateTimeFilter<"Milestone"> | Date | string
    status?: StringFilter<"Milestone"> | string
    priority?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    roadmap?: XOR<RoadmapScalarRelationFilter, RoadmapWhereInput>
    features?: FeatureListRelationFilter
  }

  export type MilestoneOrderByWithRelationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roadmap?: RoadmapOrderByWithRelationInput
    features?: FeatureOrderByRelationAggregateInput
  }

  export type MilestoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MilestoneWhereInput | MilestoneWhereInput[]
    OR?: MilestoneWhereInput[]
    NOT?: MilestoneWhereInput | MilestoneWhereInput[]
    roadmapId?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    targetDate?: DateTimeFilter<"Milestone"> | Date | string
    status?: StringFilter<"Milestone"> | string
    priority?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
    roadmap?: XOR<RoadmapScalarRelationFilter, RoadmapWhereInput>
    features?: FeatureListRelationFilter
  }, "id">

  export type MilestoneOrderByWithAggregationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MilestoneCountOrderByAggregateInput
    _max?: MilestoneMaxOrderByAggregateInput
    _min?: MilestoneMinOrderByAggregateInput
  }

  export type MilestoneScalarWhereWithAggregatesInput = {
    AND?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    OR?: MilestoneScalarWhereWithAggregatesInput[]
    NOT?: MilestoneScalarWhereWithAggregatesInput | MilestoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Milestone"> | string
    roadmapId?: StringWithAggregatesFilter<"Milestone"> | string
    name?: StringWithAggregatesFilter<"Milestone"> | string
    description?: StringNullableWithAggregatesFilter<"Milestone"> | string | null
    targetDate?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    status?: StringWithAggregatesFilter<"Milestone"> | string
    priority?: StringWithAggregatesFilter<"Milestone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Milestone"> | Date | string
  }

  export type VersionWhereInput = {
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    id?: StringFilter<"Version"> | string
    roadmapId?: StringFilter<"Version"> | string
    name?: StringFilter<"Version"> | string
    description?: StringNullableFilter<"Version"> | string | null
    releaseDate?: DateTimeNullableFilter<"Version"> | Date | string | null
    status?: StringFilter<"Version"> | string
    createdAt?: DateTimeFilter<"Version"> | Date | string
    updatedAt?: DateTimeFilter<"Version"> | Date | string
    roadmap?: XOR<RoadmapScalarRelationFilter, RoadmapWhereInput>
    features?: FeatureListRelationFilter
  }

  export type VersionOrderByWithRelationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roadmap?: RoadmapOrderByWithRelationInput
    features?: FeatureOrderByRelationAggregateInput
  }

  export type VersionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VersionWhereInput | VersionWhereInput[]
    OR?: VersionWhereInput[]
    NOT?: VersionWhereInput | VersionWhereInput[]
    roadmapId?: StringFilter<"Version"> | string
    name?: StringFilter<"Version"> | string
    description?: StringNullableFilter<"Version"> | string | null
    releaseDate?: DateTimeNullableFilter<"Version"> | Date | string | null
    status?: StringFilter<"Version"> | string
    createdAt?: DateTimeFilter<"Version"> | Date | string
    updatedAt?: DateTimeFilter<"Version"> | Date | string
    roadmap?: XOR<RoadmapScalarRelationFilter, RoadmapWhereInput>
    features?: FeatureListRelationFilter
  }, "id">

  export type VersionOrderByWithAggregationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    releaseDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VersionCountOrderByAggregateInput
    _max?: VersionMaxOrderByAggregateInput
    _min?: VersionMinOrderByAggregateInput
  }

  export type VersionScalarWhereWithAggregatesInput = {
    AND?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    OR?: VersionScalarWhereWithAggregatesInput[]
    NOT?: VersionScalarWhereWithAggregatesInput | VersionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Version"> | string
    roadmapId?: StringWithAggregatesFilter<"Version"> | string
    name?: StringWithAggregatesFilter<"Version"> | string
    description?: StringNullableWithAggregatesFilter<"Version"> | string | null
    releaseDate?: DateTimeNullableWithAggregatesFilter<"Version"> | Date | string | null
    status?: StringWithAggregatesFilter<"Version"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Version"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Version"> | Date | string
  }

  export type FeatureWhereInput = {
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    id?: StringFilter<"Feature"> | string
    milestoneId?: StringNullableFilter<"Feature"> | string | null
    versionId?: StringNullableFilter<"Feature"> | string | null
    name?: StringFilter<"Feature"> | string
    description?: StringNullableFilter<"Feature"> | string | null
    status?: StringFilter<"Feature"> | string
    priority?: StringFilter<"Feature"> | string
    effort?: StringNullableFilter<"Feature"> | string | null
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
    milestone?: XOR<MilestoneNullableScalarRelationFilter, MilestoneWhereInput> | null
    version?: XOR<VersionNullableScalarRelationFilter, VersionWhereInput> | null
    tasks?: TaskListRelationFilter
  }

  export type FeatureOrderByWithRelationInput = {
    id?: SortOrder
    milestoneId?: SortOrderInput | SortOrder
    versionId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    effort?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    milestone?: MilestoneOrderByWithRelationInput
    version?: VersionOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type FeatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeatureWhereInput | FeatureWhereInput[]
    OR?: FeatureWhereInput[]
    NOT?: FeatureWhereInput | FeatureWhereInput[]
    milestoneId?: StringNullableFilter<"Feature"> | string | null
    versionId?: StringNullableFilter<"Feature"> | string | null
    name?: StringFilter<"Feature"> | string
    description?: StringNullableFilter<"Feature"> | string | null
    status?: StringFilter<"Feature"> | string
    priority?: StringFilter<"Feature"> | string
    effort?: StringNullableFilter<"Feature"> | string | null
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
    milestone?: XOR<MilestoneNullableScalarRelationFilter, MilestoneWhereInput> | null
    version?: XOR<VersionNullableScalarRelationFilter, VersionWhereInput> | null
    tasks?: TaskListRelationFilter
  }, "id">

  export type FeatureOrderByWithAggregationInput = {
    id?: SortOrder
    milestoneId?: SortOrderInput | SortOrder
    versionId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    effort?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeatureCountOrderByAggregateInput
    _max?: FeatureMaxOrderByAggregateInput
    _min?: FeatureMinOrderByAggregateInput
  }

  export type FeatureScalarWhereWithAggregatesInput = {
    AND?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    OR?: FeatureScalarWhereWithAggregatesInput[]
    NOT?: FeatureScalarWhereWithAggregatesInput | FeatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Feature"> | string
    milestoneId?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    versionId?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    name?: StringWithAggregatesFilter<"Feature"> | string
    description?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    status?: StringWithAggregatesFilter<"Feature"> | string
    priority?: StringWithAggregatesFilter<"Feature"> | string
    effort?: StringNullableWithAggregatesFilter<"Feature"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Feature"> | Date | string
  }

  export type SprintWhereInput = {
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    id?: StringFilter<"Sprint"> | string
    projectId?: StringFilter<"Sprint"> | string
    name?: StringFilter<"Sprint"> | string
    startDate?: DateTimeFilter<"Sprint"> | Date | string
    endDate?: DateTimeFilter<"Sprint"> | Date | string
    goal?: StringFilter<"Sprint"> | string
    status?: StringFilter<"Sprint"> | string
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    Task?: TaskListRelationFilter
  }

  export type SprintOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    goal?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    Task?: TaskOrderByRelationAggregateInput
  }

  export type SprintWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SprintWhereInput | SprintWhereInput[]
    OR?: SprintWhereInput[]
    NOT?: SprintWhereInput | SprintWhereInput[]
    projectId?: StringFilter<"Sprint"> | string
    name?: StringFilter<"Sprint"> | string
    startDate?: DateTimeFilter<"Sprint"> | Date | string
    endDate?: DateTimeFilter<"Sprint"> | Date | string
    goal?: StringFilter<"Sprint"> | string
    status?: StringFilter<"Sprint"> | string
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    Task?: TaskListRelationFilter
  }, "id">

  export type SprintOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    goal?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SprintCountOrderByAggregateInput
    _max?: SprintMaxOrderByAggregateInput
    _min?: SprintMinOrderByAggregateInput
  }

  export type SprintScalarWhereWithAggregatesInput = {
    AND?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    OR?: SprintScalarWhereWithAggregatesInput[]
    NOT?: SprintScalarWhereWithAggregatesInput | SprintScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sprint"> | string
    projectId?: StringWithAggregatesFilter<"Sprint"> | string
    name?: StringWithAggregatesFilter<"Sprint"> | string
    startDate?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    goal?: StringWithAggregatesFilter<"Sprint"> | string
    status?: StringWithAggregatesFilter<"Sprint"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sprint"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    projectId?: StringFilter<"Task"> | string
    sprintId?: StringFilter<"Task"> | string
    teamId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    content?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    featureId?: StringNullableFilter<"Task"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    sprint?: XOR<SprintScalarRelationFilter, SprintWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    feature?: XOR<FeatureNullableScalarRelationFilter, FeatureWhereInput> | null
    AgentTask?: AgentTaskListRelationFilter
    AgentWorklog?: AgentWorklogListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featureId?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    sprint?: SprintOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    feature?: FeatureOrderByWithRelationInput
    AgentTask?: AgentTaskOrderByRelationAggregateInput
    AgentWorklog?: AgentWorklogOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    projectId?: StringFilter<"Task"> | string
    sprintId?: StringFilter<"Task"> | string
    teamId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    content?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    featureId?: StringNullableFilter<"Task"> | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    sprint?: XOR<SprintScalarRelationFilter, SprintWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    feature?: XOR<FeatureNullableScalarRelationFilter, FeatureWhereInput> | null
    AgentTask?: AgentTaskListRelationFilter
    AgentWorklog?: AgentWorklogListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    status?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featureId?: SortOrderInput | SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    projectId?: StringWithAggregatesFilter<"Task"> | string
    sprintId?: StringWithAggregatesFilter<"Task"> | string
    teamId?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    content?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: StringWithAggregatesFilter<"Task"> | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    featureId?: StringNullableWithAggregatesFilter<"Task"> | string | null
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    projectId?: StringFilter<"Team"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
    agents?: AgentListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    agents?: AgentOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    projectId?: StringFilter<"Team"> | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tasks?: TaskListRelationFilter
    agents?: AgentListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    projectId?: StringWithAggregatesFilter<"Team"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    DomainKnowledge?: DomainKnowledgeListRelationFilter
    DatabaseSchema?: DatabaseSchemaListRelationFilter
    Requirement?: RequirementListRelationFilter
    RequirementAttachment?: RequirementAttachmentListRelationFilter
    Documentation?: DocumentationListRelationFilter
    DocumentVersion?: DocumentVersionListRelationFilter
    DocumentComment?: DocumentCommentListRelationFilter
    DocumentAttachment?: DocumentAttachmentListRelationFilter
    MindMap?: MindMapListRelationFilter
    ArchitectureChangeHistory?: ArchitectureChangeHistoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    projectMembers?: ProjectMemberOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    DomainKnowledge?: DomainKnowledgeOrderByRelationAggregateInput
    DatabaseSchema?: DatabaseSchemaOrderByRelationAggregateInput
    Requirement?: RequirementOrderByRelationAggregateInput
    RequirementAttachment?: RequirementAttachmentOrderByRelationAggregateInput
    Documentation?: DocumentationOrderByRelationAggregateInput
    DocumentVersion?: DocumentVersionOrderByRelationAggregateInput
    DocumentComment?: DocumentCommentOrderByRelationAggregateInput
    DocumentAttachment?: DocumentAttachmentOrderByRelationAggregateInput
    MindMap?: MindMapOrderByRelationAggregateInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    avatar?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
    sessions?: SessionListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    DomainKnowledge?: DomainKnowledgeListRelationFilter
    DatabaseSchema?: DatabaseSchemaListRelationFilter
    Requirement?: RequirementListRelationFilter
    RequirementAttachment?: RequirementAttachmentListRelationFilter
    Documentation?: DocumentationListRelationFilter
    DocumentVersion?: DocumentVersionListRelationFilter
    DocumentComment?: DocumentCommentListRelationFilter
    DocumentAttachment?: DocumentAttachmentListRelationFilter
    MindMap?: MindMapListRelationFilter
    ArchitectureChangeHistory?: ArchitectureChangeHistoryListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    token?: StringWithAggregatesFilter<"Session"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    permissions?: StringNullableListFilter<"ProjectMember">
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_userId?: ProjectMemberProjectIdUserIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    permissions?: StringNullableListFilter<"ProjectMember">
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "projectId_userId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMember"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMember"> | string
    userId?: StringWithAggregatesFilter<"ProjectMember"> | string
    role?: EnumProjectRoleWithAggregatesFilter<"ProjectMember"> | $Enums.ProjectRole
    permissions?: StringNullableListFilter<"ProjectMember">
    joinedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AgentCreateInput = {
    id?: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgentInput
    team: TeamCreateNestedOneWithoutAgentsInput
    AgentActivity?: AgentActivityCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    projectId: string
    teamId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    AgentActivity?: AgentActivityUncheckedCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgentNestedInput
    team?: TeamUpdateOneRequiredWithoutAgentsNestedInput
    AgentActivity?: AgentActivityUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentActivity?: AgentActivityUncheckedUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    projectId: string
    teamId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTaskCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutAgentTaskInput
    task: TaskCreateNestedOneWithoutAgentTaskInput
  }

  export type AgentTaskUncheckedCreateInput = {
    id?: string
    agentId: string
    taskId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutAgentTaskNestedInput
    task?: TaskUpdateOneRequiredWithoutAgentTaskNestedInput
  }

  export type AgentTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTaskCreateManyInput = {
    id?: string
    agentId: string
    taskId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentActivityCreateInput = {
    id?: string
    body: string
    action?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutAgentActivityInput
  }

  export type AgentActivityUncheckedCreateInput = {
    id?: string
    agentId: string
    body: string
    action?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutAgentActivityNestedInput
  }

  export type AgentActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentActivityCreateManyInput = {
    id?: string
    agentId: string
    body: string
    action?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWorklogCreateInput = {
    id?: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgentWorklogInput
    agent: AgentCreateNestedOneWithoutAgentWorklogInput
    task: TaskCreateNestedOneWithoutAgentWorklogInput
  }

  export type AgentWorklogUncheckedCreateInput = {
    id?: string
    projectId: string
    agentId: string
    taskId: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentWorklogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgentWorklogNestedInput
    agent?: AgentUpdateOneRequiredWithoutAgentWorklogNestedInput
    task?: TaskUpdateOneRequiredWithoutAgentWorklogNestedInput
  }

  export type AgentWorklogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWorklogCreateManyInput = {
    id?: string
    projectId: string
    agentId: string
    taskId: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentWorklogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWorklogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentPromptTemplateCreateInput = {
    id?: string
    name: string
    responsibility: string
    prompt: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentPromptTemplateUncheckedCreateInput = {
    id?: string
    name: string
    responsibility: string
    prompt: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentPromptTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentPromptTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentPromptTemplateCreateManyInput = {
    id?: string
    name: string
    responsibility: string
    prompt: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentPromptTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentPromptTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    responsibility?: StringFieldUpdateOperationsInput | string
    prompt?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiDesignCreateInput = {
    id?: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutApiDesignInput
    examples?: ApiExampleCreateNestedManyWithoutApiDesignInput
    errorCodes?: ApiErrorCodeCreateNestedManyWithoutApiDesignInput
  }

  export type ApiDesignUncheckedCreateInput = {
    id?: string
    projectId: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    examples?: ApiExampleUncheckedCreateNestedManyWithoutApiDesignInput
    errorCodes?: ApiErrorCodeUncheckedCreateNestedManyWithoutApiDesignInput
  }

  export type ApiDesignUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutApiDesignNestedInput
    examples?: ApiExampleUpdateManyWithoutApiDesignNestedInput
    errorCodes?: ApiErrorCodeUpdateManyWithoutApiDesignNestedInput
  }

  export type ApiDesignUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examples?: ApiExampleUncheckedUpdateManyWithoutApiDesignNestedInput
    errorCodes?: ApiErrorCodeUncheckedUpdateManyWithoutApiDesignNestedInput
  }

  export type ApiDesignCreateManyInput = {
    id?: string
    projectId: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ApiDesignUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiDesignUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiExampleCreateInput = {
    id?: string
    name: string
    description: string
    requestUrl: string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus: number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    isSuccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    apiDesign: ApiDesignCreateNestedOneWithoutExamplesInput
  }

  export type ApiExampleUncheckedCreateInput = {
    id?: string
    apiDesignId: string
    name: string
    description: string
    requestUrl: string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus: number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    isSuccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiExampleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestUrl?: StringFieldUpdateOperationsInput | string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus?: IntFieldUpdateOperationsInput | number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiDesign?: ApiDesignUpdateOneRequiredWithoutExamplesNestedInput
  }

  export type ApiExampleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiDesignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestUrl?: StringFieldUpdateOperationsInput | string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus?: IntFieldUpdateOperationsInput | number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiExampleCreateManyInput = {
    id?: string
    apiDesignId: string
    name: string
    description: string
    requestUrl: string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus: number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    isSuccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiExampleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestUrl?: StringFieldUpdateOperationsInput | string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus?: IntFieldUpdateOperationsInput | number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiExampleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiDesignId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestUrl?: StringFieldUpdateOperationsInput | string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus?: IntFieldUpdateOperationsInput | number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorCodeCreateInput = {
    id?: string
    code: string
    httpStatus: number
    message: string
    description: string
    solution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiDesign: ApiDesignCreateNestedOneWithoutErrorCodesInput
  }

  export type ApiErrorCodeUncheckedCreateInput = {
    id?: string
    apiDesignId: string
    code: string
    httpStatus: number
    message: string
    description: string
    solution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiErrorCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    httpStatus?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiDesign?: ApiDesignUpdateOneRequiredWithoutErrorCodesNestedInput
  }

  export type ApiErrorCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiDesignId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    httpStatus?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorCodeCreateManyInput = {
    id?: string
    apiDesignId: string
    code: string
    httpStatus: number
    message: string
    description: string
    solution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiErrorCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    httpStatus?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiDesignId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    httpStatus?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemArchitectureCreateInput = {
    id?: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutSystemArchitectureInput
    platformArchitectures?: PlatformArchitectureCreateNestedManyWithoutSystemArchitectureInput
    changeHistories?: ArchitectureChangeHistoryCreateNestedManyWithoutArchitectureInput
    previousVersion?: SystemArchitectureCreateNestedOneWithoutNextVersionsInput
    nextVersions?: SystemArchitectureCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    previousVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedCreateNestedManyWithoutSystemArchitectureInput
    changeHistories?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutArchitectureInput
    nextVersions?: SystemArchitectureUncheckedCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutSystemArchitectureNestedInput
    platformArchitectures?: PlatformArchitectureUpdateManyWithoutSystemArchitectureNestedInput
    changeHistories?: ArchitectureChangeHistoryUpdateManyWithoutArchitectureNestedInput
    previousVersion?: SystemArchitectureUpdateOneWithoutNextVersionsNestedInput
    nextVersions?: SystemArchitectureUpdateManyWithoutPreviousVersionNestedInput
  }

  export type SystemArchitectureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    previousVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedUpdateManyWithoutSystemArchitectureNestedInput
    changeHistories?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutArchitectureNestedInput
    nextVersions?: SystemArchitectureUncheckedUpdateManyWithoutPreviousVersionNestedInput
  }

  export type SystemArchitectureCreateManyInput = {
    id?: string
    projectId: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    previousVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SystemArchitectureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemArchitectureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    previousVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlatformArchitectureCreateInput = {
    id?: string
    platform: string
    displayName: string
    description: string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureCreatetechnologiesInput | string[]
    components?: PlatformArchitectureCreatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: string | null
    scalingStrategy?: string | null
    diagrams?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    systemArchitecture: SystemArchitectureCreateNestedOneWithoutPlatformArchitecturesInput
  }

  export type PlatformArchitectureUncheckedCreateInput = {
    id?: string
    systemArchitectureId: string
    platform: string
    displayName: string
    description: string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureCreatetechnologiesInput | string[]
    components?: PlatformArchitectureCreatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: string | null
    scalingStrategy?: string | null
    diagrams?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformArchitectureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureUpdatetechnologiesInput | string[]
    components?: PlatformArchitectureUpdatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    scalingStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    systemArchitecture?: SystemArchitectureUpdateOneRequiredWithoutPlatformArchitecturesNestedInput
  }

  export type PlatformArchitectureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemArchitectureId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureUpdatetechnologiesInput | string[]
    components?: PlatformArchitectureUpdatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    scalingStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformArchitectureCreateManyInput = {
    id?: string
    systemArchitectureId: string
    platform: string
    displayName: string
    description: string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureCreatetechnologiesInput | string[]
    components?: PlatformArchitectureCreatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: string | null
    scalingStrategy?: string | null
    diagrams?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformArchitectureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureUpdatetechnologiesInput | string[]
    components?: PlatformArchitectureUpdatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    scalingStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformArchitectureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    systemArchitectureId?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureUpdatetechnologiesInput | string[]
    components?: PlatformArchitectureUpdatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    scalingStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArchitectureChangeHistoryCreateInput = {
    id?: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact?: string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    architecture: SystemArchitectureCreateNestedOneWithoutChangeHistoriesInput
    User?: UserCreateNestedOneWithoutArchitectureChangeHistoryInput
  }

  export type ArchitectureChangeHistoryUncheckedCreateInput = {
    id?: string
    architectureId: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact?: string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    userId?: string | null
  }

  export type ArchitectureChangeHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    architecture?: SystemArchitectureUpdateOneRequiredWithoutChangeHistoriesNestedInput
    User?: UserUpdateOneWithoutArchitectureChangeHistoryNestedInput
  }

  export type ArchitectureChangeHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    architectureId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArchitectureChangeHistoryCreateManyInput = {
    id?: string
    architectureId: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact?: string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    userId?: string | null
  }

  export type ArchitectureChangeHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArchitectureChangeHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    architectureId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DatabaseSchemaCreateInput = {
    id?: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDatabaseSchemaInput
    tables?: DatabaseTableCreateNestedManyWithoutSchemaInput
    User?: UserCreateNestedOneWithoutDatabaseSchemaInput
  }

  export type DatabaseSchemaUncheckedCreateInput = {
    id?: string
    projectId: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    tables?: DatabaseTableUncheckedCreateNestedManyWithoutSchemaInput
  }

  export type DatabaseSchemaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDatabaseSchemaNestedInput
    tables?: DatabaseTableUpdateManyWithoutSchemaNestedInput
    User?: UserUpdateOneWithoutDatabaseSchemaNestedInput
  }

  export type DatabaseSchemaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: DatabaseTableUncheckedUpdateManyWithoutSchemaNestedInput
  }

  export type DatabaseSchemaCreateManyInput = {
    id?: string
    projectId: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type DatabaseSchemaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DatabaseSchemaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DatabaseTableCreateInput = {
    id?: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schema: DatabaseSchemaCreateNestedOneWithoutTablesInput
    columns?: TableColumnCreateNestedManyWithoutTableInput
    indexes?: DatabaseIndexCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationCreateNestedManyWithoutSourceTableInput
    targetRelations?: DatabaseRelationCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableUncheckedCreateInput = {
    id?: string
    schemaId: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    columns?: TableColumnUncheckedCreateNestedManyWithoutTableInput
    indexes?: DatabaseIndexUncheckedCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutSourceTableInput
    targetRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: DatabaseSchemaUpdateOneRequiredWithoutTablesNestedInput
    columns?: TableColumnUpdateManyWithoutTableNestedInput
    indexes?: DatabaseIndexUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUpdateManyWithoutSourceTableNestedInput
    targetRelations?: DatabaseRelationUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columns?: TableColumnUncheckedUpdateManyWithoutTableNestedInput
    indexes?: DatabaseIndexUncheckedUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUncheckedUpdateManyWithoutSourceTableNestedInput
    targetRelations?: DatabaseRelationUncheckedUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableCreateManyInput = {
    id?: string
    schemaId: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseTableUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseTableUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableColumnCreateInput = {
    id?: string
    columnName: string
    displayName: string
    columnType: $Enums.ColumnType
    length?: number | null
    precision?: number | null
    scale?: number | null
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: string | null
    comment?: string | null
    enumValues?: TableColumnCreateenumValuesInput | string[]
    isForeignKey?: boolean
    referencedTable?: string | null
    referencedColumn?: string | null
    onDelete?: string | null
    onUpdate?: string | null
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
    table: DatabaseTableCreateNestedOneWithoutColumnsInput
  }

  export type TableColumnUncheckedCreateInput = {
    id?: string
    tableId: string
    columnName: string
    displayName: string
    columnType: $Enums.ColumnType
    length?: number | null
    precision?: number | null
    scale?: number | null
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: string | null
    comment?: string | null
    enumValues?: TableColumnCreateenumValuesInput | string[]
    isForeignKey?: boolean
    referencedTable?: string | null
    referencedColumn?: string | null
    onDelete?: string | null
    onUpdate?: string | null
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableColumnUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    columnType?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    precision?: NullableIntFieldUpdateOperationsInput | number | null
    scale?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryKey?: BoolFieldUpdateOperationsInput | boolean
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    isAutoIncrement?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    enumValues?: TableColumnUpdateenumValuesInput | string[]
    isForeignKey?: BoolFieldUpdateOperationsInput | boolean
    referencedTable?: NullableStringFieldUpdateOperationsInput | string | null
    referencedColumn?: NullableStringFieldUpdateOperationsInput | string | null
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    table?: DatabaseTableUpdateOneRequiredWithoutColumnsNestedInput
  }

  export type TableColumnUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    columnType?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    precision?: NullableIntFieldUpdateOperationsInput | number | null
    scale?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryKey?: BoolFieldUpdateOperationsInput | boolean
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    isAutoIncrement?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    enumValues?: TableColumnUpdateenumValuesInput | string[]
    isForeignKey?: BoolFieldUpdateOperationsInput | boolean
    referencedTable?: NullableStringFieldUpdateOperationsInput | string | null
    referencedColumn?: NullableStringFieldUpdateOperationsInput | string | null
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableColumnCreateManyInput = {
    id?: string
    tableId: string
    columnName: string
    displayName: string
    columnType: $Enums.ColumnType
    length?: number | null
    precision?: number | null
    scale?: number | null
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: string | null
    comment?: string | null
    enumValues?: TableColumnCreateenumValuesInput | string[]
    isForeignKey?: boolean
    referencedTable?: string | null
    referencedColumn?: string | null
    onDelete?: string | null
    onUpdate?: string | null
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableColumnUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    columnType?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    precision?: NullableIntFieldUpdateOperationsInput | number | null
    scale?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryKey?: BoolFieldUpdateOperationsInput | boolean
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    isAutoIncrement?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    enumValues?: TableColumnUpdateenumValuesInput | string[]
    isForeignKey?: BoolFieldUpdateOperationsInput | boolean
    referencedTable?: NullableStringFieldUpdateOperationsInput | string | null
    referencedColumn?: NullableStringFieldUpdateOperationsInput | string | null
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableColumnUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    columnType?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    precision?: NullableIntFieldUpdateOperationsInput | number | null
    scale?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryKey?: BoolFieldUpdateOperationsInput | boolean
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    isAutoIncrement?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    enumValues?: TableColumnUpdateenumValuesInput | string[]
    isForeignKey?: BoolFieldUpdateOperationsInput | boolean
    referencedTable?: NullableStringFieldUpdateOperationsInput | string | null
    referencedColumn?: NullableStringFieldUpdateOperationsInput | string | null
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseIndexCreateInput = {
    id?: string
    indexName: string
    indexType: $Enums.IndexType
    columns?: DatabaseIndexCreatecolumnsInput | string[]
    isUnique?: boolean
    comment?: string | null
    algorithm?: string | null
    lockOption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    table: DatabaseTableCreateNestedOneWithoutIndexesInput
  }

  export type DatabaseIndexUncheckedCreateInput = {
    id?: string
    tableId: string
    indexName: string
    indexType: $Enums.IndexType
    columns?: DatabaseIndexCreatecolumnsInput | string[]
    isUnique?: boolean
    comment?: string | null
    algorithm?: string | null
    lockOption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseIndexUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexName?: StringFieldUpdateOperationsInput | string
    indexType?: EnumIndexTypeFieldUpdateOperationsInput | $Enums.IndexType
    columns?: DatabaseIndexUpdatecolumnsInput | string[]
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    algorithm?: NullableStringFieldUpdateOperationsInput | string | null
    lockOption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    table?: DatabaseTableUpdateOneRequiredWithoutIndexesNestedInput
  }

  export type DatabaseIndexUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    indexName?: StringFieldUpdateOperationsInput | string
    indexType?: EnumIndexTypeFieldUpdateOperationsInput | $Enums.IndexType
    columns?: DatabaseIndexUpdatecolumnsInput | string[]
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    algorithm?: NullableStringFieldUpdateOperationsInput | string | null
    lockOption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseIndexCreateManyInput = {
    id?: string
    tableId: string
    indexName: string
    indexType: $Enums.IndexType
    columns?: DatabaseIndexCreatecolumnsInput | string[]
    isUnique?: boolean
    comment?: string | null
    algorithm?: string | null
    lockOption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseIndexUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexName?: StringFieldUpdateOperationsInput | string
    indexType?: EnumIndexTypeFieldUpdateOperationsInput | $Enums.IndexType
    columns?: DatabaseIndexUpdatecolumnsInput | string[]
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    algorithm?: NullableStringFieldUpdateOperationsInput | string | null
    lockOption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseIndexUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    indexName?: StringFieldUpdateOperationsInput | string
    indexType?: EnumIndexTypeFieldUpdateOperationsInput | $Enums.IndexType
    columns?: DatabaseIndexUpdatecolumnsInput | string[]
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    algorithm?: NullableStringFieldUpdateOperationsInput | string | null
    lockOption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseRelationCreateInput = {
    id?: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceColumns?: DatabaseRelationCreatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationCreatetargetColumnsInput | string[]
    onDelete?: string | null
    onUpdate?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceTable: DatabaseTableCreateNestedOneWithoutSourceRelationsInput
    targetTable: DatabaseTableCreateNestedOneWithoutTargetRelationsInput
  }

  export type DatabaseRelationUncheckedCreateInput = {
    id?: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceTableId: string
    sourceColumns?: DatabaseRelationCreatesourceColumnsInput | string[]
    targetTableId: string
    targetColumns?: DatabaseRelationCreatetargetColumnsInput | string[]
    onDelete?: string | null
    onUpdate?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceTable?: DatabaseTableUpdateOneRequiredWithoutSourceRelationsNestedInput
    targetTable?: DatabaseTableUpdateOneRequiredWithoutTargetRelationsNestedInput
  }

  export type DatabaseRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceTableId?: StringFieldUpdateOperationsInput | string
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetTableId?: StringFieldUpdateOperationsInput | string
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseRelationCreateManyInput = {
    id?: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceTableId: string
    sourceColumns?: DatabaseRelationCreatesourceColumnsInput | string[]
    targetTableId: string
    targetColumns?: DatabaseRelationCreatetargetColumnsInput | string[]
    onDelete?: string | null
    onUpdate?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceTableId?: StringFieldUpdateOperationsInput | string
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetTableId?: StringFieldUpdateOperationsInput | string
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentationCreateInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDocumentationInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentationInput
    User?: UserCreateNestedOneWithoutDocumentationInput
  }

  export type DocumentationUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    userId?: string | null
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentationInput
  }

  export type DocumentationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDocumentationNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentationNestedInput
    User?: UserUpdateOneWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentationNestedInput
  }

  export type DocumentationCreateManyInput = {
    id?: string
    projectId: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type DocumentationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentVersionCreateInput = {
    id?: string
    version: string
    content: string
    changeLog: string
    createdAt?: Date | string
    documentation: DocumentationCreateNestedOneWithoutVersionsInput
    User?: UserCreateNestedOneWithoutDocumentVersionInput
  }

  export type DocumentVersionUncheckedCreateInput = {
    id?: string
    documentationId: string
    version: string
    content: string
    changeLog: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type DocumentVersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentation?: DocumentationUpdateOneRequiredWithoutVersionsNestedInput
    User?: UserUpdateOneWithoutDocumentVersionNestedInput
  }

  export type DocumentVersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentVersionCreateManyInput = {
    id?: string
    documentationId: string
    version: string
    content: string
    changeLog: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type DocumentVersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentTagCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentations?: DocumentationCreateNestedManyWithoutTagsInput
  }

  export type DocumentTagUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documentations?: DocumentationUncheckedCreateNestedManyWithoutTagsInput
  }

  export type DocumentTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentations?: DocumentationUpdateManyWithoutTagsNestedInput
  }

  export type DocumentTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentations?: DocumentationUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type DocumentTagCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentation: DocumentationCreateNestedOneWithoutCommentsInput
    parent?: DocumentCommentCreateNestedOneWithoutRepliesInput
    replies?: DocumentCommentCreateNestedManyWithoutParentInput
    User?: UserCreateNestedOneWithoutDocumentCommentInput
  }

  export type DocumentCommentUncheckedCreateInput = {
    id?: string
    documentationId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    replies?: DocumentCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DocumentCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentation?: DocumentationUpdateOneRequiredWithoutCommentsNestedInput
    parent?: DocumentCommentUpdateOneWithoutRepliesNestedInput
    replies?: DocumentCommentUpdateManyWithoutParentNestedInput
    User?: UserUpdateOneWithoutDocumentCommentNestedInput
  }

  export type DocumentCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: DocumentCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DocumentCommentCreateManyInput = {
    id?: string
    documentationId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type DocumentCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentAttachmentCreateInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    documentation: DocumentationCreateNestedOneWithoutAttachmentsInput
    User?: UserCreateNestedOneWithoutDocumentAttachmentInput
  }

  export type DocumentAttachmentUncheckedCreateInput = {
    id?: string
    documentationId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type DocumentAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentation?: DocumentationUpdateOneRequiredWithoutAttachmentsNestedInput
    User?: UserUpdateOneWithoutDocumentAttachmentNestedInput
  }

  export type DocumentAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentAttachmentCreateManyInput = {
    id?: string
    documentationId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type DocumentAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MindMapCreateInput = {
    id?: string
    title: string
    description?: string | null
    overview: string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutMindMapInput
    rootNode?: MindMapNodeCreateNestedOneWithoutRootOfMapInput
    nodes?: MindMapNodeCreateNestedManyWithoutMindMapInput
    User?: UserCreateNestedOneWithoutMindMapInput
  }

  export type MindMapUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    overview: string
    nodeId?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    nodes?: MindMapNodeUncheckedCreateNestedManyWithoutMindMapInput
  }

  export type MindMapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutMindMapNestedInput
    rootNode?: MindMapNodeUpdateOneWithoutRootOfMapNestedInput
    nodes?: MindMapNodeUpdateManyWithoutMindMapNestedInput
    User?: UserUpdateOneWithoutMindMapNestedInput
  }

  export type MindMapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: MindMapNodeUncheckedUpdateManyWithoutMindMapNestedInput
  }

  export type MindMapCreateManyInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    overview: string
    nodeId?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type MindMapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MindMapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MindMapNodeCreateInput = {
    id?: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mindMap: MindMapCreateNestedOneWithoutNodesInput
    rootOfMap?: MindMapCreateNestedOneWithoutRootNodeInput
    parent?: MindMapNodeCreateNestedOneWithoutChildrenInput
    children?: MindMapNodeCreateNestedManyWithoutParentInput
  }

  export type MindMapNodeUncheckedCreateInput = {
    id?: string
    mindMapId: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    parentId?: string | null
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootOfMap?: MindMapUncheckedCreateNestedOneWithoutRootNodeInput
    children?: MindMapNodeUncheckedCreateNestedManyWithoutParentInput
  }

  export type MindMapNodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mindMap?: MindMapUpdateOneRequiredWithoutNodesNestedInput
    rootOfMap?: MindMapUpdateOneWithoutRootNodeNestedInput
    parent?: MindMapNodeUpdateOneWithoutChildrenNestedInput
    children?: MindMapNodeUpdateManyWithoutParentNestedInput
  }

  export type MindMapNodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mindMapId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootOfMap?: MindMapUncheckedUpdateOneWithoutRootNodeNestedInput
    children?: MindMapNodeUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MindMapNodeCreateManyInput = {
    id?: string
    mindMapId: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    parentId?: string | null
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MindMapNodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MindMapNodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mindMapId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainKnowledgeCreateInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDomainKnowledgeInput
    concepts?: DomainConceptCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceCreateNestedManyWithoutDomainKnowledgeInput
    User?: UserCreateNestedOneWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeUncheckedCreateInput = {
    id?: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    concepts?: DomainConceptUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceUncheckedCreateNestedManyWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDomainKnowledgeNestedInput
    concepts?: DomainConceptUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUpdateManyWithoutDomainKnowledgeNestedInput
    User?: UserUpdateOneWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    concepts?: DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeCreateManyInput = {
    id?: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type DomainKnowledgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DomainKnowledgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DomainConceptCreateInput = {
    id?: string
    name: string
    definition: string
    examples?: DomainConceptCreateexamplesInput | string[]
    relatedConcepts?: DomainConceptCreaterelatedConceptsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    domainKnowledge: DomainKnowledgeCreateNestedOneWithoutConceptsInput
  }

  export type DomainConceptUncheckedCreateInput = {
    id?: string
    domainKnowledgeId: string
    name: string
    definition: string
    examples?: DomainConceptCreateexamplesInput | string[]
    relatedConcepts?: DomainConceptCreaterelatedConceptsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainConceptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    examples?: DomainConceptUpdateexamplesInput | string[]
    relatedConcepts?: DomainConceptUpdaterelatedConceptsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainKnowledge?: DomainKnowledgeUpdateOneRequiredWithoutConceptsNestedInput
  }

  export type DomainConceptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    examples?: DomainConceptUpdateexamplesInput | string[]
    relatedConcepts?: DomainConceptUpdaterelatedConceptsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainConceptCreateManyInput = {
    id?: string
    domainKnowledgeId: string
    name: string
    definition: string
    examples?: DomainConceptCreateexamplesInput | string[]
    relatedConcepts?: DomainConceptCreaterelatedConceptsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainConceptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    examples?: DomainConceptUpdateexamplesInput | string[]
    relatedConcepts?: DomainConceptUpdaterelatedConceptsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainConceptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    examples?: DomainConceptUpdateexamplesInput | string[]
    relatedConcepts?: DomainConceptUpdaterelatedConceptsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainPatternCreateInput = {
    id?: string
    name: string
    description: string
    context: string
    solution: string
    consequences: string
    examples?: DomainPatternCreateexamplesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    domainKnowledge: DomainKnowledgeCreateNestedOneWithoutPatternsInput
  }

  export type DomainPatternUncheckedCreateInput = {
    id?: string
    domainKnowledgeId: string
    name: string
    description: string
    context: string
    solution: string
    consequences: string
    examples?: DomainPatternCreateexamplesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    examples?: DomainPatternUpdateexamplesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainKnowledge?: DomainKnowledgeUpdateOneRequiredWithoutPatternsNestedInput
  }

  export type DomainPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    examples?: DomainPatternUpdateexamplesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainPatternCreateManyInput = {
    id?: string
    domainKnowledgeId: string
    name: string
    description: string
    context: string
    solution: string
    consequences: string
    examples?: DomainPatternCreateexamplesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    examples?: DomainPatternUpdateexamplesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    examples?: DomainPatternUpdateexamplesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainBestPracticeCreateInput = {
    id?: string
    title: string
    description: string
    rationale: string
    implementation: string
    benefits?: DomainBestPracticeCreatebenefitsInput | string[]
    considerations?: DomainBestPracticeCreateconsiderationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    domainKnowledge: DomainKnowledgeCreateNestedOneWithoutBestPracticesInput
  }

  export type DomainBestPracticeUncheckedCreateInput = {
    id?: string
    domainKnowledgeId: string
    title: string
    description: string
    rationale: string
    implementation: string
    benefits?: DomainBestPracticeCreatebenefitsInput | string[]
    considerations?: DomainBestPracticeCreateconsiderationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainBestPracticeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    implementation?: StringFieldUpdateOperationsInput | string
    benefits?: DomainBestPracticeUpdatebenefitsInput | string[]
    considerations?: DomainBestPracticeUpdateconsiderationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainKnowledge?: DomainKnowledgeUpdateOneRequiredWithoutBestPracticesNestedInput
  }

  export type DomainBestPracticeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    implementation?: StringFieldUpdateOperationsInput | string
    benefits?: DomainBestPracticeUpdatebenefitsInput | string[]
    considerations?: DomainBestPracticeUpdateconsiderationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainBestPracticeCreateManyInput = {
    id?: string
    domainKnowledgeId: string
    title: string
    description: string
    rationale: string
    implementation: string
    benefits?: DomainBestPracticeCreatebenefitsInput | string[]
    considerations?: DomainBestPracticeCreateconsiderationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainBestPracticeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    implementation?: StringFieldUpdateOperationsInput | string
    benefits?: DomainBestPracticeUpdatebenefitsInput | string[]
    considerations?: DomainBestPracticeUpdateconsiderationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainBestPracticeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    implementation?: StringFieldUpdateOperationsInput | string
    benefits?: DomainBestPracticeUpdatebenefitsInput | string[]
    considerations?: DomainBestPracticeUpdateconsiderationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainAntiPatternCreateInput = {
    id?: string
    name: string
    description: string
    symptoms?: DomainAntiPatternCreatesymptomsInput | string[]
    causes?: DomainAntiPatternCreatecausesInput | string[]
    consequences?: DomainAntiPatternCreateconsequencesInput | string[]
    refactoring: string
    createdAt?: Date | string
    updatedAt?: Date | string
    domainKnowledge: DomainKnowledgeCreateNestedOneWithoutAntiPatternsInput
  }

  export type DomainAntiPatternUncheckedCreateInput = {
    id?: string
    domainKnowledgeId: string
    name: string
    description: string
    symptoms?: DomainAntiPatternCreatesymptomsInput | string[]
    causes?: DomainAntiPatternCreatecausesInput | string[]
    consequences?: DomainAntiPatternCreateconsequencesInput | string[]
    refactoring: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainAntiPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    symptoms?: DomainAntiPatternUpdatesymptomsInput | string[]
    causes?: DomainAntiPatternUpdatecausesInput | string[]
    consequences?: DomainAntiPatternUpdateconsequencesInput | string[]
    refactoring?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainKnowledge?: DomainKnowledgeUpdateOneRequiredWithoutAntiPatternsNestedInput
  }

  export type DomainAntiPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    symptoms?: DomainAntiPatternUpdatesymptomsInput | string[]
    causes?: DomainAntiPatternUpdatecausesInput | string[]
    consequences?: DomainAntiPatternUpdateconsequencesInput | string[]
    refactoring?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainAntiPatternCreateManyInput = {
    id?: string
    domainKnowledgeId: string
    name: string
    description: string
    symptoms?: DomainAntiPatternCreatesymptomsInput | string[]
    causes?: DomainAntiPatternCreatecausesInput | string[]
    consequences?: DomainAntiPatternCreateconsequencesInput | string[]
    refactoring: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainAntiPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    symptoms?: DomainAntiPatternUpdatesymptomsInput | string[]
    causes?: DomainAntiPatternUpdatecausesInput | string[]
    consequences?: DomainAntiPatternUpdateconsequencesInput | string[]
    refactoring?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainAntiPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    symptoms?: DomainAntiPatternUpdatesymptomsInput | string[]
    causes?: DomainAntiPatternUpdatecausesInput | string[]
    consequences?: DomainAntiPatternUpdateconsequencesInput | string[]
    refactoring?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainReferenceCreateInput = {
    id?: string
    title: string
    type: string
    url?: string | null
    author?: string | null
    publishDate?: Date | string | null
    summary?: string | null
    createdAt?: Date | string
    domainKnowledge: DomainKnowledgeCreateNestedOneWithoutReferencesInput
  }

  export type DomainReferenceUncheckedCreateInput = {
    id?: string
    domainKnowledgeId: string
    title: string
    type: string
    url?: string | null
    author?: string | null
    publishDate?: Date | string | null
    summary?: string | null
    createdAt?: Date | string
  }

  export type DomainReferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    domainKnowledge?: DomainKnowledgeUpdateOneRequiredWithoutReferencesNestedInput
  }

  export type DomainReferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainReferenceCreateManyInput = {
    id?: string
    domainKnowledgeId: string
    title: string
    type: string
    url?: string | null
    author?: string | null
    publishDate?: Date | string | null
    summary?: string | null
    createdAt?: Date | string
  }

  export type DomainReferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainReferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    domainKnowledgeId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequirementCreateInput = {
    id?: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutRequirementInput
    parent?: RequirementCreateNestedOneWithoutChildrenInput
    children?: RequirementCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentCreateNestedManyWithoutRequirementInput
    User?: UserCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateInput = {
    id?: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    children?: RequirementUncheckedCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionUncheckedCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutRequirementNestedInput
    parent?: RequirementUpdateOneWithoutChildrenNestedInput
    children?: RequirementUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUpdateManyWithoutRequirementNestedInput
    User?: UserUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RequirementUncheckedUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUncheckedUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementCreateManyInput = {
    id?: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type RequirementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequirementQuestionCreateInput = {
    id?: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutRequirementQuestionInput
    requirement: RequirementCreateNestedOneWithoutQuestionsInput
    agent: AgentCreateNestedOneWithoutRequirementQuestionInput
  }

  export type RequirementQuestionUncheckedCreateInput = {
    id?: string
    projectId: string
    requirementId: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
  }

  export type RequirementQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutRequirementQuestionNestedInput
    requirement?: RequirementUpdateOneRequiredWithoutQuestionsNestedInput
    agent?: AgentUpdateOneRequiredWithoutRequirementQuestionNestedInput
  }

  export type RequirementQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementQuestionCreateManyInput = {
    id?: string
    projectId: string
    requirementId: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
  }

  export type RequirementQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementAttachmentCreateInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutRequirementAttachmentInput
    requirement: RequirementCreateNestedOneWithoutAttachmentsInput
    User?: UserCreateNestedOneWithoutRequirementAttachmentInput
  }

  export type RequirementAttachmentUncheckedCreateInput = {
    id?: string
    projectId: string
    requirementId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type RequirementAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutRequirementAttachmentNestedInput
    requirement?: RequirementUpdateOneRequiredWithoutAttachmentsNestedInput
    User?: UserUpdateOneWithoutRequirementAttachmentNestedInput
  }

  export type RequirementAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequirementAttachmentCreateManyInput = {
    id?: string
    projectId: string
    requirementId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type RequirementAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadmapCreateInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutRoadmapsInput
    milestones?: MilestoneCreateNestedManyWithoutRoadmapInput
    versions?: VersionCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneUncheckedCreateNestedManyWithoutRoadmapInput
    versions?: VersionUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutRoadmapsNestedInput
    milestones?: MilestoneUpdateManyWithoutRoadmapNestedInput
    versions?: VersionUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUncheckedUpdateManyWithoutRoadmapNestedInput
    versions?: VersionUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapCreateManyInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneCreateInput = {
    id?: string
    name: string
    description?: string | null
    targetDate: Date | string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmap: RoadmapCreateNestedOneWithoutMilestonesInput
    features?: FeatureCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateInput = {
    id?: string
    roadmapId: string
    name: string
    description?: string | null
    targetDate: Date | string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: FeatureUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmap?: RoadmapUpdateOneRequiredWithoutMilestonesNestedInput
    features?: FeatureUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: FeatureUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneCreateManyInput = {
    id?: string
    roadmapId: string
    name: string
    description?: string | null
    targetDate: Date | string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MilestoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VersionCreateInput = {
    id?: string
    name: string
    description?: string | null
    releaseDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmap: RoadmapCreateNestedOneWithoutVersionsInput
    features?: FeatureCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateInput = {
    id?: string
    roadmapId: string
    name: string
    description?: string | null
    releaseDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: FeatureUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmap?: RoadmapUpdateOneRequiredWithoutVersionsNestedInput
    features?: FeatureUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: FeatureUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type VersionCreateManyInput = {
    id?: string
    roadmapId: string
    name: string
    description?: string | null
    releaseDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VersionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VersionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    milestone?: MilestoneCreateNestedOneWithoutFeaturesInput
    version?: VersionCreateNestedOneWithoutFeaturesInput
    tasks?: TaskCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateInput = {
    id?: string
    milestoneId?: string | null
    versionId?: string | null
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestone?: MilestoneUpdateOneWithoutFeaturesNestedInput
    version?: VersionUpdateOneWithoutFeaturesNestedInput
    tasks?: TaskUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureCreateManyInput = {
    id?: string
    milestoneId?: string | null
    versionId?: string | null
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintCreateInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    goal: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintInput
    Task?: TaskCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    goal: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Task?: TaskUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintNestedInput
    Task?: TaskUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Task?: TaskUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type SprintCreateManyInput = {
    id?: string
    projectId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    goal: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SprintUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SprintUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    sprint: SprintCreateNestedOneWithoutTaskInput
    team: TeamCreateNestedOneWithoutTasksInput
    feature?: FeatureCreateNestedOneWithoutTasksInput
    AgentTask?: AgentTaskCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    projectId: string
    sprintId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    sprint?: SprintUpdateOneRequiredWithoutTaskNestedInput
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    feature?: FeatureUpdateOneWithoutTasksNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    projectId: string
    sprintId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
    agents?: AgentCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    agents?: AgentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    agents?: AgentUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    agents?: AgentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateInput = {
    id?: string
    role?: $Enums.ProjectRole
    permissions?: ProjectMemberCreatepermissionsInput | string[]
    joinedAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: string
    projectId: string
    userId: string
    role?: $Enums.ProjectRole
    permissions?: ProjectMemberCreatepermissionsInput | string[]
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyInput = {
    id?: string
    projectId: string
    userId: string
    role?: $Enums.ProjectRole
    permissions?: ProjectMemberCreatepermissionsInput | string[]
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type AgentActivityListRelationFilter = {
    every?: AgentActivityWhereInput
    some?: AgentActivityWhereInput
    none?: AgentActivityWhereInput
  }

  export type AgentTaskListRelationFilter = {
    every?: AgentTaskWhereInput
    some?: AgentTaskWhereInput
    none?: AgentTaskWhereInput
  }

  export type AgentWorklogListRelationFilter = {
    every?: AgentWorklogWhereInput
    some?: AgentWorklogWhereInput
    none?: AgentWorklogWhereInput
  }

  export type RequirementQuestionListRelationFilter = {
    every?: RequirementQuestionWhereInput
    some?: RequirementQuestionWhereInput
    none?: RequirementQuestionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AgentActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentWorklogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequirementQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    workPrompt?: SortOrder
    responsibilities?: SortOrder
    skills?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    workPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    workPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type AgentTaskCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentTaskMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AgentActivityCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    body?: SortOrder
    action?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    body?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentActivityMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    body?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AgentWorklogCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    workType?: SortOrder
    summarize?: SortOrder
    nextPlan?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentWorklogMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    workType?: SortOrder
    summarize?: SortOrder
    nextPlan?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentWorklogMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    agentId?: SortOrder
    taskId?: SortOrder
    workType?: SortOrder
    summarize?: SortOrder
    nextPlan?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AgentPromptTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    responsibility?: SortOrder
    prompt?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentPromptTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    responsibility?: SortOrder
    prompt?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentPromptTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    responsibility?: SortOrder
    prompt?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumApiMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiMethod | EnumApiMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ApiMethod[] | ListEnumApiMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiMethod[] | ListEnumApiMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumApiMethodFilter<$PrismaModel> | $Enums.ApiMethod
  }

  export type EnumApiContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiContentType | EnumApiContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiContentType[] | ListEnumApiContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiContentType[] | ListEnumApiContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiContentTypeFilter<$PrismaModel> | $Enums.ApiContentType
  }

  export type EnumApiAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiAuthType | EnumApiAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiAuthType[] | ListEnumApiAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiAuthType[] | ListEnumApiAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiAuthTypeFilter<$PrismaModel> | $Enums.ApiAuthType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumApiStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiStatus | EnumApiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiStatusFilter<$PrismaModel> | $Enums.ApiStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ApiExampleListRelationFilter = {
    every?: ApiExampleWhereInput
    some?: ApiExampleWhereInput
    none?: ApiExampleWhereInput
  }

  export type ApiErrorCodeListRelationFilter = {
    every?: ApiErrorCodeWhereInput
    some?: ApiErrorCodeWhereInput
    none?: ApiErrorCodeWhereInput
  }

  export type ApiExampleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiErrorCodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiDesignApiPathApiMethodApiVersionCompoundUniqueInput = {
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion: string
  }

  export type ApiDesignCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    apiName?: SortOrder
    apiPath?: SortOrder
    apiMethod?: SortOrder
    apiVersion?: SortOrder
    platform?: SortOrder
    module?: SortOrder
    apiDescription?: SortOrder
    businessLogic?: SortOrder
    apiContentType?: SortOrder
    requestHeaders?: SortOrder
    requestParams?: SortOrder
    requestBody?: SortOrder
    responseHeaders?: SortOrder
    responseBody?: SortOrder
    authentication?: SortOrder
    authDetails?: SortOrder
    permissions?: SortOrder
    rateLimit?: SortOrder
    timeout?: SortOrder
    maxPayloadSize?: SortOrder
    status?: SortOrder
    deprecated?: SortOrder
    deprecationDate?: SortOrder
    sunsetDate?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ApiDesignAvgOrderByAggregateInput = {
    rateLimit?: SortOrder
    timeout?: SortOrder
    maxPayloadSize?: SortOrder
    version?: SortOrder
  }

  export type ApiDesignMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    apiName?: SortOrder
    apiPath?: SortOrder
    apiMethod?: SortOrder
    apiVersion?: SortOrder
    platform?: SortOrder
    module?: SortOrder
    apiDescription?: SortOrder
    businessLogic?: SortOrder
    apiContentType?: SortOrder
    authentication?: SortOrder
    rateLimit?: SortOrder
    timeout?: SortOrder
    maxPayloadSize?: SortOrder
    status?: SortOrder
    deprecated?: SortOrder
    deprecationDate?: SortOrder
    sunsetDate?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ApiDesignMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    apiName?: SortOrder
    apiPath?: SortOrder
    apiMethod?: SortOrder
    apiVersion?: SortOrder
    platform?: SortOrder
    module?: SortOrder
    apiDescription?: SortOrder
    businessLogic?: SortOrder
    apiContentType?: SortOrder
    authentication?: SortOrder
    rateLimit?: SortOrder
    timeout?: SortOrder
    maxPayloadSize?: SortOrder
    status?: SortOrder
    deprecated?: SortOrder
    deprecationDate?: SortOrder
    sunsetDate?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ApiDesignSumOrderByAggregateInput = {
    rateLimit?: SortOrder
    timeout?: SortOrder
    maxPayloadSize?: SortOrder
    version?: SortOrder
  }

  export type EnumApiMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiMethod | EnumApiMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ApiMethod[] | ListEnumApiMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiMethod[] | ListEnumApiMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumApiMethodWithAggregatesFilter<$PrismaModel> | $Enums.ApiMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiMethodFilter<$PrismaModel>
    _max?: NestedEnumApiMethodFilter<$PrismaModel>
  }

  export type EnumApiContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiContentType | EnumApiContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiContentType[] | ListEnumApiContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiContentType[] | ListEnumApiContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApiContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiContentTypeFilter<$PrismaModel>
    _max?: NestedEnumApiContentTypeFilter<$PrismaModel>
  }

  export type EnumApiAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiAuthType | EnumApiAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiAuthType[] | ListEnumApiAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiAuthType[] | ListEnumApiAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApiAuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumApiAuthTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumApiStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiStatus | EnumApiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApiStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiStatusFilter<$PrismaModel>
    _max?: NestedEnumApiStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ApiDesignScalarRelationFilter = {
    is?: ApiDesignWhereInput
    isNot?: ApiDesignWhereInput
  }

  export type ApiExampleCountOrderByAggregateInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requestUrl?: SortOrder
    requestHeaders?: SortOrder
    requestParams?: SortOrder
    requestBody?: SortOrder
    responseStatus?: SortOrder
    responseHeaders?: SortOrder
    responseBody?: SortOrder
    notes?: SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiExampleAvgOrderByAggregateInput = {
    responseStatus?: SortOrder
  }

  export type ApiExampleMaxOrderByAggregateInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requestUrl?: SortOrder
    responseStatus?: SortOrder
    notes?: SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiExampleMinOrderByAggregateInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    requestUrl?: SortOrder
    responseStatus?: SortOrder
    notes?: SortOrder
    isSuccess?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiExampleSumOrderByAggregateInput = {
    responseStatus?: SortOrder
  }

  export type ApiErrorCodeApiDesignIdCodeCompoundUniqueInput = {
    apiDesignId: string
    code: string
  }

  export type ApiErrorCodeCountOrderByAggregateInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    code?: SortOrder
    httpStatus?: SortOrder
    message?: SortOrder
    description?: SortOrder
    solution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiErrorCodeAvgOrderByAggregateInput = {
    httpStatus?: SortOrder
  }

  export type ApiErrorCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    code?: SortOrder
    httpStatus?: SortOrder
    message?: SortOrder
    description?: SortOrder
    solution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiErrorCodeMinOrderByAggregateInput = {
    id?: SortOrder
    apiDesignId?: SortOrder
    code?: SortOrder
    httpStatus?: SortOrder
    message?: SortOrder
    description?: SortOrder
    solution?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiErrorCodeSumOrderByAggregateInput = {
    httpStatus?: SortOrder
  }

  export type EnumArchitectureStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArchitectureStatus | EnumArchitectureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArchitectureStatus[] | ListEnumArchitectureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArchitectureStatus[] | ListEnumArchitectureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArchitectureStatusFilter<$PrismaModel> | $Enums.ArchitectureStatus
  }

  export type PlatformArchitectureListRelationFilter = {
    every?: PlatformArchitectureWhereInput
    some?: PlatformArchitectureWhereInput
    none?: PlatformArchitectureWhereInput
  }

  export type ArchitectureChangeHistoryListRelationFilter = {
    every?: ArchitectureChangeHistoryWhereInput
    some?: ArchitectureChangeHistoryWhereInput
    none?: ArchitectureChangeHistoryWhereInput
  }

  export type SystemArchitectureNullableScalarRelationFilter = {
    is?: SystemArchitectureWhereInput | null
    isNot?: SystemArchitectureWhereInput | null
  }

  export type SystemArchitectureListRelationFilter = {
    every?: SystemArchitectureWhereInput
    some?: SystemArchitectureWhereInput
    none?: SystemArchitectureWhereInput
  }

  export type PlatformArchitectureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArchitectureChangeHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemArchitectureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemArchitectureCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    version?: SortOrder
    status?: SortOrder
    platforms?: SortOrder
    components?: SortOrder
    technologies?: SortOrder
    diagrams?: SortOrder
    notes?: SortOrder
    versionNumber?: SortOrder
    previousVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SystemArchitectureAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type SystemArchitectureMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    version?: SortOrder
    status?: SortOrder
    diagrams?: SortOrder
    notes?: SortOrder
    versionNumber?: SortOrder
    previousVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SystemArchitectureMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    version?: SortOrder
    status?: SortOrder
    diagrams?: SortOrder
    notes?: SortOrder
    versionNumber?: SortOrder
    previousVersionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SystemArchitectureSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type EnumArchitectureStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArchitectureStatus | EnumArchitectureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArchitectureStatus[] | ListEnumArchitectureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArchitectureStatus[] | ListEnumArchitectureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArchitectureStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArchitectureStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArchitectureStatusFilter<$PrismaModel>
    _max?: NestedEnumArchitectureStatusFilter<$PrismaModel>
  }

  export type SystemArchitectureScalarRelationFilter = {
    is?: SystemArchitectureWhereInput
    isNot?: SystemArchitectureWhereInput
  }

  export type PlatformArchitectureCountOrderByAggregateInput = {
    id?: SortOrder
    systemArchitectureId?: SortOrder
    platform?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    frontend?: SortOrder
    backend?: SortOrder
    infrastructure?: SortOrder
    technologies?: SortOrder
    components?: SortOrder
    dependencies?: SortOrder
    deploymentStrategy?: SortOrder
    scalingStrategy?: SortOrder
    diagrams?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformArchitectureMaxOrderByAggregateInput = {
    id?: SortOrder
    systemArchitectureId?: SortOrder
    platform?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    deploymentStrategy?: SortOrder
    scalingStrategy?: SortOrder
    diagrams?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformArchitectureMinOrderByAggregateInput = {
    id?: SortOrder
    systemArchitectureId?: SortOrder
    platform?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    deploymentStrategy?: SortOrder
    scalingStrategy?: SortOrder
    diagrams?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ArchitectureChangeHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    architectureId?: SortOrder
    changeType?: SortOrder
    changeDescription?: SortOrder
    changeReason?: SortOrder
    impact?: SortOrder
    beforeChange?: SortOrder
    afterChange?: SortOrder
    changedAt?: SortOrder
    userId?: SortOrder
  }

  export type ArchitectureChangeHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    architectureId?: SortOrder
    changeType?: SortOrder
    changeDescription?: SortOrder
    changeReason?: SortOrder
    impact?: SortOrder
    changedAt?: SortOrder
    userId?: SortOrder
  }

  export type ArchitectureChangeHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    architectureId?: SortOrder
    changeType?: SortOrder
    changeDescription?: SortOrder
    changeReason?: SortOrder
    impact?: SortOrder
    changedAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumDatabaseEngineFilter<$PrismaModel = never> = {
    equals?: $Enums.DatabaseEngine | EnumDatabaseEngineFieldRefInput<$PrismaModel>
    in?: $Enums.DatabaseEngine[] | ListEnumDatabaseEngineFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatabaseEngine[] | ListEnumDatabaseEngineFieldRefInput<$PrismaModel>
    not?: NestedEnumDatabaseEngineFilter<$PrismaModel> | $Enums.DatabaseEngine
  }

  export type DatabaseTableListRelationFilter = {
    every?: DatabaseTableWhereInput
    some?: DatabaseTableWhereInput
    none?: DatabaseTableWhereInput
  }

  export type DatabaseTableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatabaseSchemaProjectIdSchemaNameCompoundUniqueInput = {
    projectId: string
    schemaName: string
  }

  export type DatabaseSchemaCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    schemaName?: SortOrder
    engine?: SortOrder
    charset?: SortOrder
    collation?: SortOrder
    description?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type DatabaseSchemaAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type DatabaseSchemaMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    schemaName?: SortOrder
    engine?: SortOrder
    charset?: SortOrder
    collation?: SortOrder
    description?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type DatabaseSchemaMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    schemaName?: SortOrder
    engine?: SortOrder
    charset?: SortOrder
    collation?: SortOrder
    description?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type DatabaseSchemaSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumDatabaseEngineWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatabaseEngine | EnumDatabaseEngineFieldRefInput<$PrismaModel>
    in?: $Enums.DatabaseEngine[] | ListEnumDatabaseEngineFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatabaseEngine[] | ListEnumDatabaseEngineFieldRefInput<$PrismaModel>
    not?: NestedEnumDatabaseEngineWithAggregatesFilter<$PrismaModel> | $Enums.DatabaseEngine
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatabaseEngineFilter<$PrismaModel>
    _max?: NestedEnumDatabaseEngineFilter<$PrismaModel>
  }

  export type DatabaseSchemaScalarRelationFilter = {
    is?: DatabaseSchemaWhereInput
    isNot?: DatabaseSchemaWhereInput
  }

  export type TableColumnListRelationFilter = {
    every?: TableColumnWhereInput
    some?: TableColumnWhereInput
    none?: TableColumnWhereInput
  }

  export type DatabaseIndexListRelationFilter = {
    every?: DatabaseIndexWhereInput
    some?: DatabaseIndexWhereInput
    none?: DatabaseIndexWhereInput
  }

  export type DatabaseRelationListRelationFilter = {
    every?: DatabaseRelationWhereInput
    some?: DatabaseRelationWhereInput
    none?: DatabaseRelationWhereInput
  }

  export type TableColumnOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatabaseIndexOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatabaseRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatabaseTableSchemaIdTableNameCompoundUniqueInput = {
    schemaId: string
    tableName: string
  }

  export type DatabaseTableCountOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    tableName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    engine?: SortOrder
    charset?: SortOrder
    collation?: SortOrder
    autoIncrement?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatabaseTableAvgOrderByAggregateInput = {
    autoIncrement?: SortOrder
  }

  export type DatabaseTableMaxOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    tableName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    engine?: SortOrder
    charset?: SortOrder
    collation?: SortOrder
    autoIncrement?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatabaseTableMinOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    tableName?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    engine?: SortOrder
    charset?: SortOrder
    collation?: SortOrder
    autoIncrement?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatabaseTableSumOrderByAggregateInput = {
    autoIncrement?: SortOrder
  }

  export type EnumColumnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ColumnType | EnumColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumColumnTypeFilter<$PrismaModel> | $Enums.ColumnType
  }

  export type DatabaseTableScalarRelationFilter = {
    is?: DatabaseTableWhereInput
    isNot?: DatabaseTableWhereInput
  }

  export type TableColumnTableIdColumnNameCompoundUniqueInput = {
    tableId: string
    columnName: string
  }

  export type TableColumnCountOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    columnName?: SortOrder
    displayName?: SortOrder
    columnType?: SortOrder
    length?: SortOrder
    precision?: SortOrder
    scale?: SortOrder
    isPrimaryKey?: SortOrder
    isNullable?: SortOrder
    isUnique?: SortOrder
    isAutoIncrement?: SortOrder
    defaultValue?: SortOrder
    comment?: SortOrder
    enumValues?: SortOrder
    isForeignKey?: SortOrder
    referencedTable?: SortOrder
    referencedColumn?: SortOrder
    onDelete?: SortOrder
    onUpdate?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableColumnAvgOrderByAggregateInput = {
    length?: SortOrder
    precision?: SortOrder
    scale?: SortOrder
    position?: SortOrder
  }

  export type TableColumnMaxOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    columnName?: SortOrder
    displayName?: SortOrder
    columnType?: SortOrder
    length?: SortOrder
    precision?: SortOrder
    scale?: SortOrder
    isPrimaryKey?: SortOrder
    isNullable?: SortOrder
    isUnique?: SortOrder
    isAutoIncrement?: SortOrder
    defaultValue?: SortOrder
    comment?: SortOrder
    isForeignKey?: SortOrder
    referencedTable?: SortOrder
    referencedColumn?: SortOrder
    onDelete?: SortOrder
    onUpdate?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableColumnMinOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    columnName?: SortOrder
    displayName?: SortOrder
    columnType?: SortOrder
    length?: SortOrder
    precision?: SortOrder
    scale?: SortOrder
    isPrimaryKey?: SortOrder
    isNullable?: SortOrder
    isUnique?: SortOrder
    isAutoIncrement?: SortOrder
    defaultValue?: SortOrder
    comment?: SortOrder
    isForeignKey?: SortOrder
    referencedTable?: SortOrder
    referencedColumn?: SortOrder
    onDelete?: SortOrder
    onUpdate?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TableColumnSumOrderByAggregateInput = {
    length?: SortOrder
    precision?: SortOrder
    scale?: SortOrder
    position?: SortOrder
  }

  export type EnumColumnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ColumnType | EnumColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumColumnTypeWithAggregatesFilter<$PrismaModel> | $Enums.ColumnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumColumnTypeFilter<$PrismaModel>
    _max?: NestedEnumColumnTypeFilter<$PrismaModel>
  }

  export type EnumIndexTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IndexType | EnumIndexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndexType[] | ListEnumIndexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndexType[] | ListEnumIndexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndexTypeFilter<$PrismaModel> | $Enums.IndexType
  }

  export type DatabaseIndexTableIdIndexNameCompoundUniqueInput = {
    tableId: string
    indexName: string
  }

  export type DatabaseIndexCountOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    indexName?: SortOrder
    indexType?: SortOrder
    columns?: SortOrder
    isUnique?: SortOrder
    comment?: SortOrder
    algorithm?: SortOrder
    lockOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatabaseIndexMaxOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    indexName?: SortOrder
    indexType?: SortOrder
    isUnique?: SortOrder
    comment?: SortOrder
    algorithm?: SortOrder
    lockOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatabaseIndexMinOrderByAggregateInput = {
    id?: SortOrder
    tableId?: SortOrder
    indexName?: SortOrder
    indexType?: SortOrder
    isUnique?: SortOrder
    comment?: SortOrder
    algorithm?: SortOrder
    lockOption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumIndexTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndexType | EnumIndexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndexType[] | ListEnumIndexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndexType[] | ListEnumIndexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndexTypeWithAggregatesFilter<$PrismaModel> | $Enums.IndexType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndexTypeFilter<$PrismaModel>
    _max?: NestedEnumIndexTypeFilter<$PrismaModel>
  }

  export type EnumRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeFilter<$PrismaModel> | $Enums.RelationType
  }

  export type DatabaseRelationCountOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    relationName?: SortOrder
    relationType?: SortOrder
    sourceTableId?: SortOrder
    sourceColumns?: SortOrder
    targetTableId?: SortOrder
    targetColumns?: SortOrder
    onDelete?: SortOrder
    onUpdate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatabaseRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    relationName?: SortOrder
    relationType?: SortOrder
    sourceTableId?: SortOrder
    targetTableId?: SortOrder
    onDelete?: SortOrder
    onUpdate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DatabaseRelationMinOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    relationName?: SortOrder
    relationType?: SortOrder
    sourceTableId?: SortOrder
    targetTableId?: SortOrder
    onDelete?: SortOrder
    onUpdate?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationTypeFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type EnumDocumentVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVisibility | EnumDocumentVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVisibility[] | ListEnumDocumentVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVisibility[] | ListEnumDocumentVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVisibilityFilter<$PrismaModel> | $Enums.DocumentVisibility
  }

  export type DocumentTagListRelationFilter = {
    every?: DocumentTagWhereInput
    some?: DocumentTagWhereInput
    none?: DocumentTagWhereInput
  }

  export type DocumentVersionListRelationFilter = {
    every?: DocumentVersionWhereInput
    some?: DocumentVersionWhereInput
    none?: DocumentVersionWhereInput
  }

  export type DocumentCommentListRelationFilter = {
    every?: DocumentCommentWhereInput
    some?: DocumentCommentWhereInput
    none?: DocumentCommentWhereInput
  }

  export type DocumentAttachmentListRelationFilter = {
    every?: DocumentAttachmentWhereInput
    some?: DocumentAttachmentWhereInput
    none?: DocumentAttachmentWhereInput
  }

  export type DocumentTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentVersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentationCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    url?: SortOrder
    version?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentationAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type DocumentationMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    url?: SortOrder
    version?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentationMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    status?: SortOrder
    visibility?: SortOrder
    category?: SortOrder
    url?: SortOrder
    version?: SortOrder
    versionNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentationSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type EnumDocumentVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVisibility | EnumDocumentVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVisibility[] | ListEnumDocumentVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVisibility[] | ListEnumDocumentVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.DocumentVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentVisibilityFilter<$PrismaModel>
    _max?: NestedEnumDocumentVisibilityFilter<$PrismaModel>
  }

  export type DocumentationScalarRelationFilter = {
    is?: DocumentationWhereInput
    isNot?: DocumentationWhereInput
  }

  export type DocumentVersionCountOrderByAggregateInput = {
    id?: SortOrder
    documentationId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    changeLog?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentVersionMaxOrderByAggregateInput = {
    id?: SortOrder
    documentationId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    changeLog?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentVersionMinOrderByAggregateInput = {
    id?: SortOrder
    documentationId?: SortOrder
    version?: SortOrder
    content?: SortOrder
    changeLog?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentationListRelationFilter = {
    every?: DocumentationWhereInput
    some?: DocumentationWhereInput
    none?: DocumentationWhereInput
  }

  export type DocumentationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentCommentNullableScalarRelationFilter = {
    is?: DocumentCommentWhereInput | null
    isNot?: DocumentCommentWhereInput | null
  }

  export type DocumentCommentCountOrderByAggregateInput = {
    id?: SortOrder
    documentationId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    documentationId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentCommentMinOrderByAggregateInput = {
    id?: SortOrder
    documentationId?: SortOrder
    content?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    documentationId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    documentationId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    documentationId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type DocumentAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MindMapNodeNullableScalarRelationFilter = {
    is?: MindMapNodeWhereInput | null
    isNot?: MindMapNodeWhereInput | null
  }

  export type MindMapNodeListRelationFilter = {
    every?: MindMapNodeWhereInput
    some?: MindMapNodeWhereInput
    none?: MindMapNodeWhereInput
  }

  export type MindMapNodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MindMapCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    overview?: SortOrder
    nodeId?: SortOrder
    theme?: SortOrder
    layout?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type MindMapAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type MindMapMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    overview?: SortOrder
    nodeId?: SortOrder
    layout?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type MindMapMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    overview?: SortOrder
    nodeId?: SortOrder
    layout?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type MindMapSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeFilter<$PrismaModel> | $Enums.NodeType
  }

  export type MindMapScalarRelationFilter = {
    is?: MindMapWhereInput
    isNot?: MindMapWhereInput
  }

  export type MindMapNullableScalarRelationFilter = {
    is?: MindMapWhereInput | null
    isNot?: MindMapWhereInput | null
  }

  export type MindMapNodeCountOrderByAggregateInput = {
    id?: SortOrder
    mindMapId?: SortOrder
    content?: SortOrder
    note?: SortOrder
    nodeType?: SortOrder
    parentId?: SortOrder
    position?: SortOrder
    expanded?: SortOrder
    style?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MindMapNodeAvgOrderByAggregateInput = {
    position?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
  }

  export type MindMapNodeMaxOrderByAggregateInput = {
    id?: SortOrder
    mindMapId?: SortOrder
    content?: SortOrder
    note?: SortOrder
    nodeType?: SortOrder
    parentId?: SortOrder
    position?: SortOrder
    expanded?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MindMapNodeMinOrderByAggregateInput = {
    id?: SortOrder
    mindMapId?: SortOrder
    content?: SortOrder
    note?: SortOrder
    nodeType?: SortOrder
    parentId?: SortOrder
    position?: SortOrder
    expanded?: SortOrder
    link?: SortOrder
    icon?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MindMapNodeSumOrderByAggregateInput = {
    position?: SortOrder
    priority?: SortOrder
    progress?: SortOrder
  }

  export type EnumNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.NodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumNodeTypeFilter<$PrismaModel>
  }

  export type EnumKnowledgeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeCategory | EnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeCategory[] | ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeCategory[] | ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeCategoryFilter<$PrismaModel> | $Enums.KnowledgeCategory
  }

  export type DomainConceptListRelationFilter = {
    every?: DomainConceptWhereInput
    some?: DomainConceptWhereInput
    none?: DomainConceptWhereInput
  }

  export type DomainPatternListRelationFilter = {
    every?: DomainPatternWhereInput
    some?: DomainPatternWhereInput
    none?: DomainPatternWhereInput
  }

  export type DomainBestPracticeListRelationFilter = {
    every?: DomainBestPracticeWhereInput
    some?: DomainBestPracticeWhereInput
    none?: DomainBestPracticeWhereInput
  }

  export type DomainAntiPatternListRelationFilter = {
    every?: DomainAntiPatternWhereInput
    some?: DomainAntiPatternWhereInput
    none?: DomainAntiPatternWhereInput
  }

  export type DomainReferenceListRelationFilter = {
    every?: DomainReferenceWhereInput
    some?: DomainReferenceWhereInput
    none?: DomainReferenceWhereInput
  }

  export type DomainConceptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainPatternOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainBestPracticeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainAntiPatternOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainKnowledgeCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    domain?: SortOrder
    description?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type DomainKnowledgeAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type DomainKnowledgeMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    domain?: SortOrder
    description?: SortOrder
    category?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type DomainKnowledgeMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    domain?: SortOrder
    description?: SortOrder
    category?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type DomainKnowledgeSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumKnowledgeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeCategory | EnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeCategory[] | ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeCategory[] | ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeCategoryFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeCategoryFilter<$PrismaModel>
  }

  export type DomainKnowledgeScalarRelationFilter = {
    is?: DomainKnowledgeWhereInput
    isNot?: DomainKnowledgeWhereInput
  }

  export type DomainConceptCountOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    examples?: SortOrder
    relatedConcepts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainConceptMaxOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainConceptMinOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    definition?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainPatternCountOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    context?: SortOrder
    solution?: SortOrder
    consequences?: SortOrder
    examples?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    context?: SortOrder
    solution?: SortOrder
    consequences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainPatternMinOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    context?: SortOrder
    solution?: SortOrder
    consequences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainBestPracticeCountOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    implementation?: SortOrder
    benefits?: SortOrder
    considerations?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainBestPracticeMaxOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    implementation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainBestPracticeMinOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    rationale?: SortOrder
    implementation?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainAntiPatternCountOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    symptoms?: SortOrder
    causes?: SortOrder
    consequences?: SortOrder
    refactoring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainAntiPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    refactoring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainAntiPatternMinOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    refactoring?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DomainReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    url?: SortOrder
    author?: SortOrder
    publishDate?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type DomainReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    url?: SortOrder
    author?: SortOrder
    publishDate?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type DomainReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    domainKnowledgeId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    url?: SortOrder
    author?: SortOrder
    publishDate?: SortOrder
    summary?: SortOrder
    createdAt?: SortOrder
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type MindMapListRelationFilter = {
    every?: MindMapWhereInput
    some?: MindMapWhereInput
    none?: MindMapWhereInput
  }

  export type SprintListRelationFilter = {
    every?: SprintWhereInput
    some?: SprintWhereInput
    none?: SprintWhereInput
  }

  export type RequirementListRelationFilter = {
    every?: RequirementWhereInput
    some?: RequirementWhereInput
    none?: RequirementWhereInput
  }

  export type DomainKnowledgeListRelationFilter = {
    every?: DomainKnowledgeWhereInput
    some?: DomainKnowledgeWhereInput
    none?: DomainKnowledgeWhereInput
  }

  export type RoadmapListRelationFilter = {
    every?: RoadmapWhereInput
    some?: RoadmapWhereInput
    none?: RoadmapWhereInput
  }

  export type ApiDesignListRelationFilter = {
    every?: ApiDesignWhereInput
    some?: ApiDesignWhereInput
    none?: ApiDesignWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type DatabaseSchemaListRelationFilter = {
    every?: DatabaseSchemaWhereInput
    some?: DatabaseSchemaWhereInput
    none?: DatabaseSchemaWhereInput
  }

  export type RequirementAttachmentListRelationFilter = {
    every?: RequirementAttachmentWhereInput
    some?: RequirementAttachmentWhereInput
    none?: RequirementAttachmentWhereInput
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MindMapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SprintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequirementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DomainKnowledgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiDesignOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DatabaseSchemaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequirementAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: SortOrder
  }

  export type EnumRequirementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementType | EnumRequirementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementType[] | ListEnumRequirementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementType[] | ListEnumRequirementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementTypeFilter<$PrismaModel> | $Enums.RequirementType
  }

  export type EnumRequirementPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementPriority | EnumRequirementPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementPriority[] | ListEnumRequirementPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementPriority[] | ListEnumRequirementPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementPriorityFilter<$PrismaModel> | $Enums.RequirementPriority
  }

  export type EnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }

  export type EnumRequirementSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementSource | EnumRequirementSourceFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementSource[] | ListEnumRequirementSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementSource[] | ListEnumRequirementSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementSourceFilter<$PrismaModel> | $Enums.RequirementSource
  }

  export type RequirementNullableScalarRelationFilter = {
    is?: RequirementWhereInput | null
    isNot?: RequirementWhereInput | null
  }

  export type RequirementCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    source?: SortOrder
    parentId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type RequirementAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type RequirementMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    source?: SortOrder
    parentId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type RequirementMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    source?: SortOrder
    parentId?: SortOrder
    version?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    userId?: SortOrder
  }

  export type RequirementSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type EnumRequirementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementType | EnumRequirementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementType[] | ListEnumRequirementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementType[] | ListEnumRequirementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementTypeWithAggregatesFilter<$PrismaModel> | $Enums.RequirementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementTypeFilter<$PrismaModel>
    _max?: NestedEnumRequirementTypeFilter<$PrismaModel>
  }

  export type EnumRequirementPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementPriority | EnumRequirementPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementPriority[] | ListEnumRequirementPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementPriority[] | ListEnumRequirementPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementPriorityWithAggregatesFilter<$PrismaModel> | $Enums.RequirementPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementPriorityFilter<$PrismaModel>
    _max?: NestedEnumRequirementPriorityFilter<$PrismaModel>
  }

  export type EnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type EnumRequirementSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementSource | EnumRequirementSourceFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementSource[] | ListEnumRequirementSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementSource[] | ListEnumRequirementSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementSourceWithAggregatesFilter<$PrismaModel> | $Enums.RequirementSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementSourceFilter<$PrismaModel>
    _max?: NestedEnumRequirementSourceFilter<$PrismaModel>
  }

  export type EnumQuestionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusFilter<$PrismaModel> | $Enums.QuestionStatus
  }

  export type EnumQuestionPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionPriority | EnumQuestionPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionPriority[] | ListEnumQuestionPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionPriority[] | ListEnumQuestionPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionPriorityFilter<$PrismaModel> | $Enums.QuestionPriority
  }

  export type RequirementScalarRelationFilter = {
    is?: RequirementWhereInput
    isNot?: RequirementWhereInput
  }

  export type RequirementQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    clarified?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answeredAt?: SortOrder
  }

  export type RequirementQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    clarified?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answeredAt?: SortOrder
  }

  export type RequirementQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    clarified?: SortOrder
    agentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    answeredAt?: SortOrder
  }

  export type EnumQuestionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionStatusFilter<$PrismaModel>
  }

  export type EnumQuestionPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionPriority | EnumQuestionPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionPriority[] | ListEnumQuestionPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionPriority[] | ListEnumQuestionPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionPriorityWithAggregatesFilter<$PrismaModel> | $Enums.QuestionPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionPriorityFilter<$PrismaModel>
    _max?: NestedEnumQuestionPriorityFilter<$PrismaModel>
  }

  export type RequirementAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type RequirementAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type RequirementAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type RequirementAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    requirementId?: SortOrder
    fileName?: SortOrder
    fileUrl?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type RequirementAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MilestoneListRelationFilter = {
    every?: MilestoneWhereInput
    some?: MilestoneWhereInput
    none?: MilestoneWhereInput
  }

  export type VersionListRelationFilter = {
    every?: VersionWhereInput
    some?: VersionWhereInput
    none?: VersionWhereInput
  }

  export type MilestoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VersionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapScalarRelationFilter = {
    is?: RoadmapWhereInput
    isNot?: RoadmapWhereInput
  }

  export type FeatureListRelationFilter = {
    every?: FeatureWhereInput
    some?: FeatureWhereInput
    none?: FeatureWhereInput
  }

  export type FeatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MilestoneCountOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneMaxOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneMinOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionCountOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    releaseDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionMaxOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    releaseDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VersionMinOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    releaseDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MilestoneNullableScalarRelationFilter = {
    is?: MilestoneWhereInput | null
    isNot?: MilestoneWhereInput | null
  }

  export type VersionNullableScalarRelationFilter = {
    is?: VersionWhereInput | null
    isNot?: VersionWhereInput | null
  }

  export type FeatureCountOrderByAggregateInput = {
    id?: SortOrder
    milestoneId?: SortOrder
    versionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    effort?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureMaxOrderByAggregateInput = {
    id?: SortOrder
    milestoneId?: SortOrder
    versionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    effort?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeatureMinOrderByAggregateInput = {
    id?: SortOrder
    milestoneId?: SortOrder
    versionId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    effort?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    goal?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    goal?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    goal?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SprintScalarRelationFilter = {
    is?: SprintWhereInput
    isNot?: SprintWhereInput
  }

  export type FeatureNullableScalarRelationFilter = {
    is?: FeatureWhereInput | null
    isNot?: FeatureWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featureId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featureId?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    sprintId?: SortOrder
    teamId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    status?: SortOrder
    dueDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    featureId?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type ProjectMemberProjectIdUserIdCompoundUniqueInput = {
    projectId: string
    userId: string
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AgentCreateresponsibilitiesInput = {
    set: string[]
  }

  export type AgentCreateskillsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutAgentInput = {
    create?: XOR<ProjectCreateWithoutAgentInput, ProjectUncheckedCreateWithoutAgentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAgentInput
    connect?: ProjectWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutAgentsInput = {
    create?: XOR<TeamCreateWithoutAgentsInput, TeamUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAgentsInput
    connect?: TeamWhereUniqueInput
  }

  export type AgentActivityCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentActivityCreateWithoutAgentInput, AgentActivityUncheckedCreateWithoutAgentInput> | AgentActivityCreateWithoutAgentInput[] | AgentActivityUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentActivityCreateOrConnectWithoutAgentInput | AgentActivityCreateOrConnectWithoutAgentInput[]
    createMany?: AgentActivityCreateManyAgentInputEnvelope
    connect?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
  }

  export type AgentTaskCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentTaskCreateWithoutAgentInput, AgentTaskUncheckedCreateWithoutAgentInput> | AgentTaskCreateWithoutAgentInput[] | AgentTaskUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutAgentInput | AgentTaskCreateOrConnectWithoutAgentInput[]
    createMany?: AgentTaskCreateManyAgentInputEnvelope
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
  }

  export type AgentWorklogCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentWorklogCreateWithoutAgentInput, AgentWorklogUncheckedCreateWithoutAgentInput> | AgentWorklogCreateWithoutAgentInput[] | AgentWorklogUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutAgentInput | AgentWorklogCreateOrConnectWithoutAgentInput[]
    createMany?: AgentWorklogCreateManyAgentInputEnvelope
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
  }

  export type RequirementQuestionCreateNestedManyWithoutAgentInput = {
    create?: XOR<RequirementQuestionCreateWithoutAgentInput, RequirementQuestionUncheckedCreateWithoutAgentInput> | RequirementQuestionCreateWithoutAgentInput[] | RequirementQuestionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutAgentInput | RequirementQuestionCreateOrConnectWithoutAgentInput[]
    createMany?: RequirementQuestionCreateManyAgentInputEnvelope
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
  }

  export type AgentActivityUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentActivityCreateWithoutAgentInput, AgentActivityUncheckedCreateWithoutAgentInput> | AgentActivityCreateWithoutAgentInput[] | AgentActivityUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentActivityCreateOrConnectWithoutAgentInput | AgentActivityCreateOrConnectWithoutAgentInput[]
    createMany?: AgentActivityCreateManyAgentInputEnvelope
    connect?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
  }

  export type AgentTaskUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentTaskCreateWithoutAgentInput, AgentTaskUncheckedCreateWithoutAgentInput> | AgentTaskCreateWithoutAgentInput[] | AgentTaskUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutAgentInput | AgentTaskCreateOrConnectWithoutAgentInput[]
    createMany?: AgentTaskCreateManyAgentInputEnvelope
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
  }

  export type AgentWorklogUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<AgentWorklogCreateWithoutAgentInput, AgentWorklogUncheckedCreateWithoutAgentInput> | AgentWorklogCreateWithoutAgentInput[] | AgentWorklogUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutAgentInput | AgentWorklogCreateOrConnectWithoutAgentInput[]
    createMany?: AgentWorklogCreateManyAgentInputEnvelope
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
  }

  export type RequirementQuestionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<RequirementQuestionCreateWithoutAgentInput, RequirementQuestionUncheckedCreateWithoutAgentInput> | RequirementQuestionCreateWithoutAgentInput[] | RequirementQuestionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutAgentInput | RequirementQuestionCreateOrConnectWithoutAgentInput[]
    createMany?: RequirementQuestionCreateManyAgentInputEnvelope
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type AgentUpdateresponsibilitiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type AgentUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectUpdateOneRequiredWithoutAgentNestedInput = {
    create?: XOR<ProjectCreateWithoutAgentInput, ProjectUncheckedCreateWithoutAgentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAgentInput
    upsert?: ProjectUpsertWithoutAgentInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAgentInput, ProjectUpdateWithoutAgentInput>, ProjectUncheckedUpdateWithoutAgentInput>
  }

  export type TeamUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<TeamCreateWithoutAgentsInput, TeamUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutAgentsInput
    upsert?: TeamUpsertWithoutAgentsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutAgentsInput, TeamUpdateWithoutAgentsInput>, TeamUncheckedUpdateWithoutAgentsInput>
  }

  export type AgentActivityUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentActivityCreateWithoutAgentInput, AgentActivityUncheckedCreateWithoutAgentInput> | AgentActivityCreateWithoutAgentInput[] | AgentActivityUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentActivityCreateOrConnectWithoutAgentInput | AgentActivityCreateOrConnectWithoutAgentInput[]
    upsert?: AgentActivityUpsertWithWhereUniqueWithoutAgentInput | AgentActivityUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentActivityCreateManyAgentInputEnvelope
    set?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
    disconnect?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
    delete?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
    connect?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
    update?: AgentActivityUpdateWithWhereUniqueWithoutAgentInput | AgentActivityUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentActivityUpdateManyWithWhereWithoutAgentInput | AgentActivityUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentActivityScalarWhereInput | AgentActivityScalarWhereInput[]
  }

  export type AgentTaskUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentTaskCreateWithoutAgentInput, AgentTaskUncheckedCreateWithoutAgentInput> | AgentTaskCreateWithoutAgentInput[] | AgentTaskUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutAgentInput | AgentTaskCreateOrConnectWithoutAgentInput[]
    upsert?: AgentTaskUpsertWithWhereUniqueWithoutAgentInput | AgentTaskUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentTaskCreateManyAgentInputEnvelope
    set?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    disconnect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    delete?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    update?: AgentTaskUpdateWithWhereUniqueWithoutAgentInput | AgentTaskUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentTaskUpdateManyWithWhereWithoutAgentInput | AgentTaskUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
  }

  export type AgentWorklogUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentWorklogCreateWithoutAgentInput, AgentWorklogUncheckedCreateWithoutAgentInput> | AgentWorklogCreateWithoutAgentInput[] | AgentWorklogUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutAgentInput | AgentWorklogCreateOrConnectWithoutAgentInput[]
    upsert?: AgentWorklogUpsertWithWhereUniqueWithoutAgentInput | AgentWorklogUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentWorklogCreateManyAgentInputEnvelope
    set?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    disconnect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    delete?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    update?: AgentWorklogUpdateWithWhereUniqueWithoutAgentInput | AgentWorklogUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentWorklogUpdateManyWithWhereWithoutAgentInput | AgentWorklogUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentWorklogScalarWhereInput | AgentWorklogScalarWhereInput[]
  }

  export type RequirementQuestionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<RequirementQuestionCreateWithoutAgentInput, RequirementQuestionUncheckedCreateWithoutAgentInput> | RequirementQuestionCreateWithoutAgentInput[] | RequirementQuestionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutAgentInput | RequirementQuestionCreateOrConnectWithoutAgentInput[]
    upsert?: RequirementQuestionUpsertWithWhereUniqueWithoutAgentInput | RequirementQuestionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: RequirementQuestionCreateManyAgentInputEnvelope
    set?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    disconnect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    delete?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    update?: RequirementQuestionUpdateWithWhereUniqueWithoutAgentInput | RequirementQuestionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: RequirementQuestionUpdateManyWithWhereWithoutAgentInput | RequirementQuestionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: RequirementQuestionScalarWhereInput | RequirementQuestionScalarWhereInput[]
  }

  export type AgentActivityUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentActivityCreateWithoutAgentInput, AgentActivityUncheckedCreateWithoutAgentInput> | AgentActivityCreateWithoutAgentInput[] | AgentActivityUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentActivityCreateOrConnectWithoutAgentInput | AgentActivityCreateOrConnectWithoutAgentInput[]
    upsert?: AgentActivityUpsertWithWhereUniqueWithoutAgentInput | AgentActivityUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentActivityCreateManyAgentInputEnvelope
    set?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
    disconnect?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
    delete?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
    connect?: AgentActivityWhereUniqueInput | AgentActivityWhereUniqueInput[]
    update?: AgentActivityUpdateWithWhereUniqueWithoutAgentInput | AgentActivityUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentActivityUpdateManyWithWhereWithoutAgentInput | AgentActivityUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentActivityScalarWhereInput | AgentActivityScalarWhereInput[]
  }

  export type AgentTaskUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentTaskCreateWithoutAgentInput, AgentTaskUncheckedCreateWithoutAgentInput> | AgentTaskCreateWithoutAgentInput[] | AgentTaskUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutAgentInput | AgentTaskCreateOrConnectWithoutAgentInput[]
    upsert?: AgentTaskUpsertWithWhereUniqueWithoutAgentInput | AgentTaskUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentTaskCreateManyAgentInputEnvelope
    set?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    disconnect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    delete?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    update?: AgentTaskUpdateWithWhereUniqueWithoutAgentInput | AgentTaskUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentTaskUpdateManyWithWhereWithoutAgentInput | AgentTaskUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
  }

  export type AgentWorklogUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<AgentWorklogCreateWithoutAgentInput, AgentWorklogUncheckedCreateWithoutAgentInput> | AgentWorklogCreateWithoutAgentInput[] | AgentWorklogUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutAgentInput | AgentWorklogCreateOrConnectWithoutAgentInput[]
    upsert?: AgentWorklogUpsertWithWhereUniqueWithoutAgentInput | AgentWorklogUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: AgentWorklogCreateManyAgentInputEnvelope
    set?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    disconnect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    delete?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    update?: AgentWorklogUpdateWithWhereUniqueWithoutAgentInput | AgentWorklogUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: AgentWorklogUpdateManyWithWhereWithoutAgentInput | AgentWorklogUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: AgentWorklogScalarWhereInput | AgentWorklogScalarWhereInput[]
  }

  export type RequirementQuestionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<RequirementQuestionCreateWithoutAgentInput, RequirementQuestionUncheckedCreateWithoutAgentInput> | RequirementQuestionCreateWithoutAgentInput[] | RequirementQuestionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutAgentInput | RequirementQuestionCreateOrConnectWithoutAgentInput[]
    upsert?: RequirementQuestionUpsertWithWhereUniqueWithoutAgentInput | RequirementQuestionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: RequirementQuestionCreateManyAgentInputEnvelope
    set?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    disconnect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    delete?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    update?: RequirementQuestionUpdateWithWhereUniqueWithoutAgentInput | RequirementQuestionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: RequirementQuestionUpdateManyWithWhereWithoutAgentInput | RequirementQuestionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: RequirementQuestionScalarWhereInput | RequirementQuestionScalarWhereInput[]
  }

  export type AgentCreateNestedOneWithoutAgentTaskInput = {
    create?: XOR<AgentCreateWithoutAgentTaskInput, AgentUncheckedCreateWithoutAgentTaskInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAgentTaskInput
    connect?: AgentWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutAgentTaskInput = {
    create?: XOR<TaskCreateWithoutAgentTaskInput, TaskUncheckedCreateWithoutAgentTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAgentTaskInput
    connect?: TaskWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutAgentTaskNestedInput = {
    create?: XOR<AgentCreateWithoutAgentTaskInput, AgentUncheckedCreateWithoutAgentTaskInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAgentTaskInput
    upsert?: AgentUpsertWithoutAgentTaskInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAgentTaskInput, AgentUpdateWithoutAgentTaskInput>, AgentUncheckedUpdateWithoutAgentTaskInput>
  }

  export type TaskUpdateOneRequiredWithoutAgentTaskNestedInput = {
    create?: XOR<TaskCreateWithoutAgentTaskInput, TaskUncheckedCreateWithoutAgentTaskInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAgentTaskInput
    upsert?: TaskUpsertWithoutAgentTaskInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAgentTaskInput, TaskUpdateWithoutAgentTaskInput>, TaskUncheckedUpdateWithoutAgentTaskInput>
  }

  export type AgentCreateNestedOneWithoutAgentActivityInput = {
    create?: XOR<AgentCreateWithoutAgentActivityInput, AgentUncheckedCreateWithoutAgentActivityInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAgentActivityInput
    connect?: AgentWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutAgentActivityNestedInput = {
    create?: XOR<AgentCreateWithoutAgentActivityInput, AgentUncheckedCreateWithoutAgentActivityInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAgentActivityInput
    upsert?: AgentUpsertWithoutAgentActivityInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAgentActivityInput, AgentUpdateWithoutAgentActivityInput>, AgentUncheckedUpdateWithoutAgentActivityInput>
  }

  export type ProjectCreateNestedOneWithoutAgentWorklogInput = {
    create?: XOR<ProjectCreateWithoutAgentWorklogInput, ProjectUncheckedCreateWithoutAgentWorklogInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAgentWorklogInput
    connect?: ProjectWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutAgentWorklogInput = {
    create?: XOR<AgentCreateWithoutAgentWorklogInput, AgentUncheckedCreateWithoutAgentWorklogInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAgentWorklogInput
    connect?: AgentWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutAgentWorklogInput = {
    create?: XOR<TaskCreateWithoutAgentWorklogInput, TaskUncheckedCreateWithoutAgentWorklogInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAgentWorklogInput
    connect?: TaskWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutAgentWorklogNestedInput = {
    create?: XOR<ProjectCreateWithoutAgentWorklogInput, ProjectUncheckedCreateWithoutAgentWorklogInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAgentWorklogInput
    upsert?: ProjectUpsertWithoutAgentWorklogInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAgentWorklogInput, ProjectUpdateWithoutAgentWorklogInput>, ProjectUncheckedUpdateWithoutAgentWorklogInput>
  }

  export type AgentUpdateOneRequiredWithoutAgentWorklogNestedInput = {
    create?: XOR<AgentCreateWithoutAgentWorklogInput, AgentUncheckedCreateWithoutAgentWorklogInput>
    connectOrCreate?: AgentCreateOrConnectWithoutAgentWorklogInput
    upsert?: AgentUpsertWithoutAgentWorklogInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutAgentWorklogInput, AgentUpdateWithoutAgentWorklogInput>, AgentUncheckedUpdateWithoutAgentWorklogInput>
  }

  export type TaskUpdateOneRequiredWithoutAgentWorklogNestedInput = {
    create?: XOR<TaskCreateWithoutAgentWorklogInput, TaskUncheckedCreateWithoutAgentWorklogInput>
    connectOrCreate?: TaskCreateOrConnectWithoutAgentWorklogInput
    upsert?: TaskUpsertWithoutAgentWorklogInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutAgentWorklogInput, TaskUpdateWithoutAgentWorklogInput>, TaskUncheckedUpdateWithoutAgentWorklogInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ApiDesignCreatepermissionsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutApiDesignInput = {
    create?: XOR<ProjectCreateWithoutApiDesignInput, ProjectUncheckedCreateWithoutApiDesignInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiDesignInput
    connect?: ProjectWhereUniqueInput
  }

  export type ApiExampleCreateNestedManyWithoutApiDesignInput = {
    create?: XOR<ApiExampleCreateWithoutApiDesignInput, ApiExampleUncheckedCreateWithoutApiDesignInput> | ApiExampleCreateWithoutApiDesignInput[] | ApiExampleUncheckedCreateWithoutApiDesignInput[]
    connectOrCreate?: ApiExampleCreateOrConnectWithoutApiDesignInput | ApiExampleCreateOrConnectWithoutApiDesignInput[]
    createMany?: ApiExampleCreateManyApiDesignInputEnvelope
    connect?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
  }

  export type ApiErrorCodeCreateNestedManyWithoutApiDesignInput = {
    create?: XOR<ApiErrorCodeCreateWithoutApiDesignInput, ApiErrorCodeUncheckedCreateWithoutApiDesignInput> | ApiErrorCodeCreateWithoutApiDesignInput[] | ApiErrorCodeUncheckedCreateWithoutApiDesignInput[]
    connectOrCreate?: ApiErrorCodeCreateOrConnectWithoutApiDesignInput | ApiErrorCodeCreateOrConnectWithoutApiDesignInput[]
    createMany?: ApiErrorCodeCreateManyApiDesignInputEnvelope
    connect?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
  }

  export type ApiExampleUncheckedCreateNestedManyWithoutApiDesignInput = {
    create?: XOR<ApiExampleCreateWithoutApiDesignInput, ApiExampleUncheckedCreateWithoutApiDesignInput> | ApiExampleCreateWithoutApiDesignInput[] | ApiExampleUncheckedCreateWithoutApiDesignInput[]
    connectOrCreate?: ApiExampleCreateOrConnectWithoutApiDesignInput | ApiExampleCreateOrConnectWithoutApiDesignInput[]
    createMany?: ApiExampleCreateManyApiDesignInputEnvelope
    connect?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
  }

  export type ApiErrorCodeUncheckedCreateNestedManyWithoutApiDesignInput = {
    create?: XOR<ApiErrorCodeCreateWithoutApiDesignInput, ApiErrorCodeUncheckedCreateWithoutApiDesignInput> | ApiErrorCodeCreateWithoutApiDesignInput[] | ApiErrorCodeUncheckedCreateWithoutApiDesignInput[]
    connectOrCreate?: ApiErrorCodeCreateOrConnectWithoutApiDesignInput | ApiErrorCodeCreateOrConnectWithoutApiDesignInput[]
    createMany?: ApiErrorCodeCreateManyApiDesignInputEnvelope
    connect?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
  }

  export type EnumApiMethodFieldUpdateOperationsInput = {
    set?: $Enums.ApiMethod
  }

  export type EnumApiContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApiContentType
  }

  export type EnumApiAuthTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApiAuthType
  }

  export type ApiDesignUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumApiStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApiStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectUpdateOneRequiredWithoutApiDesignNestedInput = {
    create?: XOR<ProjectCreateWithoutApiDesignInput, ProjectUncheckedCreateWithoutApiDesignInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutApiDesignInput
    upsert?: ProjectUpsertWithoutApiDesignInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutApiDesignInput, ProjectUpdateWithoutApiDesignInput>, ProjectUncheckedUpdateWithoutApiDesignInput>
  }

  export type ApiExampleUpdateManyWithoutApiDesignNestedInput = {
    create?: XOR<ApiExampleCreateWithoutApiDesignInput, ApiExampleUncheckedCreateWithoutApiDesignInput> | ApiExampleCreateWithoutApiDesignInput[] | ApiExampleUncheckedCreateWithoutApiDesignInput[]
    connectOrCreate?: ApiExampleCreateOrConnectWithoutApiDesignInput | ApiExampleCreateOrConnectWithoutApiDesignInput[]
    upsert?: ApiExampleUpsertWithWhereUniqueWithoutApiDesignInput | ApiExampleUpsertWithWhereUniqueWithoutApiDesignInput[]
    createMany?: ApiExampleCreateManyApiDesignInputEnvelope
    set?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
    disconnect?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
    delete?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
    connect?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
    update?: ApiExampleUpdateWithWhereUniqueWithoutApiDesignInput | ApiExampleUpdateWithWhereUniqueWithoutApiDesignInput[]
    updateMany?: ApiExampleUpdateManyWithWhereWithoutApiDesignInput | ApiExampleUpdateManyWithWhereWithoutApiDesignInput[]
    deleteMany?: ApiExampleScalarWhereInput | ApiExampleScalarWhereInput[]
  }

  export type ApiErrorCodeUpdateManyWithoutApiDesignNestedInput = {
    create?: XOR<ApiErrorCodeCreateWithoutApiDesignInput, ApiErrorCodeUncheckedCreateWithoutApiDesignInput> | ApiErrorCodeCreateWithoutApiDesignInput[] | ApiErrorCodeUncheckedCreateWithoutApiDesignInput[]
    connectOrCreate?: ApiErrorCodeCreateOrConnectWithoutApiDesignInput | ApiErrorCodeCreateOrConnectWithoutApiDesignInput[]
    upsert?: ApiErrorCodeUpsertWithWhereUniqueWithoutApiDesignInput | ApiErrorCodeUpsertWithWhereUniqueWithoutApiDesignInput[]
    createMany?: ApiErrorCodeCreateManyApiDesignInputEnvelope
    set?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
    disconnect?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
    delete?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
    connect?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
    update?: ApiErrorCodeUpdateWithWhereUniqueWithoutApiDesignInput | ApiErrorCodeUpdateWithWhereUniqueWithoutApiDesignInput[]
    updateMany?: ApiErrorCodeUpdateManyWithWhereWithoutApiDesignInput | ApiErrorCodeUpdateManyWithWhereWithoutApiDesignInput[]
    deleteMany?: ApiErrorCodeScalarWhereInput | ApiErrorCodeScalarWhereInput[]
  }

  export type ApiExampleUncheckedUpdateManyWithoutApiDesignNestedInput = {
    create?: XOR<ApiExampleCreateWithoutApiDesignInput, ApiExampleUncheckedCreateWithoutApiDesignInput> | ApiExampleCreateWithoutApiDesignInput[] | ApiExampleUncheckedCreateWithoutApiDesignInput[]
    connectOrCreate?: ApiExampleCreateOrConnectWithoutApiDesignInput | ApiExampleCreateOrConnectWithoutApiDesignInput[]
    upsert?: ApiExampleUpsertWithWhereUniqueWithoutApiDesignInput | ApiExampleUpsertWithWhereUniqueWithoutApiDesignInput[]
    createMany?: ApiExampleCreateManyApiDesignInputEnvelope
    set?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
    disconnect?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
    delete?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
    connect?: ApiExampleWhereUniqueInput | ApiExampleWhereUniqueInput[]
    update?: ApiExampleUpdateWithWhereUniqueWithoutApiDesignInput | ApiExampleUpdateWithWhereUniqueWithoutApiDesignInput[]
    updateMany?: ApiExampleUpdateManyWithWhereWithoutApiDesignInput | ApiExampleUpdateManyWithWhereWithoutApiDesignInput[]
    deleteMany?: ApiExampleScalarWhereInput | ApiExampleScalarWhereInput[]
  }

  export type ApiErrorCodeUncheckedUpdateManyWithoutApiDesignNestedInput = {
    create?: XOR<ApiErrorCodeCreateWithoutApiDesignInput, ApiErrorCodeUncheckedCreateWithoutApiDesignInput> | ApiErrorCodeCreateWithoutApiDesignInput[] | ApiErrorCodeUncheckedCreateWithoutApiDesignInput[]
    connectOrCreate?: ApiErrorCodeCreateOrConnectWithoutApiDesignInput | ApiErrorCodeCreateOrConnectWithoutApiDesignInput[]
    upsert?: ApiErrorCodeUpsertWithWhereUniqueWithoutApiDesignInput | ApiErrorCodeUpsertWithWhereUniqueWithoutApiDesignInput[]
    createMany?: ApiErrorCodeCreateManyApiDesignInputEnvelope
    set?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
    disconnect?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
    delete?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
    connect?: ApiErrorCodeWhereUniqueInput | ApiErrorCodeWhereUniqueInput[]
    update?: ApiErrorCodeUpdateWithWhereUniqueWithoutApiDesignInput | ApiErrorCodeUpdateWithWhereUniqueWithoutApiDesignInput[]
    updateMany?: ApiErrorCodeUpdateManyWithWhereWithoutApiDesignInput | ApiErrorCodeUpdateManyWithWhereWithoutApiDesignInput[]
    deleteMany?: ApiErrorCodeScalarWhereInput | ApiErrorCodeScalarWhereInput[]
  }

  export type ApiDesignCreateNestedOneWithoutExamplesInput = {
    create?: XOR<ApiDesignCreateWithoutExamplesInput, ApiDesignUncheckedCreateWithoutExamplesInput>
    connectOrCreate?: ApiDesignCreateOrConnectWithoutExamplesInput
    connect?: ApiDesignWhereUniqueInput
  }

  export type ApiDesignUpdateOneRequiredWithoutExamplesNestedInput = {
    create?: XOR<ApiDesignCreateWithoutExamplesInput, ApiDesignUncheckedCreateWithoutExamplesInput>
    connectOrCreate?: ApiDesignCreateOrConnectWithoutExamplesInput
    upsert?: ApiDesignUpsertWithoutExamplesInput
    connect?: ApiDesignWhereUniqueInput
    update?: XOR<XOR<ApiDesignUpdateToOneWithWhereWithoutExamplesInput, ApiDesignUpdateWithoutExamplesInput>, ApiDesignUncheckedUpdateWithoutExamplesInput>
  }

  export type ApiDesignCreateNestedOneWithoutErrorCodesInput = {
    create?: XOR<ApiDesignCreateWithoutErrorCodesInput, ApiDesignUncheckedCreateWithoutErrorCodesInput>
    connectOrCreate?: ApiDesignCreateOrConnectWithoutErrorCodesInput
    connect?: ApiDesignWhereUniqueInput
  }

  export type ApiDesignUpdateOneRequiredWithoutErrorCodesNestedInput = {
    create?: XOR<ApiDesignCreateWithoutErrorCodesInput, ApiDesignUncheckedCreateWithoutErrorCodesInput>
    connectOrCreate?: ApiDesignCreateOrConnectWithoutErrorCodesInput
    upsert?: ApiDesignUpsertWithoutErrorCodesInput
    connect?: ApiDesignWhereUniqueInput
    update?: XOR<XOR<ApiDesignUpdateToOneWithWhereWithoutErrorCodesInput, ApiDesignUpdateWithoutErrorCodesInput>, ApiDesignUncheckedUpdateWithoutErrorCodesInput>
  }

  export type SystemArchitectureCreateplatformsInput = {
    set: string[]
  }

  export type SystemArchitectureCreatecomponentsInput = {
    set: string[]
  }

  export type SystemArchitectureCreatetechnologiesInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutSystemArchitectureInput = {
    create?: XOR<ProjectCreateWithoutSystemArchitectureInput, ProjectUncheckedCreateWithoutSystemArchitectureInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSystemArchitectureInput
    connect?: ProjectWhereUniqueInput
  }

  export type PlatformArchitectureCreateNestedManyWithoutSystemArchitectureInput = {
    create?: XOR<PlatformArchitectureCreateWithoutSystemArchitectureInput, PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput> | PlatformArchitectureCreateWithoutSystemArchitectureInput[] | PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput[]
    connectOrCreate?: PlatformArchitectureCreateOrConnectWithoutSystemArchitectureInput | PlatformArchitectureCreateOrConnectWithoutSystemArchitectureInput[]
    createMany?: PlatformArchitectureCreateManySystemArchitectureInputEnvelope
    connect?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
  }

  export type ArchitectureChangeHistoryCreateNestedManyWithoutArchitectureInput = {
    create?: XOR<ArchitectureChangeHistoryCreateWithoutArchitectureInput, ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput> | ArchitectureChangeHistoryCreateWithoutArchitectureInput[] | ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput[]
    connectOrCreate?: ArchitectureChangeHistoryCreateOrConnectWithoutArchitectureInput | ArchitectureChangeHistoryCreateOrConnectWithoutArchitectureInput[]
    createMany?: ArchitectureChangeHistoryCreateManyArchitectureInputEnvelope
    connect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
  }

  export type SystemArchitectureCreateNestedOneWithoutNextVersionsInput = {
    create?: XOR<SystemArchitectureCreateWithoutNextVersionsInput, SystemArchitectureUncheckedCreateWithoutNextVersionsInput>
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutNextVersionsInput
    connect?: SystemArchitectureWhereUniqueInput
  }

  export type SystemArchitectureCreateNestedManyWithoutPreviousVersionInput = {
    create?: XOR<SystemArchitectureCreateWithoutPreviousVersionInput, SystemArchitectureUncheckedCreateWithoutPreviousVersionInput> | SystemArchitectureCreateWithoutPreviousVersionInput[] | SystemArchitectureUncheckedCreateWithoutPreviousVersionInput[]
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutPreviousVersionInput | SystemArchitectureCreateOrConnectWithoutPreviousVersionInput[]
    createMany?: SystemArchitectureCreateManyPreviousVersionInputEnvelope
    connect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
  }

  export type PlatformArchitectureUncheckedCreateNestedManyWithoutSystemArchitectureInput = {
    create?: XOR<PlatformArchitectureCreateWithoutSystemArchitectureInput, PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput> | PlatformArchitectureCreateWithoutSystemArchitectureInput[] | PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput[]
    connectOrCreate?: PlatformArchitectureCreateOrConnectWithoutSystemArchitectureInput | PlatformArchitectureCreateOrConnectWithoutSystemArchitectureInput[]
    createMany?: PlatformArchitectureCreateManySystemArchitectureInputEnvelope
    connect?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
  }

  export type ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutArchitectureInput = {
    create?: XOR<ArchitectureChangeHistoryCreateWithoutArchitectureInput, ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput> | ArchitectureChangeHistoryCreateWithoutArchitectureInput[] | ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput[]
    connectOrCreate?: ArchitectureChangeHistoryCreateOrConnectWithoutArchitectureInput | ArchitectureChangeHistoryCreateOrConnectWithoutArchitectureInput[]
    createMany?: ArchitectureChangeHistoryCreateManyArchitectureInputEnvelope
    connect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
  }

  export type SystemArchitectureUncheckedCreateNestedManyWithoutPreviousVersionInput = {
    create?: XOR<SystemArchitectureCreateWithoutPreviousVersionInput, SystemArchitectureUncheckedCreateWithoutPreviousVersionInput> | SystemArchitectureCreateWithoutPreviousVersionInput[] | SystemArchitectureUncheckedCreateWithoutPreviousVersionInput[]
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutPreviousVersionInput | SystemArchitectureCreateOrConnectWithoutPreviousVersionInput[]
    createMany?: SystemArchitectureCreateManyPreviousVersionInputEnvelope
    connect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
  }

  export type EnumArchitectureStatusFieldUpdateOperationsInput = {
    set?: $Enums.ArchitectureStatus
  }

  export type SystemArchitectureUpdateplatformsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SystemArchitectureUpdatecomponentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SystemArchitectureUpdatetechnologiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutSystemArchitectureNestedInput = {
    create?: XOR<ProjectCreateWithoutSystemArchitectureInput, ProjectUncheckedCreateWithoutSystemArchitectureInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSystemArchitectureInput
    upsert?: ProjectUpsertWithoutSystemArchitectureInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSystemArchitectureInput, ProjectUpdateWithoutSystemArchitectureInput>, ProjectUncheckedUpdateWithoutSystemArchitectureInput>
  }

  export type PlatformArchitectureUpdateManyWithoutSystemArchitectureNestedInput = {
    create?: XOR<PlatformArchitectureCreateWithoutSystemArchitectureInput, PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput> | PlatformArchitectureCreateWithoutSystemArchitectureInput[] | PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput[]
    connectOrCreate?: PlatformArchitectureCreateOrConnectWithoutSystemArchitectureInput | PlatformArchitectureCreateOrConnectWithoutSystemArchitectureInput[]
    upsert?: PlatformArchitectureUpsertWithWhereUniqueWithoutSystemArchitectureInput | PlatformArchitectureUpsertWithWhereUniqueWithoutSystemArchitectureInput[]
    createMany?: PlatformArchitectureCreateManySystemArchitectureInputEnvelope
    set?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
    disconnect?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
    delete?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
    connect?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
    update?: PlatformArchitectureUpdateWithWhereUniqueWithoutSystemArchitectureInput | PlatformArchitectureUpdateWithWhereUniqueWithoutSystemArchitectureInput[]
    updateMany?: PlatformArchitectureUpdateManyWithWhereWithoutSystemArchitectureInput | PlatformArchitectureUpdateManyWithWhereWithoutSystemArchitectureInput[]
    deleteMany?: PlatformArchitectureScalarWhereInput | PlatformArchitectureScalarWhereInput[]
  }

  export type ArchitectureChangeHistoryUpdateManyWithoutArchitectureNestedInput = {
    create?: XOR<ArchitectureChangeHistoryCreateWithoutArchitectureInput, ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput> | ArchitectureChangeHistoryCreateWithoutArchitectureInput[] | ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput[]
    connectOrCreate?: ArchitectureChangeHistoryCreateOrConnectWithoutArchitectureInput | ArchitectureChangeHistoryCreateOrConnectWithoutArchitectureInput[]
    upsert?: ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutArchitectureInput | ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutArchitectureInput[]
    createMany?: ArchitectureChangeHistoryCreateManyArchitectureInputEnvelope
    set?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    disconnect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    delete?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    connect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    update?: ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutArchitectureInput | ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutArchitectureInput[]
    updateMany?: ArchitectureChangeHistoryUpdateManyWithWhereWithoutArchitectureInput | ArchitectureChangeHistoryUpdateManyWithWhereWithoutArchitectureInput[]
    deleteMany?: ArchitectureChangeHistoryScalarWhereInput | ArchitectureChangeHistoryScalarWhereInput[]
  }

  export type SystemArchitectureUpdateOneWithoutNextVersionsNestedInput = {
    create?: XOR<SystemArchitectureCreateWithoutNextVersionsInput, SystemArchitectureUncheckedCreateWithoutNextVersionsInput>
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutNextVersionsInput
    upsert?: SystemArchitectureUpsertWithoutNextVersionsInput
    disconnect?: SystemArchitectureWhereInput | boolean
    delete?: SystemArchitectureWhereInput | boolean
    connect?: SystemArchitectureWhereUniqueInput
    update?: XOR<XOR<SystemArchitectureUpdateToOneWithWhereWithoutNextVersionsInput, SystemArchitectureUpdateWithoutNextVersionsInput>, SystemArchitectureUncheckedUpdateWithoutNextVersionsInput>
  }

  export type SystemArchitectureUpdateManyWithoutPreviousVersionNestedInput = {
    create?: XOR<SystemArchitectureCreateWithoutPreviousVersionInput, SystemArchitectureUncheckedCreateWithoutPreviousVersionInput> | SystemArchitectureCreateWithoutPreviousVersionInput[] | SystemArchitectureUncheckedCreateWithoutPreviousVersionInput[]
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutPreviousVersionInput | SystemArchitectureCreateOrConnectWithoutPreviousVersionInput[]
    upsert?: SystemArchitectureUpsertWithWhereUniqueWithoutPreviousVersionInput | SystemArchitectureUpsertWithWhereUniqueWithoutPreviousVersionInput[]
    createMany?: SystemArchitectureCreateManyPreviousVersionInputEnvelope
    set?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    disconnect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    delete?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    connect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    update?: SystemArchitectureUpdateWithWhereUniqueWithoutPreviousVersionInput | SystemArchitectureUpdateWithWhereUniqueWithoutPreviousVersionInput[]
    updateMany?: SystemArchitectureUpdateManyWithWhereWithoutPreviousVersionInput | SystemArchitectureUpdateManyWithWhereWithoutPreviousVersionInput[]
    deleteMany?: SystemArchitectureScalarWhereInput | SystemArchitectureScalarWhereInput[]
  }

  export type PlatformArchitectureUncheckedUpdateManyWithoutSystemArchitectureNestedInput = {
    create?: XOR<PlatformArchitectureCreateWithoutSystemArchitectureInput, PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput> | PlatformArchitectureCreateWithoutSystemArchitectureInput[] | PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput[]
    connectOrCreate?: PlatformArchitectureCreateOrConnectWithoutSystemArchitectureInput | PlatformArchitectureCreateOrConnectWithoutSystemArchitectureInput[]
    upsert?: PlatformArchitectureUpsertWithWhereUniqueWithoutSystemArchitectureInput | PlatformArchitectureUpsertWithWhereUniqueWithoutSystemArchitectureInput[]
    createMany?: PlatformArchitectureCreateManySystemArchitectureInputEnvelope
    set?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
    disconnect?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
    delete?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
    connect?: PlatformArchitectureWhereUniqueInput | PlatformArchitectureWhereUniqueInput[]
    update?: PlatformArchitectureUpdateWithWhereUniqueWithoutSystemArchitectureInput | PlatformArchitectureUpdateWithWhereUniqueWithoutSystemArchitectureInput[]
    updateMany?: PlatformArchitectureUpdateManyWithWhereWithoutSystemArchitectureInput | PlatformArchitectureUpdateManyWithWhereWithoutSystemArchitectureInput[]
    deleteMany?: PlatformArchitectureScalarWhereInput | PlatformArchitectureScalarWhereInput[]
  }

  export type ArchitectureChangeHistoryUncheckedUpdateManyWithoutArchitectureNestedInput = {
    create?: XOR<ArchitectureChangeHistoryCreateWithoutArchitectureInput, ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput> | ArchitectureChangeHistoryCreateWithoutArchitectureInput[] | ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput[]
    connectOrCreate?: ArchitectureChangeHistoryCreateOrConnectWithoutArchitectureInput | ArchitectureChangeHistoryCreateOrConnectWithoutArchitectureInput[]
    upsert?: ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutArchitectureInput | ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutArchitectureInput[]
    createMany?: ArchitectureChangeHistoryCreateManyArchitectureInputEnvelope
    set?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    disconnect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    delete?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    connect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    update?: ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutArchitectureInput | ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutArchitectureInput[]
    updateMany?: ArchitectureChangeHistoryUpdateManyWithWhereWithoutArchitectureInput | ArchitectureChangeHistoryUpdateManyWithWhereWithoutArchitectureInput[]
    deleteMany?: ArchitectureChangeHistoryScalarWhereInput | ArchitectureChangeHistoryScalarWhereInput[]
  }

  export type SystemArchitectureUncheckedUpdateManyWithoutPreviousVersionNestedInput = {
    create?: XOR<SystemArchitectureCreateWithoutPreviousVersionInput, SystemArchitectureUncheckedCreateWithoutPreviousVersionInput> | SystemArchitectureCreateWithoutPreviousVersionInput[] | SystemArchitectureUncheckedCreateWithoutPreviousVersionInput[]
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutPreviousVersionInput | SystemArchitectureCreateOrConnectWithoutPreviousVersionInput[]
    upsert?: SystemArchitectureUpsertWithWhereUniqueWithoutPreviousVersionInput | SystemArchitectureUpsertWithWhereUniqueWithoutPreviousVersionInput[]
    createMany?: SystemArchitectureCreateManyPreviousVersionInputEnvelope
    set?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    disconnect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    delete?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    connect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    update?: SystemArchitectureUpdateWithWhereUniqueWithoutPreviousVersionInput | SystemArchitectureUpdateWithWhereUniqueWithoutPreviousVersionInput[]
    updateMany?: SystemArchitectureUpdateManyWithWhereWithoutPreviousVersionInput | SystemArchitectureUpdateManyWithWhereWithoutPreviousVersionInput[]
    deleteMany?: SystemArchitectureScalarWhereInput | SystemArchitectureScalarWhereInput[]
  }

  export type PlatformArchitectureCreatetechnologiesInput = {
    set: string[]
  }

  export type PlatformArchitectureCreatecomponentsInput = {
    set: string[]
  }

  export type SystemArchitectureCreateNestedOneWithoutPlatformArchitecturesInput = {
    create?: XOR<SystemArchitectureCreateWithoutPlatformArchitecturesInput, SystemArchitectureUncheckedCreateWithoutPlatformArchitecturesInput>
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutPlatformArchitecturesInput
    connect?: SystemArchitectureWhereUniqueInput
  }

  export type PlatformArchitectureUpdatetechnologiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlatformArchitectureUpdatecomponentsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type SystemArchitectureUpdateOneRequiredWithoutPlatformArchitecturesNestedInput = {
    create?: XOR<SystemArchitectureCreateWithoutPlatformArchitecturesInput, SystemArchitectureUncheckedCreateWithoutPlatformArchitecturesInput>
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutPlatformArchitecturesInput
    upsert?: SystemArchitectureUpsertWithoutPlatformArchitecturesInput
    connect?: SystemArchitectureWhereUniqueInput
    update?: XOR<XOR<SystemArchitectureUpdateToOneWithWhereWithoutPlatformArchitecturesInput, SystemArchitectureUpdateWithoutPlatformArchitecturesInput>, SystemArchitectureUncheckedUpdateWithoutPlatformArchitecturesInput>
  }

  export type SystemArchitectureCreateNestedOneWithoutChangeHistoriesInput = {
    create?: XOR<SystemArchitectureCreateWithoutChangeHistoriesInput, SystemArchitectureUncheckedCreateWithoutChangeHistoriesInput>
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutChangeHistoriesInput
    connect?: SystemArchitectureWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutArchitectureChangeHistoryInput = {
    create?: XOR<UserCreateWithoutArchitectureChangeHistoryInput, UserUncheckedCreateWithoutArchitectureChangeHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutArchitectureChangeHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type SystemArchitectureUpdateOneRequiredWithoutChangeHistoriesNestedInput = {
    create?: XOR<SystemArchitectureCreateWithoutChangeHistoriesInput, SystemArchitectureUncheckedCreateWithoutChangeHistoriesInput>
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutChangeHistoriesInput
    upsert?: SystemArchitectureUpsertWithoutChangeHistoriesInput
    connect?: SystemArchitectureWhereUniqueInput
    update?: XOR<XOR<SystemArchitectureUpdateToOneWithWhereWithoutChangeHistoriesInput, SystemArchitectureUpdateWithoutChangeHistoriesInput>, SystemArchitectureUncheckedUpdateWithoutChangeHistoriesInput>
  }

  export type UserUpdateOneWithoutArchitectureChangeHistoryNestedInput = {
    create?: XOR<UserCreateWithoutArchitectureChangeHistoryInput, UserUncheckedCreateWithoutArchitectureChangeHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutArchitectureChangeHistoryInput
    upsert?: UserUpsertWithoutArchitectureChangeHistoryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArchitectureChangeHistoryInput, UserUpdateWithoutArchitectureChangeHistoryInput>, UserUncheckedUpdateWithoutArchitectureChangeHistoryInput>
  }

  export type ProjectCreateNestedOneWithoutDatabaseSchemaInput = {
    create?: XOR<ProjectCreateWithoutDatabaseSchemaInput, ProjectUncheckedCreateWithoutDatabaseSchemaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDatabaseSchemaInput
    connect?: ProjectWhereUniqueInput
  }

  export type DatabaseTableCreateNestedManyWithoutSchemaInput = {
    create?: XOR<DatabaseTableCreateWithoutSchemaInput, DatabaseTableUncheckedCreateWithoutSchemaInput> | DatabaseTableCreateWithoutSchemaInput[] | DatabaseTableUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutSchemaInput | DatabaseTableCreateOrConnectWithoutSchemaInput[]
    createMany?: DatabaseTableCreateManySchemaInputEnvelope
    connect?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutDatabaseSchemaInput = {
    create?: XOR<UserCreateWithoutDatabaseSchemaInput, UserUncheckedCreateWithoutDatabaseSchemaInput>
    connectOrCreate?: UserCreateOrConnectWithoutDatabaseSchemaInput
    connect?: UserWhereUniqueInput
  }

  export type DatabaseTableUncheckedCreateNestedManyWithoutSchemaInput = {
    create?: XOR<DatabaseTableCreateWithoutSchemaInput, DatabaseTableUncheckedCreateWithoutSchemaInput> | DatabaseTableCreateWithoutSchemaInput[] | DatabaseTableUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutSchemaInput | DatabaseTableCreateOrConnectWithoutSchemaInput[]
    createMany?: DatabaseTableCreateManySchemaInputEnvelope
    connect?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
  }

  export type EnumDatabaseEngineFieldUpdateOperationsInput = {
    set?: $Enums.DatabaseEngine
  }

  export type ProjectUpdateOneRequiredWithoutDatabaseSchemaNestedInput = {
    create?: XOR<ProjectCreateWithoutDatabaseSchemaInput, ProjectUncheckedCreateWithoutDatabaseSchemaInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDatabaseSchemaInput
    upsert?: ProjectUpsertWithoutDatabaseSchemaInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDatabaseSchemaInput, ProjectUpdateWithoutDatabaseSchemaInput>, ProjectUncheckedUpdateWithoutDatabaseSchemaInput>
  }

  export type DatabaseTableUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<DatabaseTableCreateWithoutSchemaInput, DatabaseTableUncheckedCreateWithoutSchemaInput> | DatabaseTableCreateWithoutSchemaInput[] | DatabaseTableUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutSchemaInput | DatabaseTableCreateOrConnectWithoutSchemaInput[]
    upsert?: DatabaseTableUpsertWithWhereUniqueWithoutSchemaInput | DatabaseTableUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: DatabaseTableCreateManySchemaInputEnvelope
    set?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
    disconnect?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
    delete?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
    connect?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
    update?: DatabaseTableUpdateWithWhereUniqueWithoutSchemaInput | DatabaseTableUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: DatabaseTableUpdateManyWithWhereWithoutSchemaInput | DatabaseTableUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: DatabaseTableScalarWhereInput | DatabaseTableScalarWhereInput[]
  }

  export type UserUpdateOneWithoutDatabaseSchemaNestedInput = {
    create?: XOR<UserCreateWithoutDatabaseSchemaInput, UserUncheckedCreateWithoutDatabaseSchemaInput>
    connectOrCreate?: UserCreateOrConnectWithoutDatabaseSchemaInput
    upsert?: UserUpsertWithoutDatabaseSchemaInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDatabaseSchemaInput, UserUpdateWithoutDatabaseSchemaInput>, UserUncheckedUpdateWithoutDatabaseSchemaInput>
  }

  export type DatabaseTableUncheckedUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<DatabaseTableCreateWithoutSchemaInput, DatabaseTableUncheckedCreateWithoutSchemaInput> | DatabaseTableCreateWithoutSchemaInput[] | DatabaseTableUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutSchemaInput | DatabaseTableCreateOrConnectWithoutSchemaInput[]
    upsert?: DatabaseTableUpsertWithWhereUniqueWithoutSchemaInput | DatabaseTableUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: DatabaseTableCreateManySchemaInputEnvelope
    set?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
    disconnect?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
    delete?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
    connect?: DatabaseTableWhereUniqueInput | DatabaseTableWhereUniqueInput[]
    update?: DatabaseTableUpdateWithWhereUniqueWithoutSchemaInput | DatabaseTableUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: DatabaseTableUpdateManyWithWhereWithoutSchemaInput | DatabaseTableUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: DatabaseTableScalarWhereInput | DatabaseTableScalarWhereInput[]
  }

  export type DatabaseSchemaCreateNestedOneWithoutTablesInput = {
    create?: XOR<DatabaseSchemaCreateWithoutTablesInput, DatabaseSchemaUncheckedCreateWithoutTablesInput>
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutTablesInput
    connect?: DatabaseSchemaWhereUniqueInput
  }

  export type TableColumnCreateNestedManyWithoutTableInput = {
    create?: XOR<TableColumnCreateWithoutTableInput, TableColumnUncheckedCreateWithoutTableInput> | TableColumnCreateWithoutTableInput[] | TableColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableColumnCreateOrConnectWithoutTableInput | TableColumnCreateOrConnectWithoutTableInput[]
    createMany?: TableColumnCreateManyTableInputEnvelope
    connect?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
  }

  export type DatabaseIndexCreateNestedManyWithoutTableInput = {
    create?: XOR<DatabaseIndexCreateWithoutTableInput, DatabaseIndexUncheckedCreateWithoutTableInput> | DatabaseIndexCreateWithoutTableInput[] | DatabaseIndexUncheckedCreateWithoutTableInput[]
    connectOrCreate?: DatabaseIndexCreateOrConnectWithoutTableInput | DatabaseIndexCreateOrConnectWithoutTableInput[]
    createMany?: DatabaseIndexCreateManyTableInputEnvelope
    connect?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
  }

  export type DatabaseRelationCreateNestedManyWithoutSourceTableInput = {
    create?: XOR<DatabaseRelationCreateWithoutSourceTableInput, DatabaseRelationUncheckedCreateWithoutSourceTableInput> | DatabaseRelationCreateWithoutSourceTableInput[] | DatabaseRelationUncheckedCreateWithoutSourceTableInput[]
    connectOrCreate?: DatabaseRelationCreateOrConnectWithoutSourceTableInput | DatabaseRelationCreateOrConnectWithoutSourceTableInput[]
    createMany?: DatabaseRelationCreateManySourceTableInputEnvelope
    connect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
  }

  export type DatabaseRelationCreateNestedManyWithoutTargetTableInput = {
    create?: XOR<DatabaseRelationCreateWithoutTargetTableInput, DatabaseRelationUncheckedCreateWithoutTargetTableInput> | DatabaseRelationCreateWithoutTargetTableInput[] | DatabaseRelationUncheckedCreateWithoutTargetTableInput[]
    connectOrCreate?: DatabaseRelationCreateOrConnectWithoutTargetTableInput | DatabaseRelationCreateOrConnectWithoutTargetTableInput[]
    createMany?: DatabaseRelationCreateManyTargetTableInputEnvelope
    connect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
  }

  export type TableColumnUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<TableColumnCreateWithoutTableInput, TableColumnUncheckedCreateWithoutTableInput> | TableColumnCreateWithoutTableInput[] | TableColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableColumnCreateOrConnectWithoutTableInput | TableColumnCreateOrConnectWithoutTableInput[]
    createMany?: TableColumnCreateManyTableInputEnvelope
    connect?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
  }

  export type DatabaseIndexUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<DatabaseIndexCreateWithoutTableInput, DatabaseIndexUncheckedCreateWithoutTableInput> | DatabaseIndexCreateWithoutTableInput[] | DatabaseIndexUncheckedCreateWithoutTableInput[]
    connectOrCreate?: DatabaseIndexCreateOrConnectWithoutTableInput | DatabaseIndexCreateOrConnectWithoutTableInput[]
    createMany?: DatabaseIndexCreateManyTableInputEnvelope
    connect?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
  }

  export type DatabaseRelationUncheckedCreateNestedManyWithoutSourceTableInput = {
    create?: XOR<DatabaseRelationCreateWithoutSourceTableInput, DatabaseRelationUncheckedCreateWithoutSourceTableInput> | DatabaseRelationCreateWithoutSourceTableInput[] | DatabaseRelationUncheckedCreateWithoutSourceTableInput[]
    connectOrCreate?: DatabaseRelationCreateOrConnectWithoutSourceTableInput | DatabaseRelationCreateOrConnectWithoutSourceTableInput[]
    createMany?: DatabaseRelationCreateManySourceTableInputEnvelope
    connect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
  }

  export type DatabaseRelationUncheckedCreateNestedManyWithoutTargetTableInput = {
    create?: XOR<DatabaseRelationCreateWithoutTargetTableInput, DatabaseRelationUncheckedCreateWithoutTargetTableInput> | DatabaseRelationCreateWithoutTargetTableInput[] | DatabaseRelationUncheckedCreateWithoutTargetTableInput[]
    connectOrCreate?: DatabaseRelationCreateOrConnectWithoutTargetTableInput | DatabaseRelationCreateOrConnectWithoutTargetTableInput[]
    createMany?: DatabaseRelationCreateManyTargetTableInputEnvelope
    connect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
  }

  export type DatabaseSchemaUpdateOneRequiredWithoutTablesNestedInput = {
    create?: XOR<DatabaseSchemaCreateWithoutTablesInput, DatabaseSchemaUncheckedCreateWithoutTablesInput>
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutTablesInput
    upsert?: DatabaseSchemaUpsertWithoutTablesInput
    connect?: DatabaseSchemaWhereUniqueInput
    update?: XOR<XOR<DatabaseSchemaUpdateToOneWithWhereWithoutTablesInput, DatabaseSchemaUpdateWithoutTablesInput>, DatabaseSchemaUncheckedUpdateWithoutTablesInput>
  }

  export type TableColumnUpdateManyWithoutTableNestedInput = {
    create?: XOR<TableColumnCreateWithoutTableInput, TableColumnUncheckedCreateWithoutTableInput> | TableColumnCreateWithoutTableInput[] | TableColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableColumnCreateOrConnectWithoutTableInput | TableColumnCreateOrConnectWithoutTableInput[]
    upsert?: TableColumnUpsertWithWhereUniqueWithoutTableInput | TableColumnUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: TableColumnCreateManyTableInputEnvelope
    set?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
    disconnect?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
    delete?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
    connect?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
    update?: TableColumnUpdateWithWhereUniqueWithoutTableInput | TableColumnUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: TableColumnUpdateManyWithWhereWithoutTableInput | TableColumnUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: TableColumnScalarWhereInput | TableColumnScalarWhereInput[]
  }

  export type DatabaseIndexUpdateManyWithoutTableNestedInput = {
    create?: XOR<DatabaseIndexCreateWithoutTableInput, DatabaseIndexUncheckedCreateWithoutTableInput> | DatabaseIndexCreateWithoutTableInput[] | DatabaseIndexUncheckedCreateWithoutTableInput[]
    connectOrCreate?: DatabaseIndexCreateOrConnectWithoutTableInput | DatabaseIndexCreateOrConnectWithoutTableInput[]
    upsert?: DatabaseIndexUpsertWithWhereUniqueWithoutTableInput | DatabaseIndexUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: DatabaseIndexCreateManyTableInputEnvelope
    set?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
    disconnect?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
    delete?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
    connect?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
    update?: DatabaseIndexUpdateWithWhereUniqueWithoutTableInput | DatabaseIndexUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: DatabaseIndexUpdateManyWithWhereWithoutTableInput | DatabaseIndexUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: DatabaseIndexScalarWhereInput | DatabaseIndexScalarWhereInput[]
  }

  export type DatabaseRelationUpdateManyWithoutSourceTableNestedInput = {
    create?: XOR<DatabaseRelationCreateWithoutSourceTableInput, DatabaseRelationUncheckedCreateWithoutSourceTableInput> | DatabaseRelationCreateWithoutSourceTableInput[] | DatabaseRelationUncheckedCreateWithoutSourceTableInput[]
    connectOrCreate?: DatabaseRelationCreateOrConnectWithoutSourceTableInput | DatabaseRelationCreateOrConnectWithoutSourceTableInput[]
    upsert?: DatabaseRelationUpsertWithWhereUniqueWithoutSourceTableInput | DatabaseRelationUpsertWithWhereUniqueWithoutSourceTableInput[]
    createMany?: DatabaseRelationCreateManySourceTableInputEnvelope
    set?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    disconnect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    delete?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    connect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    update?: DatabaseRelationUpdateWithWhereUniqueWithoutSourceTableInput | DatabaseRelationUpdateWithWhereUniqueWithoutSourceTableInput[]
    updateMany?: DatabaseRelationUpdateManyWithWhereWithoutSourceTableInput | DatabaseRelationUpdateManyWithWhereWithoutSourceTableInput[]
    deleteMany?: DatabaseRelationScalarWhereInput | DatabaseRelationScalarWhereInput[]
  }

  export type DatabaseRelationUpdateManyWithoutTargetTableNestedInput = {
    create?: XOR<DatabaseRelationCreateWithoutTargetTableInput, DatabaseRelationUncheckedCreateWithoutTargetTableInput> | DatabaseRelationCreateWithoutTargetTableInput[] | DatabaseRelationUncheckedCreateWithoutTargetTableInput[]
    connectOrCreate?: DatabaseRelationCreateOrConnectWithoutTargetTableInput | DatabaseRelationCreateOrConnectWithoutTargetTableInput[]
    upsert?: DatabaseRelationUpsertWithWhereUniqueWithoutTargetTableInput | DatabaseRelationUpsertWithWhereUniqueWithoutTargetTableInput[]
    createMany?: DatabaseRelationCreateManyTargetTableInputEnvelope
    set?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    disconnect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    delete?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    connect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    update?: DatabaseRelationUpdateWithWhereUniqueWithoutTargetTableInput | DatabaseRelationUpdateWithWhereUniqueWithoutTargetTableInput[]
    updateMany?: DatabaseRelationUpdateManyWithWhereWithoutTargetTableInput | DatabaseRelationUpdateManyWithWhereWithoutTargetTableInput[]
    deleteMany?: DatabaseRelationScalarWhereInput | DatabaseRelationScalarWhereInput[]
  }

  export type TableColumnUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<TableColumnCreateWithoutTableInput, TableColumnUncheckedCreateWithoutTableInput> | TableColumnCreateWithoutTableInput[] | TableColumnUncheckedCreateWithoutTableInput[]
    connectOrCreate?: TableColumnCreateOrConnectWithoutTableInput | TableColumnCreateOrConnectWithoutTableInput[]
    upsert?: TableColumnUpsertWithWhereUniqueWithoutTableInput | TableColumnUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: TableColumnCreateManyTableInputEnvelope
    set?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
    disconnect?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
    delete?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
    connect?: TableColumnWhereUniqueInput | TableColumnWhereUniqueInput[]
    update?: TableColumnUpdateWithWhereUniqueWithoutTableInput | TableColumnUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: TableColumnUpdateManyWithWhereWithoutTableInput | TableColumnUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: TableColumnScalarWhereInput | TableColumnScalarWhereInput[]
  }

  export type DatabaseIndexUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<DatabaseIndexCreateWithoutTableInput, DatabaseIndexUncheckedCreateWithoutTableInput> | DatabaseIndexCreateWithoutTableInput[] | DatabaseIndexUncheckedCreateWithoutTableInput[]
    connectOrCreate?: DatabaseIndexCreateOrConnectWithoutTableInput | DatabaseIndexCreateOrConnectWithoutTableInput[]
    upsert?: DatabaseIndexUpsertWithWhereUniqueWithoutTableInput | DatabaseIndexUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: DatabaseIndexCreateManyTableInputEnvelope
    set?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
    disconnect?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
    delete?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
    connect?: DatabaseIndexWhereUniqueInput | DatabaseIndexWhereUniqueInput[]
    update?: DatabaseIndexUpdateWithWhereUniqueWithoutTableInput | DatabaseIndexUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: DatabaseIndexUpdateManyWithWhereWithoutTableInput | DatabaseIndexUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: DatabaseIndexScalarWhereInput | DatabaseIndexScalarWhereInput[]
  }

  export type DatabaseRelationUncheckedUpdateManyWithoutSourceTableNestedInput = {
    create?: XOR<DatabaseRelationCreateWithoutSourceTableInput, DatabaseRelationUncheckedCreateWithoutSourceTableInput> | DatabaseRelationCreateWithoutSourceTableInput[] | DatabaseRelationUncheckedCreateWithoutSourceTableInput[]
    connectOrCreate?: DatabaseRelationCreateOrConnectWithoutSourceTableInput | DatabaseRelationCreateOrConnectWithoutSourceTableInput[]
    upsert?: DatabaseRelationUpsertWithWhereUniqueWithoutSourceTableInput | DatabaseRelationUpsertWithWhereUniqueWithoutSourceTableInput[]
    createMany?: DatabaseRelationCreateManySourceTableInputEnvelope
    set?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    disconnect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    delete?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    connect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    update?: DatabaseRelationUpdateWithWhereUniqueWithoutSourceTableInput | DatabaseRelationUpdateWithWhereUniqueWithoutSourceTableInput[]
    updateMany?: DatabaseRelationUpdateManyWithWhereWithoutSourceTableInput | DatabaseRelationUpdateManyWithWhereWithoutSourceTableInput[]
    deleteMany?: DatabaseRelationScalarWhereInput | DatabaseRelationScalarWhereInput[]
  }

  export type DatabaseRelationUncheckedUpdateManyWithoutTargetTableNestedInput = {
    create?: XOR<DatabaseRelationCreateWithoutTargetTableInput, DatabaseRelationUncheckedCreateWithoutTargetTableInput> | DatabaseRelationCreateWithoutTargetTableInput[] | DatabaseRelationUncheckedCreateWithoutTargetTableInput[]
    connectOrCreate?: DatabaseRelationCreateOrConnectWithoutTargetTableInput | DatabaseRelationCreateOrConnectWithoutTargetTableInput[]
    upsert?: DatabaseRelationUpsertWithWhereUniqueWithoutTargetTableInput | DatabaseRelationUpsertWithWhereUniqueWithoutTargetTableInput[]
    createMany?: DatabaseRelationCreateManyTargetTableInputEnvelope
    set?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    disconnect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    delete?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    connect?: DatabaseRelationWhereUniqueInput | DatabaseRelationWhereUniqueInput[]
    update?: DatabaseRelationUpdateWithWhereUniqueWithoutTargetTableInput | DatabaseRelationUpdateWithWhereUniqueWithoutTargetTableInput[]
    updateMany?: DatabaseRelationUpdateManyWithWhereWithoutTargetTableInput | DatabaseRelationUpdateManyWithWhereWithoutTargetTableInput[]
    deleteMany?: DatabaseRelationScalarWhereInput | DatabaseRelationScalarWhereInput[]
  }

  export type TableColumnCreateenumValuesInput = {
    set: string[]
  }

  export type DatabaseTableCreateNestedOneWithoutColumnsInput = {
    create?: XOR<DatabaseTableCreateWithoutColumnsInput, DatabaseTableUncheckedCreateWithoutColumnsInput>
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutColumnsInput
    connect?: DatabaseTableWhereUniqueInput
  }

  export type EnumColumnTypeFieldUpdateOperationsInput = {
    set?: $Enums.ColumnType
  }

  export type TableColumnUpdateenumValuesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DatabaseTableUpdateOneRequiredWithoutColumnsNestedInput = {
    create?: XOR<DatabaseTableCreateWithoutColumnsInput, DatabaseTableUncheckedCreateWithoutColumnsInput>
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutColumnsInput
    upsert?: DatabaseTableUpsertWithoutColumnsInput
    connect?: DatabaseTableWhereUniqueInput
    update?: XOR<XOR<DatabaseTableUpdateToOneWithWhereWithoutColumnsInput, DatabaseTableUpdateWithoutColumnsInput>, DatabaseTableUncheckedUpdateWithoutColumnsInput>
  }

  export type DatabaseIndexCreatecolumnsInput = {
    set: string[]
  }

  export type DatabaseTableCreateNestedOneWithoutIndexesInput = {
    create?: XOR<DatabaseTableCreateWithoutIndexesInput, DatabaseTableUncheckedCreateWithoutIndexesInput>
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutIndexesInput
    connect?: DatabaseTableWhereUniqueInput
  }

  export type EnumIndexTypeFieldUpdateOperationsInput = {
    set?: $Enums.IndexType
  }

  export type DatabaseIndexUpdatecolumnsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DatabaseTableUpdateOneRequiredWithoutIndexesNestedInput = {
    create?: XOR<DatabaseTableCreateWithoutIndexesInput, DatabaseTableUncheckedCreateWithoutIndexesInput>
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutIndexesInput
    upsert?: DatabaseTableUpsertWithoutIndexesInput
    connect?: DatabaseTableWhereUniqueInput
    update?: XOR<XOR<DatabaseTableUpdateToOneWithWhereWithoutIndexesInput, DatabaseTableUpdateWithoutIndexesInput>, DatabaseTableUncheckedUpdateWithoutIndexesInput>
  }

  export type DatabaseRelationCreatesourceColumnsInput = {
    set: string[]
  }

  export type DatabaseRelationCreatetargetColumnsInput = {
    set: string[]
  }

  export type DatabaseTableCreateNestedOneWithoutSourceRelationsInput = {
    create?: XOR<DatabaseTableCreateWithoutSourceRelationsInput, DatabaseTableUncheckedCreateWithoutSourceRelationsInput>
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutSourceRelationsInput
    connect?: DatabaseTableWhereUniqueInput
  }

  export type DatabaseTableCreateNestedOneWithoutTargetRelationsInput = {
    create?: XOR<DatabaseTableCreateWithoutTargetRelationsInput, DatabaseTableUncheckedCreateWithoutTargetRelationsInput>
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutTargetRelationsInput
    connect?: DatabaseTableWhereUniqueInput
  }

  export type EnumRelationTypeFieldUpdateOperationsInput = {
    set?: $Enums.RelationType
  }

  export type DatabaseRelationUpdatesourceColumnsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DatabaseRelationUpdatetargetColumnsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DatabaseTableUpdateOneRequiredWithoutSourceRelationsNestedInput = {
    create?: XOR<DatabaseTableCreateWithoutSourceRelationsInput, DatabaseTableUncheckedCreateWithoutSourceRelationsInput>
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutSourceRelationsInput
    upsert?: DatabaseTableUpsertWithoutSourceRelationsInput
    connect?: DatabaseTableWhereUniqueInput
    update?: XOR<XOR<DatabaseTableUpdateToOneWithWhereWithoutSourceRelationsInput, DatabaseTableUpdateWithoutSourceRelationsInput>, DatabaseTableUncheckedUpdateWithoutSourceRelationsInput>
  }

  export type DatabaseTableUpdateOneRequiredWithoutTargetRelationsNestedInput = {
    create?: XOR<DatabaseTableCreateWithoutTargetRelationsInput, DatabaseTableUncheckedCreateWithoutTargetRelationsInput>
    connectOrCreate?: DatabaseTableCreateOrConnectWithoutTargetRelationsInput
    upsert?: DatabaseTableUpsertWithoutTargetRelationsInput
    connect?: DatabaseTableWhereUniqueInput
    update?: XOR<XOR<DatabaseTableUpdateToOneWithWhereWithoutTargetRelationsInput, DatabaseTableUpdateWithoutTargetRelationsInput>, DatabaseTableUncheckedUpdateWithoutTargetRelationsInput>
  }

  export type ProjectCreateNestedOneWithoutDocumentationInput = {
    create?: XOR<ProjectCreateWithoutDocumentationInput, ProjectUncheckedCreateWithoutDocumentationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentationInput
    connect?: ProjectWhereUniqueInput
  }

  export type DocumentTagCreateNestedManyWithoutDocumentationsInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentationsInput, DocumentTagUncheckedCreateWithoutDocumentationsInput> | DocumentTagCreateWithoutDocumentationsInput[] | DocumentTagUncheckedCreateWithoutDocumentationsInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentationsInput | DocumentTagCreateOrConnectWithoutDocumentationsInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type DocumentVersionCreateNestedManyWithoutDocumentationInput = {
    create?: XOR<DocumentVersionCreateWithoutDocumentationInput, DocumentVersionUncheckedCreateWithoutDocumentationInput> | DocumentVersionCreateWithoutDocumentationInput[] | DocumentVersionUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutDocumentationInput | DocumentVersionCreateOrConnectWithoutDocumentationInput[]
    createMany?: DocumentVersionCreateManyDocumentationInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type DocumentCommentCreateNestedManyWithoutDocumentationInput = {
    create?: XOR<DocumentCommentCreateWithoutDocumentationInput, DocumentCommentUncheckedCreateWithoutDocumentationInput> | DocumentCommentCreateWithoutDocumentationInput[] | DocumentCommentUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutDocumentationInput | DocumentCommentCreateOrConnectWithoutDocumentationInput[]
    createMany?: DocumentCommentCreateManyDocumentationInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type DocumentAttachmentCreateNestedManyWithoutDocumentationInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentationInput, DocumentAttachmentUncheckedCreateWithoutDocumentationInput> | DocumentAttachmentCreateWithoutDocumentationInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentationInput | DocumentAttachmentCreateOrConnectWithoutDocumentationInput[]
    createMany?: DocumentAttachmentCreateManyDocumentationInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutDocumentationInput = {
    create?: XOR<UserCreateWithoutDocumentationInput, UserUncheckedCreateWithoutDocumentationInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentationInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentTagUncheckedCreateNestedManyWithoutDocumentationsInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentationsInput, DocumentTagUncheckedCreateWithoutDocumentationsInput> | DocumentTagCreateWithoutDocumentationsInput[] | DocumentTagUncheckedCreateWithoutDocumentationsInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentationsInput | DocumentTagCreateOrConnectWithoutDocumentationsInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
  }

  export type DocumentVersionUncheckedCreateNestedManyWithoutDocumentationInput = {
    create?: XOR<DocumentVersionCreateWithoutDocumentationInput, DocumentVersionUncheckedCreateWithoutDocumentationInput> | DocumentVersionCreateWithoutDocumentationInput[] | DocumentVersionUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutDocumentationInput | DocumentVersionCreateOrConnectWithoutDocumentationInput[]
    createMany?: DocumentVersionCreateManyDocumentationInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type DocumentCommentUncheckedCreateNestedManyWithoutDocumentationInput = {
    create?: XOR<DocumentCommentCreateWithoutDocumentationInput, DocumentCommentUncheckedCreateWithoutDocumentationInput> | DocumentCommentCreateWithoutDocumentationInput[] | DocumentCommentUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutDocumentationInput | DocumentCommentCreateOrConnectWithoutDocumentationInput[]
    createMany?: DocumentCommentCreateManyDocumentationInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentationInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentationInput, DocumentAttachmentUncheckedCreateWithoutDocumentationInput> | DocumentAttachmentCreateWithoutDocumentationInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentationInput | DocumentAttachmentCreateOrConnectWithoutDocumentationInput[]
    createMany?: DocumentAttachmentCreateManyDocumentationInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type EnumDocumentVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.DocumentVisibility
  }

  export type ProjectUpdateOneRequiredWithoutDocumentationNestedInput = {
    create?: XOR<ProjectCreateWithoutDocumentationInput, ProjectUncheckedCreateWithoutDocumentationInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDocumentationInput
    upsert?: ProjectUpsertWithoutDocumentationInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDocumentationInput, ProjectUpdateWithoutDocumentationInput>, ProjectUncheckedUpdateWithoutDocumentationInput>
  }

  export type DocumentTagUpdateManyWithoutDocumentationsNestedInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentationsInput, DocumentTagUncheckedCreateWithoutDocumentationsInput> | DocumentTagCreateWithoutDocumentationsInput[] | DocumentTagUncheckedCreateWithoutDocumentationsInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentationsInput | DocumentTagCreateOrConnectWithoutDocumentationsInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutDocumentationsInput | DocumentTagUpsertWithWhereUniqueWithoutDocumentationsInput[]
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutDocumentationsInput | DocumentTagUpdateWithWhereUniqueWithoutDocumentationsInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutDocumentationsInput | DocumentTagUpdateManyWithWhereWithoutDocumentationsInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type DocumentVersionUpdateManyWithoutDocumentationNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutDocumentationInput, DocumentVersionUncheckedCreateWithoutDocumentationInput> | DocumentVersionCreateWithoutDocumentationInput[] | DocumentVersionUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutDocumentationInput | DocumentVersionCreateOrConnectWithoutDocumentationInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutDocumentationInput | DocumentVersionUpsertWithWhereUniqueWithoutDocumentationInput[]
    createMany?: DocumentVersionCreateManyDocumentationInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutDocumentationInput | DocumentVersionUpdateWithWhereUniqueWithoutDocumentationInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutDocumentationInput | DocumentVersionUpdateManyWithWhereWithoutDocumentationInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type DocumentCommentUpdateManyWithoutDocumentationNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutDocumentationInput, DocumentCommentUncheckedCreateWithoutDocumentationInput> | DocumentCommentCreateWithoutDocumentationInput[] | DocumentCommentUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutDocumentationInput | DocumentCommentCreateOrConnectWithoutDocumentationInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutDocumentationInput | DocumentCommentUpsertWithWhereUniqueWithoutDocumentationInput[]
    createMany?: DocumentCommentCreateManyDocumentationInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutDocumentationInput | DocumentCommentUpdateWithWhereUniqueWithoutDocumentationInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutDocumentationInput | DocumentCommentUpdateManyWithWhereWithoutDocumentationInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type DocumentAttachmentUpdateManyWithoutDocumentationNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentationInput, DocumentAttachmentUncheckedCreateWithoutDocumentationInput> | DocumentAttachmentCreateWithoutDocumentationInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentationInput | DocumentAttachmentCreateOrConnectWithoutDocumentationInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentationInput | DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentationInput[]
    createMany?: DocumentAttachmentCreateManyDocumentationInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentationInput | DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentationInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutDocumentationInput | DocumentAttachmentUpdateManyWithWhereWithoutDocumentationInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutDocumentationNestedInput = {
    create?: XOR<UserCreateWithoutDocumentationInput, UserUncheckedCreateWithoutDocumentationInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentationInput
    upsert?: UserUpsertWithoutDocumentationInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentationInput, UserUpdateWithoutDocumentationInput>, UserUncheckedUpdateWithoutDocumentationInput>
  }

  export type DocumentTagUncheckedUpdateManyWithoutDocumentationsNestedInput = {
    create?: XOR<DocumentTagCreateWithoutDocumentationsInput, DocumentTagUncheckedCreateWithoutDocumentationsInput> | DocumentTagCreateWithoutDocumentationsInput[] | DocumentTagUncheckedCreateWithoutDocumentationsInput[]
    connectOrCreate?: DocumentTagCreateOrConnectWithoutDocumentationsInput | DocumentTagCreateOrConnectWithoutDocumentationsInput[]
    upsert?: DocumentTagUpsertWithWhereUniqueWithoutDocumentationsInput | DocumentTagUpsertWithWhereUniqueWithoutDocumentationsInput[]
    set?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    disconnect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    delete?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    connect?: DocumentTagWhereUniqueInput | DocumentTagWhereUniqueInput[]
    update?: DocumentTagUpdateWithWhereUniqueWithoutDocumentationsInput | DocumentTagUpdateWithWhereUniqueWithoutDocumentationsInput[]
    updateMany?: DocumentTagUpdateManyWithWhereWithoutDocumentationsInput | DocumentTagUpdateManyWithWhereWithoutDocumentationsInput[]
    deleteMany?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
  }

  export type DocumentVersionUncheckedUpdateManyWithoutDocumentationNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutDocumentationInput, DocumentVersionUncheckedCreateWithoutDocumentationInput> | DocumentVersionCreateWithoutDocumentationInput[] | DocumentVersionUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutDocumentationInput | DocumentVersionCreateOrConnectWithoutDocumentationInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutDocumentationInput | DocumentVersionUpsertWithWhereUniqueWithoutDocumentationInput[]
    createMany?: DocumentVersionCreateManyDocumentationInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutDocumentationInput | DocumentVersionUpdateWithWhereUniqueWithoutDocumentationInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutDocumentationInput | DocumentVersionUpdateManyWithWhereWithoutDocumentationInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type DocumentCommentUncheckedUpdateManyWithoutDocumentationNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutDocumentationInput, DocumentCommentUncheckedCreateWithoutDocumentationInput> | DocumentCommentCreateWithoutDocumentationInput[] | DocumentCommentUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutDocumentationInput | DocumentCommentCreateOrConnectWithoutDocumentationInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutDocumentationInput | DocumentCommentUpsertWithWhereUniqueWithoutDocumentationInput[]
    createMany?: DocumentCommentCreateManyDocumentationInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutDocumentationInput | DocumentCommentUpdateWithWhereUniqueWithoutDocumentationInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutDocumentationInput | DocumentCommentUpdateManyWithWhereWithoutDocumentationInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutDocumentationNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutDocumentationInput, DocumentAttachmentUncheckedCreateWithoutDocumentationInput> | DocumentAttachmentCreateWithoutDocumentationInput[] | DocumentAttachmentUncheckedCreateWithoutDocumentationInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutDocumentationInput | DocumentAttachmentCreateOrConnectWithoutDocumentationInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentationInput | DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentationInput[]
    createMany?: DocumentAttachmentCreateManyDocumentationInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentationInput | DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentationInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutDocumentationInput | DocumentAttachmentUpdateManyWithWhereWithoutDocumentationInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type DocumentationCreateNestedOneWithoutVersionsInput = {
    create?: XOR<DocumentationCreateWithoutVersionsInput, DocumentationUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: DocumentationCreateOrConnectWithoutVersionsInput
    connect?: DocumentationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentVersionInput = {
    create?: XOR<UserCreateWithoutDocumentVersionInput, UserUncheckedCreateWithoutDocumentVersionInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentVersionInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentationUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<DocumentationCreateWithoutVersionsInput, DocumentationUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: DocumentationCreateOrConnectWithoutVersionsInput
    upsert?: DocumentationUpsertWithoutVersionsInput
    connect?: DocumentationWhereUniqueInput
    update?: XOR<XOR<DocumentationUpdateToOneWithWhereWithoutVersionsInput, DocumentationUpdateWithoutVersionsInput>, DocumentationUncheckedUpdateWithoutVersionsInput>
  }

  export type UserUpdateOneWithoutDocumentVersionNestedInput = {
    create?: XOR<UserCreateWithoutDocumentVersionInput, UserUncheckedCreateWithoutDocumentVersionInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentVersionInput
    upsert?: UserUpsertWithoutDocumentVersionInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentVersionInput, UserUpdateWithoutDocumentVersionInput>, UserUncheckedUpdateWithoutDocumentVersionInput>
  }

  export type DocumentationCreateNestedManyWithoutTagsInput = {
    create?: XOR<DocumentationCreateWithoutTagsInput, DocumentationUncheckedCreateWithoutTagsInput> | DocumentationCreateWithoutTagsInput[] | DocumentationUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutTagsInput | DocumentationCreateOrConnectWithoutTagsInput[]
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
  }

  export type DocumentationUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<DocumentationCreateWithoutTagsInput, DocumentationUncheckedCreateWithoutTagsInput> | DocumentationCreateWithoutTagsInput[] | DocumentationUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutTagsInput | DocumentationCreateOrConnectWithoutTagsInput[]
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
  }

  export type DocumentationUpdateManyWithoutTagsNestedInput = {
    create?: XOR<DocumentationCreateWithoutTagsInput, DocumentationUncheckedCreateWithoutTagsInput> | DocumentationCreateWithoutTagsInput[] | DocumentationUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutTagsInput | DocumentationCreateOrConnectWithoutTagsInput[]
    upsert?: DocumentationUpsertWithWhereUniqueWithoutTagsInput | DocumentationUpsertWithWhereUniqueWithoutTagsInput[]
    set?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    disconnect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    delete?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    update?: DocumentationUpdateWithWhereUniqueWithoutTagsInput | DocumentationUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: DocumentationUpdateManyWithWhereWithoutTagsInput | DocumentationUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: DocumentationScalarWhereInput | DocumentationScalarWhereInput[]
  }

  export type DocumentationUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<DocumentationCreateWithoutTagsInput, DocumentationUncheckedCreateWithoutTagsInput> | DocumentationCreateWithoutTagsInput[] | DocumentationUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutTagsInput | DocumentationCreateOrConnectWithoutTagsInput[]
    upsert?: DocumentationUpsertWithWhereUniqueWithoutTagsInput | DocumentationUpsertWithWhereUniqueWithoutTagsInput[]
    set?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    disconnect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    delete?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    update?: DocumentationUpdateWithWhereUniqueWithoutTagsInput | DocumentationUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: DocumentationUpdateManyWithWhereWithoutTagsInput | DocumentationUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: DocumentationScalarWhereInput | DocumentationScalarWhereInput[]
  }

  export type DocumentationCreateNestedOneWithoutCommentsInput = {
    create?: XOR<DocumentationCreateWithoutCommentsInput, DocumentationUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DocumentationCreateOrConnectWithoutCommentsInput
    connect?: DocumentationWhereUniqueInput
  }

  export type DocumentCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<DocumentCommentCreateWithoutRepliesInput, DocumentCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutRepliesInput
    connect?: DocumentCommentWhereUniqueInput
  }

  export type DocumentCommentCreateNestedManyWithoutParentInput = {
    create?: XOR<DocumentCommentCreateWithoutParentInput, DocumentCommentUncheckedCreateWithoutParentInput> | DocumentCommentCreateWithoutParentInput[] | DocumentCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutParentInput | DocumentCommentCreateOrConnectWithoutParentInput[]
    createMany?: DocumentCommentCreateManyParentInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutDocumentCommentInput = {
    create?: XOR<UserCreateWithoutDocumentCommentInput, UserUncheckedCreateWithoutDocumentCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentCommentInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentCommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<DocumentCommentCreateWithoutParentInput, DocumentCommentUncheckedCreateWithoutParentInput> | DocumentCommentCreateWithoutParentInput[] | DocumentCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutParentInput | DocumentCommentCreateOrConnectWithoutParentInput[]
    createMany?: DocumentCommentCreateManyParentInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type DocumentationUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<DocumentationCreateWithoutCommentsInput, DocumentationUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: DocumentationCreateOrConnectWithoutCommentsInput
    upsert?: DocumentationUpsertWithoutCommentsInput
    connect?: DocumentationWhereUniqueInput
    update?: XOR<XOR<DocumentationUpdateToOneWithWhereWithoutCommentsInput, DocumentationUpdateWithoutCommentsInput>, DocumentationUncheckedUpdateWithoutCommentsInput>
  }

  export type DocumentCommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutRepliesInput, DocumentCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutRepliesInput
    upsert?: DocumentCommentUpsertWithoutRepliesInput
    disconnect?: DocumentCommentWhereInput | boolean
    delete?: DocumentCommentWhereInput | boolean
    connect?: DocumentCommentWhereUniqueInput
    update?: XOR<XOR<DocumentCommentUpdateToOneWithWhereWithoutRepliesInput, DocumentCommentUpdateWithoutRepliesInput>, DocumentCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type DocumentCommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutParentInput, DocumentCommentUncheckedCreateWithoutParentInput> | DocumentCommentCreateWithoutParentInput[] | DocumentCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutParentInput | DocumentCommentCreateOrConnectWithoutParentInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutParentInput | DocumentCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DocumentCommentCreateManyParentInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutParentInput | DocumentCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutParentInput | DocumentCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutDocumentCommentNestedInput = {
    create?: XOR<UserCreateWithoutDocumentCommentInput, UserUncheckedCreateWithoutDocumentCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentCommentInput
    upsert?: UserUpsertWithoutDocumentCommentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentCommentInput, UserUpdateWithoutDocumentCommentInput>, UserUncheckedUpdateWithoutDocumentCommentInput>
  }

  export type DocumentCommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutParentInput, DocumentCommentUncheckedCreateWithoutParentInput> | DocumentCommentCreateWithoutParentInput[] | DocumentCommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutParentInput | DocumentCommentCreateOrConnectWithoutParentInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutParentInput | DocumentCommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DocumentCommentCreateManyParentInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutParentInput | DocumentCommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutParentInput | DocumentCommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type DocumentationCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<DocumentationCreateWithoutAttachmentsInput, DocumentationUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: DocumentationCreateOrConnectWithoutAttachmentsInput
    connect?: DocumentationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentAttachmentInput = {
    create?: XOR<UserCreateWithoutDocumentAttachmentInput, UserUncheckedCreateWithoutDocumentAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentAttachmentInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentationUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<DocumentationCreateWithoutAttachmentsInput, DocumentationUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: DocumentationCreateOrConnectWithoutAttachmentsInput
    upsert?: DocumentationUpsertWithoutAttachmentsInput
    connect?: DocumentationWhereUniqueInput
    update?: XOR<XOR<DocumentationUpdateToOneWithWhereWithoutAttachmentsInput, DocumentationUpdateWithoutAttachmentsInput>, DocumentationUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneWithoutDocumentAttachmentNestedInput = {
    create?: XOR<UserCreateWithoutDocumentAttachmentInput, UserUncheckedCreateWithoutDocumentAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentAttachmentInput
    upsert?: UserUpsertWithoutDocumentAttachmentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentAttachmentInput, UserUpdateWithoutDocumentAttachmentInput>, UserUncheckedUpdateWithoutDocumentAttachmentInput>
  }

  export type ProjectCreateNestedOneWithoutMindMapInput = {
    create?: XOR<ProjectCreateWithoutMindMapInput, ProjectUncheckedCreateWithoutMindMapInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMindMapInput
    connect?: ProjectWhereUniqueInput
  }

  export type MindMapNodeCreateNestedOneWithoutRootOfMapInput = {
    create?: XOR<MindMapNodeCreateWithoutRootOfMapInput, MindMapNodeUncheckedCreateWithoutRootOfMapInput>
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutRootOfMapInput
    connect?: MindMapNodeWhereUniqueInput
  }

  export type MindMapNodeCreateNestedManyWithoutMindMapInput = {
    create?: XOR<MindMapNodeCreateWithoutMindMapInput, MindMapNodeUncheckedCreateWithoutMindMapInput> | MindMapNodeCreateWithoutMindMapInput[] | MindMapNodeUncheckedCreateWithoutMindMapInput[]
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutMindMapInput | MindMapNodeCreateOrConnectWithoutMindMapInput[]
    createMany?: MindMapNodeCreateManyMindMapInputEnvelope
    connect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutMindMapInput = {
    create?: XOR<UserCreateWithoutMindMapInput, UserUncheckedCreateWithoutMindMapInput>
    connectOrCreate?: UserCreateOrConnectWithoutMindMapInput
    connect?: UserWhereUniqueInput
  }

  export type MindMapNodeUncheckedCreateNestedManyWithoutMindMapInput = {
    create?: XOR<MindMapNodeCreateWithoutMindMapInput, MindMapNodeUncheckedCreateWithoutMindMapInput> | MindMapNodeCreateWithoutMindMapInput[] | MindMapNodeUncheckedCreateWithoutMindMapInput[]
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutMindMapInput | MindMapNodeCreateOrConnectWithoutMindMapInput[]
    createMany?: MindMapNodeCreateManyMindMapInputEnvelope
    connect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutMindMapNestedInput = {
    create?: XOR<ProjectCreateWithoutMindMapInput, ProjectUncheckedCreateWithoutMindMapInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMindMapInput
    upsert?: ProjectUpsertWithoutMindMapInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMindMapInput, ProjectUpdateWithoutMindMapInput>, ProjectUncheckedUpdateWithoutMindMapInput>
  }

  export type MindMapNodeUpdateOneWithoutRootOfMapNestedInput = {
    create?: XOR<MindMapNodeCreateWithoutRootOfMapInput, MindMapNodeUncheckedCreateWithoutRootOfMapInput>
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutRootOfMapInput
    upsert?: MindMapNodeUpsertWithoutRootOfMapInput
    disconnect?: MindMapNodeWhereInput | boolean
    delete?: MindMapNodeWhereInput | boolean
    connect?: MindMapNodeWhereUniqueInput
    update?: XOR<XOR<MindMapNodeUpdateToOneWithWhereWithoutRootOfMapInput, MindMapNodeUpdateWithoutRootOfMapInput>, MindMapNodeUncheckedUpdateWithoutRootOfMapInput>
  }

  export type MindMapNodeUpdateManyWithoutMindMapNestedInput = {
    create?: XOR<MindMapNodeCreateWithoutMindMapInput, MindMapNodeUncheckedCreateWithoutMindMapInput> | MindMapNodeCreateWithoutMindMapInput[] | MindMapNodeUncheckedCreateWithoutMindMapInput[]
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutMindMapInput | MindMapNodeCreateOrConnectWithoutMindMapInput[]
    upsert?: MindMapNodeUpsertWithWhereUniqueWithoutMindMapInput | MindMapNodeUpsertWithWhereUniqueWithoutMindMapInput[]
    createMany?: MindMapNodeCreateManyMindMapInputEnvelope
    set?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    disconnect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    delete?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    connect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    update?: MindMapNodeUpdateWithWhereUniqueWithoutMindMapInput | MindMapNodeUpdateWithWhereUniqueWithoutMindMapInput[]
    updateMany?: MindMapNodeUpdateManyWithWhereWithoutMindMapInput | MindMapNodeUpdateManyWithWhereWithoutMindMapInput[]
    deleteMany?: MindMapNodeScalarWhereInput | MindMapNodeScalarWhereInput[]
  }

  export type UserUpdateOneWithoutMindMapNestedInput = {
    create?: XOR<UserCreateWithoutMindMapInput, UserUncheckedCreateWithoutMindMapInput>
    connectOrCreate?: UserCreateOrConnectWithoutMindMapInput
    upsert?: UserUpsertWithoutMindMapInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMindMapInput, UserUpdateWithoutMindMapInput>, UserUncheckedUpdateWithoutMindMapInput>
  }

  export type MindMapNodeUncheckedUpdateManyWithoutMindMapNestedInput = {
    create?: XOR<MindMapNodeCreateWithoutMindMapInput, MindMapNodeUncheckedCreateWithoutMindMapInput> | MindMapNodeCreateWithoutMindMapInput[] | MindMapNodeUncheckedCreateWithoutMindMapInput[]
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutMindMapInput | MindMapNodeCreateOrConnectWithoutMindMapInput[]
    upsert?: MindMapNodeUpsertWithWhereUniqueWithoutMindMapInput | MindMapNodeUpsertWithWhereUniqueWithoutMindMapInput[]
    createMany?: MindMapNodeCreateManyMindMapInputEnvelope
    set?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    disconnect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    delete?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    connect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    update?: MindMapNodeUpdateWithWhereUniqueWithoutMindMapInput | MindMapNodeUpdateWithWhereUniqueWithoutMindMapInput[]
    updateMany?: MindMapNodeUpdateManyWithWhereWithoutMindMapInput | MindMapNodeUpdateManyWithWhereWithoutMindMapInput[]
    deleteMany?: MindMapNodeScalarWhereInput | MindMapNodeScalarWhereInput[]
  }

  export type MindMapCreateNestedOneWithoutNodesInput = {
    create?: XOR<MindMapCreateWithoutNodesInput, MindMapUncheckedCreateWithoutNodesInput>
    connectOrCreate?: MindMapCreateOrConnectWithoutNodesInput
    connect?: MindMapWhereUniqueInput
  }

  export type MindMapCreateNestedOneWithoutRootNodeInput = {
    create?: XOR<MindMapCreateWithoutRootNodeInput, MindMapUncheckedCreateWithoutRootNodeInput>
    connectOrCreate?: MindMapCreateOrConnectWithoutRootNodeInput
    connect?: MindMapWhereUniqueInput
  }

  export type MindMapNodeCreateNestedOneWithoutChildrenInput = {
    create?: XOR<MindMapNodeCreateWithoutChildrenInput, MindMapNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutChildrenInput
    connect?: MindMapNodeWhereUniqueInput
  }

  export type MindMapNodeCreateNestedManyWithoutParentInput = {
    create?: XOR<MindMapNodeCreateWithoutParentInput, MindMapNodeUncheckedCreateWithoutParentInput> | MindMapNodeCreateWithoutParentInput[] | MindMapNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutParentInput | MindMapNodeCreateOrConnectWithoutParentInput[]
    createMany?: MindMapNodeCreateManyParentInputEnvelope
    connect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
  }

  export type MindMapUncheckedCreateNestedOneWithoutRootNodeInput = {
    create?: XOR<MindMapCreateWithoutRootNodeInput, MindMapUncheckedCreateWithoutRootNodeInput>
    connectOrCreate?: MindMapCreateOrConnectWithoutRootNodeInput
    connect?: MindMapWhereUniqueInput
  }

  export type MindMapNodeUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<MindMapNodeCreateWithoutParentInput, MindMapNodeUncheckedCreateWithoutParentInput> | MindMapNodeCreateWithoutParentInput[] | MindMapNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutParentInput | MindMapNodeCreateOrConnectWithoutParentInput[]
    createMany?: MindMapNodeCreateManyParentInputEnvelope
    connect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
  }

  export type EnumNodeTypeFieldUpdateOperationsInput = {
    set?: $Enums.NodeType
  }

  export type MindMapUpdateOneRequiredWithoutNodesNestedInput = {
    create?: XOR<MindMapCreateWithoutNodesInput, MindMapUncheckedCreateWithoutNodesInput>
    connectOrCreate?: MindMapCreateOrConnectWithoutNodesInput
    upsert?: MindMapUpsertWithoutNodesInput
    connect?: MindMapWhereUniqueInput
    update?: XOR<XOR<MindMapUpdateToOneWithWhereWithoutNodesInput, MindMapUpdateWithoutNodesInput>, MindMapUncheckedUpdateWithoutNodesInput>
  }

  export type MindMapUpdateOneWithoutRootNodeNestedInput = {
    create?: XOR<MindMapCreateWithoutRootNodeInput, MindMapUncheckedCreateWithoutRootNodeInput>
    connectOrCreate?: MindMapCreateOrConnectWithoutRootNodeInput
    upsert?: MindMapUpsertWithoutRootNodeInput
    disconnect?: MindMapWhereInput | boolean
    delete?: MindMapWhereInput | boolean
    connect?: MindMapWhereUniqueInput
    update?: XOR<XOR<MindMapUpdateToOneWithWhereWithoutRootNodeInput, MindMapUpdateWithoutRootNodeInput>, MindMapUncheckedUpdateWithoutRootNodeInput>
  }

  export type MindMapNodeUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<MindMapNodeCreateWithoutChildrenInput, MindMapNodeUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutChildrenInput
    upsert?: MindMapNodeUpsertWithoutChildrenInput
    disconnect?: MindMapNodeWhereInput | boolean
    delete?: MindMapNodeWhereInput | boolean
    connect?: MindMapNodeWhereUniqueInput
    update?: XOR<XOR<MindMapNodeUpdateToOneWithWhereWithoutChildrenInput, MindMapNodeUpdateWithoutChildrenInput>, MindMapNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type MindMapNodeUpdateManyWithoutParentNestedInput = {
    create?: XOR<MindMapNodeCreateWithoutParentInput, MindMapNodeUncheckedCreateWithoutParentInput> | MindMapNodeCreateWithoutParentInput[] | MindMapNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutParentInput | MindMapNodeCreateOrConnectWithoutParentInput[]
    upsert?: MindMapNodeUpsertWithWhereUniqueWithoutParentInput | MindMapNodeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MindMapNodeCreateManyParentInputEnvelope
    set?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    disconnect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    delete?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    connect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    update?: MindMapNodeUpdateWithWhereUniqueWithoutParentInput | MindMapNodeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MindMapNodeUpdateManyWithWhereWithoutParentInput | MindMapNodeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MindMapNodeScalarWhereInput | MindMapNodeScalarWhereInput[]
  }

  export type MindMapUncheckedUpdateOneWithoutRootNodeNestedInput = {
    create?: XOR<MindMapCreateWithoutRootNodeInput, MindMapUncheckedCreateWithoutRootNodeInput>
    connectOrCreate?: MindMapCreateOrConnectWithoutRootNodeInput
    upsert?: MindMapUpsertWithoutRootNodeInput
    disconnect?: MindMapWhereInput | boolean
    delete?: MindMapWhereInput | boolean
    connect?: MindMapWhereUniqueInput
    update?: XOR<XOR<MindMapUpdateToOneWithWhereWithoutRootNodeInput, MindMapUpdateWithoutRootNodeInput>, MindMapUncheckedUpdateWithoutRootNodeInput>
  }

  export type MindMapNodeUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<MindMapNodeCreateWithoutParentInput, MindMapNodeUncheckedCreateWithoutParentInput> | MindMapNodeCreateWithoutParentInput[] | MindMapNodeUncheckedCreateWithoutParentInput[]
    connectOrCreate?: MindMapNodeCreateOrConnectWithoutParentInput | MindMapNodeCreateOrConnectWithoutParentInput[]
    upsert?: MindMapNodeUpsertWithWhereUniqueWithoutParentInput | MindMapNodeUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: MindMapNodeCreateManyParentInputEnvelope
    set?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    disconnect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    delete?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    connect?: MindMapNodeWhereUniqueInput | MindMapNodeWhereUniqueInput[]
    update?: MindMapNodeUpdateWithWhereUniqueWithoutParentInput | MindMapNodeUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: MindMapNodeUpdateManyWithWhereWithoutParentInput | MindMapNodeUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: MindMapNodeScalarWhereInput | MindMapNodeScalarWhereInput[]
  }

  export type DomainKnowledgeCreatetagsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutDomainKnowledgeInput = {
    create?: XOR<ProjectCreateWithoutDomainKnowledgeInput, ProjectUncheckedCreateWithoutDomainKnowledgeInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDomainKnowledgeInput
    connect?: ProjectWhereUniqueInput
  }

  export type DomainConceptCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainConceptCreateWithoutDomainKnowledgeInput, DomainConceptUncheckedCreateWithoutDomainKnowledgeInput> | DomainConceptCreateWithoutDomainKnowledgeInput[] | DomainConceptUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainConceptCreateOrConnectWithoutDomainKnowledgeInput | DomainConceptCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainConceptCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
  }

  export type DomainPatternCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainPatternCreateWithoutDomainKnowledgeInput, DomainPatternUncheckedCreateWithoutDomainKnowledgeInput> | DomainPatternCreateWithoutDomainKnowledgeInput[] | DomainPatternUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainPatternCreateOrConnectWithoutDomainKnowledgeInput | DomainPatternCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainPatternCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
  }

  export type DomainBestPracticeCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainBestPracticeCreateWithoutDomainKnowledgeInput, DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput> | DomainBestPracticeCreateWithoutDomainKnowledgeInput[] | DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainBestPracticeCreateOrConnectWithoutDomainKnowledgeInput | DomainBestPracticeCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainBestPracticeCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
  }

  export type DomainAntiPatternCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainAntiPatternCreateWithoutDomainKnowledgeInput, DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput> | DomainAntiPatternCreateWithoutDomainKnowledgeInput[] | DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainAntiPatternCreateOrConnectWithoutDomainKnowledgeInput | DomainAntiPatternCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainAntiPatternCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
  }

  export type DomainReferenceCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainReferenceCreateWithoutDomainKnowledgeInput, DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput> | DomainReferenceCreateWithoutDomainKnowledgeInput[] | DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainReferenceCreateOrConnectWithoutDomainKnowledgeInput | DomainReferenceCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainReferenceCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutDomainKnowledgeInput = {
    create?: XOR<UserCreateWithoutDomainKnowledgeInput, UserUncheckedCreateWithoutDomainKnowledgeInput>
    connectOrCreate?: UserCreateOrConnectWithoutDomainKnowledgeInput
    connect?: UserWhereUniqueInput
  }

  export type DomainConceptUncheckedCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainConceptCreateWithoutDomainKnowledgeInput, DomainConceptUncheckedCreateWithoutDomainKnowledgeInput> | DomainConceptCreateWithoutDomainKnowledgeInput[] | DomainConceptUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainConceptCreateOrConnectWithoutDomainKnowledgeInput | DomainConceptCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainConceptCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
  }

  export type DomainPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainPatternCreateWithoutDomainKnowledgeInput, DomainPatternUncheckedCreateWithoutDomainKnowledgeInput> | DomainPatternCreateWithoutDomainKnowledgeInput[] | DomainPatternUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainPatternCreateOrConnectWithoutDomainKnowledgeInput | DomainPatternCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainPatternCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
  }

  export type DomainBestPracticeUncheckedCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainBestPracticeCreateWithoutDomainKnowledgeInput, DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput> | DomainBestPracticeCreateWithoutDomainKnowledgeInput[] | DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainBestPracticeCreateOrConnectWithoutDomainKnowledgeInput | DomainBestPracticeCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainBestPracticeCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
  }

  export type DomainAntiPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainAntiPatternCreateWithoutDomainKnowledgeInput, DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput> | DomainAntiPatternCreateWithoutDomainKnowledgeInput[] | DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainAntiPatternCreateOrConnectWithoutDomainKnowledgeInput | DomainAntiPatternCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainAntiPatternCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
  }

  export type DomainReferenceUncheckedCreateNestedManyWithoutDomainKnowledgeInput = {
    create?: XOR<DomainReferenceCreateWithoutDomainKnowledgeInput, DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput> | DomainReferenceCreateWithoutDomainKnowledgeInput[] | DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainReferenceCreateOrConnectWithoutDomainKnowledgeInput | DomainReferenceCreateOrConnectWithoutDomainKnowledgeInput[]
    createMany?: DomainReferenceCreateManyDomainKnowledgeInputEnvelope
    connect?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
  }

  export type EnumKnowledgeCategoryFieldUpdateOperationsInput = {
    set?: $Enums.KnowledgeCategory
  }

  export type DomainKnowledgeUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutDomainKnowledgeNestedInput = {
    create?: XOR<ProjectCreateWithoutDomainKnowledgeInput, ProjectUncheckedCreateWithoutDomainKnowledgeInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDomainKnowledgeInput
    upsert?: ProjectUpsertWithoutDomainKnowledgeInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDomainKnowledgeInput, ProjectUpdateWithoutDomainKnowledgeInput>, ProjectUncheckedUpdateWithoutDomainKnowledgeInput>
  }

  export type DomainConceptUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainConceptCreateWithoutDomainKnowledgeInput, DomainConceptUncheckedCreateWithoutDomainKnowledgeInput> | DomainConceptCreateWithoutDomainKnowledgeInput[] | DomainConceptUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainConceptCreateOrConnectWithoutDomainKnowledgeInput | DomainConceptCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainConceptUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainConceptUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainConceptCreateManyDomainKnowledgeInputEnvelope
    set?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
    disconnect?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
    delete?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
    connect?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
    update?: DomainConceptUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainConceptUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainConceptUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainConceptUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainConceptScalarWhereInput | DomainConceptScalarWhereInput[]
  }

  export type DomainPatternUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainPatternCreateWithoutDomainKnowledgeInput, DomainPatternUncheckedCreateWithoutDomainKnowledgeInput> | DomainPatternCreateWithoutDomainKnowledgeInput[] | DomainPatternUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainPatternCreateOrConnectWithoutDomainKnowledgeInput | DomainPatternCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainPatternCreateManyDomainKnowledgeInputEnvelope
    set?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
    disconnect?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
    delete?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
    connect?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
    update?: DomainPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainPatternUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainPatternUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainPatternScalarWhereInput | DomainPatternScalarWhereInput[]
  }

  export type DomainBestPracticeUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainBestPracticeCreateWithoutDomainKnowledgeInput, DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput> | DomainBestPracticeCreateWithoutDomainKnowledgeInput[] | DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainBestPracticeCreateOrConnectWithoutDomainKnowledgeInput | DomainBestPracticeCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainBestPracticeUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainBestPracticeUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainBestPracticeCreateManyDomainKnowledgeInputEnvelope
    set?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
    disconnect?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
    delete?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
    connect?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
    update?: DomainBestPracticeUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainBestPracticeUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainBestPracticeUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainBestPracticeUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainBestPracticeScalarWhereInput | DomainBestPracticeScalarWhereInput[]
  }

  export type DomainAntiPatternUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainAntiPatternCreateWithoutDomainKnowledgeInput, DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput> | DomainAntiPatternCreateWithoutDomainKnowledgeInput[] | DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainAntiPatternCreateOrConnectWithoutDomainKnowledgeInput | DomainAntiPatternCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainAntiPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainAntiPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainAntiPatternCreateManyDomainKnowledgeInputEnvelope
    set?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
    disconnect?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
    delete?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
    connect?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
    update?: DomainAntiPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainAntiPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainAntiPatternUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainAntiPatternUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainAntiPatternScalarWhereInput | DomainAntiPatternScalarWhereInput[]
  }

  export type DomainReferenceUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainReferenceCreateWithoutDomainKnowledgeInput, DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput> | DomainReferenceCreateWithoutDomainKnowledgeInput[] | DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainReferenceCreateOrConnectWithoutDomainKnowledgeInput | DomainReferenceCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainReferenceUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainReferenceUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainReferenceCreateManyDomainKnowledgeInputEnvelope
    set?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
    disconnect?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
    delete?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
    connect?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
    update?: DomainReferenceUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainReferenceUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainReferenceUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainReferenceUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainReferenceScalarWhereInput | DomainReferenceScalarWhereInput[]
  }

  export type UserUpdateOneWithoutDomainKnowledgeNestedInput = {
    create?: XOR<UserCreateWithoutDomainKnowledgeInput, UserUncheckedCreateWithoutDomainKnowledgeInput>
    connectOrCreate?: UserCreateOrConnectWithoutDomainKnowledgeInput
    upsert?: UserUpsertWithoutDomainKnowledgeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDomainKnowledgeInput, UserUpdateWithoutDomainKnowledgeInput>, UserUncheckedUpdateWithoutDomainKnowledgeInput>
  }

  export type DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainConceptCreateWithoutDomainKnowledgeInput, DomainConceptUncheckedCreateWithoutDomainKnowledgeInput> | DomainConceptCreateWithoutDomainKnowledgeInput[] | DomainConceptUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainConceptCreateOrConnectWithoutDomainKnowledgeInput | DomainConceptCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainConceptUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainConceptUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainConceptCreateManyDomainKnowledgeInputEnvelope
    set?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
    disconnect?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
    delete?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
    connect?: DomainConceptWhereUniqueInput | DomainConceptWhereUniqueInput[]
    update?: DomainConceptUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainConceptUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainConceptUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainConceptUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainConceptScalarWhereInput | DomainConceptScalarWhereInput[]
  }

  export type DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainPatternCreateWithoutDomainKnowledgeInput, DomainPatternUncheckedCreateWithoutDomainKnowledgeInput> | DomainPatternCreateWithoutDomainKnowledgeInput[] | DomainPatternUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainPatternCreateOrConnectWithoutDomainKnowledgeInput | DomainPatternCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainPatternCreateManyDomainKnowledgeInputEnvelope
    set?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
    disconnect?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
    delete?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
    connect?: DomainPatternWhereUniqueInput | DomainPatternWhereUniqueInput[]
    update?: DomainPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainPatternUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainPatternUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainPatternScalarWhereInput | DomainPatternScalarWhereInput[]
  }

  export type DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainBestPracticeCreateWithoutDomainKnowledgeInput, DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput> | DomainBestPracticeCreateWithoutDomainKnowledgeInput[] | DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainBestPracticeCreateOrConnectWithoutDomainKnowledgeInput | DomainBestPracticeCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainBestPracticeUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainBestPracticeUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainBestPracticeCreateManyDomainKnowledgeInputEnvelope
    set?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
    disconnect?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
    delete?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
    connect?: DomainBestPracticeWhereUniqueInput | DomainBestPracticeWhereUniqueInput[]
    update?: DomainBestPracticeUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainBestPracticeUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainBestPracticeUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainBestPracticeUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainBestPracticeScalarWhereInput | DomainBestPracticeScalarWhereInput[]
  }

  export type DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainAntiPatternCreateWithoutDomainKnowledgeInput, DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput> | DomainAntiPatternCreateWithoutDomainKnowledgeInput[] | DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainAntiPatternCreateOrConnectWithoutDomainKnowledgeInput | DomainAntiPatternCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainAntiPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainAntiPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainAntiPatternCreateManyDomainKnowledgeInputEnvelope
    set?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
    disconnect?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
    delete?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
    connect?: DomainAntiPatternWhereUniqueInput | DomainAntiPatternWhereUniqueInput[]
    update?: DomainAntiPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainAntiPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainAntiPatternUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainAntiPatternUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainAntiPatternScalarWhereInput | DomainAntiPatternScalarWhereInput[]
  }

  export type DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeNestedInput = {
    create?: XOR<DomainReferenceCreateWithoutDomainKnowledgeInput, DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput> | DomainReferenceCreateWithoutDomainKnowledgeInput[] | DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput[]
    connectOrCreate?: DomainReferenceCreateOrConnectWithoutDomainKnowledgeInput | DomainReferenceCreateOrConnectWithoutDomainKnowledgeInput[]
    upsert?: DomainReferenceUpsertWithWhereUniqueWithoutDomainKnowledgeInput | DomainReferenceUpsertWithWhereUniqueWithoutDomainKnowledgeInput[]
    createMany?: DomainReferenceCreateManyDomainKnowledgeInputEnvelope
    set?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
    disconnect?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
    delete?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
    connect?: DomainReferenceWhereUniqueInput | DomainReferenceWhereUniqueInput[]
    update?: DomainReferenceUpdateWithWhereUniqueWithoutDomainKnowledgeInput | DomainReferenceUpdateWithWhereUniqueWithoutDomainKnowledgeInput[]
    updateMany?: DomainReferenceUpdateManyWithWhereWithoutDomainKnowledgeInput | DomainReferenceUpdateManyWithWhereWithoutDomainKnowledgeInput[]
    deleteMany?: DomainReferenceScalarWhereInput | DomainReferenceScalarWhereInput[]
  }

  export type DomainConceptCreateexamplesInput = {
    set: string[]
  }

  export type DomainConceptCreaterelatedConceptsInput = {
    set: string[]
  }

  export type DomainKnowledgeCreateNestedOneWithoutConceptsInput = {
    create?: XOR<DomainKnowledgeCreateWithoutConceptsInput, DomainKnowledgeUncheckedCreateWithoutConceptsInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutConceptsInput
    connect?: DomainKnowledgeWhereUniqueInput
  }

  export type DomainConceptUpdateexamplesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DomainConceptUpdaterelatedConceptsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DomainKnowledgeUpdateOneRequiredWithoutConceptsNestedInput = {
    create?: XOR<DomainKnowledgeCreateWithoutConceptsInput, DomainKnowledgeUncheckedCreateWithoutConceptsInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutConceptsInput
    upsert?: DomainKnowledgeUpsertWithoutConceptsInput
    connect?: DomainKnowledgeWhereUniqueInput
    update?: XOR<XOR<DomainKnowledgeUpdateToOneWithWhereWithoutConceptsInput, DomainKnowledgeUpdateWithoutConceptsInput>, DomainKnowledgeUncheckedUpdateWithoutConceptsInput>
  }

  export type DomainPatternCreateexamplesInput = {
    set: string[]
  }

  export type DomainKnowledgeCreateNestedOneWithoutPatternsInput = {
    create?: XOR<DomainKnowledgeCreateWithoutPatternsInput, DomainKnowledgeUncheckedCreateWithoutPatternsInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutPatternsInput
    connect?: DomainKnowledgeWhereUniqueInput
  }

  export type DomainPatternUpdateexamplesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DomainKnowledgeUpdateOneRequiredWithoutPatternsNestedInput = {
    create?: XOR<DomainKnowledgeCreateWithoutPatternsInput, DomainKnowledgeUncheckedCreateWithoutPatternsInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutPatternsInput
    upsert?: DomainKnowledgeUpsertWithoutPatternsInput
    connect?: DomainKnowledgeWhereUniqueInput
    update?: XOR<XOR<DomainKnowledgeUpdateToOneWithWhereWithoutPatternsInput, DomainKnowledgeUpdateWithoutPatternsInput>, DomainKnowledgeUncheckedUpdateWithoutPatternsInput>
  }

  export type DomainBestPracticeCreatebenefitsInput = {
    set: string[]
  }

  export type DomainBestPracticeCreateconsiderationsInput = {
    set: string[]
  }

  export type DomainKnowledgeCreateNestedOneWithoutBestPracticesInput = {
    create?: XOR<DomainKnowledgeCreateWithoutBestPracticesInput, DomainKnowledgeUncheckedCreateWithoutBestPracticesInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutBestPracticesInput
    connect?: DomainKnowledgeWhereUniqueInput
  }

  export type DomainBestPracticeUpdatebenefitsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DomainBestPracticeUpdateconsiderationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DomainKnowledgeUpdateOneRequiredWithoutBestPracticesNestedInput = {
    create?: XOR<DomainKnowledgeCreateWithoutBestPracticesInput, DomainKnowledgeUncheckedCreateWithoutBestPracticesInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutBestPracticesInput
    upsert?: DomainKnowledgeUpsertWithoutBestPracticesInput
    connect?: DomainKnowledgeWhereUniqueInput
    update?: XOR<XOR<DomainKnowledgeUpdateToOneWithWhereWithoutBestPracticesInput, DomainKnowledgeUpdateWithoutBestPracticesInput>, DomainKnowledgeUncheckedUpdateWithoutBestPracticesInput>
  }

  export type DomainAntiPatternCreatesymptomsInput = {
    set: string[]
  }

  export type DomainAntiPatternCreatecausesInput = {
    set: string[]
  }

  export type DomainAntiPatternCreateconsequencesInput = {
    set: string[]
  }

  export type DomainKnowledgeCreateNestedOneWithoutAntiPatternsInput = {
    create?: XOR<DomainKnowledgeCreateWithoutAntiPatternsInput, DomainKnowledgeUncheckedCreateWithoutAntiPatternsInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutAntiPatternsInput
    connect?: DomainKnowledgeWhereUniqueInput
  }

  export type DomainAntiPatternUpdatesymptomsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DomainAntiPatternUpdatecausesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DomainAntiPatternUpdateconsequencesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type DomainKnowledgeUpdateOneRequiredWithoutAntiPatternsNestedInput = {
    create?: XOR<DomainKnowledgeCreateWithoutAntiPatternsInput, DomainKnowledgeUncheckedCreateWithoutAntiPatternsInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutAntiPatternsInput
    upsert?: DomainKnowledgeUpsertWithoutAntiPatternsInput
    connect?: DomainKnowledgeWhereUniqueInput
    update?: XOR<XOR<DomainKnowledgeUpdateToOneWithWhereWithoutAntiPatternsInput, DomainKnowledgeUpdateWithoutAntiPatternsInput>, DomainKnowledgeUncheckedUpdateWithoutAntiPatternsInput>
  }

  export type DomainKnowledgeCreateNestedOneWithoutReferencesInput = {
    create?: XOR<DomainKnowledgeCreateWithoutReferencesInput, DomainKnowledgeUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutReferencesInput
    connect?: DomainKnowledgeWhereUniqueInput
  }

  export type DomainKnowledgeUpdateOneRequiredWithoutReferencesNestedInput = {
    create?: XOR<DomainKnowledgeCreateWithoutReferencesInput, DomainKnowledgeUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutReferencesInput
    upsert?: DomainKnowledgeUpsertWithoutReferencesInput
    connect?: DomainKnowledgeWhereUniqueInput
    update?: XOR<XOR<DomainKnowledgeUpdateToOneWithWhereWithoutReferencesInput, DomainKnowledgeUpdateWithoutReferencesInput>, DomainKnowledgeUncheckedUpdateWithoutReferencesInput>
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DocumentationCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentationCreateWithoutProjectInput, DocumentationUncheckedCreateWithoutProjectInput> | DocumentationCreateWithoutProjectInput[] | DocumentationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutProjectInput | DocumentationCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentationCreateManyProjectInputEnvelope
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
  }

  export type MindMapCreateNestedManyWithoutProjectInput = {
    create?: XOR<MindMapCreateWithoutProjectInput, MindMapUncheckedCreateWithoutProjectInput> | MindMapCreateWithoutProjectInput[] | MindMapUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MindMapCreateOrConnectWithoutProjectInput | MindMapCreateOrConnectWithoutProjectInput[]
    createMany?: MindMapCreateManyProjectInputEnvelope
    connect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
  }

  export type SprintCreateNestedManyWithoutProjectInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type RequirementCreateNestedManyWithoutProjectInput = {
    create?: XOR<RequirementCreateWithoutProjectInput, RequirementUncheckedCreateWithoutProjectInput> | RequirementCreateWithoutProjectInput[] | RequirementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutProjectInput | RequirementCreateOrConnectWithoutProjectInput[]
    createMany?: RequirementCreateManyProjectInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type DomainKnowledgeCreateNestedManyWithoutProjectInput = {
    create?: XOR<DomainKnowledgeCreateWithoutProjectInput, DomainKnowledgeUncheckedCreateWithoutProjectInput> | DomainKnowledgeCreateWithoutProjectInput[] | DomainKnowledgeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutProjectInput | DomainKnowledgeCreateOrConnectWithoutProjectInput[]
    createMany?: DomainKnowledgeCreateManyProjectInputEnvelope
    connect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
  }

  export type SystemArchitectureCreateNestedManyWithoutProjectInput = {
    create?: XOR<SystemArchitectureCreateWithoutProjectInput, SystemArchitectureUncheckedCreateWithoutProjectInput> | SystemArchitectureCreateWithoutProjectInput[] | SystemArchitectureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutProjectInput | SystemArchitectureCreateOrConnectWithoutProjectInput[]
    createMany?: SystemArchitectureCreateManyProjectInputEnvelope
    connect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
  }

  export type RoadmapCreateNestedManyWithoutProjectInput = {
    create?: XOR<RoadmapCreateWithoutProjectInput, RoadmapUncheckedCreateWithoutProjectInput> | RoadmapCreateWithoutProjectInput[] | RoadmapUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutProjectInput | RoadmapCreateOrConnectWithoutProjectInput[]
    createMany?: RoadmapCreateManyProjectInputEnvelope
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
  }

  export type ApiDesignCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiDesignCreateWithoutProjectInput, ApiDesignUncheckedCreateWithoutProjectInput> | ApiDesignCreateWithoutProjectInput[] | ApiDesignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiDesignCreateOrConnectWithoutProjectInput | ApiDesignCreateOrConnectWithoutProjectInput[]
    createMany?: ApiDesignCreateManyProjectInputEnvelope
    connect?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutProjectInput = {
    create?: XOR<TeamCreateWithoutProjectInput, TeamUncheckedCreateWithoutProjectInput> | TeamCreateWithoutProjectInput[] | TeamUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutProjectInput | TeamCreateOrConnectWithoutProjectInput[]
    createMany?: TeamCreateManyProjectInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutProjectInput = {
    create?: XOR<AgentCreateWithoutProjectInput, AgentUncheckedCreateWithoutProjectInput> | AgentCreateWithoutProjectInput[] | AgentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutProjectInput | AgentCreateOrConnectWithoutProjectInput[]
    createMany?: AgentCreateManyProjectInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type AgentWorklogCreateNestedManyWithoutProjectInput = {
    create?: XOR<AgentWorklogCreateWithoutProjectInput, AgentWorklogUncheckedCreateWithoutProjectInput> | AgentWorklogCreateWithoutProjectInput[] | AgentWorklogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutProjectInput | AgentWorklogCreateOrConnectWithoutProjectInput[]
    createMany?: AgentWorklogCreateManyProjectInputEnvelope
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
  }

  export type DatabaseSchemaCreateNestedManyWithoutProjectInput = {
    create?: XOR<DatabaseSchemaCreateWithoutProjectInput, DatabaseSchemaUncheckedCreateWithoutProjectInput> | DatabaseSchemaCreateWithoutProjectInput[] | DatabaseSchemaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutProjectInput | DatabaseSchemaCreateOrConnectWithoutProjectInput[]
    createMany?: DatabaseSchemaCreateManyProjectInputEnvelope
    connect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
  }

  export type RequirementQuestionCreateNestedManyWithoutProjectInput = {
    create?: XOR<RequirementQuestionCreateWithoutProjectInput, RequirementQuestionUncheckedCreateWithoutProjectInput> | RequirementQuestionCreateWithoutProjectInput[] | RequirementQuestionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutProjectInput | RequirementQuestionCreateOrConnectWithoutProjectInput[]
    createMany?: RequirementQuestionCreateManyProjectInputEnvelope
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
  }

  export type RequirementAttachmentCreateNestedManyWithoutProjectInput = {
    create?: XOR<RequirementAttachmentCreateWithoutProjectInput, RequirementAttachmentUncheckedCreateWithoutProjectInput> | RequirementAttachmentCreateWithoutProjectInput[] | RequirementAttachmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutProjectInput | RequirementAttachmentCreateOrConnectWithoutProjectInput[]
    createMany?: RequirementAttachmentCreateManyProjectInputEnvelope
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DocumentationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DocumentationCreateWithoutProjectInput, DocumentationUncheckedCreateWithoutProjectInput> | DocumentationCreateWithoutProjectInput[] | DocumentationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutProjectInput | DocumentationCreateOrConnectWithoutProjectInput[]
    createMany?: DocumentationCreateManyProjectInputEnvelope
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
  }

  export type MindMapUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MindMapCreateWithoutProjectInput, MindMapUncheckedCreateWithoutProjectInput> | MindMapCreateWithoutProjectInput[] | MindMapUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MindMapCreateOrConnectWithoutProjectInput | MindMapCreateOrConnectWithoutProjectInput[]
    createMany?: MindMapCreateManyProjectInputEnvelope
    connect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
  }

  export type SprintUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
  }

  export type RequirementUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<RequirementCreateWithoutProjectInput, RequirementUncheckedCreateWithoutProjectInput> | RequirementCreateWithoutProjectInput[] | RequirementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutProjectInput | RequirementCreateOrConnectWithoutProjectInput[]
    createMany?: RequirementCreateManyProjectInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DomainKnowledgeCreateWithoutProjectInput, DomainKnowledgeUncheckedCreateWithoutProjectInput> | DomainKnowledgeCreateWithoutProjectInput[] | DomainKnowledgeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutProjectInput | DomainKnowledgeCreateOrConnectWithoutProjectInput[]
    createMany?: DomainKnowledgeCreateManyProjectInputEnvelope
    connect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
  }

  export type SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SystemArchitectureCreateWithoutProjectInput, SystemArchitectureUncheckedCreateWithoutProjectInput> | SystemArchitectureCreateWithoutProjectInput[] | SystemArchitectureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutProjectInput | SystemArchitectureCreateOrConnectWithoutProjectInput[]
    createMany?: SystemArchitectureCreateManyProjectInputEnvelope
    connect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
  }

  export type RoadmapUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<RoadmapCreateWithoutProjectInput, RoadmapUncheckedCreateWithoutProjectInput> | RoadmapCreateWithoutProjectInput[] | RoadmapUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutProjectInput | RoadmapCreateOrConnectWithoutProjectInput[]
    createMany?: RoadmapCreateManyProjectInputEnvelope
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
  }

  export type ApiDesignUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ApiDesignCreateWithoutProjectInput, ApiDesignUncheckedCreateWithoutProjectInput> | ApiDesignCreateWithoutProjectInput[] | ApiDesignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiDesignCreateOrConnectWithoutProjectInput | ApiDesignCreateOrConnectWithoutProjectInput[]
    createMany?: ApiDesignCreateManyProjectInputEnvelope
    connect?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TeamCreateWithoutProjectInput, TeamUncheckedCreateWithoutProjectInput> | TeamCreateWithoutProjectInput[] | TeamUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutProjectInput | TeamCreateOrConnectWithoutProjectInput[]
    createMany?: TeamCreateManyProjectInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AgentCreateWithoutProjectInput, AgentUncheckedCreateWithoutProjectInput> | AgentCreateWithoutProjectInput[] | AgentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutProjectInput | AgentCreateOrConnectWithoutProjectInput[]
    createMany?: AgentCreateManyProjectInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type AgentWorklogUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AgentWorklogCreateWithoutProjectInput, AgentWorklogUncheckedCreateWithoutProjectInput> | AgentWorklogCreateWithoutProjectInput[] | AgentWorklogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutProjectInput | AgentWorklogCreateOrConnectWithoutProjectInput[]
    createMany?: AgentWorklogCreateManyProjectInputEnvelope
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
  }

  export type DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DatabaseSchemaCreateWithoutProjectInput, DatabaseSchemaUncheckedCreateWithoutProjectInput> | DatabaseSchemaCreateWithoutProjectInput[] | DatabaseSchemaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutProjectInput | DatabaseSchemaCreateOrConnectWithoutProjectInput[]
    createMany?: DatabaseSchemaCreateManyProjectInputEnvelope
    connect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
  }

  export type RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<RequirementQuestionCreateWithoutProjectInput, RequirementQuestionUncheckedCreateWithoutProjectInput> | RequirementQuestionCreateWithoutProjectInput[] | RequirementQuestionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutProjectInput | RequirementQuestionCreateOrConnectWithoutProjectInput[]
    createMany?: RequirementQuestionCreateManyProjectInputEnvelope
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
  }

  export type RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<RequirementAttachmentCreateWithoutProjectInput, RequirementAttachmentUncheckedCreateWithoutProjectInput> | RequirementAttachmentCreateWithoutProjectInput[] | RequirementAttachmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutProjectInput | RequirementAttachmentCreateOrConnectWithoutProjectInput[]
    createMany?: RequirementAttachmentCreateManyProjectInputEnvelope
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DocumentationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentationCreateWithoutProjectInput, DocumentationUncheckedCreateWithoutProjectInput> | DocumentationCreateWithoutProjectInput[] | DocumentationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutProjectInput | DocumentationCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentationUpsertWithWhereUniqueWithoutProjectInput | DocumentationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentationCreateManyProjectInputEnvelope
    set?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    disconnect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    delete?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    update?: DocumentationUpdateWithWhereUniqueWithoutProjectInput | DocumentationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentationUpdateManyWithWhereWithoutProjectInput | DocumentationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentationScalarWhereInput | DocumentationScalarWhereInput[]
  }

  export type MindMapUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MindMapCreateWithoutProjectInput, MindMapUncheckedCreateWithoutProjectInput> | MindMapCreateWithoutProjectInput[] | MindMapUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MindMapCreateOrConnectWithoutProjectInput | MindMapCreateOrConnectWithoutProjectInput[]
    upsert?: MindMapUpsertWithWhereUniqueWithoutProjectInput | MindMapUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MindMapCreateManyProjectInputEnvelope
    set?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    disconnect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    delete?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    connect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    update?: MindMapUpdateWithWhereUniqueWithoutProjectInput | MindMapUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MindMapUpdateManyWithWhereWithoutProjectInput | MindMapUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MindMapScalarWhereInput | MindMapScalarWhereInput[]
  }

  export type SprintUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutProjectInput | SprintUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutProjectInput | SprintUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutProjectInput | SprintUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type RequirementUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RequirementCreateWithoutProjectInput, RequirementUncheckedCreateWithoutProjectInput> | RequirementCreateWithoutProjectInput[] | RequirementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutProjectInput | RequirementCreateOrConnectWithoutProjectInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutProjectInput | RequirementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RequirementCreateManyProjectInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutProjectInput | RequirementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutProjectInput | RequirementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type DomainKnowledgeUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DomainKnowledgeCreateWithoutProjectInput, DomainKnowledgeUncheckedCreateWithoutProjectInput> | DomainKnowledgeCreateWithoutProjectInput[] | DomainKnowledgeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutProjectInput | DomainKnowledgeCreateOrConnectWithoutProjectInput[]
    upsert?: DomainKnowledgeUpsertWithWhereUniqueWithoutProjectInput | DomainKnowledgeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DomainKnowledgeCreateManyProjectInputEnvelope
    set?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    disconnect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    delete?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    connect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    update?: DomainKnowledgeUpdateWithWhereUniqueWithoutProjectInput | DomainKnowledgeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DomainKnowledgeUpdateManyWithWhereWithoutProjectInput | DomainKnowledgeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DomainKnowledgeScalarWhereInput | DomainKnowledgeScalarWhereInput[]
  }

  export type SystemArchitectureUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SystemArchitectureCreateWithoutProjectInput, SystemArchitectureUncheckedCreateWithoutProjectInput> | SystemArchitectureCreateWithoutProjectInput[] | SystemArchitectureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutProjectInput | SystemArchitectureCreateOrConnectWithoutProjectInput[]
    upsert?: SystemArchitectureUpsertWithWhereUniqueWithoutProjectInput | SystemArchitectureUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SystemArchitectureCreateManyProjectInputEnvelope
    set?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    disconnect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    delete?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    connect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    update?: SystemArchitectureUpdateWithWhereUniqueWithoutProjectInput | SystemArchitectureUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SystemArchitectureUpdateManyWithWhereWithoutProjectInput | SystemArchitectureUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SystemArchitectureScalarWhereInput | SystemArchitectureScalarWhereInput[]
  }

  export type RoadmapUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RoadmapCreateWithoutProjectInput, RoadmapUncheckedCreateWithoutProjectInput> | RoadmapCreateWithoutProjectInput[] | RoadmapUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutProjectInput | RoadmapCreateOrConnectWithoutProjectInput[]
    upsert?: RoadmapUpsertWithWhereUniqueWithoutProjectInput | RoadmapUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RoadmapCreateManyProjectInputEnvelope
    set?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    disconnect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    delete?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    update?: RoadmapUpdateWithWhereUniqueWithoutProjectInput | RoadmapUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RoadmapUpdateManyWithWhereWithoutProjectInput | RoadmapUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
  }

  export type ApiDesignUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiDesignCreateWithoutProjectInput, ApiDesignUncheckedCreateWithoutProjectInput> | ApiDesignCreateWithoutProjectInput[] | ApiDesignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiDesignCreateOrConnectWithoutProjectInput | ApiDesignCreateOrConnectWithoutProjectInput[]
    upsert?: ApiDesignUpsertWithWhereUniqueWithoutProjectInput | ApiDesignUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiDesignCreateManyProjectInputEnvelope
    set?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
    disconnect?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
    delete?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
    connect?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
    update?: ApiDesignUpdateWithWhereUniqueWithoutProjectInput | ApiDesignUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiDesignUpdateManyWithWhereWithoutProjectInput | ApiDesignUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiDesignScalarWhereInput | ApiDesignScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TeamCreateWithoutProjectInput, TeamUncheckedCreateWithoutProjectInput> | TeamCreateWithoutProjectInput[] | TeamUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutProjectInput | TeamCreateOrConnectWithoutProjectInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutProjectInput | TeamUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TeamCreateManyProjectInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutProjectInput | TeamUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutProjectInput | TeamUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AgentCreateWithoutProjectInput, AgentUncheckedCreateWithoutProjectInput> | AgentCreateWithoutProjectInput[] | AgentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutProjectInput | AgentCreateOrConnectWithoutProjectInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutProjectInput | AgentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AgentCreateManyProjectInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutProjectInput | AgentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutProjectInput | AgentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type AgentWorklogUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AgentWorklogCreateWithoutProjectInput, AgentWorklogUncheckedCreateWithoutProjectInput> | AgentWorklogCreateWithoutProjectInput[] | AgentWorklogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutProjectInput | AgentWorklogCreateOrConnectWithoutProjectInput[]
    upsert?: AgentWorklogUpsertWithWhereUniqueWithoutProjectInput | AgentWorklogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AgentWorklogCreateManyProjectInputEnvelope
    set?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    disconnect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    delete?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    update?: AgentWorklogUpdateWithWhereUniqueWithoutProjectInput | AgentWorklogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AgentWorklogUpdateManyWithWhereWithoutProjectInput | AgentWorklogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AgentWorklogScalarWhereInput | AgentWorklogScalarWhereInput[]
  }

  export type DatabaseSchemaUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DatabaseSchemaCreateWithoutProjectInput, DatabaseSchemaUncheckedCreateWithoutProjectInput> | DatabaseSchemaCreateWithoutProjectInput[] | DatabaseSchemaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutProjectInput | DatabaseSchemaCreateOrConnectWithoutProjectInput[]
    upsert?: DatabaseSchemaUpsertWithWhereUniqueWithoutProjectInput | DatabaseSchemaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DatabaseSchemaCreateManyProjectInputEnvelope
    set?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    disconnect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    delete?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    connect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    update?: DatabaseSchemaUpdateWithWhereUniqueWithoutProjectInput | DatabaseSchemaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DatabaseSchemaUpdateManyWithWhereWithoutProjectInput | DatabaseSchemaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DatabaseSchemaScalarWhereInput | DatabaseSchemaScalarWhereInput[]
  }

  export type RequirementQuestionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RequirementQuestionCreateWithoutProjectInput, RequirementQuestionUncheckedCreateWithoutProjectInput> | RequirementQuestionCreateWithoutProjectInput[] | RequirementQuestionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutProjectInput | RequirementQuestionCreateOrConnectWithoutProjectInput[]
    upsert?: RequirementQuestionUpsertWithWhereUniqueWithoutProjectInput | RequirementQuestionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RequirementQuestionCreateManyProjectInputEnvelope
    set?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    disconnect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    delete?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    update?: RequirementQuestionUpdateWithWhereUniqueWithoutProjectInput | RequirementQuestionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RequirementQuestionUpdateManyWithWhereWithoutProjectInput | RequirementQuestionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RequirementQuestionScalarWhereInput | RequirementQuestionScalarWhereInput[]
  }

  export type RequirementAttachmentUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RequirementAttachmentCreateWithoutProjectInput, RequirementAttachmentUncheckedCreateWithoutProjectInput> | RequirementAttachmentCreateWithoutProjectInput[] | RequirementAttachmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutProjectInput | RequirementAttachmentCreateOrConnectWithoutProjectInput[]
    upsert?: RequirementAttachmentUpsertWithWhereUniqueWithoutProjectInput | RequirementAttachmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RequirementAttachmentCreateManyProjectInputEnvelope
    set?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    disconnect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    delete?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    update?: RequirementAttachmentUpdateWithWhereUniqueWithoutProjectInput | RequirementAttachmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RequirementAttachmentUpdateManyWithWhereWithoutProjectInput | RequirementAttachmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RequirementAttachmentScalarWhereInput | RequirementAttachmentScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DocumentationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DocumentationCreateWithoutProjectInput, DocumentationUncheckedCreateWithoutProjectInput> | DocumentationCreateWithoutProjectInput[] | DocumentationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutProjectInput | DocumentationCreateOrConnectWithoutProjectInput[]
    upsert?: DocumentationUpsertWithWhereUniqueWithoutProjectInput | DocumentationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DocumentationCreateManyProjectInputEnvelope
    set?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    disconnect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    delete?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    update?: DocumentationUpdateWithWhereUniqueWithoutProjectInput | DocumentationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DocumentationUpdateManyWithWhereWithoutProjectInput | DocumentationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DocumentationScalarWhereInput | DocumentationScalarWhereInput[]
  }

  export type MindMapUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MindMapCreateWithoutProjectInput, MindMapUncheckedCreateWithoutProjectInput> | MindMapCreateWithoutProjectInput[] | MindMapUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MindMapCreateOrConnectWithoutProjectInput | MindMapCreateOrConnectWithoutProjectInput[]
    upsert?: MindMapUpsertWithWhereUniqueWithoutProjectInput | MindMapUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MindMapCreateManyProjectInputEnvelope
    set?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    disconnect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    delete?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    connect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    update?: MindMapUpdateWithWhereUniqueWithoutProjectInput | MindMapUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MindMapUpdateManyWithWhereWithoutProjectInput | MindMapUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MindMapScalarWhereInput | MindMapScalarWhereInput[]
  }

  export type SprintUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput> | SprintCreateWithoutProjectInput[] | SprintUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SprintCreateOrConnectWithoutProjectInput | SprintCreateOrConnectWithoutProjectInput[]
    upsert?: SprintUpsertWithWhereUniqueWithoutProjectInput | SprintUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SprintCreateManyProjectInputEnvelope
    set?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    disconnect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    delete?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    connect?: SprintWhereUniqueInput | SprintWhereUniqueInput[]
    update?: SprintUpdateWithWhereUniqueWithoutProjectInput | SprintUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SprintUpdateManyWithWhereWithoutProjectInput | SprintUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SprintScalarWhereInput | SprintScalarWhereInput[]
  }

  export type RequirementUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RequirementCreateWithoutProjectInput, RequirementUncheckedCreateWithoutProjectInput> | RequirementCreateWithoutProjectInput[] | RequirementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutProjectInput | RequirementCreateOrConnectWithoutProjectInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutProjectInput | RequirementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RequirementCreateManyProjectInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutProjectInput | RequirementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutProjectInput | RequirementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DomainKnowledgeCreateWithoutProjectInput, DomainKnowledgeUncheckedCreateWithoutProjectInput> | DomainKnowledgeCreateWithoutProjectInput[] | DomainKnowledgeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutProjectInput | DomainKnowledgeCreateOrConnectWithoutProjectInput[]
    upsert?: DomainKnowledgeUpsertWithWhereUniqueWithoutProjectInput | DomainKnowledgeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DomainKnowledgeCreateManyProjectInputEnvelope
    set?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    disconnect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    delete?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    connect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    update?: DomainKnowledgeUpdateWithWhereUniqueWithoutProjectInput | DomainKnowledgeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DomainKnowledgeUpdateManyWithWhereWithoutProjectInput | DomainKnowledgeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DomainKnowledgeScalarWhereInput | DomainKnowledgeScalarWhereInput[]
  }

  export type SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SystemArchitectureCreateWithoutProjectInput, SystemArchitectureUncheckedCreateWithoutProjectInput> | SystemArchitectureCreateWithoutProjectInput[] | SystemArchitectureUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SystemArchitectureCreateOrConnectWithoutProjectInput | SystemArchitectureCreateOrConnectWithoutProjectInput[]
    upsert?: SystemArchitectureUpsertWithWhereUniqueWithoutProjectInput | SystemArchitectureUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SystemArchitectureCreateManyProjectInputEnvelope
    set?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    disconnect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    delete?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    connect?: SystemArchitectureWhereUniqueInput | SystemArchitectureWhereUniqueInput[]
    update?: SystemArchitectureUpdateWithWhereUniqueWithoutProjectInput | SystemArchitectureUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SystemArchitectureUpdateManyWithWhereWithoutProjectInput | SystemArchitectureUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SystemArchitectureScalarWhereInput | SystemArchitectureScalarWhereInput[]
  }

  export type RoadmapUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RoadmapCreateWithoutProjectInput, RoadmapUncheckedCreateWithoutProjectInput> | RoadmapCreateWithoutProjectInput[] | RoadmapUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutProjectInput | RoadmapCreateOrConnectWithoutProjectInput[]
    upsert?: RoadmapUpsertWithWhereUniqueWithoutProjectInput | RoadmapUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RoadmapCreateManyProjectInputEnvelope
    set?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    disconnect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    delete?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    update?: RoadmapUpdateWithWhereUniqueWithoutProjectInput | RoadmapUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RoadmapUpdateManyWithWhereWithoutProjectInput | RoadmapUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
  }

  export type ApiDesignUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ApiDesignCreateWithoutProjectInput, ApiDesignUncheckedCreateWithoutProjectInput> | ApiDesignCreateWithoutProjectInput[] | ApiDesignUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ApiDesignCreateOrConnectWithoutProjectInput | ApiDesignCreateOrConnectWithoutProjectInput[]
    upsert?: ApiDesignUpsertWithWhereUniqueWithoutProjectInput | ApiDesignUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ApiDesignCreateManyProjectInputEnvelope
    set?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
    disconnect?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
    delete?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
    connect?: ApiDesignWhereUniqueInput | ApiDesignWhereUniqueInput[]
    update?: ApiDesignUpdateWithWhereUniqueWithoutProjectInput | ApiDesignUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ApiDesignUpdateManyWithWhereWithoutProjectInput | ApiDesignUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ApiDesignScalarWhereInput | ApiDesignScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TeamCreateWithoutProjectInput, TeamUncheckedCreateWithoutProjectInput> | TeamCreateWithoutProjectInput[] | TeamUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutProjectInput | TeamCreateOrConnectWithoutProjectInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutProjectInput | TeamUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TeamCreateManyProjectInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutProjectInput | TeamUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutProjectInput | TeamUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AgentCreateWithoutProjectInput, AgentUncheckedCreateWithoutProjectInput> | AgentCreateWithoutProjectInput[] | AgentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutProjectInput | AgentCreateOrConnectWithoutProjectInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutProjectInput | AgentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AgentCreateManyProjectInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutProjectInput | AgentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutProjectInput | AgentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AgentWorklogCreateWithoutProjectInput, AgentWorklogUncheckedCreateWithoutProjectInput> | AgentWorklogCreateWithoutProjectInput[] | AgentWorklogUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutProjectInput | AgentWorklogCreateOrConnectWithoutProjectInput[]
    upsert?: AgentWorklogUpsertWithWhereUniqueWithoutProjectInput | AgentWorklogUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AgentWorklogCreateManyProjectInputEnvelope
    set?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    disconnect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    delete?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    update?: AgentWorklogUpdateWithWhereUniqueWithoutProjectInput | AgentWorklogUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AgentWorklogUpdateManyWithWhereWithoutProjectInput | AgentWorklogUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AgentWorklogScalarWhereInput | AgentWorklogScalarWhereInput[]
  }

  export type DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DatabaseSchemaCreateWithoutProjectInput, DatabaseSchemaUncheckedCreateWithoutProjectInput> | DatabaseSchemaCreateWithoutProjectInput[] | DatabaseSchemaUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutProjectInput | DatabaseSchemaCreateOrConnectWithoutProjectInput[]
    upsert?: DatabaseSchemaUpsertWithWhereUniqueWithoutProjectInput | DatabaseSchemaUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DatabaseSchemaCreateManyProjectInputEnvelope
    set?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    disconnect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    delete?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    connect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    update?: DatabaseSchemaUpdateWithWhereUniqueWithoutProjectInput | DatabaseSchemaUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DatabaseSchemaUpdateManyWithWhereWithoutProjectInput | DatabaseSchemaUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DatabaseSchemaScalarWhereInput | DatabaseSchemaScalarWhereInput[]
  }

  export type RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RequirementQuestionCreateWithoutProjectInput, RequirementQuestionUncheckedCreateWithoutProjectInput> | RequirementQuestionCreateWithoutProjectInput[] | RequirementQuestionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutProjectInput | RequirementQuestionCreateOrConnectWithoutProjectInput[]
    upsert?: RequirementQuestionUpsertWithWhereUniqueWithoutProjectInput | RequirementQuestionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RequirementQuestionCreateManyProjectInputEnvelope
    set?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    disconnect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    delete?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    update?: RequirementQuestionUpdateWithWhereUniqueWithoutProjectInput | RequirementQuestionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RequirementQuestionUpdateManyWithWhereWithoutProjectInput | RequirementQuestionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RequirementQuestionScalarWhereInput | RequirementQuestionScalarWhereInput[]
  }

  export type RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<RequirementAttachmentCreateWithoutProjectInput, RequirementAttachmentUncheckedCreateWithoutProjectInput> | RequirementAttachmentCreateWithoutProjectInput[] | RequirementAttachmentUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutProjectInput | RequirementAttachmentCreateOrConnectWithoutProjectInput[]
    upsert?: RequirementAttachmentUpsertWithWhereUniqueWithoutProjectInput | RequirementAttachmentUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: RequirementAttachmentCreateManyProjectInputEnvelope
    set?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    disconnect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    delete?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    update?: RequirementAttachmentUpdateWithWhereUniqueWithoutProjectInput | RequirementAttachmentUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: RequirementAttachmentUpdateManyWithWhereWithoutProjectInput | RequirementAttachmentUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: RequirementAttachmentScalarWhereInput | RequirementAttachmentScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutRequirementInput = {
    create?: XOR<ProjectCreateWithoutRequirementInput, ProjectUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRequirementInput
    connect?: ProjectWhereUniqueInput
  }

  export type RequirementCreateNestedOneWithoutChildrenInput = {
    create?: XOR<RequirementCreateWithoutChildrenInput, RequirementUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutChildrenInput
    connect?: RequirementWhereUniqueInput
  }

  export type RequirementCreateNestedManyWithoutParentInput = {
    create?: XOR<RequirementCreateWithoutParentInput, RequirementUncheckedCreateWithoutParentInput> | RequirementCreateWithoutParentInput[] | RequirementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutParentInput | RequirementCreateOrConnectWithoutParentInput[]
    createMany?: RequirementCreateManyParentInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type RequirementQuestionCreateNestedManyWithoutRequirementInput = {
    create?: XOR<RequirementQuestionCreateWithoutRequirementInput, RequirementQuestionUncheckedCreateWithoutRequirementInput> | RequirementQuestionCreateWithoutRequirementInput[] | RequirementQuestionUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutRequirementInput | RequirementQuestionCreateOrConnectWithoutRequirementInput[]
    createMany?: RequirementQuestionCreateManyRequirementInputEnvelope
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
  }

  export type RequirementAttachmentCreateNestedManyWithoutRequirementInput = {
    create?: XOR<RequirementAttachmentCreateWithoutRequirementInput, RequirementAttachmentUncheckedCreateWithoutRequirementInput> | RequirementAttachmentCreateWithoutRequirementInput[] | RequirementAttachmentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutRequirementInput | RequirementAttachmentCreateOrConnectWithoutRequirementInput[]
    createMany?: RequirementAttachmentCreateManyRequirementInputEnvelope
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutRequirementInput = {
    create?: XOR<UserCreateWithoutRequirementInput, UserUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequirementInput
    connect?: UserWhereUniqueInput
  }

  export type RequirementUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<RequirementCreateWithoutParentInput, RequirementUncheckedCreateWithoutParentInput> | RequirementCreateWithoutParentInput[] | RequirementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutParentInput | RequirementCreateOrConnectWithoutParentInput[]
    createMany?: RequirementCreateManyParentInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type RequirementQuestionUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<RequirementQuestionCreateWithoutRequirementInput, RequirementQuestionUncheckedCreateWithoutRequirementInput> | RequirementQuestionCreateWithoutRequirementInput[] | RequirementQuestionUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutRequirementInput | RequirementQuestionCreateOrConnectWithoutRequirementInput[]
    createMany?: RequirementQuestionCreateManyRequirementInputEnvelope
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
  }

  export type RequirementAttachmentUncheckedCreateNestedManyWithoutRequirementInput = {
    create?: XOR<RequirementAttachmentCreateWithoutRequirementInput, RequirementAttachmentUncheckedCreateWithoutRequirementInput> | RequirementAttachmentCreateWithoutRequirementInput[] | RequirementAttachmentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutRequirementInput | RequirementAttachmentCreateOrConnectWithoutRequirementInput[]
    createMany?: RequirementAttachmentCreateManyRequirementInputEnvelope
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
  }

  export type EnumRequirementTypeFieldUpdateOperationsInput = {
    set?: $Enums.RequirementType
  }

  export type EnumRequirementPriorityFieldUpdateOperationsInput = {
    set?: $Enums.RequirementPriority
  }

  export type EnumRequirementStatusFieldUpdateOperationsInput = {
    set?: $Enums.RequirementStatus
  }

  export type EnumRequirementSourceFieldUpdateOperationsInput = {
    set?: $Enums.RequirementSource
  }

  export type ProjectUpdateOneRequiredWithoutRequirementNestedInput = {
    create?: XOR<ProjectCreateWithoutRequirementInput, ProjectUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRequirementInput
    upsert?: ProjectUpsertWithoutRequirementInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRequirementInput, ProjectUpdateWithoutRequirementInput>, ProjectUncheckedUpdateWithoutRequirementInput>
  }

  export type RequirementUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<RequirementCreateWithoutChildrenInput, RequirementUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutChildrenInput
    upsert?: RequirementUpsertWithoutChildrenInput
    disconnect?: RequirementWhereInput | boolean
    delete?: RequirementWhereInput | boolean
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutChildrenInput, RequirementUpdateWithoutChildrenInput>, RequirementUncheckedUpdateWithoutChildrenInput>
  }

  export type RequirementUpdateManyWithoutParentNestedInput = {
    create?: XOR<RequirementCreateWithoutParentInput, RequirementUncheckedCreateWithoutParentInput> | RequirementCreateWithoutParentInput[] | RequirementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutParentInput | RequirementCreateOrConnectWithoutParentInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutParentInput | RequirementUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RequirementCreateManyParentInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutParentInput | RequirementUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutParentInput | RequirementUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type RequirementQuestionUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<RequirementQuestionCreateWithoutRequirementInput, RequirementQuestionUncheckedCreateWithoutRequirementInput> | RequirementQuestionCreateWithoutRequirementInput[] | RequirementQuestionUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutRequirementInput | RequirementQuestionCreateOrConnectWithoutRequirementInput[]
    upsert?: RequirementQuestionUpsertWithWhereUniqueWithoutRequirementInput | RequirementQuestionUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: RequirementQuestionCreateManyRequirementInputEnvelope
    set?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    disconnect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    delete?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    update?: RequirementQuestionUpdateWithWhereUniqueWithoutRequirementInput | RequirementQuestionUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: RequirementQuestionUpdateManyWithWhereWithoutRequirementInput | RequirementQuestionUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: RequirementQuestionScalarWhereInput | RequirementQuestionScalarWhereInput[]
  }

  export type RequirementAttachmentUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<RequirementAttachmentCreateWithoutRequirementInput, RequirementAttachmentUncheckedCreateWithoutRequirementInput> | RequirementAttachmentCreateWithoutRequirementInput[] | RequirementAttachmentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutRequirementInput | RequirementAttachmentCreateOrConnectWithoutRequirementInput[]
    upsert?: RequirementAttachmentUpsertWithWhereUniqueWithoutRequirementInput | RequirementAttachmentUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: RequirementAttachmentCreateManyRequirementInputEnvelope
    set?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    disconnect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    delete?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    update?: RequirementAttachmentUpdateWithWhereUniqueWithoutRequirementInput | RequirementAttachmentUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: RequirementAttachmentUpdateManyWithWhereWithoutRequirementInput | RequirementAttachmentUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: RequirementAttachmentScalarWhereInput | RequirementAttachmentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutRequirementNestedInput = {
    create?: XOR<UserCreateWithoutRequirementInput, UserUncheckedCreateWithoutRequirementInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequirementInput
    upsert?: UserUpsertWithoutRequirementInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequirementInput, UserUpdateWithoutRequirementInput>, UserUncheckedUpdateWithoutRequirementInput>
  }

  export type RequirementUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<RequirementCreateWithoutParentInput, RequirementUncheckedCreateWithoutParentInput> | RequirementCreateWithoutParentInput[] | RequirementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutParentInput | RequirementCreateOrConnectWithoutParentInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutParentInput | RequirementUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RequirementCreateManyParentInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutParentInput | RequirementUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutParentInput | RequirementUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type RequirementQuestionUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<RequirementQuestionCreateWithoutRequirementInput, RequirementQuestionUncheckedCreateWithoutRequirementInput> | RequirementQuestionCreateWithoutRequirementInput[] | RequirementQuestionUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementQuestionCreateOrConnectWithoutRequirementInput | RequirementQuestionCreateOrConnectWithoutRequirementInput[]
    upsert?: RequirementQuestionUpsertWithWhereUniqueWithoutRequirementInput | RequirementQuestionUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: RequirementQuestionCreateManyRequirementInputEnvelope
    set?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    disconnect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    delete?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    connect?: RequirementQuestionWhereUniqueInput | RequirementQuestionWhereUniqueInput[]
    update?: RequirementQuestionUpdateWithWhereUniqueWithoutRequirementInput | RequirementQuestionUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: RequirementQuestionUpdateManyWithWhereWithoutRequirementInput | RequirementQuestionUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: RequirementQuestionScalarWhereInput | RequirementQuestionScalarWhereInput[]
  }

  export type RequirementAttachmentUncheckedUpdateManyWithoutRequirementNestedInput = {
    create?: XOR<RequirementAttachmentCreateWithoutRequirementInput, RequirementAttachmentUncheckedCreateWithoutRequirementInput> | RequirementAttachmentCreateWithoutRequirementInput[] | RequirementAttachmentUncheckedCreateWithoutRequirementInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutRequirementInput | RequirementAttachmentCreateOrConnectWithoutRequirementInput[]
    upsert?: RequirementAttachmentUpsertWithWhereUniqueWithoutRequirementInput | RequirementAttachmentUpsertWithWhereUniqueWithoutRequirementInput[]
    createMany?: RequirementAttachmentCreateManyRequirementInputEnvelope
    set?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    disconnect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    delete?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    update?: RequirementAttachmentUpdateWithWhereUniqueWithoutRequirementInput | RequirementAttachmentUpdateWithWhereUniqueWithoutRequirementInput[]
    updateMany?: RequirementAttachmentUpdateManyWithWhereWithoutRequirementInput | RequirementAttachmentUpdateManyWithWhereWithoutRequirementInput[]
    deleteMany?: RequirementAttachmentScalarWhereInput | RequirementAttachmentScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutRequirementQuestionInput = {
    create?: XOR<ProjectCreateWithoutRequirementQuestionInput, ProjectUncheckedCreateWithoutRequirementQuestionInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRequirementQuestionInput
    connect?: ProjectWhereUniqueInput
  }

  export type RequirementCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<RequirementCreateWithoutQuestionsInput, RequirementUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutQuestionsInput
    connect?: RequirementWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutRequirementQuestionInput = {
    create?: XOR<AgentCreateWithoutRequirementQuestionInput, AgentUncheckedCreateWithoutRequirementQuestionInput>
    connectOrCreate?: AgentCreateOrConnectWithoutRequirementQuestionInput
    connect?: AgentWhereUniqueInput
  }

  export type EnumQuestionStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuestionStatus
  }

  export type EnumQuestionPriorityFieldUpdateOperationsInput = {
    set?: $Enums.QuestionPriority
  }

  export type ProjectUpdateOneRequiredWithoutRequirementQuestionNestedInput = {
    create?: XOR<ProjectCreateWithoutRequirementQuestionInput, ProjectUncheckedCreateWithoutRequirementQuestionInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRequirementQuestionInput
    upsert?: ProjectUpsertWithoutRequirementQuestionInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRequirementQuestionInput, ProjectUpdateWithoutRequirementQuestionInput>, ProjectUncheckedUpdateWithoutRequirementQuestionInput>
  }

  export type RequirementUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<RequirementCreateWithoutQuestionsInput, RequirementUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutQuestionsInput
    upsert?: RequirementUpsertWithoutQuestionsInput
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutQuestionsInput, RequirementUpdateWithoutQuestionsInput>, RequirementUncheckedUpdateWithoutQuestionsInput>
  }

  export type AgentUpdateOneRequiredWithoutRequirementQuestionNestedInput = {
    create?: XOR<AgentCreateWithoutRequirementQuestionInput, AgentUncheckedCreateWithoutRequirementQuestionInput>
    connectOrCreate?: AgentCreateOrConnectWithoutRequirementQuestionInput
    upsert?: AgentUpsertWithoutRequirementQuestionInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutRequirementQuestionInput, AgentUpdateWithoutRequirementQuestionInput>, AgentUncheckedUpdateWithoutRequirementQuestionInput>
  }

  export type ProjectCreateNestedOneWithoutRequirementAttachmentInput = {
    create?: XOR<ProjectCreateWithoutRequirementAttachmentInput, ProjectUncheckedCreateWithoutRequirementAttachmentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRequirementAttachmentInput
    connect?: ProjectWhereUniqueInput
  }

  export type RequirementCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<RequirementCreateWithoutAttachmentsInput, RequirementUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutAttachmentsInput
    connect?: RequirementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRequirementAttachmentInput = {
    create?: XOR<UserCreateWithoutRequirementAttachmentInput, UserUncheckedCreateWithoutRequirementAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequirementAttachmentInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutRequirementAttachmentNestedInput = {
    create?: XOR<ProjectCreateWithoutRequirementAttachmentInput, ProjectUncheckedCreateWithoutRequirementAttachmentInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRequirementAttachmentInput
    upsert?: ProjectUpsertWithoutRequirementAttachmentInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRequirementAttachmentInput, ProjectUpdateWithoutRequirementAttachmentInput>, ProjectUncheckedUpdateWithoutRequirementAttachmentInput>
  }

  export type RequirementUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<RequirementCreateWithoutAttachmentsInput, RequirementUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: RequirementCreateOrConnectWithoutAttachmentsInput
    upsert?: RequirementUpsertWithoutAttachmentsInput
    connect?: RequirementWhereUniqueInput
    update?: XOR<XOR<RequirementUpdateToOneWithWhereWithoutAttachmentsInput, RequirementUpdateWithoutAttachmentsInput>, RequirementUncheckedUpdateWithoutAttachmentsInput>
  }

  export type UserUpdateOneWithoutRequirementAttachmentNestedInput = {
    create?: XOR<UserCreateWithoutRequirementAttachmentInput, UserUncheckedCreateWithoutRequirementAttachmentInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequirementAttachmentInput
    upsert?: UserUpsertWithoutRequirementAttachmentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequirementAttachmentInput, UserUpdateWithoutRequirementAttachmentInput>, UserUncheckedUpdateWithoutRequirementAttachmentInput>
  }

  export type ProjectCreateNestedOneWithoutRoadmapsInput = {
    create?: XOR<ProjectCreateWithoutRoadmapsInput, ProjectUncheckedCreateWithoutRoadmapsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoadmapsInput
    connect?: ProjectWhereUniqueInput
  }

  export type MilestoneCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<MilestoneCreateWithoutRoadmapInput, MilestoneUncheckedCreateWithoutRoadmapInput> | MilestoneCreateWithoutRoadmapInput[] | MilestoneUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutRoadmapInput | MilestoneCreateOrConnectWithoutRoadmapInput[]
    createMany?: MilestoneCreateManyRoadmapInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type VersionCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<VersionCreateWithoutRoadmapInput, VersionUncheckedCreateWithoutRoadmapInput> | VersionCreateWithoutRoadmapInput[] | VersionUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutRoadmapInput | VersionCreateOrConnectWithoutRoadmapInput[]
    createMany?: VersionCreateManyRoadmapInputEnvelope
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
  }

  export type MilestoneUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<MilestoneCreateWithoutRoadmapInput, MilestoneUncheckedCreateWithoutRoadmapInput> | MilestoneCreateWithoutRoadmapInput[] | MilestoneUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutRoadmapInput | MilestoneCreateOrConnectWithoutRoadmapInput[]
    createMany?: MilestoneCreateManyRoadmapInputEnvelope
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
  }

  export type VersionUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<VersionCreateWithoutRoadmapInput, VersionUncheckedCreateWithoutRoadmapInput> | VersionCreateWithoutRoadmapInput[] | VersionUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutRoadmapInput | VersionCreateOrConnectWithoutRoadmapInput[]
    createMany?: VersionCreateManyRoadmapInputEnvelope
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutRoadmapsNestedInput = {
    create?: XOR<ProjectCreateWithoutRoadmapsInput, ProjectUncheckedCreateWithoutRoadmapsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutRoadmapsInput
    upsert?: ProjectUpsertWithoutRoadmapsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutRoadmapsInput, ProjectUpdateWithoutRoadmapsInput>, ProjectUncheckedUpdateWithoutRoadmapsInput>
  }

  export type MilestoneUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<MilestoneCreateWithoutRoadmapInput, MilestoneUncheckedCreateWithoutRoadmapInput> | MilestoneCreateWithoutRoadmapInput[] | MilestoneUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutRoadmapInput | MilestoneCreateOrConnectWithoutRoadmapInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutRoadmapInput | MilestoneUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: MilestoneCreateManyRoadmapInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutRoadmapInput | MilestoneUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutRoadmapInput | MilestoneUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type VersionUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<VersionCreateWithoutRoadmapInput, VersionUncheckedCreateWithoutRoadmapInput> | VersionCreateWithoutRoadmapInput[] | VersionUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutRoadmapInput | VersionCreateOrConnectWithoutRoadmapInput[]
    upsert?: VersionUpsertWithWhereUniqueWithoutRoadmapInput | VersionUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: VersionCreateManyRoadmapInputEnvelope
    set?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    disconnect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    delete?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    update?: VersionUpdateWithWhereUniqueWithoutRoadmapInput | VersionUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: VersionUpdateManyWithWhereWithoutRoadmapInput | VersionUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: VersionScalarWhereInput | VersionScalarWhereInput[]
  }

  export type MilestoneUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<MilestoneCreateWithoutRoadmapInput, MilestoneUncheckedCreateWithoutRoadmapInput> | MilestoneCreateWithoutRoadmapInput[] | MilestoneUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: MilestoneCreateOrConnectWithoutRoadmapInput | MilestoneCreateOrConnectWithoutRoadmapInput[]
    upsert?: MilestoneUpsertWithWhereUniqueWithoutRoadmapInput | MilestoneUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: MilestoneCreateManyRoadmapInputEnvelope
    set?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    disconnect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    delete?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    connect?: MilestoneWhereUniqueInput | MilestoneWhereUniqueInput[]
    update?: MilestoneUpdateWithWhereUniqueWithoutRoadmapInput | MilestoneUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: MilestoneUpdateManyWithWhereWithoutRoadmapInput | MilestoneUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
  }

  export type VersionUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<VersionCreateWithoutRoadmapInput, VersionUncheckedCreateWithoutRoadmapInput> | VersionCreateWithoutRoadmapInput[] | VersionUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: VersionCreateOrConnectWithoutRoadmapInput | VersionCreateOrConnectWithoutRoadmapInput[]
    upsert?: VersionUpsertWithWhereUniqueWithoutRoadmapInput | VersionUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: VersionCreateManyRoadmapInputEnvelope
    set?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    disconnect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    delete?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    connect?: VersionWhereUniqueInput | VersionWhereUniqueInput[]
    update?: VersionUpdateWithWhereUniqueWithoutRoadmapInput | VersionUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: VersionUpdateManyWithWhereWithoutRoadmapInput | VersionUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: VersionScalarWhereInput | VersionScalarWhereInput[]
  }

  export type RoadmapCreateNestedOneWithoutMilestonesInput = {
    create?: XOR<RoadmapCreateWithoutMilestonesInput, RoadmapUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutMilestonesInput
    connect?: RoadmapWhereUniqueInput
  }

  export type FeatureCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<FeatureCreateWithoutMilestoneInput, FeatureUncheckedCreateWithoutMilestoneInput> | FeatureCreateWithoutMilestoneInput[] | FeatureUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutMilestoneInput | FeatureCreateOrConnectWithoutMilestoneInput[]
    createMany?: FeatureCreateManyMilestoneInputEnvelope
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type FeatureUncheckedCreateNestedManyWithoutMilestoneInput = {
    create?: XOR<FeatureCreateWithoutMilestoneInput, FeatureUncheckedCreateWithoutMilestoneInput> | FeatureCreateWithoutMilestoneInput[] | FeatureUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutMilestoneInput | FeatureCreateOrConnectWithoutMilestoneInput[]
    createMany?: FeatureCreateManyMilestoneInputEnvelope
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type RoadmapUpdateOneRequiredWithoutMilestonesNestedInput = {
    create?: XOR<RoadmapCreateWithoutMilestonesInput, RoadmapUncheckedCreateWithoutMilestonesInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutMilestonesInput
    upsert?: RoadmapUpsertWithoutMilestonesInput
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutMilestonesInput, RoadmapUpdateWithoutMilestonesInput>, RoadmapUncheckedUpdateWithoutMilestonesInput>
  }

  export type FeatureUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<FeatureCreateWithoutMilestoneInput, FeatureUncheckedCreateWithoutMilestoneInput> | FeatureCreateWithoutMilestoneInput[] | FeatureUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutMilestoneInput | FeatureCreateOrConnectWithoutMilestoneInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutMilestoneInput | FeatureUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: FeatureCreateManyMilestoneInputEnvelope
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutMilestoneInput | FeatureUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutMilestoneInput | FeatureUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type FeatureUncheckedUpdateManyWithoutMilestoneNestedInput = {
    create?: XOR<FeatureCreateWithoutMilestoneInput, FeatureUncheckedCreateWithoutMilestoneInput> | FeatureCreateWithoutMilestoneInput[] | FeatureUncheckedCreateWithoutMilestoneInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutMilestoneInput | FeatureCreateOrConnectWithoutMilestoneInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutMilestoneInput | FeatureUpsertWithWhereUniqueWithoutMilestoneInput[]
    createMany?: FeatureCreateManyMilestoneInputEnvelope
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutMilestoneInput | FeatureUpdateWithWhereUniqueWithoutMilestoneInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutMilestoneInput | FeatureUpdateManyWithWhereWithoutMilestoneInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type RoadmapCreateNestedOneWithoutVersionsInput = {
    create?: XOR<RoadmapCreateWithoutVersionsInput, RoadmapUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutVersionsInput
    connect?: RoadmapWhereUniqueInput
  }

  export type FeatureCreateNestedManyWithoutVersionInput = {
    create?: XOR<FeatureCreateWithoutVersionInput, FeatureUncheckedCreateWithoutVersionInput> | FeatureCreateWithoutVersionInput[] | FeatureUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutVersionInput | FeatureCreateOrConnectWithoutVersionInput[]
    createMany?: FeatureCreateManyVersionInputEnvelope
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type FeatureUncheckedCreateNestedManyWithoutVersionInput = {
    create?: XOR<FeatureCreateWithoutVersionInput, FeatureUncheckedCreateWithoutVersionInput> | FeatureCreateWithoutVersionInput[] | FeatureUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutVersionInput | FeatureCreateOrConnectWithoutVersionInput[]
    createMany?: FeatureCreateManyVersionInputEnvelope
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
  }

  export type RoadmapUpdateOneRequiredWithoutVersionsNestedInput = {
    create?: XOR<RoadmapCreateWithoutVersionsInput, RoadmapUncheckedCreateWithoutVersionsInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutVersionsInput
    upsert?: RoadmapUpsertWithoutVersionsInput
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutVersionsInput, RoadmapUpdateWithoutVersionsInput>, RoadmapUncheckedUpdateWithoutVersionsInput>
  }

  export type FeatureUpdateManyWithoutVersionNestedInput = {
    create?: XOR<FeatureCreateWithoutVersionInput, FeatureUncheckedCreateWithoutVersionInput> | FeatureCreateWithoutVersionInput[] | FeatureUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutVersionInput | FeatureCreateOrConnectWithoutVersionInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutVersionInput | FeatureUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: FeatureCreateManyVersionInputEnvelope
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutVersionInput | FeatureUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutVersionInput | FeatureUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type FeatureUncheckedUpdateManyWithoutVersionNestedInput = {
    create?: XOR<FeatureCreateWithoutVersionInput, FeatureUncheckedCreateWithoutVersionInput> | FeatureCreateWithoutVersionInput[] | FeatureUncheckedCreateWithoutVersionInput[]
    connectOrCreate?: FeatureCreateOrConnectWithoutVersionInput | FeatureCreateOrConnectWithoutVersionInput[]
    upsert?: FeatureUpsertWithWhereUniqueWithoutVersionInput | FeatureUpsertWithWhereUniqueWithoutVersionInput[]
    createMany?: FeatureCreateManyVersionInputEnvelope
    set?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    disconnect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    delete?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    connect?: FeatureWhereUniqueInput | FeatureWhereUniqueInput[]
    update?: FeatureUpdateWithWhereUniqueWithoutVersionInput | FeatureUpdateWithWhereUniqueWithoutVersionInput[]
    updateMany?: FeatureUpdateManyWithWhereWithoutVersionInput | FeatureUpdateManyWithWhereWithoutVersionInput[]
    deleteMany?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
  }

  export type MilestoneCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<MilestoneCreateWithoutFeaturesInput, MilestoneUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutFeaturesInput
    connect?: MilestoneWhereUniqueInput
  }

  export type VersionCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<VersionCreateWithoutFeaturesInput, VersionUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: VersionCreateOrConnectWithoutFeaturesInput
    connect?: VersionWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutFeatureInput = {
    create?: XOR<TaskCreateWithoutFeatureInput, TaskUncheckedCreateWithoutFeatureInput> | TaskCreateWithoutFeatureInput[] | TaskUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutFeatureInput | TaskCreateOrConnectWithoutFeatureInput[]
    createMany?: TaskCreateManyFeatureInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutFeatureInput = {
    create?: XOR<TaskCreateWithoutFeatureInput, TaskUncheckedCreateWithoutFeatureInput> | TaskCreateWithoutFeatureInput[] | TaskUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutFeatureInput | TaskCreateOrConnectWithoutFeatureInput[]
    createMany?: TaskCreateManyFeatureInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type MilestoneUpdateOneWithoutFeaturesNestedInput = {
    create?: XOR<MilestoneCreateWithoutFeaturesInput, MilestoneUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: MilestoneCreateOrConnectWithoutFeaturesInput
    upsert?: MilestoneUpsertWithoutFeaturesInput
    disconnect?: MilestoneWhereInput | boolean
    delete?: MilestoneWhereInput | boolean
    connect?: MilestoneWhereUniqueInput
    update?: XOR<XOR<MilestoneUpdateToOneWithWhereWithoutFeaturesInput, MilestoneUpdateWithoutFeaturesInput>, MilestoneUncheckedUpdateWithoutFeaturesInput>
  }

  export type VersionUpdateOneWithoutFeaturesNestedInput = {
    create?: XOR<VersionCreateWithoutFeaturesInput, VersionUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: VersionCreateOrConnectWithoutFeaturesInput
    upsert?: VersionUpsertWithoutFeaturesInput
    disconnect?: VersionWhereInput | boolean
    delete?: VersionWhereInput | boolean
    connect?: VersionWhereUniqueInput
    update?: XOR<XOR<VersionUpdateToOneWithWhereWithoutFeaturesInput, VersionUpdateWithoutFeaturesInput>, VersionUncheckedUpdateWithoutFeaturesInput>
  }

  export type TaskUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<TaskCreateWithoutFeatureInput, TaskUncheckedCreateWithoutFeatureInput> | TaskCreateWithoutFeatureInput[] | TaskUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutFeatureInput | TaskCreateOrConnectWithoutFeatureInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutFeatureInput | TaskUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: TaskCreateManyFeatureInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutFeatureInput | TaskUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutFeatureInput | TaskUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutFeatureNestedInput = {
    create?: XOR<TaskCreateWithoutFeatureInput, TaskUncheckedCreateWithoutFeatureInput> | TaskCreateWithoutFeatureInput[] | TaskUncheckedCreateWithoutFeatureInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutFeatureInput | TaskCreateOrConnectWithoutFeatureInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutFeatureInput | TaskUpsertWithWhereUniqueWithoutFeatureInput[]
    createMany?: TaskCreateManyFeatureInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutFeatureInput | TaskUpdateWithWhereUniqueWithoutFeatureInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutFeatureInput | TaskUpdateManyWithWhereWithoutFeatureInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutSprintInput = {
    create?: XOR<ProjectCreateWithoutSprintInput, ProjectUncheckedCreateWithoutSprintInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSprintInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutSprintInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutSprintInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutSprintNestedInput = {
    create?: XOR<ProjectCreateWithoutSprintInput, ProjectUncheckedCreateWithoutSprintInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSprintInput
    upsert?: ProjectUpsertWithoutSprintInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSprintInput, ProjectUpdateWithoutSprintInput>, ProjectUncheckedUpdateWithoutSprintInput>
  }

  export type TaskUpdateManyWithoutSprintNestedInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSprintInput | TaskUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSprintInput | TaskUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSprintInput | TaskUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutSprintNestedInput = {
    create?: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput> | TaskCreateWithoutSprintInput[] | TaskUncheckedCreateWithoutSprintInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutSprintInput | TaskCreateOrConnectWithoutSprintInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutSprintInput | TaskUpsertWithWhereUniqueWithoutSprintInput[]
    createMany?: TaskCreateManySprintInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutSprintInput | TaskUpdateWithWhereUniqueWithoutSprintInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutSprintInput | TaskUpdateManyWithWhereWithoutSprintInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type SprintCreateNestedOneWithoutTaskInput = {
    create?: XOR<SprintCreateWithoutTaskInput, SprintUncheckedCreateWithoutTaskInput>
    connectOrCreate?: SprintCreateOrConnectWithoutTaskInput
    connect?: SprintWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutTasksInput = {
    create?: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTasksInput
    connect?: TeamWhereUniqueInput
  }

  export type FeatureCreateNestedOneWithoutTasksInput = {
    create?: XOR<FeatureCreateWithoutTasksInput, FeatureUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutTasksInput
    connect?: FeatureWhereUniqueInput
  }

  export type AgentTaskCreateNestedManyWithoutTaskInput = {
    create?: XOR<AgentTaskCreateWithoutTaskInput, AgentTaskUncheckedCreateWithoutTaskInput> | AgentTaskCreateWithoutTaskInput[] | AgentTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutTaskInput | AgentTaskCreateOrConnectWithoutTaskInput[]
    createMany?: AgentTaskCreateManyTaskInputEnvelope
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
  }

  export type AgentWorklogCreateNestedManyWithoutTaskInput = {
    create?: XOR<AgentWorklogCreateWithoutTaskInput, AgentWorklogUncheckedCreateWithoutTaskInput> | AgentWorklogCreateWithoutTaskInput[] | AgentWorklogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutTaskInput | AgentWorklogCreateOrConnectWithoutTaskInput[]
    createMany?: AgentWorklogCreateManyTaskInputEnvelope
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
  }

  export type AgentTaskUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<AgentTaskCreateWithoutTaskInput, AgentTaskUncheckedCreateWithoutTaskInput> | AgentTaskCreateWithoutTaskInput[] | AgentTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutTaskInput | AgentTaskCreateOrConnectWithoutTaskInput[]
    createMany?: AgentTaskCreateManyTaskInputEnvelope
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
  }

  export type AgentWorklogUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<AgentWorklogCreateWithoutTaskInput, AgentWorklogUncheckedCreateWithoutTaskInput> | AgentWorklogCreateWithoutTaskInput[] | AgentWorklogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutTaskInput | AgentWorklogCreateOrConnectWithoutTaskInput[]
    createMany?: AgentWorklogCreateManyTaskInputEnvelope
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type SprintUpdateOneRequiredWithoutTaskNestedInput = {
    create?: XOR<SprintCreateWithoutTaskInput, SprintUncheckedCreateWithoutTaskInput>
    connectOrCreate?: SprintCreateOrConnectWithoutTaskInput
    upsert?: SprintUpsertWithoutTaskInput
    connect?: SprintWhereUniqueInput
    update?: XOR<XOR<SprintUpdateToOneWithWhereWithoutTaskInput, SprintUpdateWithoutTaskInput>, SprintUncheckedUpdateWithoutTaskInput>
  }

  export type TeamUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTasksInput
    upsert?: TeamUpsertWithoutTasksInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTasksInput, TeamUpdateWithoutTasksInput>, TeamUncheckedUpdateWithoutTasksInput>
  }

  export type FeatureUpdateOneWithoutTasksNestedInput = {
    create?: XOR<FeatureCreateWithoutTasksInput, FeatureUncheckedCreateWithoutTasksInput>
    connectOrCreate?: FeatureCreateOrConnectWithoutTasksInput
    upsert?: FeatureUpsertWithoutTasksInput
    disconnect?: FeatureWhereInput | boolean
    delete?: FeatureWhereInput | boolean
    connect?: FeatureWhereUniqueInput
    update?: XOR<XOR<FeatureUpdateToOneWithWhereWithoutTasksInput, FeatureUpdateWithoutTasksInput>, FeatureUncheckedUpdateWithoutTasksInput>
  }

  export type AgentTaskUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AgentTaskCreateWithoutTaskInput, AgentTaskUncheckedCreateWithoutTaskInput> | AgentTaskCreateWithoutTaskInput[] | AgentTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutTaskInput | AgentTaskCreateOrConnectWithoutTaskInput[]
    upsert?: AgentTaskUpsertWithWhereUniqueWithoutTaskInput | AgentTaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AgentTaskCreateManyTaskInputEnvelope
    set?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    disconnect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    delete?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    update?: AgentTaskUpdateWithWhereUniqueWithoutTaskInput | AgentTaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AgentTaskUpdateManyWithWhereWithoutTaskInput | AgentTaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
  }

  export type AgentWorklogUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AgentWorklogCreateWithoutTaskInput, AgentWorklogUncheckedCreateWithoutTaskInput> | AgentWorklogCreateWithoutTaskInput[] | AgentWorklogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutTaskInput | AgentWorklogCreateOrConnectWithoutTaskInput[]
    upsert?: AgentWorklogUpsertWithWhereUniqueWithoutTaskInput | AgentWorklogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AgentWorklogCreateManyTaskInputEnvelope
    set?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    disconnect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    delete?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    update?: AgentWorklogUpdateWithWhereUniqueWithoutTaskInput | AgentWorklogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AgentWorklogUpdateManyWithWhereWithoutTaskInput | AgentWorklogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AgentWorklogScalarWhereInput | AgentWorklogScalarWhereInput[]
  }

  export type AgentTaskUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AgentTaskCreateWithoutTaskInput, AgentTaskUncheckedCreateWithoutTaskInput> | AgentTaskCreateWithoutTaskInput[] | AgentTaskUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AgentTaskCreateOrConnectWithoutTaskInput | AgentTaskCreateOrConnectWithoutTaskInput[]
    upsert?: AgentTaskUpsertWithWhereUniqueWithoutTaskInput | AgentTaskUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AgentTaskCreateManyTaskInputEnvelope
    set?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    disconnect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    delete?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    connect?: AgentTaskWhereUniqueInput | AgentTaskWhereUniqueInput[]
    update?: AgentTaskUpdateWithWhereUniqueWithoutTaskInput | AgentTaskUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AgentTaskUpdateManyWithWhereWithoutTaskInput | AgentTaskUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
  }

  export type AgentWorklogUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<AgentWorklogCreateWithoutTaskInput, AgentWorklogUncheckedCreateWithoutTaskInput> | AgentWorklogCreateWithoutTaskInput[] | AgentWorklogUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: AgentWorklogCreateOrConnectWithoutTaskInput | AgentWorklogCreateOrConnectWithoutTaskInput[]
    upsert?: AgentWorklogUpsertWithWhereUniqueWithoutTaskInput | AgentWorklogUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: AgentWorklogCreateManyTaskInputEnvelope
    set?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    disconnect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    delete?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    connect?: AgentWorklogWhereUniqueInput | AgentWorklogWhereUniqueInput[]
    update?: AgentWorklogUpdateWithWhereUniqueWithoutTaskInput | AgentWorklogUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: AgentWorklogUpdateManyWithWhereWithoutTaskInput | AgentWorklogUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: AgentWorklogScalarWhereInput | AgentWorklogScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTeamInput = {
    create?: XOR<ProjectCreateWithoutTeamInput, ProjectUncheckedCreateWithoutTeamInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamInput
    connect?: ProjectWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutTeamInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AgentCreateNestedManyWithoutTeamInput = {
    create?: XOR<AgentCreateWithoutTeamInput, AgentUncheckedCreateWithoutTeamInput> | AgentCreateWithoutTeamInput[] | AgentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTeamInput | AgentCreateOrConnectWithoutTeamInput[]
    createMany?: AgentCreateManyTeamInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<AgentCreateWithoutTeamInput, AgentUncheckedCreateWithoutTeamInput> | AgentCreateWithoutTeamInput[] | AgentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTeamInput | AgentCreateOrConnectWithoutTeamInput[]
    createMany?: AgentCreateManyTeamInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type ProjectUpdateOneRequiredWithoutTeamNestedInput = {
    create?: XOR<ProjectCreateWithoutTeamInput, ProjectUncheckedCreateWithoutTeamInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTeamInput
    upsert?: ProjectUpsertWithoutTeamInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTeamInput, ProjectUpdateWithoutTeamInput>, ProjectUncheckedUpdateWithoutTeamInput>
  }

  export type TaskUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTeamInput | TaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTeamInput | TaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTeamInput | TaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AgentUpdateManyWithoutTeamNestedInput = {
    create?: XOR<AgentCreateWithoutTeamInput, AgentUncheckedCreateWithoutTeamInput> | AgentCreateWithoutTeamInput[] | AgentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTeamInput | AgentCreateOrConnectWithoutTeamInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutTeamInput | AgentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: AgentCreateManyTeamInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutTeamInput | AgentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutTeamInput | AgentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput> | TaskCreateWithoutTeamInput[] | TaskUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutTeamInput | TaskCreateOrConnectWithoutTeamInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutTeamInput | TaskUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TaskCreateManyTeamInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutTeamInput | TaskUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutTeamInput | TaskUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<AgentCreateWithoutTeamInput, AgentUncheckedCreateWithoutTeamInput> | AgentCreateWithoutTeamInput[] | AgentUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutTeamInput | AgentCreateOrConnectWithoutTeamInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutTeamInput | AgentUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: AgentCreateManyTeamInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutTeamInput | AgentUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutTeamInput | AgentUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type ProjectCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DomainKnowledgeCreateNestedManyWithoutUserInput = {
    create?: XOR<DomainKnowledgeCreateWithoutUserInput, DomainKnowledgeUncheckedCreateWithoutUserInput> | DomainKnowledgeCreateWithoutUserInput[] | DomainKnowledgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutUserInput | DomainKnowledgeCreateOrConnectWithoutUserInput[]
    createMany?: DomainKnowledgeCreateManyUserInputEnvelope
    connect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
  }

  export type DatabaseSchemaCreateNestedManyWithoutUserInput = {
    create?: XOR<DatabaseSchemaCreateWithoutUserInput, DatabaseSchemaUncheckedCreateWithoutUserInput> | DatabaseSchemaCreateWithoutUserInput[] | DatabaseSchemaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutUserInput | DatabaseSchemaCreateOrConnectWithoutUserInput[]
    createMany?: DatabaseSchemaCreateManyUserInputEnvelope
    connect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
  }

  export type RequirementCreateNestedManyWithoutUserInput = {
    create?: XOR<RequirementCreateWithoutUserInput, RequirementUncheckedCreateWithoutUserInput> | RequirementCreateWithoutUserInput[] | RequirementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutUserInput | RequirementCreateOrConnectWithoutUserInput[]
    createMany?: RequirementCreateManyUserInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type RequirementAttachmentCreateNestedManyWithoutUserInput = {
    create?: XOR<RequirementAttachmentCreateWithoutUserInput, RequirementAttachmentUncheckedCreateWithoutUserInput> | RequirementAttachmentCreateWithoutUserInput[] | RequirementAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutUserInput | RequirementAttachmentCreateOrConnectWithoutUserInput[]
    createMany?: RequirementAttachmentCreateManyUserInputEnvelope
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
  }

  export type DocumentationCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentationCreateWithoutUserInput, DocumentationUncheckedCreateWithoutUserInput> | DocumentationCreateWithoutUserInput[] | DocumentationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutUserInput | DocumentationCreateOrConnectWithoutUserInput[]
    createMany?: DocumentationCreateManyUserInputEnvelope
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
  }

  export type DocumentVersionCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentVersionCreateWithoutUserInput, DocumentVersionUncheckedCreateWithoutUserInput> | DocumentVersionCreateWithoutUserInput[] | DocumentVersionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUserInput | DocumentVersionCreateOrConnectWithoutUserInput[]
    createMany?: DocumentVersionCreateManyUserInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type DocumentCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput> | DocumentCommentCreateWithoutUserInput[] | DocumentCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutUserInput | DocumentCommentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCommentCreateManyUserInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type DocumentAttachmentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentAttachmentCreateWithoutUserInput, DocumentAttachmentUncheckedCreateWithoutUserInput> | DocumentAttachmentCreateWithoutUserInput[] | DocumentAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutUserInput | DocumentAttachmentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentAttachmentCreateManyUserInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type MindMapCreateNestedManyWithoutUserInput = {
    create?: XOR<MindMapCreateWithoutUserInput, MindMapUncheckedCreateWithoutUserInput> | MindMapCreateWithoutUserInput[] | MindMapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MindMapCreateOrConnectWithoutUserInput | MindMapCreateOrConnectWithoutUserInput[]
    createMany?: MindMapCreateManyUserInputEnvelope
    connect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
  }

  export type ArchitectureChangeHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<ArchitectureChangeHistoryCreateWithoutUserInput, ArchitectureChangeHistoryUncheckedCreateWithoutUserInput> | ArchitectureChangeHistoryCreateWithoutUserInput[] | ArchitectureChangeHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ArchitectureChangeHistoryCreateOrConnectWithoutUserInput | ArchitectureChangeHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ArchitectureChangeHistoryCreateManyUserInputEnvelope
    connect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DomainKnowledgeCreateWithoutUserInput, DomainKnowledgeUncheckedCreateWithoutUserInput> | DomainKnowledgeCreateWithoutUserInput[] | DomainKnowledgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutUserInput | DomainKnowledgeCreateOrConnectWithoutUserInput[]
    createMany?: DomainKnowledgeCreateManyUserInputEnvelope
    connect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
  }

  export type DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DatabaseSchemaCreateWithoutUserInput, DatabaseSchemaUncheckedCreateWithoutUserInput> | DatabaseSchemaCreateWithoutUserInput[] | DatabaseSchemaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutUserInput | DatabaseSchemaCreateOrConnectWithoutUserInput[]
    createMany?: DatabaseSchemaCreateManyUserInputEnvelope
    connect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
  }

  export type RequirementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RequirementCreateWithoutUserInput, RequirementUncheckedCreateWithoutUserInput> | RequirementCreateWithoutUserInput[] | RequirementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutUserInput | RequirementCreateOrConnectWithoutUserInput[]
    createMany?: RequirementCreateManyUserInputEnvelope
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
  }

  export type RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RequirementAttachmentCreateWithoutUserInput, RequirementAttachmentUncheckedCreateWithoutUserInput> | RequirementAttachmentCreateWithoutUserInput[] | RequirementAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutUserInput | RequirementAttachmentCreateOrConnectWithoutUserInput[]
    createMany?: RequirementAttachmentCreateManyUserInputEnvelope
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
  }

  export type DocumentationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentationCreateWithoutUserInput, DocumentationUncheckedCreateWithoutUserInput> | DocumentationCreateWithoutUserInput[] | DocumentationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutUserInput | DocumentationCreateOrConnectWithoutUserInput[]
    createMany?: DocumentationCreateManyUserInputEnvelope
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
  }

  export type DocumentVersionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentVersionCreateWithoutUserInput, DocumentVersionUncheckedCreateWithoutUserInput> | DocumentVersionCreateWithoutUserInput[] | DocumentVersionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUserInput | DocumentVersionCreateOrConnectWithoutUserInput[]
    createMany?: DocumentVersionCreateManyUserInputEnvelope
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
  }

  export type DocumentCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput> | DocumentCommentCreateWithoutUserInput[] | DocumentCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutUserInput | DocumentCommentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCommentCreateManyUserInputEnvelope
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
  }

  export type DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentAttachmentCreateWithoutUserInput, DocumentAttachmentUncheckedCreateWithoutUserInput> | DocumentAttachmentCreateWithoutUserInput[] | DocumentAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutUserInput | DocumentAttachmentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentAttachmentCreateManyUserInputEnvelope
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
  }

  export type MindMapUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MindMapCreateWithoutUserInput, MindMapUncheckedCreateWithoutUserInput> | MindMapCreateWithoutUserInput[] | MindMapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MindMapCreateOrConnectWithoutUserInput | MindMapCreateOrConnectWithoutUserInput[]
    createMany?: MindMapCreateManyUserInputEnvelope
    connect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
  }

  export type ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ArchitectureChangeHistoryCreateWithoutUserInput, ArchitectureChangeHistoryUncheckedCreateWithoutUserInput> | ArchitectureChangeHistoryCreateWithoutUserInput[] | ArchitectureChangeHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ArchitectureChangeHistoryCreateOrConnectWithoutUserInput | ArchitectureChangeHistoryCreateOrConnectWithoutUserInput[]
    createMany?: ArchitectureChangeHistoryCreateManyUserInputEnvelope
    connect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type ProjectUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DomainKnowledgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<DomainKnowledgeCreateWithoutUserInput, DomainKnowledgeUncheckedCreateWithoutUserInput> | DomainKnowledgeCreateWithoutUserInput[] | DomainKnowledgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutUserInput | DomainKnowledgeCreateOrConnectWithoutUserInput[]
    upsert?: DomainKnowledgeUpsertWithWhereUniqueWithoutUserInput | DomainKnowledgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DomainKnowledgeCreateManyUserInputEnvelope
    set?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    disconnect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    delete?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    connect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    update?: DomainKnowledgeUpdateWithWhereUniqueWithoutUserInput | DomainKnowledgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DomainKnowledgeUpdateManyWithWhereWithoutUserInput | DomainKnowledgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DomainKnowledgeScalarWhereInput | DomainKnowledgeScalarWhereInput[]
  }

  export type DatabaseSchemaUpdateManyWithoutUserNestedInput = {
    create?: XOR<DatabaseSchemaCreateWithoutUserInput, DatabaseSchemaUncheckedCreateWithoutUserInput> | DatabaseSchemaCreateWithoutUserInput[] | DatabaseSchemaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutUserInput | DatabaseSchemaCreateOrConnectWithoutUserInput[]
    upsert?: DatabaseSchemaUpsertWithWhereUniqueWithoutUserInput | DatabaseSchemaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DatabaseSchemaCreateManyUserInputEnvelope
    set?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    disconnect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    delete?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    connect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    update?: DatabaseSchemaUpdateWithWhereUniqueWithoutUserInput | DatabaseSchemaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DatabaseSchemaUpdateManyWithWhereWithoutUserInput | DatabaseSchemaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DatabaseSchemaScalarWhereInput | DatabaseSchemaScalarWhereInput[]
  }

  export type RequirementUpdateManyWithoutUserNestedInput = {
    create?: XOR<RequirementCreateWithoutUserInput, RequirementUncheckedCreateWithoutUserInput> | RequirementCreateWithoutUserInput[] | RequirementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutUserInput | RequirementCreateOrConnectWithoutUserInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutUserInput | RequirementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RequirementCreateManyUserInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutUserInput | RequirementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutUserInput | RequirementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type RequirementAttachmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<RequirementAttachmentCreateWithoutUserInput, RequirementAttachmentUncheckedCreateWithoutUserInput> | RequirementAttachmentCreateWithoutUserInput[] | RequirementAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutUserInput | RequirementAttachmentCreateOrConnectWithoutUserInput[]
    upsert?: RequirementAttachmentUpsertWithWhereUniqueWithoutUserInput | RequirementAttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RequirementAttachmentCreateManyUserInputEnvelope
    set?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    disconnect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    delete?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    update?: RequirementAttachmentUpdateWithWhereUniqueWithoutUserInput | RequirementAttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RequirementAttachmentUpdateManyWithWhereWithoutUserInput | RequirementAttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RequirementAttachmentScalarWhereInput | RequirementAttachmentScalarWhereInput[]
  }

  export type DocumentationUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentationCreateWithoutUserInput, DocumentationUncheckedCreateWithoutUserInput> | DocumentationCreateWithoutUserInput[] | DocumentationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutUserInput | DocumentationCreateOrConnectWithoutUserInput[]
    upsert?: DocumentationUpsertWithWhereUniqueWithoutUserInput | DocumentationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentationCreateManyUserInputEnvelope
    set?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    disconnect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    delete?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    update?: DocumentationUpdateWithWhereUniqueWithoutUserInput | DocumentationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentationUpdateManyWithWhereWithoutUserInput | DocumentationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentationScalarWhereInput | DocumentationScalarWhereInput[]
  }

  export type DocumentVersionUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutUserInput, DocumentVersionUncheckedCreateWithoutUserInput> | DocumentVersionCreateWithoutUserInput[] | DocumentVersionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUserInput | DocumentVersionCreateOrConnectWithoutUserInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutUserInput | DocumentVersionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentVersionCreateManyUserInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutUserInput | DocumentVersionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutUserInput | DocumentVersionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type DocumentCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput> | DocumentCommentCreateWithoutUserInput[] | DocumentCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutUserInput | DocumentCommentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutUserInput | DocumentCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCommentCreateManyUserInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutUserInput | DocumentCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutUserInput | DocumentCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type DocumentAttachmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutUserInput, DocumentAttachmentUncheckedCreateWithoutUserInput> | DocumentAttachmentCreateWithoutUserInput[] | DocumentAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutUserInput | DocumentAttachmentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutUserInput | DocumentAttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentAttachmentCreateManyUserInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutUserInput | DocumentAttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutUserInput | DocumentAttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type MindMapUpdateManyWithoutUserNestedInput = {
    create?: XOR<MindMapCreateWithoutUserInput, MindMapUncheckedCreateWithoutUserInput> | MindMapCreateWithoutUserInput[] | MindMapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MindMapCreateOrConnectWithoutUserInput | MindMapCreateOrConnectWithoutUserInput[]
    upsert?: MindMapUpsertWithWhereUniqueWithoutUserInput | MindMapUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MindMapCreateManyUserInputEnvelope
    set?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    disconnect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    delete?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    connect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    update?: MindMapUpdateWithWhereUniqueWithoutUserInput | MindMapUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MindMapUpdateManyWithWhereWithoutUserInput | MindMapUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MindMapScalarWhereInput | MindMapScalarWhereInput[]
  }

  export type ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<ArchitectureChangeHistoryCreateWithoutUserInput, ArchitectureChangeHistoryUncheckedCreateWithoutUserInput> | ArchitectureChangeHistoryCreateWithoutUserInput[] | ArchitectureChangeHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ArchitectureChangeHistoryCreateOrConnectWithoutUserInput | ArchitectureChangeHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutUserInput | ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ArchitectureChangeHistoryCreateManyUserInputEnvelope
    set?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    disconnect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    delete?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    connect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    update?: ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutUserInput | ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ArchitectureChangeHistoryUpdateManyWithWhereWithoutUserInput | ArchitectureChangeHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ArchitectureChangeHistoryScalarWhereInput | ArchitectureChangeHistoryScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput> | ProjectCreateWithoutCreatorInput[] | ProjectUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutCreatorInput | ProjectCreateOrConnectWithoutCreatorInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutCreatorInput | ProjectUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ProjectCreateManyCreatorInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutCreatorInput | ProjectUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutCreatorInput | ProjectUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput> | ProjectMemberCreateWithoutUserInput[] | ProjectMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutUserInput | ProjectMemberCreateOrConnectWithoutUserInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutUserInput | ProjectMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProjectMemberCreateManyUserInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutUserInput | ProjectMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutUserInput | ProjectMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DomainKnowledgeCreateWithoutUserInput, DomainKnowledgeUncheckedCreateWithoutUserInput> | DomainKnowledgeCreateWithoutUserInput[] | DomainKnowledgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DomainKnowledgeCreateOrConnectWithoutUserInput | DomainKnowledgeCreateOrConnectWithoutUserInput[]
    upsert?: DomainKnowledgeUpsertWithWhereUniqueWithoutUserInput | DomainKnowledgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DomainKnowledgeCreateManyUserInputEnvelope
    set?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    disconnect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    delete?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    connect?: DomainKnowledgeWhereUniqueInput | DomainKnowledgeWhereUniqueInput[]
    update?: DomainKnowledgeUpdateWithWhereUniqueWithoutUserInput | DomainKnowledgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DomainKnowledgeUpdateManyWithWhereWithoutUserInput | DomainKnowledgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DomainKnowledgeScalarWhereInput | DomainKnowledgeScalarWhereInput[]
  }

  export type DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DatabaseSchemaCreateWithoutUserInput, DatabaseSchemaUncheckedCreateWithoutUserInput> | DatabaseSchemaCreateWithoutUserInput[] | DatabaseSchemaUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DatabaseSchemaCreateOrConnectWithoutUserInput | DatabaseSchemaCreateOrConnectWithoutUserInput[]
    upsert?: DatabaseSchemaUpsertWithWhereUniqueWithoutUserInput | DatabaseSchemaUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DatabaseSchemaCreateManyUserInputEnvelope
    set?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    disconnect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    delete?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    connect?: DatabaseSchemaWhereUniqueInput | DatabaseSchemaWhereUniqueInput[]
    update?: DatabaseSchemaUpdateWithWhereUniqueWithoutUserInput | DatabaseSchemaUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DatabaseSchemaUpdateManyWithWhereWithoutUserInput | DatabaseSchemaUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DatabaseSchemaScalarWhereInput | DatabaseSchemaScalarWhereInput[]
  }

  export type RequirementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RequirementCreateWithoutUserInput, RequirementUncheckedCreateWithoutUserInput> | RequirementCreateWithoutUserInput[] | RequirementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequirementCreateOrConnectWithoutUserInput | RequirementCreateOrConnectWithoutUserInput[]
    upsert?: RequirementUpsertWithWhereUniqueWithoutUserInput | RequirementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RequirementCreateManyUserInputEnvelope
    set?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    disconnect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    delete?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    connect?: RequirementWhereUniqueInput | RequirementWhereUniqueInput[]
    update?: RequirementUpdateWithWhereUniqueWithoutUserInput | RequirementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RequirementUpdateManyWithWhereWithoutUserInput | RequirementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
  }

  export type RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RequirementAttachmentCreateWithoutUserInput, RequirementAttachmentUncheckedCreateWithoutUserInput> | RequirementAttachmentCreateWithoutUserInput[] | RequirementAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RequirementAttachmentCreateOrConnectWithoutUserInput | RequirementAttachmentCreateOrConnectWithoutUserInput[]
    upsert?: RequirementAttachmentUpsertWithWhereUniqueWithoutUserInput | RequirementAttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RequirementAttachmentCreateManyUserInputEnvelope
    set?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    disconnect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    delete?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    connect?: RequirementAttachmentWhereUniqueInput | RequirementAttachmentWhereUniqueInput[]
    update?: RequirementAttachmentUpdateWithWhereUniqueWithoutUserInput | RequirementAttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RequirementAttachmentUpdateManyWithWhereWithoutUserInput | RequirementAttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RequirementAttachmentScalarWhereInput | RequirementAttachmentScalarWhereInput[]
  }

  export type DocumentationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentationCreateWithoutUserInput, DocumentationUncheckedCreateWithoutUserInput> | DocumentationCreateWithoutUserInput[] | DocumentationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentationCreateOrConnectWithoutUserInput | DocumentationCreateOrConnectWithoutUserInput[]
    upsert?: DocumentationUpsertWithWhereUniqueWithoutUserInput | DocumentationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentationCreateManyUserInputEnvelope
    set?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    disconnect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    delete?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    connect?: DocumentationWhereUniqueInput | DocumentationWhereUniqueInput[]
    update?: DocumentationUpdateWithWhereUniqueWithoutUserInput | DocumentationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentationUpdateManyWithWhereWithoutUserInput | DocumentationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentationScalarWhereInput | DocumentationScalarWhereInput[]
  }

  export type DocumentVersionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentVersionCreateWithoutUserInput, DocumentVersionUncheckedCreateWithoutUserInput> | DocumentVersionCreateWithoutUserInput[] | DocumentVersionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentVersionCreateOrConnectWithoutUserInput | DocumentVersionCreateOrConnectWithoutUserInput[]
    upsert?: DocumentVersionUpsertWithWhereUniqueWithoutUserInput | DocumentVersionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentVersionCreateManyUserInputEnvelope
    set?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    disconnect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    delete?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    connect?: DocumentVersionWhereUniqueInput | DocumentVersionWhereUniqueInput[]
    update?: DocumentVersionUpdateWithWhereUniqueWithoutUserInput | DocumentVersionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentVersionUpdateManyWithWhereWithoutUserInput | DocumentVersionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
  }

  export type DocumentCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput> | DocumentCommentCreateWithoutUserInput[] | DocumentCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCommentCreateOrConnectWithoutUserInput | DocumentCommentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentCommentUpsertWithWhereUniqueWithoutUserInput | DocumentCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCommentCreateManyUserInputEnvelope
    set?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    disconnect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    delete?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    connect?: DocumentCommentWhereUniqueInput | DocumentCommentWhereUniqueInput[]
    update?: DocumentCommentUpdateWithWhereUniqueWithoutUserInput | DocumentCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentCommentUpdateManyWithWhereWithoutUserInput | DocumentCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentAttachmentCreateWithoutUserInput, DocumentAttachmentUncheckedCreateWithoutUserInput> | DocumentAttachmentCreateWithoutUserInput[] | DocumentAttachmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentAttachmentCreateOrConnectWithoutUserInput | DocumentAttachmentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentAttachmentUpsertWithWhereUniqueWithoutUserInput | DocumentAttachmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentAttachmentCreateManyUserInputEnvelope
    set?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    disconnect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    delete?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    connect?: DocumentAttachmentWhereUniqueInput | DocumentAttachmentWhereUniqueInput[]
    update?: DocumentAttachmentUpdateWithWhereUniqueWithoutUserInput | DocumentAttachmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentAttachmentUpdateManyWithWhereWithoutUserInput | DocumentAttachmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
  }

  export type MindMapUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MindMapCreateWithoutUserInput, MindMapUncheckedCreateWithoutUserInput> | MindMapCreateWithoutUserInput[] | MindMapUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MindMapCreateOrConnectWithoutUserInput | MindMapCreateOrConnectWithoutUserInput[]
    upsert?: MindMapUpsertWithWhereUniqueWithoutUserInput | MindMapUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MindMapCreateManyUserInputEnvelope
    set?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    disconnect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    delete?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    connect?: MindMapWhereUniqueInput | MindMapWhereUniqueInput[]
    update?: MindMapUpdateWithWhereUniqueWithoutUserInput | MindMapUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MindMapUpdateManyWithWhereWithoutUserInput | MindMapUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MindMapScalarWhereInput | MindMapScalarWhereInput[]
  }

  export type ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ArchitectureChangeHistoryCreateWithoutUserInput, ArchitectureChangeHistoryUncheckedCreateWithoutUserInput> | ArchitectureChangeHistoryCreateWithoutUserInput[] | ArchitectureChangeHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ArchitectureChangeHistoryCreateOrConnectWithoutUserInput | ArchitectureChangeHistoryCreateOrConnectWithoutUserInput[]
    upsert?: ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutUserInput | ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ArchitectureChangeHistoryCreateManyUserInputEnvelope
    set?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    disconnect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    delete?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    connect?: ArchitectureChangeHistoryWhereUniqueInput | ArchitectureChangeHistoryWhereUniqueInput[]
    update?: ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutUserInput | ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ArchitectureChangeHistoryUpdateManyWithWhereWithoutUserInput | ArchitectureChangeHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ArchitectureChangeHistoryScalarWhereInput | ArchitectureChangeHistoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type ProjectMemberCreatepermissionsInput = {
    set: string[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProjectMembersInput = {
    create?: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumProjectRoleFieldUpdateOperationsInput = {
    set?: $Enums.ProjectRole
  }

  export type ProjectMemberUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutProjectMembersNestedInput = {
    create?: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectMembersInput
    upsert?: UserUpsertWithoutProjectMembersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectMembersInput, UserUpdateWithoutProjectMembersInput>, UserUncheckedUpdateWithoutProjectMembersInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumApiMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiMethod | EnumApiMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ApiMethod[] | ListEnumApiMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiMethod[] | ListEnumApiMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumApiMethodFilter<$PrismaModel> | $Enums.ApiMethod
  }

  export type NestedEnumApiContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiContentType | EnumApiContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiContentType[] | ListEnumApiContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiContentType[] | ListEnumApiContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiContentTypeFilter<$PrismaModel> | $Enums.ApiContentType
  }

  export type NestedEnumApiAuthTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiAuthType | EnumApiAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiAuthType[] | ListEnumApiAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiAuthType[] | ListEnumApiAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiAuthTypeFilter<$PrismaModel> | $Enums.ApiAuthType
  }

  export type NestedEnumApiStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiStatus | EnumApiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiStatusFilter<$PrismaModel> | $Enums.ApiStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumApiMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiMethod | EnumApiMethodFieldRefInput<$PrismaModel>
    in?: $Enums.ApiMethod[] | ListEnumApiMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiMethod[] | ListEnumApiMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumApiMethodWithAggregatesFilter<$PrismaModel> | $Enums.ApiMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiMethodFilter<$PrismaModel>
    _max?: NestedEnumApiMethodFilter<$PrismaModel>
  }

  export type NestedEnumApiContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiContentType | EnumApiContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiContentType[] | ListEnumApiContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiContentType[] | ListEnumApiContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApiContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiContentTypeFilter<$PrismaModel>
    _max?: NestedEnumApiContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumApiAuthTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiAuthType | EnumApiAuthTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiAuthType[] | ListEnumApiAuthTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiAuthType[] | ListEnumApiAuthTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApiAuthTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApiAuthType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiAuthTypeFilter<$PrismaModel>
    _max?: NestedEnumApiAuthTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumApiStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiStatus | EnumApiStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApiStatus[] | ListEnumApiStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApiStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApiStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiStatusFilter<$PrismaModel>
    _max?: NestedEnumApiStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumArchitectureStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ArchitectureStatus | EnumArchitectureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArchitectureStatus[] | ListEnumArchitectureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArchitectureStatus[] | ListEnumArchitectureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArchitectureStatusFilter<$PrismaModel> | $Enums.ArchitectureStatus
  }

  export type NestedEnumArchitectureStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArchitectureStatus | EnumArchitectureStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ArchitectureStatus[] | ListEnumArchitectureStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArchitectureStatus[] | ListEnumArchitectureStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumArchitectureStatusWithAggregatesFilter<$PrismaModel> | $Enums.ArchitectureStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArchitectureStatusFilter<$PrismaModel>
    _max?: NestedEnumArchitectureStatusFilter<$PrismaModel>
  }

  export type NestedEnumDatabaseEngineFilter<$PrismaModel = never> = {
    equals?: $Enums.DatabaseEngine | EnumDatabaseEngineFieldRefInput<$PrismaModel>
    in?: $Enums.DatabaseEngine[] | ListEnumDatabaseEngineFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatabaseEngine[] | ListEnumDatabaseEngineFieldRefInput<$PrismaModel>
    not?: NestedEnumDatabaseEngineFilter<$PrismaModel> | $Enums.DatabaseEngine
  }

  export type NestedEnumDatabaseEngineWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DatabaseEngine | EnumDatabaseEngineFieldRefInput<$PrismaModel>
    in?: $Enums.DatabaseEngine[] | ListEnumDatabaseEngineFieldRefInput<$PrismaModel>
    notIn?: $Enums.DatabaseEngine[] | ListEnumDatabaseEngineFieldRefInput<$PrismaModel>
    not?: NestedEnumDatabaseEngineWithAggregatesFilter<$PrismaModel> | $Enums.DatabaseEngine
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDatabaseEngineFilter<$PrismaModel>
    _max?: NestedEnumDatabaseEngineFilter<$PrismaModel>
  }

  export type NestedEnumColumnTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ColumnType | EnumColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumColumnTypeFilter<$PrismaModel> | $Enums.ColumnType
  }

  export type NestedEnumColumnTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ColumnType | EnumColumnTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ColumnType[] | ListEnumColumnTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumColumnTypeWithAggregatesFilter<$PrismaModel> | $Enums.ColumnType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumColumnTypeFilter<$PrismaModel>
    _max?: NestedEnumColumnTypeFilter<$PrismaModel>
  }

  export type NestedEnumIndexTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IndexType | EnumIndexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndexType[] | ListEnumIndexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndexType[] | ListEnumIndexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndexTypeFilter<$PrismaModel> | $Enums.IndexType
  }

  export type NestedEnumIndexTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IndexType | EnumIndexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IndexType[] | ListEnumIndexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IndexType[] | ListEnumIndexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIndexTypeWithAggregatesFilter<$PrismaModel> | $Enums.IndexType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIndexTypeFilter<$PrismaModel>
    _max?: NestedEnumIndexTypeFilter<$PrismaModel>
  }

  export type NestedEnumRelationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeFilter<$PrismaModel> | $Enums.RelationType
  }

  export type NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationType | EnumRelationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationType[] | ListEnumRelationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationTypeWithAggregatesFilter<$PrismaModel> | $Enums.RelationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationTypeFilter<$PrismaModel>
    _max?: NestedEnumRelationTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedEnumDocumentVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVisibility | EnumDocumentVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVisibility[] | ListEnumDocumentVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVisibility[] | ListEnumDocumentVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVisibilityFilter<$PrismaModel> | $Enums.DocumentVisibility
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentVisibility | EnumDocumentVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentVisibility[] | ListEnumDocumentVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentVisibility[] | ListEnumDocumentVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.DocumentVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentVisibilityFilter<$PrismaModel>
    _max?: NestedEnumDocumentVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumNodeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeFilter<$PrismaModel> | $Enums.NodeType
  }

  export type NestedEnumNodeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NodeType | EnumNodeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NodeType[] | ListEnumNodeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNodeTypeWithAggregatesFilter<$PrismaModel> | $Enums.NodeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNodeTypeFilter<$PrismaModel>
    _max?: NestedEnumNodeTypeFilter<$PrismaModel>
  }

  export type NestedEnumKnowledgeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeCategory | EnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeCategory[] | ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeCategory[] | ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeCategoryFilter<$PrismaModel> | $Enums.KnowledgeCategory
  }

  export type NestedEnumKnowledgeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KnowledgeCategory | EnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.KnowledgeCategory[] | ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.KnowledgeCategory[] | ListEnumKnowledgeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumKnowledgeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.KnowledgeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKnowledgeCategoryFilter<$PrismaModel>
    _max?: NestedEnumKnowledgeCategoryFilter<$PrismaModel>
  }

  export type NestedEnumRequirementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementType | EnumRequirementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementType[] | ListEnumRequirementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementType[] | ListEnumRequirementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementTypeFilter<$PrismaModel> | $Enums.RequirementType
  }

  export type NestedEnumRequirementPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementPriority | EnumRequirementPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementPriority[] | ListEnumRequirementPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementPriority[] | ListEnumRequirementPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementPriorityFilter<$PrismaModel> | $Enums.RequirementPriority
  }

  export type NestedEnumRequirementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusFilter<$PrismaModel> | $Enums.RequirementStatus
  }

  export type NestedEnumRequirementSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementSource | EnumRequirementSourceFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementSource[] | ListEnumRequirementSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementSource[] | ListEnumRequirementSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementSourceFilter<$PrismaModel> | $Enums.RequirementSource
  }

  export type NestedEnumRequirementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementType | EnumRequirementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementType[] | ListEnumRequirementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementType[] | ListEnumRequirementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementTypeWithAggregatesFilter<$PrismaModel> | $Enums.RequirementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementTypeFilter<$PrismaModel>
    _max?: NestedEnumRequirementTypeFilter<$PrismaModel>
  }

  export type NestedEnumRequirementPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementPriority | EnumRequirementPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementPriority[] | ListEnumRequirementPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementPriority[] | ListEnumRequirementPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementPriorityWithAggregatesFilter<$PrismaModel> | $Enums.RequirementPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementPriorityFilter<$PrismaModel>
    _max?: NestedEnumRequirementPriorityFilter<$PrismaModel>
  }

  export type NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementStatus | EnumRequirementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementStatus[] | ListEnumRequirementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementStatusWithAggregatesFilter<$PrismaModel> | $Enums.RequirementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementStatusFilter<$PrismaModel>
    _max?: NestedEnumRequirementStatusFilter<$PrismaModel>
  }

  export type NestedEnumRequirementSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RequirementSource | EnumRequirementSourceFieldRefInput<$PrismaModel>
    in?: $Enums.RequirementSource[] | ListEnumRequirementSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.RequirementSource[] | ListEnumRequirementSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumRequirementSourceWithAggregatesFilter<$PrismaModel> | $Enums.RequirementSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRequirementSourceFilter<$PrismaModel>
    _max?: NestedEnumRequirementSourceFilter<$PrismaModel>
  }

  export type NestedEnumQuestionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusFilter<$PrismaModel> | $Enums.QuestionStatus
  }

  export type NestedEnumQuestionPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionPriority | EnumQuestionPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionPriority[] | ListEnumQuestionPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionPriority[] | ListEnumQuestionPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionPriorityFilter<$PrismaModel> | $Enums.QuestionPriority
  }

  export type NestedEnumQuestionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionStatus | EnumQuestionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionStatus[] | ListEnumQuestionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuestionPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionPriority | EnumQuestionPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionPriority[] | ListEnumQuestionPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionPriority[] | ListEnumQuestionPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionPriorityWithAggregatesFilter<$PrismaModel> | $Enums.QuestionPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionPriorityFilter<$PrismaModel>
    _max?: NestedEnumQuestionPriorityFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumProjectRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleFilter<$PrismaModel> | $Enums.ProjectRole
  }

  export type NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectRole | EnumProjectRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectRole[] | ListEnumProjectRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectRoleWithAggregatesFilter<$PrismaModel> | $Enums.ProjectRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectRoleFilter<$PrismaModel>
    _max?: NestedEnumProjectRoleFilter<$PrismaModel>
  }

  export type ProjectCreateWithoutAgentInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAgentInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAgentInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAgentInput, ProjectUncheckedCreateWithoutAgentInput>
  }

  export type TeamCreateWithoutAgentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutTeamInput
    tasks?: TaskCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutAgentsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutAgentsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutAgentsInput, TeamUncheckedCreateWithoutAgentsInput>
  }

  export type AgentActivityCreateWithoutAgentInput = {
    id?: string
    body: string
    action?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentActivityUncheckedCreateWithoutAgentInput = {
    id?: string
    body: string
    action?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentActivityCreateOrConnectWithoutAgentInput = {
    where: AgentActivityWhereUniqueInput
    create: XOR<AgentActivityCreateWithoutAgentInput, AgentActivityUncheckedCreateWithoutAgentInput>
  }

  export type AgentActivityCreateManyAgentInputEnvelope = {
    data: AgentActivityCreateManyAgentInput | AgentActivityCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentTaskCreateWithoutAgentInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    task: TaskCreateNestedOneWithoutAgentTaskInput
  }

  export type AgentTaskUncheckedCreateWithoutAgentInput = {
    id?: string
    taskId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTaskCreateOrConnectWithoutAgentInput = {
    where: AgentTaskWhereUniqueInput
    create: XOR<AgentTaskCreateWithoutAgentInput, AgentTaskUncheckedCreateWithoutAgentInput>
  }

  export type AgentTaskCreateManyAgentInputEnvelope = {
    data: AgentTaskCreateManyAgentInput | AgentTaskCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type AgentWorklogCreateWithoutAgentInput = {
    id?: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgentWorklogInput
    task: TaskCreateNestedOneWithoutAgentWorklogInput
  }

  export type AgentWorklogUncheckedCreateWithoutAgentInput = {
    id?: string
    projectId: string
    taskId: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentWorklogCreateOrConnectWithoutAgentInput = {
    where: AgentWorklogWhereUniqueInput
    create: XOR<AgentWorklogCreateWithoutAgentInput, AgentWorklogUncheckedCreateWithoutAgentInput>
  }

  export type AgentWorklogCreateManyAgentInputEnvelope = {
    data: AgentWorklogCreateManyAgentInput | AgentWorklogCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type RequirementQuestionCreateWithoutAgentInput = {
    id?: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutRequirementQuestionInput
    requirement: RequirementCreateNestedOneWithoutQuestionsInput
  }

  export type RequirementQuestionUncheckedCreateWithoutAgentInput = {
    id?: string
    projectId: string
    requirementId: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
  }

  export type RequirementQuestionCreateOrConnectWithoutAgentInput = {
    where: RequirementQuestionWhereUniqueInput
    create: XOR<RequirementQuestionCreateWithoutAgentInput, RequirementQuestionUncheckedCreateWithoutAgentInput>
  }

  export type RequirementQuestionCreateManyAgentInputEnvelope = {
    data: RequirementQuestionCreateManyAgentInput | RequirementQuestionCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutAgentInput = {
    update: XOR<ProjectUpdateWithoutAgentInput, ProjectUncheckedUpdateWithoutAgentInput>
    create: XOR<ProjectCreateWithoutAgentInput, ProjectUncheckedCreateWithoutAgentInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAgentInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAgentInput, ProjectUncheckedUpdateWithoutAgentInput>
  }

  export type ProjectUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TeamUpsertWithoutAgentsInput = {
    update: XOR<TeamUpdateWithoutAgentsInput, TeamUncheckedUpdateWithoutAgentsInput>
    create: XOR<TeamCreateWithoutAgentsInput, TeamUncheckedCreateWithoutAgentsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutAgentsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutAgentsInput, TeamUncheckedUpdateWithoutAgentsInput>
  }

  export type TeamUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTeamNestedInput
    tasks?: TaskUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type AgentActivityUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentActivityWhereUniqueInput
    update: XOR<AgentActivityUpdateWithoutAgentInput, AgentActivityUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentActivityCreateWithoutAgentInput, AgentActivityUncheckedCreateWithoutAgentInput>
  }

  export type AgentActivityUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentActivityWhereUniqueInput
    data: XOR<AgentActivityUpdateWithoutAgentInput, AgentActivityUncheckedUpdateWithoutAgentInput>
  }

  export type AgentActivityUpdateManyWithWhereWithoutAgentInput = {
    where: AgentActivityScalarWhereInput
    data: XOR<AgentActivityUpdateManyMutationInput, AgentActivityUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentActivityScalarWhereInput = {
    AND?: AgentActivityScalarWhereInput | AgentActivityScalarWhereInput[]
    OR?: AgentActivityScalarWhereInput[]
    NOT?: AgentActivityScalarWhereInput | AgentActivityScalarWhereInput[]
    id?: StringFilter<"AgentActivity"> | string
    agentId?: StringFilter<"AgentActivity"> | string
    body?: StringFilter<"AgentActivity"> | string
    action?: StringFilter<"AgentActivity"> | string
    details?: JsonNullableFilter<"AgentActivity">
    createdAt?: DateTimeFilter<"AgentActivity"> | Date | string
    updatedAt?: DateTimeFilter<"AgentActivity"> | Date | string
  }

  export type AgentTaskUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentTaskWhereUniqueInput
    update: XOR<AgentTaskUpdateWithoutAgentInput, AgentTaskUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentTaskCreateWithoutAgentInput, AgentTaskUncheckedCreateWithoutAgentInput>
  }

  export type AgentTaskUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentTaskWhereUniqueInput
    data: XOR<AgentTaskUpdateWithoutAgentInput, AgentTaskUncheckedUpdateWithoutAgentInput>
  }

  export type AgentTaskUpdateManyWithWhereWithoutAgentInput = {
    where: AgentTaskScalarWhereInput
    data: XOR<AgentTaskUpdateManyMutationInput, AgentTaskUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentTaskScalarWhereInput = {
    AND?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
    OR?: AgentTaskScalarWhereInput[]
    NOT?: AgentTaskScalarWhereInput | AgentTaskScalarWhereInput[]
    id?: StringFilter<"AgentTask"> | string
    agentId?: StringFilter<"AgentTask"> | string
    taskId?: StringFilter<"AgentTask"> | string
    createdAt?: DateTimeFilter<"AgentTask"> | Date | string
    updatedAt?: DateTimeFilter<"AgentTask"> | Date | string
  }

  export type AgentWorklogUpsertWithWhereUniqueWithoutAgentInput = {
    where: AgentWorklogWhereUniqueInput
    update: XOR<AgentWorklogUpdateWithoutAgentInput, AgentWorklogUncheckedUpdateWithoutAgentInput>
    create: XOR<AgentWorklogCreateWithoutAgentInput, AgentWorklogUncheckedCreateWithoutAgentInput>
  }

  export type AgentWorklogUpdateWithWhereUniqueWithoutAgentInput = {
    where: AgentWorklogWhereUniqueInput
    data: XOR<AgentWorklogUpdateWithoutAgentInput, AgentWorklogUncheckedUpdateWithoutAgentInput>
  }

  export type AgentWorklogUpdateManyWithWhereWithoutAgentInput = {
    where: AgentWorklogScalarWhereInput
    data: XOR<AgentWorklogUpdateManyMutationInput, AgentWorklogUncheckedUpdateManyWithoutAgentInput>
  }

  export type AgentWorklogScalarWhereInput = {
    AND?: AgentWorklogScalarWhereInput | AgentWorklogScalarWhereInput[]
    OR?: AgentWorklogScalarWhereInput[]
    NOT?: AgentWorklogScalarWhereInput | AgentWorklogScalarWhereInput[]
    id?: StringFilter<"AgentWorklog"> | string
    projectId?: StringFilter<"AgentWorklog"> | string
    agentId?: StringFilter<"AgentWorklog"> | string
    taskId?: StringFilter<"AgentWorklog"> | string
    workType?: StringFilter<"AgentWorklog"> | string
    summarize?: StringNullableFilter<"AgentWorklog"> | string | null
    nextPlan?: StringNullableFilter<"AgentWorklog"> | string | null
    content?: StringNullableFilter<"AgentWorklog"> | string | null
    metadata?: JsonNullableFilter<"AgentWorklog">
    createdAt?: DateTimeFilter<"AgentWorklog"> | Date | string
    updatedAt?: DateTimeFilter<"AgentWorklog"> | Date | string
  }

  export type RequirementQuestionUpsertWithWhereUniqueWithoutAgentInput = {
    where: RequirementQuestionWhereUniqueInput
    update: XOR<RequirementQuestionUpdateWithoutAgentInput, RequirementQuestionUncheckedUpdateWithoutAgentInput>
    create: XOR<RequirementQuestionCreateWithoutAgentInput, RequirementQuestionUncheckedCreateWithoutAgentInput>
  }

  export type RequirementQuestionUpdateWithWhereUniqueWithoutAgentInput = {
    where: RequirementQuestionWhereUniqueInput
    data: XOR<RequirementQuestionUpdateWithoutAgentInput, RequirementQuestionUncheckedUpdateWithoutAgentInput>
  }

  export type RequirementQuestionUpdateManyWithWhereWithoutAgentInput = {
    where: RequirementQuestionScalarWhereInput
    data: XOR<RequirementQuestionUpdateManyMutationInput, RequirementQuestionUncheckedUpdateManyWithoutAgentInput>
  }

  export type RequirementQuestionScalarWhereInput = {
    AND?: RequirementQuestionScalarWhereInput | RequirementQuestionScalarWhereInput[]
    OR?: RequirementQuestionScalarWhereInput[]
    NOT?: RequirementQuestionScalarWhereInput | RequirementQuestionScalarWhereInput[]
    id?: StringFilter<"RequirementQuestion"> | string
    projectId?: StringFilter<"RequirementQuestion"> | string
    requirementId?: StringFilter<"RequirementQuestion"> | string
    question?: StringFilter<"RequirementQuestion"> | string
    answer?: StringNullableFilter<"RequirementQuestion"> | string | null
    status?: EnumQuestionStatusFilter<"RequirementQuestion"> | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFilter<"RequirementQuestion"> | $Enums.QuestionPriority
    clarified?: BoolFilter<"RequirementQuestion"> | boolean
    agentId?: StringFilter<"RequirementQuestion"> | string
    createdAt?: DateTimeFilter<"RequirementQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"RequirementQuestion"> | Date | string
    answeredAt?: DateTimeNullableFilter<"RequirementQuestion"> | Date | string | null
  }

  export type AgentCreateWithoutAgentTaskInput = {
    id?: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgentInput
    team: TeamCreateNestedOneWithoutAgentsInput
    AgentActivity?: AgentActivityCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAgentTaskInput = {
    id?: string
    projectId: string
    teamId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    AgentActivity?: AgentActivityUncheckedCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAgentTaskInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAgentTaskInput, AgentUncheckedCreateWithoutAgentTaskInput>
  }

  export type TaskCreateWithoutAgentTaskInput = {
    id?: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    sprint: SprintCreateNestedOneWithoutTaskInput
    team: TeamCreateNestedOneWithoutTasksInput
    feature?: FeatureCreateNestedOneWithoutTasksInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAgentTaskInput = {
    id?: string
    projectId: string
    sprintId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAgentTaskInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAgentTaskInput, TaskUncheckedCreateWithoutAgentTaskInput>
  }

  export type AgentUpsertWithoutAgentTaskInput = {
    update: XOR<AgentUpdateWithoutAgentTaskInput, AgentUncheckedUpdateWithoutAgentTaskInput>
    create: XOR<AgentCreateWithoutAgentTaskInput, AgentUncheckedCreateWithoutAgentTaskInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAgentTaskInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAgentTaskInput, AgentUncheckedUpdateWithoutAgentTaskInput>
  }

  export type AgentUpdateWithoutAgentTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgentNestedInput
    team?: TeamUpdateOneRequiredWithoutAgentsNestedInput
    AgentActivity?: AgentActivityUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAgentTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentActivity?: AgentActivityUncheckedUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type TaskUpsertWithoutAgentTaskInput = {
    update: XOR<TaskUpdateWithoutAgentTaskInput, TaskUncheckedUpdateWithoutAgentTaskInput>
    create: XOR<TaskCreateWithoutAgentTaskInput, TaskUncheckedCreateWithoutAgentTaskInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAgentTaskInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAgentTaskInput, TaskUncheckedUpdateWithoutAgentTaskInput>
  }

  export type TaskUpdateWithoutAgentTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    sprint?: SprintUpdateOneRequiredWithoutTaskNestedInput
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    feature?: FeatureUpdateOneWithoutTasksNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAgentTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type AgentCreateWithoutAgentActivityInput = {
    id?: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgentInput
    team: TeamCreateNestedOneWithoutAgentsInput
    AgentTask?: AgentTaskCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAgentActivityInput = {
    id?: string
    projectId: string
    teamId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAgentActivityInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAgentActivityInput, AgentUncheckedCreateWithoutAgentActivityInput>
  }

  export type AgentUpsertWithoutAgentActivityInput = {
    update: XOR<AgentUpdateWithoutAgentActivityInput, AgentUncheckedUpdateWithoutAgentActivityInput>
    create: XOR<AgentCreateWithoutAgentActivityInput, AgentUncheckedCreateWithoutAgentActivityInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAgentActivityInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAgentActivityInput, AgentUncheckedUpdateWithoutAgentActivityInput>
  }

  export type AgentUpdateWithoutAgentActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgentNestedInput
    team?: TeamUpdateOneRequiredWithoutAgentsNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAgentActivityInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ProjectCreateWithoutAgentWorklogInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAgentWorklogInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAgentWorklogInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAgentWorklogInput, ProjectUncheckedCreateWithoutAgentWorklogInput>
  }

  export type AgentCreateWithoutAgentWorklogInput = {
    id?: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgentInput
    team: TeamCreateNestedOneWithoutAgentsInput
    AgentActivity?: AgentActivityCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutAgentWorklogInput = {
    id?: string
    projectId: string
    teamId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    AgentActivity?: AgentActivityUncheckedCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutAgentWorklogInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutAgentWorklogInput, AgentUncheckedCreateWithoutAgentWorklogInput>
  }

  export type TaskCreateWithoutAgentWorklogInput = {
    id?: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    sprint: SprintCreateNestedOneWithoutTaskInput
    team: TeamCreateNestedOneWithoutTasksInput
    feature?: FeatureCreateNestedOneWithoutTasksInput
    AgentTask?: AgentTaskCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutAgentWorklogInput = {
    id?: string
    projectId: string
    sprintId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutAgentWorklogInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAgentWorklogInput, TaskUncheckedCreateWithoutAgentWorklogInput>
  }

  export type ProjectUpsertWithoutAgentWorklogInput = {
    update: XOR<ProjectUpdateWithoutAgentWorklogInput, ProjectUncheckedUpdateWithoutAgentWorklogInput>
    create: XOR<ProjectCreateWithoutAgentWorklogInput, ProjectUncheckedCreateWithoutAgentWorklogInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAgentWorklogInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAgentWorklogInput, ProjectUncheckedUpdateWithoutAgentWorklogInput>
  }

  export type ProjectUpdateWithoutAgentWorklogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAgentWorklogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type AgentUpsertWithoutAgentWorklogInput = {
    update: XOR<AgentUpdateWithoutAgentWorklogInput, AgentUncheckedUpdateWithoutAgentWorklogInput>
    create: XOR<AgentCreateWithoutAgentWorklogInput, AgentUncheckedCreateWithoutAgentWorklogInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutAgentWorklogInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutAgentWorklogInput, AgentUncheckedUpdateWithoutAgentWorklogInput>
  }

  export type AgentUpdateWithoutAgentWorklogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgentNestedInput
    team?: TeamUpdateOneRequiredWithoutAgentsNestedInput
    AgentActivity?: AgentActivityUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutAgentWorklogInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentActivity?: AgentActivityUncheckedUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type TaskUpsertWithoutAgentWorklogInput = {
    update: XOR<TaskUpdateWithoutAgentWorklogInput, TaskUncheckedUpdateWithoutAgentWorklogInput>
    create: XOR<TaskCreateWithoutAgentWorklogInput, TaskUncheckedCreateWithoutAgentWorklogInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutAgentWorklogInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutAgentWorklogInput, TaskUncheckedUpdateWithoutAgentWorklogInput>
  }

  export type TaskUpdateWithoutAgentWorklogInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    sprint?: SprintUpdateOneRequiredWithoutTaskNestedInput
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    feature?: FeatureUpdateOneWithoutTasksNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutAgentWorklogInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ProjectCreateWithoutApiDesignInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutApiDesignInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutApiDesignInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutApiDesignInput, ProjectUncheckedCreateWithoutApiDesignInput>
  }

  export type ApiExampleCreateWithoutApiDesignInput = {
    id?: string
    name: string
    description: string
    requestUrl: string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus: number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    isSuccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiExampleUncheckedCreateWithoutApiDesignInput = {
    id?: string
    name: string
    description: string
    requestUrl: string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus: number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    isSuccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiExampleCreateOrConnectWithoutApiDesignInput = {
    where: ApiExampleWhereUniqueInput
    create: XOR<ApiExampleCreateWithoutApiDesignInput, ApiExampleUncheckedCreateWithoutApiDesignInput>
  }

  export type ApiExampleCreateManyApiDesignInputEnvelope = {
    data: ApiExampleCreateManyApiDesignInput | ApiExampleCreateManyApiDesignInput[]
    skipDuplicates?: boolean
  }

  export type ApiErrorCodeCreateWithoutApiDesignInput = {
    id?: string
    code: string
    httpStatus: number
    message: string
    description: string
    solution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiErrorCodeUncheckedCreateWithoutApiDesignInput = {
    id?: string
    code: string
    httpStatus: number
    message: string
    description: string
    solution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiErrorCodeCreateOrConnectWithoutApiDesignInput = {
    where: ApiErrorCodeWhereUniqueInput
    create: XOR<ApiErrorCodeCreateWithoutApiDesignInput, ApiErrorCodeUncheckedCreateWithoutApiDesignInput>
  }

  export type ApiErrorCodeCreateManyApiDesignInputEnvelope = {
    data: ApiErrorCodeCreateManyApiDesignInput | ApiErrorCodeCreateManyApiDesignInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutApiDesignInput = {
    update: XOR<ProjectUpdateWithoutApiDesignInput, ProjectUncheckedUpdateWithoutApiDesignInput>
    create: XOR<ProjectCreateWithoutApiDesignInput, ProjectUncheckedCreateWithoutApiDesignInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutApiDesignInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutApiDesignInput, ProjectUncheckedUpdateWithoutApiDesignInput>
  }

  export type ProjectUpdateWithoutApiDesignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutApiDesignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ApiExampleUpsertWithWhereUniqueWithoutApiDesignInput = {
    where: ApiExampleWhereUniqueInput
    update: XOR<ApiExampleUpdateWithoutApiDesignInput, ApiExampleUncheckedUpdateWithoutApiDesignInput>
    create: XOR<ApiExampleCreateWithoutApiDesignInput, ApiExampleUncheckedCreateWithoutApiDesignInput>
  }

  export type ApiExampleUpdateWithWhereUniqueWithoutApiDesignInput = {
    where: ApiExampleWhereUniqueInput
    data: XOR<ApiExampleUpdateWithoutApiDesignInput, ApiExampleUncheckedUpdateWithoutApiDesignInput>
  }

  export type ApiExampleUpdateManyWithWhereWithoutApiDesignInput = {
    where: ApiExampleScalarWhereInput
    data: XOR<ApiExampleUpdateManyMutationInput, ApiExampleUncheckedUpdateManyWithoutApiDesignInput>
  }

  export type ApiExampleScalarWhereInput = {
    AND?: ApiExampleScalarWhereInput | ApiExampleScalarWhereInput[]
    OR?: ApiExampleScalarWhereInput[]
    NOT?: ApiExampleScalarWhereInput | ApiExampleScalarWhereInput[]
    id?: StringFilter<"ApiExample"> | string
    apiDesignId?: StringFilter<"ApiExample"> | string
    name?: StringFilter<"ApiExample"> | string
    description?: StringFilter<"ApiExample"> | string
    requestUrl?: StringFilter<"ApiExample"> | string
    requestHeaders?: JsonNullableFilter<"ApiExample">
    requestParams?: JsonNullableFilter<"ApiExample">
    requestBody?: JsonNullableFilter<"ApiExample">
    responseStatus?: IntFilter<"ApiExample"> | number
    responseHeaders?: JsonNullableFilter<"ApiExample">
    responseBody?: JsonNullableFilter<"ApiExample">
    notes?: StringNullableFilter<"ApiExample"> | string | null
    isSuccess?: BoolFilter<"ApiExample"> | boolean
    createdAt?: DateTimeFilter<"ApiExample"> | Date | string
    updatedAt?: DateTimeFilter<"ApiExample"> | Date | string
  }

  export type ApiErrorCodeUpsertWithWhereUniqueWithoutApiDesignInput = {
    where: ApiErrorCodeWhereUniqueInput
    update: XOR<ApiErrorCodeUpdateWithoutApiDesignInput, ApiErrorCodeUncheckedUpdateWithoutApiDesignInput>
    create: XOR<ApiErrorCodeCreateWithoutApiDesignInput, ApiErrorCodeUncheckedCreateWithoutApiDesignInput>
  }

  export type ApiErrorCodeUpdateWithWhereUniqueWithoutApiDesignInput = {
    where: ApiErrorCodeWhereUniqueInput
    data: XOR<ApiErrorCodeUpdateWithoutApiDesignInput, ApiErrorCodeUncheckedUpdateWithoutApiDesignInput>
  }

  export type ApiErrorCodeUpdateManyWithWhereWithoutApiDesignInput = {
    where: ApiErrorCodeScalarWhereInput
    data: XOR<ApiErrorCodeUpdateManyMutationInput, ApiErrorCodeUncheckedUpdateManyWithoutApiDesignInput>
  }

  export type ApiErrorCodeScalarWhereInput = {
    AND?: ApiErrorCodeScalarWhereInput | ApiErrorCodeScalarWhereInput[]
    OR?: ApiErrorCodeScalarWhereInput[]
    NOT?: ApiErrorCodeScalarWhereInput | ApiErrorCodeScalarWhereInput[]
    id?: StringFilter<"ApiErrorCode"> | string
    apiDesignId?: StringFilter<"ApiErrorCode"> | string
    code?: StringFilter<"ApiErrorCode"> | string
    httpStatus?: IntFilter<"ApiErrorCode"> | number
    message?: StringFilter<"ApiErrorCode"> | string
    description?: StringFilter<"ApiErrorCode"> | string
    solution?: StringNullableFilter<"ApiErrorCode"> | string | null
    createdAt?: DateTimeFilter<"ApiErrorCode"> | Date | string
    updatedAt?: DateTimeFilter<"ApiErrorCode"> | Date | string
  }

  export type ApiDesignCreateWithoutExamplesInput = {
    id?: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutApiDesignInput
    errorCodes?: ApiErrorCodeCreateNestedManyWithoutApiDesignInput
  }

  export type ApiDesignUncheckedCreateWithoutExamplesInput = {
    id?: string
    projectId: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    errorCodes?: ApiErrorCodeUncheckedCreateNestedManyWithoutApiDesignInput
  }

  export type ApiDesignCreateOrConnectWithoutExamplesInput = {
    where: ApiDesignWhereUniqueInput
    create: XOR<ApiDesignCreateWithoutExamplesInput, ApiDesignUncheckedCreateWithoutExamplesInput>
  }

  export type ApiDesignUpsertWithoutExamplesInput = {
    update: XOR<ApiDesignUpdateWithoutExamplesInput, ApiDesignUncheckedUpdateWithoutExamplesInput>
    create: XOR<ApiDesignCreateWithoutExamplesInput, ApiDesignUncheckedCreateWithoutExamplesInput>
    where?: ApiDesignWhereInput
  }

  export type ApiDesignUpdateToOneWithWhereWithoutExamplesInput = {
    where?: ApiDesignWhereInput
    data: XOR<ApiDesignUpdateWithoutExamplesInput, ApiDesignUncheckedUpdateWithoutExamplesInput>
  }

  export type ApiDesignUpdateWithoutExamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutApiDesignNestedInput
    errorCodes?: ApiErrorCodeUpdateManyWithoutApiDesignNestedInput
  }

  export type ApiDesignUncheckedUpdateWithoutExamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCodes?: ApiErrorCodeUncheckedUpdateManyWithoutApiDesignNestedInput
  }

  export type ApiDesignCreateWithoutErrorCodesInput = {
    id?: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutApiDesignInput
    examples?: ApiExampleCreateNestedManyWithoutApiDesignInput
  }

  export type ApiDesignUncheckedCreateWithoutErrorCodesInput = {
    id?: string
    projectId: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    examples?: ApiExampleUncheckedCreateNestedManyWithoutApiDesignInput
  }

  export type ApiDesignCreateOrConnectWithoutErrorCodesInput = {
    where: ApiDesignWhereUniqueInput
    create: XOR<ApiDesignCreateWithoutErrorCodesInput, ApiDesignUncheckedCreateWithoutErrorCodesInput>
  }

  export type ApiDesignUpsertWithoutErrorCodesInput = {
    update: XOR<ApiDesignUpdateWithoutErrorCodesInput, ApiDesignUncheckedUpdateWithoutErrorCodesInput>
    create: XOR<ApiDesignCreateWithoutErrorCodesInput, ApiDesignUncheckedCreateWithoutErrorCodesInput>
    where?: ApiDesignWhereInput
  }

  export type ApiDesignUpdateToOneWithWhereWithoutErrorCodesInput = {
    where?: ApiDesignWhereInput
    data: XOR<ApiDesignUpdateWithoutErrorCodesInput, ApiDesignUncheckedUpdateWithoutErrorCodesInput>
  }

  export type ApiDesignUpdateWithoutErrorCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutApiDesignNestedInput
    examples?: ApiExampleUpdateManyWithoutApiDesignNestedInput
  }

  export type ApiDesignUncheckedUpdateWithoutErrorCodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examples?: ApiExampleUncheckedUpdateManyWithoutApiDesignNestedInput
  }

  export type ProjectCreateWithoutSystemArchitectureInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSystemArchitectureInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSystemArchitectureInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSystemArchitectureInput, ProjectUncheckedCreateWithoutSystemArchitectureInput>
  }

  export type PlatformArchitectureCreateWithoutSystemArchitectureInput = {
    id?: string
    platform: string
    displayName: string
    description: string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureCreatetechnologiesInput | string[]
    components?: PlatformArchitectureCreatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: string | null
    scalingStrategy?: string | null
    diagrams?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput = {
    id?: string
    platform: string
    displayName: string
    description: string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureCreatetechnologiesInput | string[]
    components?: PlatformArchitectureCreatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: string | null
    scalingStrategy?: string | null
    diagrams?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformArchitectureCreateOrConnectWithoutSystemArchitectureInput = {
    where: PlatformArchitectureWhereUniqueInput
    create: XOR<PlatformArchitectureCreateWithoutSystemArchitectureInput, PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput>
  }

  export type PlatformArchitectureCreateManySystemArchitectureInputEnvelope = {
    data: PlatformArchitectureCreateManySystemArchitectureInput | PlatformArchitectureCreateManySystemArchitectureInput[]
    skipDuplicates?: boolean
  }

  export type ArchitectureChangeHistoryCreateWithoutArchitectureInput = {
    id?: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact?: string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    User?: UserCreateNestedOneWithoutArchitectureChangeHistoryInput
  }

  export type ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput = {
    id?: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact?: string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    userId?: string | null
  }

  export type ArchitectureChangeHistoryCreateOrConnectWithoutArchitectureInput = {
    where: ArchitectureChangeHistoryWhereUniqueInput
    create: XOR<ArchitectureChangeHistoryCreateWithoutArchitectureInput, ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput>
  }

  export type ArchitectureChangeHistoryCreateManyArchitectureInputEnvelope = {
    data: ArchitectureChangeHistoryCreateManyArchitectureInput | ArchitectureChangeHistoryCreateManyArchitectureInput[]
    skipDuplicates?: boolean
  }

  export type SystemArchitectureCreateWithoutNextVersionsInput = {
    id?: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutSystemArchitectureInput
    platformArchitectures?: PlatformArchitectureCreateNestedManyWithoutSystemArchitectureInput
    changeHistories?: ArchitectureChangeHistoryCreateNestedManyWithoutArchitectureInput
    previousVersion?: SystemArchitectureCreateNestedOneWithoutNextVersionsInput
  }

  export type SystemArchitectureUncheckedCreateWithoutNextVersionsInput = {
    id?: string
    projectId: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    previousVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedCreateNestedManyWithoutSystemArchitectureInput
    changeHistories?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutArchitectureInput
  }

  export type SystemArchitectureCreateOrConnectWithoutNextVersionsInput = {
    where: SystemArchitectureWhereUniqueInput
    create: XOR<SystemArchitectureCreateWithoutNextVersionsInput, SystemArchitectureUncheckedCreateWithoutNextVersionsInput>
  }

  export type SystemArchitectureCreateWithoutPreviousVersionInput = {
    id?: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutSystemArchitectureInput
    platformArchitectures?: PlatformArchitectureCreateNestedManyWithoutSystemArchitectureInput
    changeHistories?: ArchitectureChangeHistoryCreateNestedManyWithoutArchitectureInput
    nextVersions?: SystemArchitectureCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureUncheckedCreateWithoutPreviousVersionInput = {
    id?: string
    projectId: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedCreateNestedManyWithoutSystemArchitectureInput
    changeHistories?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutArchitectureInput
    nextVersions?: SystemArchitectureUncheckedCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureCreateOrConnectWithoutPreviousVersionInput = {
    where: SystemArchitectureWhereUniqueInput
    create: XOR<SystemArchitectureCreateWithoutPreviousVersionInput, SystemArchitectureUncheckedCreateWithoutPreviousVersionInput>
  }

  export type SystemArchitectureCreateManyPreviousVersionInputEnvelope = {
    data: SystemArchitectureCreateManyPreviousVersionInput | SystemArchitectureCreateManyPreviousVersionInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSystemArchitectureInput = {
    update: XOR<ProjectUpdateWithoutSystemArchitectureInput, ProjectUncheckedUpdateWithoutSystemArchitectureInput>
    create: XOR<ProjectCreateWithoutSystemArchitectureInput, ProjectUncheckedCreateWithoutSystemArchitectureInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSystemArchitectureInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSystemArchitectureInput, ProjectUncheckedUpdateWithoutSystemArchitectureInput>
  }

  export type ProjectUpdateWithoutSystemArchitectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSystemArchitectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PlatformArchitectureUpsertWithWhereUniqueWithoutSystemArchitectureInput = {
    where: PlatformArchitectureWhereUniqueInput
    update: XOR<PlatformArchitectureUpdateWithoutSystemArchitectureInput, PlatformArchitectureUncheckedUpdateWithoutSystemArchitectureInput>
    create: XOR<PlatformArchitectureCreateWithoutSystemArchitectureInput, PlatformArchitectureUncheckedCreateWithoutSystemArchitectureInput>
  }

  export type PlatformArchitectureUpdateWithWhereUniqueWithoutSystemArchitectureInput = {
    where: PlatformArchitectureWhereUniqueInput
    data: XOR<PlatformArchitectureUpdateWithoutSystemArchitectureInput, PlatformArchitectureUncheckedUpdateWithoutSystemArchitectureInput>
  }

  export type PlatformArchitectureUpdateManyWithWhereWithoutSystemArchitectureInput = {
    where: PlatformArchitectureScalarWhereInput
    data: XOR<PlatformArchitectureUpdateManyMutationInput, PlatformArchitectureUncheckedUpdateManyWithoutSystemArchitectureInput>
  }

  export type PlatformArchitectureScalarWhereInput = {
    AND?: PlatformArchitectureScalarWhereInput | PlatformArchitectureScalarWhereInput[]
    OR?: PlatformArchitectureScalarWhereInput[]
    NOT?: PlatformArchitectureScalarWhereInput | PlatformArchitectureScalarWhereInput[]
    id?: StringFilter<"PlatformArchitecture"> | string
    systemArchitectureId?: StringFilter<"PlatformArchitecture"> | string
    platform?: StringFilter<"PlatformArchitecture"> | string
    displayName?: StringFilter<"PlatformArchitecture"> | string
    description?: StringFilter<"PlatformArchitecture"> | string
    frontend?: JsonNullableFilter<"PlatformArchitecture">
    backend?: JsonNullableFilter<"PlatformArchitecture">
    infrastructure?: JsonNullableFilter<"PlatformArchitecture">
    technologies?: StringNullableListFilter<"PlatformArchitecture">
    components?: StringNullableListFilter<"PlatformArchitecture">
    dependencies?: JsonNullableFilter<"PlatformArchitecture">
    deploymentStrategy?: StringNullableFilter<"PlatformArchitecture"> | string | null
    scalingStrategy?: StringNullableFilter<"PlatformArchitecture"> | string | null
    diagrams?: StringNullableFilter<"PlatformArchitecture"> | string | null
    notes?: StringNullableFilter<"PlatformArchitecture"> | string | null
    createdAt?: DateTimeFilter<"PlatformArchitecture"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformArchitecture"> | Date | string
  }

  export type ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutArchitectureInput = {
    where: ArchitectureChangeHistoryWhereUniqueInput
    update: XOR<ArchitectureChangeHistoryUpdateWithoutArchitectureInput, ArchitectureChangeHistoryUncheckedUpdateWithoutArchitectureInput>
    create: XOR<ArchitectureChangeHistoryCreateWithoutArchitectureInput, ArchitectureChangeHistoryUncheckedCreateWithoutArchitectureInput>
  }

  export type ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutArchitectureInput = {
    where: ArchitectureChangeHistoryWhereUniqueInput
    data: XOR<ArchitectureChangeHistoryUpdateWithoutArchitectureInput, ArchitectureChangeHistoryUncheckedUpdateWithoutArchitectureInput>
  }

  export type ArchitectureChangeHistoryUpdateManyWithWhereWithoutArchitectureInput = {
    where: ArchitectureChangeHistoryScalarWhereInput
    data: XOR<ArchitectureChangeHistoryUpdateManyMutationInput, ArchitectureChangeHistoryUncheckedUpdateManyWithoutArchitectureInput>
  }

  export type ArchitectureChangeHistoryScalarWhereInput = {
    AND?: ArchitectureChangeHistoryScalarWhereInput | ArchitectureChangeHistoryScalarWhereInput[]
    OR?: ArchitectureChangeHistoryScalarWhereInput[]
    NOT?: ArchitectureChangeHistoryScalarWhereInput | ArchitectureChangeHistoryScalarWhereInput[]
    id?: StringFilter<"ArchitectureChangeHistory"> | string
    architectureId?: StringFilter<"ArchitectureChangeHistory"> | string
    changeType?: StringFilter<"ArchitectureChangeHistory"> | string
    changeDescription?: StringFilter<"ArchitectureChangeHistory"> | string
    changeReason?: StringFilter<"ArchitectureChangeHistory"> | string
    impact?: StringNullableFilter<"ArchitectureChangeHistory"> | string | null
    beforeChange?: JsonNullableFilter<"ArchitectureChangeHistory">
    afterChange?: JsonNullableFilter<"ArchitectureChangeHistory">
    changedAt?: DateTimeFilter<"ArchitectureChangeHistory"> | Date | string
    userId?: StringNullableFilter<"ArchitectureChangeHistory"> | string | null
  }

  export type SystemArchitectureUpsertWithoutNextVersionsInput = {
    update: XOR<SystemArchitectureUpdateWithoutNextVersionsInput, SystemArchitectureUncheckedUpdateWithoutNextVersionsInput>
    create: XOR<SystemArchitectureCreateWithoutNextVersionsInput, SystemArchitectureUncheckedCreateWithoutNextVersionsInput>
    where?: SystemArchitectureWhereInput
  }

  export type SystemArchitectureUpdateToOneWithWhereWithoutNextVersionsInput = {
    where?: SystemArchitectureWhereInput
    data: XOR<SystemArchitectureUpdateWithoutNextVersionsInput, SystemArchitectureUncheckedUpdateWithoutNextVersionsInput>
  }

  export type SystemArchitectureUpdateWithoutNextVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutSystemArchitectureNestedInput
    platformArchitectures?: PlatformArchitectureUpdateManyWithoutSystemArchitectureNestedInput
    changeHistories?: ArchitectureChangeHistoryUpdateManyWithoutArchitectureNestedInput
    previousVersion?: SystemArchitectureUpdateOneWithoutNextVersionsNestedInput
  }

  export type SystemArchitectureUncheckedUpdateWithoutNextVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    previousVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedUpdateManyWithoutSystemArchitectureNestedInput
    changeHistories?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutArchitectureNestedInput
  }

  export type SystemArchitectureUpsertWithWhereUniqueWithoutPreviousVersionInput = {
    where: SystemArchitectureWhereUniqueInput
    update: XOR<SystemArchitectureUpdateWithoutPreviousVersionInput, SystemArchitectureUncheckedUpdateWithoutPreviousVersionInput>
    create: XOR<SystemArchitectureCreateWithoutPreviousVersionInput, SystemArchitectureUncheckedCreateWithoutPreviousVersionInput>
  }

  export type SystemArchitectureUpdateWithWhereUniqueWithoutPreviousVersionInput = {
    where: SystemArchitectureWhereUniqueInput
    data: XOR<SystemArchitectureUpdateWithoutPreviousVersionInput, SystemArchitectureUncheckedUpdateWithoutPreviousVersionInput>
  }

  export type SystemArchitectureUpdateManyWithWhereWithoutPreviousVersionInput = {
    where: SystemArchitectureScalarWhereInput
    data: XOR<SystemArchitectureUpdateManyMutationInput, SystemArchitectureUncheckedUpdateManyWithoutPreviousVersionInput>
  }

  export type SystemArchitectureScalarWhereInput = {
    AND?: SystemArchitectureScalarWhereInput | SystemArchitectureScalarWhereInput[]
    OR?: SystemArchitectureScalarWhereInput[]
    NOT?: SystemArchitectureScalarWhereInput | SystemArchitectureScalarWhereInput[]
    id?: StringFilter<"SystemArchitecture"> | string
    projectId?: StringFilter<"SystemArchitecture"> | string
    name?: StringFilter<"SystemArchitecture"> | string
    overview?: StringFilter<"SystemArchitecture"> | string
    version?: StringFilter<"SystemArchitecture"> | string
    status?: EnumArchitectureStatusFilter<"SystemArchitecture"> | $Enums.ArchitectureStatus
    platforms?: StringNullableListFilter<"SystemArchitecture">
    components?: StringNullableListFilter<"SystemArchitecture">
    technologies?: StringNullableListFilter<"SystemArchitecture">
    diagrams?: StringNullableFilter<"SystemArchitecture"> | string | null
    notes?: StringNullableFilter<"SystemArchitecture"> | string | null
    versionNumber?: IntFilter<"SystemArchitecture"> | number
    previousVersionId?: StringNullableFilter<"SystemArchitecture"> | string | null
    createdAt?: DateTimeFilter<"SystemArchitecture"> | Date | string
    updatedAt?: DateTimeFilter<"SystemArchitecture"> | Date | string
    deletedAt?: DateTimeNullableFilter<"SystemArchitecture"> | Date | string | null
  }

  export type SystemArchitectureCreateWithoutPlatformArchitecturesInput = {
    id?: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutSystemArchitectureInput
    changeHistories?: ArchitectureChangeHistoryCreateNestedManyWithoutArchitectureInput
    previousVersion?: SystemArchitectureCreateNestedOneWithoutNextVersionsInput
    nextVersions?: SystemArchitectureCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureUncheckedCreateWithoutPlatformArchitecturesInput = {
    id?: string
    projectId: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    previousVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    changeHistories?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutArchitectureInput
    nextVersions?: SystemArchitectureUncheckedCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureCreateOrConnectWithoutPlatformArchitecturesInput = {
    where: SystemArchitectureWhereUniqueInput
    create: XOR<SystemArchitectureCreateWithoutPlatformArchitecturesInput, SystemArchitectureUncheckedCreateWithoutPlatformArchitecturesInput>
  }

  export type SystemArchitectureUpsertWithoutPlatformArchitecturesInput = {
    update: XOR<SystemArchitectureUpdateWithoutPlatformArchitecturesInput, SystemArchitectureUncheckedUpdateWithoutPlatformArchitecturesInput>
    create: XOR<SystemArchitectureCreateWithoutPlatformArchitecturesInput, SystemArchitectureUncheckedCreateWithoutPlatformArchitecturesInput>
    where?: SystemArchitectureWhereInput
  }

  export type SystemArchitectureUpdateToOneWithWhereWithoutPlatformArchitecturesInput = {
    where?: SystemArchitectureWhereInput
    data: XOR<SystemArchitectureUpdateWithoutPlatformArchitecturesInput, SystemArchitectureUncheckedUpdateWithoutPlatformArchitecturesInput>
  }

  export type SystemArchitectureUpdateWithoutPlatformArchitecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutSystemArchitectureNestedInput
    changeHistories?: ArchitectureChangeHistoryUpdateManyWithoutArchitectureNestedInput
    previousVersion?: SystemArchitectureUpdateOneWithoutNextVersionsNestedInput
    nextVersions?: SystemArchitectureUpdateManyWithoutPreviousVersionNestedInput
  }

  export type SystemArchitectureUncheckedUpdateWithoutPlatformArchitecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    previousVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    changeHistories?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutArchitectureNestedInput
    nextVersions?: SystemArchitectureUncheckedUpdateManyWithoutPreviousVersionNestedInput
  }

  export type SystemArchitectureCreateWithoutChangeHistoriesInput = {
    id?: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutSystemArchitectureInput
    platformArchitectures?: PlatformArchitectureCreateNestedManyWithoutSystemArchitectureInput
    previousVersion?: SystemArchitectureCreateNestedOneWithoutNextVersionsInput
    nextVersions?: SystemArchitectureCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureUncheckedCreateWithoutChangeHistoriesInput = {
    id?: string
    projectId: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    previousVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedCreateNestedManyWithoutSystemArchitectureInput
    nextVersions?: SystemArchitectureUncheckedCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureCreateOrConnectWithoutChangeHistoriesInput = {
    where: SystemArchitectureWhereUniqueInput
    create: XOR<SystemArchitectureCreateWithoutChangeHistoriesInput, SystemArchitectureUncheckedCreateWithoutChangeHistoriesInput>
  }

  export type UserCreateWithoutArchitectureChangeHistoryInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArchitectureChangeHistoryInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArchitectureChangeHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArchitectureChangeHistoryInput, UserUncheckedCreateWithoutArchitectureChangeHistoryInput>
  }

  export type SystemArchitectureUpsertWithoutChangeHistoriesInput = {
    update: XOR<SystemArchitectureUpdateWithoutChangeHistoriesInput, SystemArchitectureUncheckedUpdateWithoutChangeHistoriesInput>
    create: XOR<SystemArchitectureCreateWithoutChangeHistoriesInput, SystemArchitectureUncheckedCreateWithoutChangeHistoriesInput>
    where?: SystemArchitectureWhereInput
  }

  export type SystemArchitectureUpdateToOneWithWhereWithoutChangeHistoriesInput = {
    where?: SystemArchitectureWhereInput
    data: XOR<SystemArchitectureUpdateWithoutChangeHistoriesInput, SystemArchitectureUncheckedUpdateWithoutChangeHistoriesInput>
  }

  export type SystemArchitectureUpdateWithoutChangeHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutSystemArchitectureNestedInput
    platformArchitectures?: PlatformArchitectureUpdateManyWithoutSystemArchitectureNestedInput
    previousVersion?: SystemArchitectureUpdateOneWithoutNextVersionsNestedInput
    nextVersions?: SystemArchitectureUpdateManyWithoutPreviousVersionNestedInput
  }

  export type SystemArchitectureUncheckedUpdateWithoutChangeHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    previousVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedUpdateManyWithoutSystemArchitectureNestedInput
    nextVersions?: SystemArchitectureUncheckedUpdateManyWithoutPreviousVersionNestedInput
  }

  export type UserUpsertWithoutArchitectureChangeHistoryInput = {
    update: XOR<UserUpdateWithoutArchitectureChangeHistoryInput, UserUncheckedUpdateWithoutArchitectureChangeHistoryInput>
    create: XOR<UserCreateWithoutArchitectureChangeHistoryInput, UserUncheckedCreateWithoutArchitectureChangeHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArchitectureChangeHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArchitectureChangeHistoryInput, UserUncheckedUpdateWithoutArchitectureChangeHistoryInput>
  }

  export type UserUpdateWithoutArchitectureChangeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArchitectureChangeHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutDatabaseSchemaInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDatabaseSchemaInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDatabaseSchemaInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDatabaseSchemaInput, ProjectUncheckedCreateWithoutDatabaseSchemaInput>
  }

  export type DatabaseTableCreateWithoutSchemaInput = {
    id?: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    columns?: TableColumnCreateNestedManyWithoutTableInput
    indexes?: DatabaseIndexCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationCreateNestedManyWithoutSourceTableInput
    targetRelations?: DatabaseRelationCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableUncheckedCreateWithoutSchemaInput = {
    id?: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    columns?: TableColumnUncheckedCreateNestedManyWithoutTableInput
    indexes?: DatabaseIndexUncheckedCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutSourceTableInput
    targetRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableCreateOrConnectWithoutSchemaInput = {
    where: DatabaseTableWhereUniqueInput
    create: XOR<DatabaseTableCreateWithoutSchemaInput, DatabaseTableUncheckedCreateWithoutSchemaInput>
  }

  export type DatabaseTableCreateManySchemaInputEnvelope = {
    data: DatabaseTableCreateManySchemaInput | DatabaseTableCreateManySchemaInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDatabaseSchemaInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDatabaseSchemaInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDatabaseSchemaInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDatabaseSchemaInput, UserUncheckedCreateWithoutDatabaseSchemaInput>
  }

  export type ProjectUpsertWithoutDatabaseSchemaInput = {
    update: XOR<ProjectUpdateWithoutDatabaseSchemaInput, ProjectUncheckedUpdateWithoutDatabaseSchemaInput>
    create: XOR<ProjectCreateWithoutDatabaseSchemaInput, ProjectUncheckedCreateWithoutDatabaseSchemaInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDatabaseSchemaInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDatabaseSchemaInput, ProjectUncheckedUpdateWithoutDatabaseSchemaInput>
  }

  export type ProjectUpdateWithoutDatabaseSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDatabaseSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DatabaseTableUpsertWithWhereUniqueWithoutSchemaInput = {
    where: DatabaseTableWhereUniqueInput
    update: XOR<DatabaseTableUpdateWithoutSchemaInput, DatabaseTableUncheckedUpdateWithoutSchemaInput>
    create: XOR<DatabaseTableCreateWithoutSchemaInput, DatabaseTableUncheckedCreateWithoutSchemaInput>
  }

  export type DatabaseTableUpdateWithWhereUniqueWithoutSchemaInput = {
    where: DatabaseTableWhereUniqueInput
    data: XOR<DatabaseTableUpdateWithoutSchemaInput, DatabaseTableUncheckedUpdateWithoutSchemaInput>
  }

  export type DatabaseTableUpdateManyWithWhereWithoutSchemaInput = {
    where: DatabaseTableScalarWhereInput
    data: XOR<DatabaseTableUpdateManyMutationInput, DatabaseTableUncheckedUpdateManyWithoutSchemaInput>
  }

  export type DatabaseTableScalarWhereInput = {
    AND?: DatabaseTableScalarWhereInput | DatabaseTableScalarWhereInput[]
    OR?: DatabaseTableScalarWhereInput[]
    NOT?: DatabaseTableScalarWhereInput | DatabaseTableScalarWhereInput[]
    id?: StringFilter<"DatabaseTable"> | string
    schemaId?: StringFilter<"DatabaseTable"> | string
    tableName?: StringFilter<"DatabaseTable"> | string
    displayName?: StringFilter<"DatabaseTable"> | string
    description?: StringNullableFilter<"DatabaseTable"> | string | null
    engine?: StringNullableFilter<"DatabaseTable"> | string | null
    charset?: StringNullableFilter<"DatabaseTable"> | string | null
    collation?: StringNullableFilter<"DatabaseTable"> | string | null
    autoIncrement?: IntNullableFilter<"DatabaseTable"> | number | null
    comment?: StringNullableFilter<"DatabaseTable"> | string | null
    createdAt?: DateTimeFilter<"DatabaseTable"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseTable"> | Date | string
  }

  export type UserUpsertWithoutDatabaseSchemaInput = {
    update: XOR<UserUpdateWithoutDatabaseSchemaInput, UserUncheckedUpdateWithoutDatabaseSchemaInput>
    create: XOR<UserCreateWithoutDatabaseSchemaInput, UserUncheckedCreateWithoutDatabaseSchemaInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDatabaseSchemaInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDatabaseSchemaInput, UserUncheckedUpdateWithoutDatabaseSchemaInput>
  }

  export type UserUpdateWithoutDatabaseSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDatabaseSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DatabaseSchemaCreateWithoutTablesInput = {
    id?: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDatabaseSchemaInput
    User?: UserCreateNestedOneWithoutDatabaseSchemaInput
  }

  export type DatabaseSchemaUncheckedCreateWithoutTablesInput = {
    id?: string
    projectId: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type DatabaseSchemaCreateOrConnectWithoutTablesInput = {
    where: DatabaseSchemaWhereUniqueInput
    create: XOR<DatabaseSchemaCreateWithoutTablesInput, DatabaseSchemaUncheckedCreateWithoutTablesInput>
  }

  export type TableColumnCreateWithoutTableInput = {
    id?: string
    columnName: string
    displayName: string
    columnType: $Enums.ColumnType
    length?: number | null
    precision?: number | null
    scale?: number | null
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: string | null
    comment?: string | null
    enumValues?: TableColumnCreateenumValuesInput | string[]
    isForeignKey?: boolean
    referencedTable?: string | null
    referencedColumn?: string | null
    onDelete?: string | null
    onUpdate?: string | null
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableColumnUncheckedCreateWithoutTableInput = {
    id?: string
    columnName: string
    displayName: string
    columnType: $Enums.ColumnType
    length?: number | null
    precision?: number | null
    scale?: number | null
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: string | null
    comment?: string | null
    enumValues?: TableColumnCreateenumValuesInput | string[]
    isForeignKey?: boolean
    referencedTable?: string | null
    referencedColumn?: string | null
    onDelete?: string | null
    onUpdate?: string | null
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableColumnCreateOrConnectWithoutTableInput = {
    where: TableColumnWhereUniqueInput
    create: XOR<TableColumnCreateWithoutTableInput, TableColumnUncheckedCreateWithoutTableInput>
  }

  export type TableColumnCreateManyTableInputEnvelope = {
    data: TableColumnCreateManyTableInput | TableColumnCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type DatabaseIndexCreateWithoutTableInput = {
    id?: string
    indexName: string
    indexType: $Enums.IndexType
    columns?: DatabaseIndexCreatecolumnsInput | string[]
    isUnique?: boolean
    comment?: string | null
    algorithm?: string | null
    lockOption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseIndexUncheckedCreateWithoutTableInput = {
    id?: string
    indexName: string
    indexType: $Enums.IndexType
    columns?: DatabaseIndexCreatecolumnsInput | string[]
    isUnique?: boolean
    comment?: string | null
    algorithm?: string | null
    lockOption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseIndexCreateOrConnectWithoutTableInput = {
    where: DatabaseIndexWhereUniqueInput
    create: XOR<DatabaseIndexCreateWithoutTableInput, DatabaseIndexUncheckedCreateWithoutTableInput>
  }

  export type DatabaseIndexCreateManyTableInputEnvelope = {
    data: DatabaseIndexCreateManyTableInput | DatabaseIndexCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type DatabaseRelationCreateWithoutSourceTableInput = {
    id?: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceColumns?: DatabaseRelationCreatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationCreatetargetColumnsInput | string[]
    onDelete?: string | null
    onUpdate?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetTable: DatabaseTableCreateNestedOneWithoutTargetRelationsInput
  }

  export type DatabaseRelationUncheckedCreateWithoutSourceTableInput = {
    id?: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceColumns?: DatabaseRelationCreatesourceColumnsInput | string[]
    targetTableId: string
    targetColumns?: DatabaseRelationCreatetargetColumnsInput | string[]
    onDelete?: string | null
    onUpdate?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseRelationCreateOrConnectWithoutSourceTableInput = {
    where: DatabaseRelationWhereUniqueInput
    create: XOR<DatabaseRelationCreateWithoutSourceTableInput, DatabaseRelationUncheckedCreateWithoutSourceTableInput>
  }

  export type DatabaseRelationCreateManySourceTableInputEnvelope = {
    data: DatabaseRelationCreateManySourceTableInput | DatabaseRelationCreateManySourceTableInput[]
    skipDuplicates?: boolean
  }

  export type DatabaseRelationCreateWithoutTargetTableInput = {
    id?: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceColumns?: DatabaseRelationCreatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationCreatetargetColumnsInput | string[]
    onDelete?: string | null
    onUpdate?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceTable: DatabaseTableCreateNestedOneWithoutSourceRelationsInput
  }

  export type DatabaseRelationUncheckedCreateWithoutTargetTableInput = {
    id?: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceTableId: string
    sourceColumns?: DatabaseRelationCreatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationCreatetargetColumnsInput | string[]
    onDelete?: string | null
    onUpdate?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseRelationCreateOrConnectWithoutTargetTableInput = {
    where: DatabaseRelationWhereUniqueInput
    create: XOR<DatabaseRelationCreateWithoutTargetTableInput, DatabaseRelationUncheckedCreateWithoutTargetTableInput>
  }

  export type DatabaseRelationCreateManyTargetTableInputEnvelope = {
    data: DatabaseRelationCreateManyTargetTableInput | DatabaseRelationCreateManyTargetTableInput[]
    skipDuplicates?: boolean
  }

  export type DatabaseSchemaUpsertWithoutTablesInput = {
    update: XOR<DatabaseSchemaUpdateWithoutTablesInput, DatabaseSchemaUncheckedUpdateWithoutTablesInput>
    create: XOR<DatabaseSchemaCreateWithoutTablesInput, DatabaseSchemaUncheckedCreateWithoutTablesInput>
    where?: DatabaseSchemaWhereInput
  }

  export type DatabaseSchemaUpdateToOneWithWhereWithoutTablesInput = {
    where?: DatabaseSchemaWhereInput
    data: XOR<DatabaseSchemaUpdateWithoutTablesInput, DatabaseSchemaUncheckedUpdateWithoutTablesInput>
  }

  export type DatabaseSchemaUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDatabaseSchemaNestedInput
    User?: UserUpdateOneWithoutDatabaseSchemaNestedInput
  }

  export type DatabaseSchemaUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TableColumnUpsertWithWhereUniqueWithoutTableInput = {
    where: TableColumnWhereUniqueInput
    update: XOR<TableColumnUpdateWithoutTableInput, TableColumnUncheckedUpdateWithoutTableInput>
    create: XOR<TableColumnCreateWithoutTableInput, TableColumnUncheckedCreateWithoutTableInput>
  }

  export type TableColumnUpdateWithWhereUniqueWithoutTableInput = {
    where: TableColumnWhereUniqueInput
    data: XOR<TableColumnUpdateWithoutTableInput, TableColumnUncheckedUpdateWithoutTableInput>
  }

  export type TableColumnUpdateManyWithWhereWithoutTableInput = {
    where: TableColumnScalarWhereInput
    data: XOR<TableColumnUpdateManyMutationInput, TableColumnUncheckedUpdateManyWithoutTableInput>
  }

  export type TableColumnScalarWhereInput = {
    AND?: TableColumnScalarWhereInput | TableColumnScalarWhereInput[]
    OR?: TableColumnScalarWhereInput[]
    NOT?: TableColumnScalarWhereInput | TableColumnScalarWhereInput[]
    id?: StringFilter<"TableColumn"> | string
    tableId?: StringFilter<"TableColumn"> | string
    columnName?: StringFilter<"TableColumn"> | string
    displayName?: StringFilter<"TableColumn"> | string
    columnType?: EnumColumnTypeFilter<"TableColumn"> | $Enums.ColumnType
    length?: IntNullableFilter<"TableColumn"> | number | null
    precision?: IntNullableFilter<"TableColumn"> | number | null
    scale?: IntNullableFilter<"TableColumn"> | number | null
    isPrimaryKey?: BoolFilter<"TableColumn"> | boolean
    isNullable?: BoolFilter<"TableColumn"> | boolean
    isUnique?: BoolFilter<"TableColumn"> | boolean
    isAutoIncrement?: BoolFilter<"TableColumn"> | boolean
    defaultValue?: StringNullableFilter<"TableColumn"> | string | null
    comment?: StringNullableFilter<"TableColumn"> | string | null
    enumValues?: StringNullableListFilter<"TableColumn">
    isForeignKey?: BoolFilter<"TableColumn"> | boolean
    referencedTable?: StringNullableFilter<"TableColumn"> | string | null
    referencedColumn?: StringNullableFilter<"TableColumn"> | string | null
    onDelete?: StringNullableFilter<"TableColumn"> | string | null
    onUpdate?: StringNullableFilter<"TableColumn"> | string | null
    position?: IntFilter<"TableColumn"> | number
    createdAt?: DateTimeFilter<"TableColumn"> | Date | string
    updatedAt?: DateTimeFilter<"TableColumn"> | Date | string
  }

  export type DatabaseIndexUpsertWithWhereUniqueWithoutTableInput = {
    where: DatabaseIndexWhereUniqueInput
    update: XOR<DatabaseIndexUpdateWithoutTableInput, DatabaseIndexUncheckedUpdateWithoutTableInput>
    create: XOR<DatabaseIndexCreateWithoutTableInput, DatabaseIndexUncheckedCreateWithoutTableInput>
  }

  export type DatabaseIndexUpdateWithWhereUniqueWithoutTableInput = {
    where: DatabaseIndexWhereUniqueInput
    data: XOR<DatabaseIndexUpdateWithoutTableInput, DatabaseIndexUncheckedUpdateWithoutTableInput>
  }

  export type DatabaseIndexUpdateManyWithWhereWithoutTableInput = {
    where: DatabaseIndexScalarWhereInput
    data: XOR<DatabaseIndexUpdateManyMutationInput, DatabaseIndexUncheckedUpdateManyWithoutTableInput>
  }

  export type DatabaseIndexScalarWhereInput = {
    AND?: DatabaseIndexScalarWhereInput | DatabaseIndexScalarWhereInput[]
    OR?: DatabaseIndexScalarWhereInput[]
    NOT?: DatabaseIndexScalarWhereInput | DatabaseIndexScalarWhereInput[]
    id?: StringFilter<"DatabaseIndex"> | string
    tableId?: StringFilter<"DatabaseIndex"> | string
    indexName?: StringFilter<"DatabaseIndex"> | string
    indexType?: EnumIndexTypeFilter<"DatabaseIndex"> | $Enums.IndexType
    columns?: StringNullableListFilter<"DatabaseIndex">
    isUnique?: BoolFilter<"DatabaseIndex"> | boolean
    comment?: StringNullableFilter<"DatabaseIndex"> | string | null
    algorithm?: StringNullableFilter<"DatabaseIndex"> | string | null
    lockOption?: StringNullableFilter<"DatabaseIndex"> | string | null
    createdAt?: DateTimeFilter<"DatabaseIndex"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseIndex"> | Date | string
  }

  export type DatabaseRelationUpsertWithWhereUniqueWithoutSourceTableInput = {
    where: DatabaseRelationWhereUniqueInput
    update: XOR<DatabaseRelationUpdateWithoutSourceTableInput, DatabaseRelationUncheckedUpdateWithoutSourceTableInput>
    create: XOR<DatabaseRelationCreateWithoutSourceTableInput, DatabaseRelationUncheckedCreateWithoutSourceTableInput>
  }

  export type DatabaseRelationUpdateWithWhereUniqueWithoutSourceTableInput = {
    where: DatabaseRelationWhereUniqueInput
    data: XOR<DatabaseRelationUpdateWithoutSourceTableInput, DatabaseRelationUncheckedUpdateWithoutSourceTableInput>
  }

  export type DatabaseRelationUpdateManyWithWhereWithoutSourceTableInput = {
    where: DatabaseRelationScalarWhereInput
    data: XOR<DatabaseRelationUpdateManyMutationInput, DatabaseRelationUncheckedUpdateManyWithoutSourceTableInput>
  }

  export type DatabaseRelationScalarWhereInput = {
    AND?: DatabaseRelationScalarWhereInput | DatabaseRelationScalarWhereInput[]
    OR?: DatabaseRelationScalarWhereInput[]
    NOT?: DatabaseRelationScalarWhereInput | DatabaseRelationScalarWhereInput[]
    id?: StringFilter<"DatabaseRelation"> | string
    schemaId?: StringFilter<"DatabaseRelation"> | string
    relationName?: StringFilter<"DatabaseRelation"> | string
    relationType?: EnumRelationTypeFilter<"DatabaseRelation"> | $Enums.RelationType
    sourceTableId?: StringFilter<"DatabaseRelation"> | string
    sourceColumns?: StringNullableListFilter<"DatabaseRelation">
    targetTableId?: StringFilter<"DatabaseRelation"> | string
    targetColumns?: StringNullableListFilter<"DatabaseRelation">
    onDelete?: StringNullableFilter<"DatabaseRelation"> | string | null
    onUpdate?: StringNullableFilter<"DatabaseRelation"> | string | null
    description?: StringNullableFilter<"DatabaseRelation"> | string | null
    createdAt?: DateTimeFilter<"DatabaseRelation"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseRelation"> | Date | string
  }

  export type DatabaseRelationUpsertWithWhereUniqueWithoutTargetTableInput = {
    where: DatabaseRelationWhereUniqueInput
    update: XOR<DatabaseRelationUpdateWithoutTargetTableInput, DatabaseRelationUncheckedUpdateWithoutTargetTableInput>
    create: XOR<DatabaseRelationCreateWithoutTargetTableInput, DatabaseRelationUncheckedCreateWithoutTargetTableInput>
  }

  export type DatabaseRelationUpdateWithWhereUniqueWithoutTargetTableInput = {
    where: DatabaseRelationWhereUniqueInput
    data: XOR<DatabaseRelationUpdateWithoutTargetTableInput, DatabaseRelationUncheckedUpdateWithoutTargetTableInput>
  }

  export type DatabaseRelationUpdateManyWithWhereWithoutTargetTableInput = {
    where: DatabaseRelationScalarWhereInput
    data: XOR<DatabaseRelationUpdateManyMutationInput, DatabaseRelationUncheckedUpdateManyWithoutTargetTableInput>
  }

  export type DatabaseTableCreateWithoutColumnsInput = {
    id?: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schema: DatabaseSchemaCreateNestedOneWithoutTablesInput
    indexes?: DatabaseIndexCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationCreateNestedManyWithoutSourceTableInput
    targetRelations?: DatabaseRelationCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableUncheckedCreateWithoutColumnsInput = {
    id?: string
    schemaId: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    indexes?: DatabaseIndexUncheckedCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutSourceTableInput
    targetRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableCreateOrConnectWithoutColumnsInput = {
    where: DatabaseTableWhereUniqueInput
    create: XOR<DatabaseTableCreateWithoutColumnsInput, DatabaseTableUncheckedCreateWithoutColumnsInput>
  }

  export type DatabaseTableUpsertWithoutColumnsInput = {
    update: XOR<DatabaseTableUpdateWithoutColumnsInput, DatabaseTableUncheckedUpdateWithoutColumnsInput>
    create: XOR<DatabaseTableCreateWithoutColumnsInput, DatabaseTableUncheckedCreateWithoutColumnsInput>
    where?: DatabaseTableWhereInput
  }

  export type DatabaseTableUpdateToOneWithWhereWithoutColumnsInput = {
    where?: DatabaseTableWhereInput
    data: XOR<DatabaseTableUpdateWithoutColumnsInput, DatabaseTableUncheckedUpdateWithoutColumnsInput>
  }

  export type DatabaseTableUpdateWithoutColumnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: DatabaseSchemaUpdateOneRequiredWithoutTablesNestedInput
    indexes?: DatabaseIndexUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUpdateManyWithoutSourceTableNestedInput
    targetRelations?: DatabaseRelationUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableUncheckedUpdateWithoutColumnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    indexes?: DatabaseIndexUncheckedUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUncheckedUpdateManyWithoutSourceTableNestedInput
    targetRelations?: DatabaseRelationUncheckedUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableCreateWithoutIndexesInput = {
    id?: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schema: DatabaseSchemaCreateNestedOneWithoutTablesInput
    columns?: TableColumnCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationCreateNestedManyWithoutSourceTableInput
    targetRelations?: DatabaseRelationCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableUncheckedCreateWithoutIndexesInput = {
    id?: string
    schemaId: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    columns?: TableColumnUncheckedCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutSourceTableInput
    targetRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableCreateOrConnectWithoutIndexesInput = {
    where: DatabaseTableWhereUniqueInput
    create: XOR<DatabaseTableCreateWithoutIndexesInput, DatabaseTableUncheckedCreateWithoutIndexesInput>
  }

  export type DatabaseTableUpsertWithoutIndexesInput = {
    update: XOR<DatabaseTableUpdateWithoutIndexesInput, DatabaseTableUncheckedUpdateWithoutIndexesInput>
    create: XOR<DatabaseTableCreateWithoutIndexesInput, DatabaseTableUncheckedCreateWithoutIndexesInput>
    where?: DatabaseTableWhereInput
  }

  export type DatabaseTableUpdateToOneWithWhereWithoutIndexesInput = {
    where?: DatabaseTableWhereInput
    data: XOR<DatabaseTableUpdateWithoutIndexesInput, DatabaseTableUncheckedUpdateWithoutIndexesInput>
  }

  export type DatabaseTableUpdateWithoutIndexesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: DatabaseSchemaUpdateOneRequiredWithoutTablesNestedInput
    columns?: TableColumnUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUpdateManyWithoutSourceTableNestedInput
    targetRelations?: DatabaseRelationUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableUncheckedUpdateWithoutIndexesInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columns?: TableColumnUncheckedUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUncheckedUpdateManyWithoutSourceTableNestedInput
    targetRelations?: DatabaseRelationUncheckedUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableCreateWithoutSourceRelationsInput = {
    id?: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schema: DatabaseSchemaCreateNestedOneWithoutTablesInput
    columns?: TableColumnCreateNestedManyWithoutTableInput
    indexes?: DatabaseIndexCreateNestedManyWithoutTableInput
    targetRelations?: DatabaseRelationCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableUncheckedCreateWithoutSourceRelationsInput = {
    id?: string
    schemaId: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    columns?: TableColumnUncheckedCreateNestedManyWithoutTableInput
    indexes?: DatabaseIndexUncheckedCreateNestedManyWithoutTableInput
    targetRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutTargetTableInput
  }

  export type DatabaseTableCreateOrConnectWithoutSourceRelationsInput = {
    where: DatabaseTableWhereUniqueInput
    create: XOR<DatabaseTableCreateWithoutSourceRelationsInput, DatabaseTableUncheckedCreateWithoutSourceRelationsInput>
  }

  export type DatabaseTableCreateWithoutTargetRelationsInput = {
    id?: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    schema: DatabaseSchemaCreateNestedOneWithoutTablesInput
    columns?: TableColumnCreateNestedManyWithoutTableInput
    indexes?: DatabaseIndexCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationCreateNestedManyWithoutSourceTableInput
  }

  export type DatabaseTableUncheckedCreateWithoutTargetRelationsInput = {
    id?: string
    schemaId: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    columns?: TableColumnUncheckedCreateNestedManyWithoutTableInput
    indexes?: DatabaseIndexUncheckedCreateNestedManyWithoutTableInput
    sourceRelations?: DatabaseRelationUncheckedCreateNestedManyWithoutSourceTableInput
  }

  export type DatabaseTableCreateOrConnectWithoutTargetRelationsInput = {
    where: DatabaseTableWhereUniqueInput
    create: XOR<DatabaseTableCreateWithoutTargetRelationsInput, DatabaseTableUncheckedCreateWithoutTargetRelationsInput>
  }

  export type DatabaseTableUpsertWithoutSourceRelationsInput = {
    update: XOR<DatabaseTableUpdateWithoutSourceRelationsInput, DatabaseTableUncheckedUpdateWithoutSourceRelationsInput>
    create: XOR<DatabaseTableCreateWithoutSourceRelationsInput, DatabaseTableUncheckedCreateWithoutSourceRelationsInput>
    where?: DatabaseTableWhereInput
  }

  export type DatabaseTableUpdateToOneWithWhereWithoutSourceRelationsInput = {
    where?: DatabaseTableWhereInput
    data: XOR<DatabaseTableUpdateWithoutSourceRelationsInput, DatabaseTableUncheckedUpdateWithoutSourceRelationsInput>
  }

  export type DatabaseTableUpdateWithoutSourceRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: DatabaseSchemaUpdateOneRequiredWithoutTablesNestedInput
    columns?: TableColumnUpdateManyWithoutTableNestedInput
    indexes?: DatabaseIndexUpdateManyWithoutTableNestedInput
    targetRelations?: DatabaseRelationUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableUncheckedUpdateWithoutSourceRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columns?: TableColumnUncheckedUpdateManyWithoutTableNestedInput
    indexes?: DatabaseIndexUncheckedUpdateManyWithoutTableNestedInput
    targetRelations?: DatabaseRelationUncheckedUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableUpsertWithoutTargetRelationsInput = {
    update: XOR<DatabaseTableUpdateWithoutTargetRelationsInput, DatabaseTableUncheckedUpdateWithoutTargetRelationsInput>
    create: XOR<DatabaseTableCreateWithoutTargetRelationsInput, DatabaseTableUncheckedCreateWithoutTargetRelationsInput>
    where?: DatabaseTableWhereInput
  }

  export type DatabaseTableUpdateToOneWithWhereWithoutTargetRelationsInput = {
    where?: DatabaseTableWhereInput
    data: XOR<DatabaseTableUpdateWithoutTargetRelationsInput, DatabaseTableUncheckedUpdateWithoutTargetRelationsInput>
  }

  export type DatabaseTableUpdateWithoutTargetRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: DatabaseSchemaUpdateOneRequiredWithoutTablesNestedInput
    columns?: TableColumnUpdateManyWithoutTableNestedInput
    indexes?: DatabaseIndexUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUpdateManyWithoutSourceTableNestedInput
  }

  export type DatabaseTableUncheckedUpdateWithoutTargetRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columns?: TableColumnUncheckedUpdateManyWithoutTableNestedInput
    indexes?: DatabaseIndexUncheckedUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUncheckedUpdateManyWithoutSourceTableNestedInput
  }

  export type ProjectCreateWithoutDocumentationInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDocumentationInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDocumentationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDocumentationInput, ProjectUncheckedCreateWithoutDocumentationInput>
  }

  export type DocumentTagCreateWithoutDocumentationsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentTagUncheckedCreateWithoutDocumentationsInput = {
    id?: string
    name: string
    description?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentTagCreateOrConnectWithoutDocumentationsInput = {
    where: DocumentTagWhereUniqueInput
    create: XOR<DocumentTagCreateWithoutDocumentationsInput, DocumentTagUncheckedCreateWithoutDocumentationsInput>
  }

  export type DocumentVersionCreateWithoutDocumentationInput = {
    id?: string
    version: string
    content: string
    changeLog: string
    createdAt?: Date | string
    User?: UserCreateNestedOneWithoutDocumentVersionInput
  }

  export type DocumentVersionUncheckedCreateWithoutDocumentationInput = {
    id?: string
    version: string
    content: string
    changeLog: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type DocumentVersionCreateOrConnectWithoutDocumentationInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutDocumentationInput, DocumentVersionUncheckedCreateWithoutDocumentationInput>
  }

  export type DocumentVersionCreateManyDocumentationInputEnvelope = {
    data: DocumentVersionCreateManyDocumentationInput | DocumentVersionCreateManyDocumentationInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCommentCreateWithoutDocumentationInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: DocumentCommentCreateNestedOneWithoutRepliesInput
    replies?: DocumentCommentCreateNestedManyWithoutParentInput
    User?: UserCreateNestedOneWithoutDocumentCommentInput
  }

  export type DocumentCommentUncheckedCreateWithoutDocumentationInput = {
    id?: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    replies?: DocumentCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DocumentCommentCreateOrConnectWithoutDocumentationInput = {
    where: DocumentCommentWhereUniqueInput
    create: XOR<DocumentCommentCreateWithoutDocumentationInput, DocumentCommentUncheckedCreateWithoutDocumentationInput>
  }

  export type DocumentCommentCreateManyDocumentationInputEnvelope = {
    data: DocumentCommentCreateManyDocumentationInput | DocumentCommentCreateManyDocumentationInput[]
    skipDuplicates?: boolean
  }

  export type DocumentAttachmentCreateWithoutDocumentationInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    User?: UserCreateNestedOneWithoutDocumentAttachmentInput
  }

  export type DocumentAttachmentUncheckedCreateWithoutDocumentationInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type DocumentAttachmentCreateOrConnectWithoutDocumentationInput = {
    where: DocumentAttachmentWhereUniqueInput
    create: XOR<DocumentAttachmentCreateWithoutDocumentationInput, DocumentAttachmentUncheckedCreateWithoutDocumentationInput>
  }

  export type DocumentAttachmentCreateManyDocumentationInputEnvelope = {
    data: DocumentAttachmentCreateManyDocumentationInput | DocumentAttachmentCreateManyDocumentationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDocumentationInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentationInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentationInput, UserUncheckedCreateWithoutDocumentationInput>
  }

  export type ProjectUpsertWithoutDocumentationInput = {
    update: XOR<ProjectUpdateWithoutDocumentationInput, ProjectUncheckedUpdateWithoutDocumentationInput>
    create: XOR<ProjectCreateWithoutDocumentationInput, ProjectUncheckedCreateWithoutDocumentationInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDocumentationInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDocumentationInput, ProjectUncheckedUpdateWithoutDocumentationInput>
  }

  export type ProjectUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DocumentTagUpsertWithWhereUniqueWithoutDocumentationsInput = {
    where: DocumentTagWhereUniqueInput
    update: XOR<DocumentTagUpdateWithoutDocumentationsInput, DocumentTagUncheckedUpdateWithoutDocumentationsInput>
    create: XOR<DocumentTagCreateWithoutDocumentationsInput, DocumentTagUncheckedCreateWithoutDocumentationsInput>
  }

  export type DocumentTagUpdateWithWhereUniqueWithoutDocumentationsInput = {
    where: DocumentTagWhereUniqueInput
    data: XOR<DocumentTagUpdateWithoutDocumentationsInput, DocumentTagUncheckedUpdateWithoutDocumentationsInput>
  }

  export type DocumentTagUpdateManyWithWhereWithoutDocumentationsInput = {
    where: DocumentTagScalarWhereInput
    data: XOR<DocumentTagUpdateManyMutationInput, DocumentTagUncheckedUpdateManyWithoutDocumentationsInput>
  }

  export type DocumentTagScalarWhereInput = {
    AND?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
    OR?: DocumentTagScalarWhereInput[]
    NOT?: DocumentTagScalarWhereInput | DocumentTagScalarWhereInput[]
    id?: StringFilter<"DocumentTag"> | string
    name?: StringFilter<"DocumentTag"> | string
    description?: StringNullableFilter<"DocumentTag"> | string | null
    color?: StringNullableFilter<"DocumentTag"> | string | null
    createdAt?: DateTimeFilter<"DocumentTag"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentTag"> | Date | string
  }

  export type DocumentVersionUpsertWithWhereUniqueWithoutDocumentationInput = {
    where: DocumentVersionWhereUniqueInput
    update: XOR<DocumentVersionUpdateWithoutDocumentationInput, DocumentVersionUncheckedUpdateWithoutDocumentationInput>
    create: XOR<DocumentVersionCreateWithoutDocumentationInput, DocumentVersionUncheckedCreateWithoutDocumentationInput>
  }

  export type DocumentVersionUpdateWithWhereUniqueWithoutDocumentationInput = {
    where: DocumentVersionWhereUniqueInput
    data: XOR<DocumentVersionUpdateWithoutDocumentationInput, DocumentVersionUncheckedUpdateWithoutDocumentationInput>
  }

  export type DocumentVersionUpdateManyWithWhereWithoutDocumentationInput = {
    where: DocumentVersionScalarWhereInput
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyWithoutDocumentationInput>
  }

  export type DocumentVersionScalarWhereInput = {
    AND?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
    OR?: DocumentVersionScalarWhereInput[]
    NOT?: DocumentVersionScalarWhereInput | DocumentVersionScalarWhereInput[]
    id?: StringFilter<"DocumentVersion"> | string
    documentationId?: StringFilter<"DocumentVersion"> | string
    version?: StringFilter<"DocumentVersion"> | string
    content?: StringFilter<"DocumentVersion"> | string
    changeLog?: StringFilter<"DocumentVersion"> | string
    createdAt?: DateTimeFilter<"DocumentVersion"> | Date | string
    userId?: StringNullableFilter<"DocumentVersion"> | string | null
  }

  export type DocumentCommentUpsertWithWhereUniqueWithoutDocumentationInput = {
    where: DocumentCommentWhereUniqueInput
    update: XOR<DocumentCommentUpdateWithoutDocumentationInput, DocumentCommentUncheckedUpdateWithoutDocumentationInput>
    create: XOR<DocumentCommentCreateWithoutDocumentationInput, DocumentCommentUncheckedCreateWithoutDocumentationInput>
  }

  export type DocumentCommentUpdateWithWhereUniqueWithoutDocumentationInput = {
    where: DocumentCommentWhereUniqueInput
    data: XOR<DocumentCommentUpdateWithoutDocumentationInput, DocumentCommentUncheckedUpdateWithoutDocumentationInput>
  }

  export type DocumentCommentUpdateManyWithWhereWithoutDocumentationInput = {
    where: DocumentCommentScalarWhereInput
    data: XOR<DocumentCommentUpdateManyMutationInput, DocumentCommentUncheckedUpdateManyWithoutDocumentationInput>
  }

  export type DocumentCommentScalarWhereInput = {
    AND?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
    OR?: DocumentCommentScalarWhereInput[]
    NOT?: DocumentCommentScalarWhereInput | DocumentCommentScalarWhereInput[]
    id?: StringFilter<"DocumentComment"> | string
    documentationId?: StringFilter<"DocumentComment"> | string
    content?: StringFilter<"DocumentComment"> | string
    parentId?: StringNullableFilter<"DocumentComment"> | string | null
    createdAt?: DateTimeFilter<"DocumentComment"> | Date | string
    updatedAt?: DateTimeFilter<"DocumentComment"> | Date | string
    userId?: StringNullableFilter<"DocumentComment"> | string | null
  }

  export type DocumentAttachmentUpsertWithWhereUniqueWithoutDocumentationInput = {
    where: DocumentAttachmentWhereUniqueInput
    update: XOR<DocumentAttachmentUpdateWithoutDocumentationInput, DocumentAttachmentUncheckedUpdateWithoutDocumentationInput>
    create: XOR<DocumentAttachmentCreateWithoutDocumentationInput, DocumentAttachmentUncheckedCreateWithoutDocumentationInput>
  }

  export type DocumentAttachmentUpdateWithWhereUniqueWithoutDocumentationInput = {
    where: DocumentAttachmentWhereUniqueInput
    data: XOR<DocumentAttachmentUpdateWithoutDocumentationInput, DocumentAttachmentUncheckedUpdateWithoutDocumentationInput>
  }

  export type DocumentAttachmentUpdateManyWithWhereWithoutDocumentationInput = {
    where: DocumentAttachmentScalarWhereInput
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyWithoutDocumentationInput>
  }

  export type DocumentAttachmentScalarWhereInput = {
    AND?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
    OR?: DocumentAttachmentScalarWhereInput[]
    NOT?: DocumentAttachmentScalarWhereInput | DocumentAttachmentScalarWhereInput[]
    id?: StringFilter<"DocumentAttachment"> | string
    documentationId?: StringFilter<"DocumentAttachment"> | string
    fileName?: StringFilter<"DocumentAttachment"> | string
    fileUrl?: StringFilter<"DocumentAttachment"> | string
    fileSize?: IntFilter<"DocumentAttachment"> | number
    mimeType?: StringFilter<"DocumentAttachment"> | string
    createdAt?: DateTimeFilter<"DocumentAttachment"> | Date | string
    userId?: StringNullableFilter<"DocumentAttachment"> | string | null
  }

  export type UserUpsertWithoutDocumentationInput = {
    update: XOR<UserUpdateWithoutDocumentationInput, UserUncheckedUpdateWithoutDocumentationInput>
    create: XOR<UserCreateWithoutDocumentationInput, UserUncheckedCreateWithoutDocumentationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentationInput, UserUncheckedUpdateWithoutDocumentationInput>
  }

  export type UserUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentationCreateWithoutVersionsInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDocumentationInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentationsInput
    comments?: DocumentCommentCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentationInput
    User?: UserCreateNestedOneWithoutDocumentationInput
  }

  export type DocumentationUncheckedCreateWithoutVersionsInput = {
    id?: string
    projectId: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    userId?: string | null
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentationsInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentationInput
  }

  export type DocumentationCreateOrConnectWithoutVersionsInput = {
    where: DocumentationWhereUniqueInput
    create: XOR<DocumentationCreateWithoutVersionsInput, DocumentationUncheckedCreateWithoutVersionsInput>
  }

  export type UserCreateWithoutDocumentVersionInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentVersionInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentVersionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentVersionInput, UserUncheckedCreateWithoutDocumentVersionInput>
  }

  export type DocumentationUpsertWithoutVersionsInput = {
    update: XOR<DocumentationUpdateWithoutVersionsInput, DocumentationUncheckedUpdateWithoutVersionsInput>
    create: XOR<DocumentationCreateWithoutVersionsInput, DocumentationUncheckedCreateWithoutVersionsInput>
    where?: DocumentationWhereInput
  }

  export type DocumentationUpdateToOneWithWhereWithoutVersionsInput = {
    where?: DocumentationWhereInput
    data: XOR<DocumentationUpdateWithoutVersionsInput, DocumentationUncheckedUpdateWithoutVersionsInput>
  }

  export type DocumentationUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDocumentationNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentationsNestedInput
    comments?: DocumentCommentUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentationNestedInput
    User?: UserUpdateOneWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentationsNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentationNestedInput
  }

  export type UserUpsertWithoutDocumentVersionInput = {
    update: XOR<UserUpdateWithoutDocumentVersionInput, UserUncheckedUpdateWithoutDocumentVersionInput>
    create: XOR<UserCreateWithoutDocumentVersionInput, UserUncheckedCreateWithoutDocumentVersionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentVersionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentVersionInput, UserUncheckedUpdateWithoutDocumentVersionInput>
  }

  export type UserUpdateWithoutDocumentVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentationCreateWithoutTagsInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDocumentationInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentationInput
    User?: UserCreateNestedOneWithoutDocumentationInput
  }

  export type DocumentationUncheckedCreateWithoutTagsInput = {
    id?: string
    projectId: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    userId?: string | null
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentationInput
  }

  export type DocumentationCreateOrConnectWithoutTagsInput = {
    where: DocumentationWhereUniqueInput
    create: XOR<DocumentationCreateWithoutTagsInput, DocumentationUncheckedCreateWithoutTagsInput>
  }

  export type DocumentationUpsertWithWhereUniqueWithoutTagsInput = {
    where: DocumentationWhereUniqueInput
    update: XOR<DocumentationUpdateWithoutTagsInput, DocumentationUncheckedUpdateWithoutTagsInput>
    create: XOR<DocumentationCreateWithoutTagsInput, DocumentationUncheckedCreateWithoutTagsInput>
  }

  export type DocumentationUpdateWithWhereUniqueWithoutTagsInput = {
    where: DocumentationWhereUniqueInput
    data: XOR<DocumentationUpdateWithoutTagsInput, DocumentationUncheckedUpdateWithoutTagsInput>
  }

  export type DocumentationUpdateManyWithWhereWithoutTagsInput = {
    where: DocumentationScalarWhereInput
    data: XOR<DocumentationUpdateManyMutationInput, DocumentationUncheckedUpdateManyWithoutTagsInput>
  }

  export type DocumentationScalarWhereInput = {
    AND?: DocumentationScalarWhereInput | DocumentationScalarWhereInput[]
    OR?: DocumentationScalarWhereInput[]
    NOT?: DocumentationScalarWhereInput | DocumentationScalarWhereInput[]
    id?: StringFilter<"Documentation"> | string
    projectId?: StringFilter<"Documentation"> | string
    title?: StringFilter<"Documentation"> | string
    content?: StringFilter<"Documentation"> | string
    summary?: StringNullableFilter<"Documentation"> | string | null
    type?: EnumDocumentTypeFilter<"Documentation"> | $Enums.DocumentType
    status?: EnumDocumentStatusFilter<"Documentation"> | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFilter<"Documentation"> | $Enums.DocumentVisibility
    category?: StringNullableFilter<"Documentation"> | string | null
    url?: StringNullableFilter<"Documentation"> | string | null
    version?: StringFilter<"Documentation"> | string
    versionNumber?: IntFilter<"Documentation"> | number
    createdAt?: DateTimeFilter<"Documentation"> | Date | string
    updatedAt?: DateTimeFilter<"Documentation"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Documentation"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Documentation"> | Date | string | null
    userId?: StringNullableFilter<"Documentation"> | string | null
  }

  export type DocumentationCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDocumentationInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentationInput
    User?: UserCreateNestedOneWithoutDocumentationInput
  }

  export type DocumentationUncheckedCreateWithoutCommentsInput = {
    id?: string
    projectId: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    userId?: string | null
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentationInput
  }

  export type DocumentationCreateOrConnectWithoutCommentsInput = {
    where: DocumentationWhereUniqueInput
    create: XOR<DocumentationCreateWithoutCommentsInput, DocumentationUncheckedCreateWithoutCommentsInput>
  }

  export type DocumentCommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentation: DocumentationCreateNestedOneWithoutCommentsInput
    parent?: DocumentCommentCreateNestedOneWithoutRepliesInput
    User?: UserCreateNestedOneWithoutDocumentCommentInput
  }

  export type DocumentCommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    documentationId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type DocumentCommentCreateOrConnectWithoutRepliesInput = {
    where: DocumentCommentWhereUniqueInput
    create: XOR<DocumentCommentCreateWithoutRepliesInput, DocumentCommentUncheckedCreateWithoutRepliesInput>
  }

  export type DocumentCommentCreateWithoutParentInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentation: DocumentationCreateNestedOneWithoutCommentsInput
    replies?: DocumentCommentCreateNestedManyWithoutParentInput
    User?: UserCreateNestedOneWithoutDocumentCommentInput
  }

  export type DocumentCommentUncheckedCreateWithoutParentInput = {
    id?: string
    documentationId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
    replies?: DocumentCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DocumentCommentCreateOrConnectWithoutParentInput = {
    where: DocumentCommentWhereUniqueInput
    create: XOR<DocumentCommentCreateWithoutParentInput, DocumentCommentUncheckedCreateWithoutParentInput>
  }

  export type DocumentCommentCreateManyParentInputEnvelope = {
    data: DocumentCommentCreateManyParentInput | DocumentCommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDocumentCommentInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentCommentInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentCommentInput, UserUncheckedCreateWithoutDocumentCommentInput>
  }

  export type DocumentationUpsertWithoutCommentsInput = {
    update: XOR<DocumentationUpdateWithoutCommentsInput, DocumentationUncheckedUpdateWithoutCommentsInput>
    create: XOR<DocumentationCreateWithoutCommentsInput, DocumentationUncheckedCreateWithoutCommentsInput>
    where?: DocumentationWhereInput
  }

  export type DocumentationUpdateToOneWithWhereWithoutCommentsInput = {
    where?: DocumentationWhereInput
    data: XOR<DocumentationUpdateWithoutCommentsInput, DocumentationUncheckedUpdateWithoutCommentsInput>
  }

  export type DocumentationUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDocumentationNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentationNestedInput
    User?: UserUpdateOneWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentationNestedInput
  }

  export type DocumentCommentUpsertWithoutRepliesInput = {
    update: XOR<DocumentCommentUpdateWithoutRepliesInput, DocumentCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<DocumentCommentCreateWithoutRepliesInput, DocumentCommentUncheckedCreateWithoutRepliesInput>
    where?: DocumentCommentWhereInput
  }

  export type DocumentCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: DocumentCommentWhereInput
    data: XOR<DocumentCommentUpdateWithoutRepliesInput, DocumentCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type DocumentCommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentation?: DocumentationUpdateOneRequiredWithoutCommentsNestedInput
    parent?: DocumentCommentUpdateOneWithoutRepliesNestedInput
    User?: UserUpdateOneWithoutDocumentCommentNestedInput
  }

  export type DocumentCommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCommentUpsertWithWhereUniqueWithoutParentInput = {
    where: DocumentCommentWhereUniqueInput
    update: XOR<DocumentCommentUpdateWithoutParentInput, DocumentCommentUncheckedUpdateWithoutParentInput>
    create: XOR<DocumentCommentCreateWithoutParentInput, DocumentCommentUncheckedCreateWithoutParentInput>
  }

  export type DocumentCommentUpdateWithWhereUniqueWithoutParentInput = {
    where: DocumentCommentWhereUniqueInput
    data: XOR<DocumentCommentUpdateWithoutParentInput, DocumentCommentUncheckedUpdateWithoutParentInput>
  }

  export type DocumentCommentUpdateManyWithWhereWithoutParentInput = {
    where: DocumentCommentScalarWhereInput
    data: XOR<DocumentCommentUpdateManyMutationInput, DocumentCommentUncheckedUpdateManyWithoutParentInput>
  }

  export type UserUpsertWithoutDocumentCommentInput = {
    update: XOR<UserUpdateWithoutDocumentCommentInput, UserUncheckedUpdateWithoutDocumentCommentInput>
    create: XOR<UserCreateWithoutDocumentCommentInput, UserUncheckedCreateWithoutDocumentCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentCommentInput, UserUncheckedUpdateWithoutDocumentCommentInput>
  }

  export type UserUpdateWithoutDocumentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DocumentationCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDocumentationInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentCreateNestedManyWithoutDocumentationInput
    User?: UserCreateNestedOneWithoutDocumentationInput
  }

  export type DocumentationUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    projectId: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    userId?: string | null
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutDocumentationInput
  }

  export type DocumentationCreateOrConnectWithoutAttachmentsInput = {
    where: DocumentationWhereUniqueInput
    create: XOR<DocumentationCreateWithoutAttachmentsInput, DocumentationUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutDocumentAttachmentInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDocumentAttachmentInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDocumentAttachmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentAttachmentInput, UserUncheckedCreateWithoutDocumentAttachmentInput>
  }

  export type DocumentationUpsertWithoutAttachmentsInput = {
    update: XOR<DocumentationUpdateWithoutAttachmentsInput, DocumentationUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<DocumentationCreateWithoutAttachmentsInput, DocumentationUncheckedCreateWithoutAttachmentsInput>
    where?: DocumentationWhereInput
  }

  export type DocumentationUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: DocumentationWhereInput
    data: XOR<DocumentationUpdateWithoutAttachmentsInput, DocumentationUncheckedUpdateWithoutAttachmentsInput>
  }

  export type DocumentationUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDocumentationNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUpdateManyWithoutDocumentationNestedInput
    User?: UserUpdateOneWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutDocumentationNestedInput
  }

  export type UserUpsertWithoutDocumentAttachmentInput = {
    update: XOR<UserUpdateWithoutDocumentAttachmentInput, UserUncheckedUpdateWithoutDocumentAttachmentInput>
    create: XOR<UserCreateWithoutDocumentAttachmentInput, UserUncheckedCreateWithoutDocumentAttachmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentAttachmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentAttachmentInput, UserUncheckedUpdateWithoutDocumentAttachmentInput>
  }

  export type UserUpdateWithoutDocumentAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutMindMapInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMindMapInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMindMapInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMindMapInput, ProjectUncheckedCreateWithoutMindMapInput>
  }

  export type MindMapNodeCreateWithoutRootOfMapInput = {
    id?: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mindMap: MindMapCreateNestedOneWithoutNodesInput
    parent?: MindMapNodeCreateNestedOneWithoutChildrenInput
    children?: MindMapNodeCreateNestedManyWithoutParentInput
  }

  export type MindMapNodeUncheckedCreateWithoutRootOfMapInput = {
    id?: string
    mindMapId: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    parentId?: string | null
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: MindMapNodeUncheckedCreateNestedManyWithoutParentInput
  }

  export type MindMapNodeCreateOrConnectWithoutRootOfMapInput = {
    where: MindMapNodeWhereUniqueInput
    create: XOR<MindMapNodeCreateWithoutRootOfMapInput, MindMapNodeUncheckedCreateWithoutRootOfMapInput>
  }

  export type MindMapNodeCreateWithoutMindMapInput = {
    id?: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootOfMap?: MindMapCreateNestedOneWithoutRootNodeInput
    parent?: MindMapNodeCreateNestedOneWithoutChildrenInput
    children?: MindMapNodeCreateNestedManyWithoutParentInput
  }

  export type MindMapNodeUncheckedCreateWithoutMindMapInput = {
    id?: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    parentId?: string | null
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootOfMap?: MindMapUncheckedCreateNestedOneWithoutRootNodeInput
    children?: MindMapNodeUncheckedCreateNestedManyWithoutParentInput
  }

  export type MindMapNodeCreateOrConnectWithoutMindMapInput = {
    where: MindMapNodeWhereUniqueInput
    create: XOR<MindMapNodeCreateWithoutMindMapInput, MindMapNodeUncheckedCreateWithoutMindMapInput>
  }

  export type MindMapNodeCreateManyMindMapInputEnvelope = {
    data: MindMapNodeCreateManyMindMapInput | MindMapNodeCreateManyMindMapInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutMindMapInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMindMapInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMindMapInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMindMapInput, UserUncheckedCreateWithoutMindMapInput>
  }

  export type ProjectUpsertWithoutMindMapInput = {
    update: XOR<ProjectUpdateWithoutMindMapInput, ProjectUncheckedUpdateWithoutMindMapInput>
    create: XOR<ProjectCreateWithoutMindMapInput, ProjectUncheckedCreateWithoutMindMapInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMindMapInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMindMapInput, ProjectUncheckedUpdateWithoutMindMapInput>
  }

  export type ProjectUpdateWithoutMindMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMindMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MindMapNodeUpsertWithoutRootOfMapInput = {
    update: XOR<MindMapNodeUpdateWithoutRootOfMapInput, MindMapNodeUncheckedUpdateWithoutRootOfMapInput>
    create: XOR<MindMapNodeCreateWithoutRootOfMapInput, MindMapNodeUncheckedCreateWithoutRootOfMapInput>
    where?: MindMapNodeWhereInput
  }

  export type MindMapNodeUpdateToOneWithWhereWithoutRootOfMapInput = {
    where?: MindMapNodeWhereInput
    data: XOR<MindMapNodeUpdateWithoutRootOfMapInput, MindMapNodeUncheckedUpdateWithoutRootOfMapInput>
  }

  export type MindMapNodeUpdateWithoutRootOfMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mindMap?: MindMapUpdateOneRequiredWithoutNodesNestedInput
    parent?: MindMapNodeUpdateOneWithoutChildrenNestedInput
    children?: MindMapNodeUpdateManyWithoutParentNestedInput
  }

  export type MindMapNodeUncheckedUpdateWithoutRootOfMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    mindMapId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: MindMapNodeUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MindMapNodeUpsertWithWhereUniqueWithoutMindMapInput = {
    where: MindMapNodeWhereUniqueInput
    update: XOR<MindMapNodeUpdateWithoutMindMapInput, MindMapNodeUncheckedUpdateWithoutMindMapInput>
    create: XOR<MindMapNodeCreateWithoutMindMapInput, MindMapNodeUncheckedCreateWithoutMindMapInput>
  }

  export type MindMapNodeUpdateWithWhereUniqueWithoutMindMapInput = {
    where: MindMapNodeWhereUniqueInput
    data: XOR<MindMapNodeUpdateWithoutMindMapInput, MindMapNodeUncheckedUpdateWithoutMindMapInput>
  }

  export type MindMapNodeUpdateManyWithWhereWithoutMindMapInput = {
    where: MindMapNodeScalarWhereInput
    data: XOR<MindMapNodeUpdateManyMutationInput, MindMapNodeUncheckedUpdateManyWithoutMindMapInput>
  }

  export type MindMapNodeScalarWhereInput = {
    AND?: MindMapNodeScalarWhereInput | MindMapNodeScalarWhereInput[]
    OR?: MindMapNodeScalarWhereInput[]
    NOT?: MindMapNodeScalarWhereInput | MindMapNodeScalarWhereInput[]
    id?: StringFilter<"MindMapNode"> | string
    mindMapId?: StringFilter<"MindMapNode"> | string
    content?: StringFilter<"MindMapNode"> | string
    note?: StringNullableFilter<"MindMapNode"> | string | null
    nodeType?: EnumNodeTypeFilter<"MindMapNode"> | $Enums.NodeType
    parentId?: StringNullableFilter<"MindMapNode"> | string | null
    position?: IntFilter<"MindMapNode"> | number
    expanded?: BoolFilter<"MindMapNode"> | boolean
    style?: JsonNullableFilter<"MindMapNode">
    link?: StringNullableFilter<"MindMapNode"> | string | null
    icon?: StringNullableFilter<"MindMapNode"> | string | null
    priority?: IntNullableFilter<"MindMapNode"> | number | null
    progress?: IntNullableFilter<"MindMapNode"> | number | null
    createdAt?: DateTimeFilter<"MindMapNode"> | Date | string
    updatedAt?: DateTimeFilter<"MindMapNode"> | Date | string
  }

  export type UserUpsertWithoutMindMapInput = {
    update: XOR<UserUpdateWithoutMindMapInput, UserUncheckedUpdateWithoutMindMapInput>
    create: XOR<UserCreateWithoutMindMapInput, UserUncheckedCreateWithoutMindMapInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMindMapInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMindMapInput, UserUncheckedUpdateWithoutMindMapInput>
  }

  export type UserUpdateWithoutMindMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMindMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MindMapCreateWithoutNodesInput = {
    id?: string
    title: string
    description?: string | null
    overview: string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutMindMapInput
    rootNode?: MindMapNodeCreateNestedOneWithoutRootOfMapInput
    User?: UserCreateNestedOneWithoutMindMapInput
  }

  export type MindMapUncheckedCreateWithoutNodesInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    overview: string
    nodeId?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type MindMapCreateOrConnectWithoutNodesInput = {
    where: MindMapWhereUniqueInput
    create: XOR<MindMapCreateWithoutNodesInput, MindMapUncheckedCreateWithoutNodesInput>
  }

  export type MindMapCreateWithoutRootNodeInput = {
    id?: string
    title: string
    description?: string | null
    overview: string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutMindMapInput
    nodes?: MindMapNodeCreateNestedManyWithoutMindMapInput
    User?: UserCreateNestedOneWithoutMindMapInput
  }

  export type MindMapUncheckedCreateWithoutRootNodeInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    overview: string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    nodes?: MindMapNodeUncheckedCreateNestedManyWithoutMindMapInput
  }

  export type MindMapCreateOrConnectWithoutRootNodeInput = {
    where: MindMapWhereUniqueInput
    create: XOR<MindMapCreateWithoutRootNodeInput, MindMapUncheckedCreateWithoutRootNodeInput>
  }

  export type MindMapNodeCreateWithoutChildrenInput = {
    id?: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mindMap: MindMapCreateNestedOneWithoutNodesInput
    rootOfMap?: MindMapCreateNestedOneWithoutRootNodeInput
    parent?: MindMapNodeCreateNestedOneWithoutChildrenInput
  }

  export type MindMapNodeUncheckedCreateWithoutChildrenInput = {
    id?: string
    mindMapId: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    parentId?: string | null
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootOfMap?: MindMapUncheckedCreateNestedOneWithoutRootNodeInput
  }

  export type MindMapNodeCreateOrConnectWithoutChildrenInput = {
    where: MindMapNodeWhereUniqueInput
    create: XOR<MindMapNodeCreateWithoutChildrenInput, MindMapNodeUncheckedCreateWithoutChildrenInput>
  }

  export type MindMapNodeCreateWithoutParentInput = {
    id?: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    mindMap: MindMapCreateNestedOneWithoutNodesInput
    rootOfMap?: MindMapCreateNestedOneWithoutRootNodeInput
    children?: MindMapNodeCreateNestedManyWithoutParentInput
  }

  export type MindMapNodeUncheckedCreateWithoutParentInput = {
    id?: string
    mindMapId: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rootOfMap?: MindMapUncheckedCreateNestedOneWithoutRootNodeInput
    children?: MindMapNodeUncheckedCreateNestedManyWithoutParentInput
  }

  export type MindMapNodeCreateOrConnectWithoutParentInput = {
    where: MindMapNodeWhereUniqueInput
    create: XOR<MindMapNodeCreateWithoutParentInput, MindMapNodeUncheckedCreateWithoutParentInput>
  }

  export type MindMapNodeCreateManyParentInputEnvelope = {
    data: MindMapNodeCreateManyParentInput | MindMapNodeCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type MindMapUpsertWithoutNodesInput = {
    update: XOR<MindMapUpdateWithoutNodesInput, MindMapUncheckedUpdateWithoutNodesInput>
    create: XOR<MindMapCreateWithoutNodesInput, MindMapUncheckedCreateWithoutNodesInput>
    where?: MindMapWhereInput
  }

  export type MindMapUpdateToOneWithWhereWithoutNodesInput = {
    where?: MindMapWhereInput
    data: XOR<MindMapUpdateWithoutNodesInput, MindMapUncheckedUpdateWithoutNodesInput>
  }

  export type MindMapUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutMindMapNestedInput
    rootNode?: MindMapNodeUpdateOneWithoutRootOfMapNestedInput
    User?: UserUpdateOneWithoutMindMapNestedInput
  }

  export type MindMapUncheckedUpdateWithoutNodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MindMapUpsertWithoutRootNodeInput = {
    update: XOR<MindMapUpdateWithoutRootNodeInput, MindMapUncheckedUpdateWithoutRootNodeInput>
    create: XOR<MindMapCreateWithoutRootNodeInput, MindMapUncheckedCreateWithoutRootNodeInput>
    where?: MindMapWhereInput
  }

  export type MindMapUpdateToOneWithWhereWithoutRootNodeInput = {
    where?: MindMapWhereInput
    data: XOR<MindMapUpdateWithoutRootNodeInput, MindMapUncheckedUpdateWithoutRootNodeInput>
  }

  export type MindMapUpdateWithoutRootNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutMindMapNestedInput
    nodes?: MindMapNodeUpdateManyWithoutMindMapNestedInput
    User?: UserUpdateOneWithoutMindMapNestedInput
  }

  export type MindMapUncheckedUpdateWithoutRootNodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: MindMapNodeUncheckedUpdateManyWithoutMindMapNestedInput
  }

  export type MindMapNodeUpsertWithoutChildrenInput = {
    update: XOR<MindMapNodeUpdateWithoutChildrenInput, MindMapNodeUncheckedUpdateWithoutChildrenInput>
    create: XOR<MindMapNodeCreateWithoutChildrenInput, MindMapNodeUncheckedCreateWithoutChildrenInput>
    where?: MindMapNodeWhereInput
  }

  export type MindMapNodeUpdateToOneWithWhereWithoutChildrenInput = {
    where?: MindMapNodeWhereInput
    data: XOR<MindMapNodeUpdateWithoutChildrenInput, MindMapNodeUncheckedUpdateWithoutChildrenInput>
  }

  export type MindMapNodeUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mindMap?: MindMapUpdateOneRequiredWithoutNodesNestedInput
    rootOfMap?: MindMapUpdateOneWithoutRootNodeNestedInput
    parent?: MindMapNodeUpdateOneWithoutChildrenNestedInput
  }

  export type MindMapNodeUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    mindMapId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootOfMap?: MindMapUncheckedUpdateOneWithoutRootNodeNestedInput
  }

  export type MindMapNodeUpsertWithWhereUniqueWithoutParentInput = {
    where: MindMapNodeWhereUniqueInput
    update: XOR<MindMapNodeUpdateWithoutParentInput, MindMapNodeUncheckedUpdateWithoutParentInput>
    create: XOR<MindMapNodeCreateWithoutParentInput, MindMapNodeUncheckedCreateWithoutParentInput>
  }

  export type MindMapNodeUpdateWithWhereUniqueWithoutParentInput = {
    where: MindMapNodeWhereUniqueInput
    data: XOR<MindMapNodeUpdateWithoutParentInput, MindMapNodeUncheckedUpdateWithoutParentInput>
  }

  export type MindMapNodeUpdateManyWithWhereWithoutParentInput = {
    where: MindMapNodeScalarWhereInput
    data: XOR<MindMapNodeUpdateManyMutationInput, MindMapNodeUncheckedUpdateManyWithoutParentInput>
  }

  export type ProjectCreateWithoutDomainKnowledgeInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDomainKnowledgeInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDomainKnowledgeInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDomainKnowledgeInput, ProjectUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainConceptCreateWithoutDomainKnowledgeInput = {
    id?: string
    name: string
    definition: string
    examples?: DomainConceptCreateexamplesInput | string[]
    relatedConcepts?: DomainConceptCreaterelatedConceptsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainConceptUncheckedCreateWithoutDomainKnowledgeInput = {
    id?: string
    name: string
    definition: string
    examples?: DomainConceptCreateexamplesInput | string[]
    relatedConcepts?: DomainConceptCreaterelatedConceptsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainConceptCreateOrConnectWithoutDomainKnowledgeInput = {
    where: DomainConceptWhereUniqueInput
    create: XOR<DomainConceptCreateWithoutDomainKnowledgeInput, DomainConceptUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainConceptCreateManyDomainKnowledgeInputEnvelope = {
    data: DomainConceptCreateManyDomainKnowledgeInput | DomainConceptCreateManyDomainKnowledgeInput[]
    skipDuplicates?: boolean
  }

  export type DomainPatternCreateWithoutDomainKnowledgeInput = {
    id?: string
    name: string
    description: string
    context: string
    solution: string
    consequences: string
    examples?: DomainPatternCreateexamplesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainPatternUncheckedCreateWithoutDomainKnowledgeInput = {
    id?: string
    name: string
    description: string
    context: string
    solution: string
    consequences: string
    examples?: DomainPatternCreateexamplesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainPatternCreateOrConnectWithoutDomainKnowledgeInput = {
    where: DomainPatternWhereUniqueInput
    create: XOR<DomainPatternCreateWithoutDomainKnowledgeInput, DomainPatternUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainPatternCreateManyDomainKnowledgeInputEnvelope = {
    data: DomainPatternCreateManyDomainKnowledgeInput | DomainPatternCreateManyDomainKnowledgeInput[]
    skipDuplicates?: boolean
  }

  export type DomainBestPracticeCreateWithoutDomainKnowledgeInput = {
    id?: string
    title: string
    description: string
    rationale: string
    implementation: string
    benefits?: DomainBestPracticeCreatebenefitsInput | string[]
    considerations?: DomainBestPracticeCreateconsiderationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput = {
    id?: string
    title: string
    description: string
    rationale: string
    implementation: string
    benefits?: DomainBestPracticeCreatebenefitsInput | string[]
    considerations?: DomainBestPracticeCreateconsiderationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainBestPracticeCreateOrConnectWithoutDomainKnowledgeInput = {
    where: DomainBestPracticeWhereUniqueInput
    create: XOR<DomainBestPracticeCreateWithoutDomainKnowledgeInput, DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainBestPracticeCreateManyDomainKnowledgeInputEnvelope = {
    data: DomainBestPracticeCreateManyDomainKnowledgeInput | DomainBestPracticeCreateManyDomainKnowledgeInput[]
    skipDuplicates?: boolean
  }

  export type DomainAntiPatternCreateWithoutDomainKnowledgeInput = {
    id?: string
    name: string
    description: string
    symptoms?: DomainAntiPatternCreatesymptomsInput | string[]
    causes?: DomainAntiPatternCreatecausesInput | string[]
    consequences?: DomainAntiPatternCreateconsequencesInput | string[]
    refactoring: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput = {
    id?: string
    name: string
    description: string
    symptoms?: DomainAntiPatternCreatesymptomsInput | string[]
    causes?: DomainAntiPatternCreatecausesInput | string[]
    consequences?: DomainAntiPatternCreateconsequencesInput | string[]
    refactoring: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainAntiPatternCreateOrConnectWithoutDomainKnowledgeInput = {
    where: DomainAntiPatternWhereUniqueInput
    create: XOR<DomainAntiPatternCreateWithoutDomainKnowledgeInput, DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainAntiPatternCreateManyDomainKnowledgeInputEnvelope = {
    data: DomainAntiPatternCreateManyDomainKnowledgeInput | DomainAntiPatternCreateManyDomainKnowledgeInput[]
    skipDuplicates?: boolean
  }

  export type DomainReferenceCreateWithoutDomainKnowledgeInput = {
    id?: string
    title: string
    type: string
    url?: string | null
    author?: string | null
    publishDate?: Date | string | null
    summary?: string | null
    createdAt?: Date | string
  }

  export type DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput = {
    id?: string
    title: string
    type: string
    url?: string | null
    author?: string | null
    publishDate?: Date | string | null
    summary?: string | null
    createdAt?: Date | string
  }

  export type DomainReferenceCreateOrConnectWithoutDomainKnowledgeInput = {
    where: DomainReferenceWhereUniqueInput
    create: XOR<DomainReferenceCreateWithoutDomainKnowledgeInput, DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainReferenceCreateManyDomainKnowledgeInputEnvelope = {
    data: DomainReferenceCreateManyDomainKnowledgeInput | DomainReferenceCreateManyDomainKnowledgeInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDomainKnowledgeInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDomainKnowledgeInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDomainKnowledgeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDomainKnowledgeInput, UserUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type ProjectUpsertWithoutDomainKnowledgeInput = {
    update: XOR<ProjectUpdateWithoutDomainKnowledgeInput, ProjectUncheckedUpdateWithoutDomainKnowledgeInput>
    create: XOR<ProjectCreateWithoutDomainKnowledgeInput, ProjectUncheckedCreateWithoutDomainKnowledgeInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDomainKnowledgeInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDomainKnowledgeInput, ProjectUncheckedUpdateWithoutDomainKnowledgeInput>
  }

  export type ProjectUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DomainConceptUpsertWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainConceptWhereUniqueInput
    update: XOR<DomainConceptUpdateWithoutDomainKnowledgeInput, DomainConceptUncheckedUpdateWithoutDomainKnowledgeInput>
    create: XOR<DomainConceptCreateWithoutDomainKnowledgeInput, DomainConceptUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainConceptUpdateWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainConceptWhereUniqueInput
    data: XOR<DomainConceptUpdateWithoutDomainKnowledgeInput, DomainConceptUncheckedUpdateWithoutDomainKnowledgeInput>
  }

  export type DomainConceptUpdateManyWithWhereWithoutDomainKnowledgeInput = {
    where: DomainConceptScalarWhereInput
    data: XOR<DomainConceptUpdateManyMutationInput, DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeInput>
  }

  export type DomainConceptScalarWhereInput = {
    AND?: DomainConceptScalarWhereInput | DomainConceptScalarWhereInput[]
    OR?: DomainConceptScalarWhereInput[]
    NOT?: DomainConceptScalarWhereInput | DomainConceptScalarWhereInput[]
    id?: StringFilter<"DomainConcept"> | string
    domainKnowledgeId?: StringFilter<"DomainConcept"> | string
    name?: StringFilter<"DomainConcept"> | string
    definition?: StringFilter<"DomainConcept"> | string
    examples?: StringNullableListFilter<"DomainConcept">
    relatedConcepts?: StringNullableListFilter<"DomainConcept">
    createdAt?: DateTimeFilter<"DomainConcept"> | Date | string
    updatedAt?: DateTimeFilter<"DomainConcept"> | Date | string
  }

  export type DomainPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainPatternWhereUniqueInput
    update: XOR<DomainPatternUpdateWithoutDomainKnowledgeInput, DomainPatternUncheckedUpdateWithoutDomainKnowledgeInput>
    create: XOR<DomainPatternCreateWithoutDomainKnowledgeInput, DomainPatternUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainPatternWhereUniqueInput
    data: XOR<DomainPatternUpdateWithoutDomainKnowledgeInput, DomainPatternUncheckedUpdateWithoutDomainKnowledgeInput>
  }

  export type DomainPatternUpdateManyWithWhereWithoutDomainKnowledgeInput = {
    where: DomainPatternScalarWhereInput
    data: XOR<DomainPatternUpdateManyMutationInput, DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeInput>
  }

  export type DomainPatternScalarWhereInput = {
    AND?: DomainPatternScalarWhereInput | DomainPatternScalarWhereInput[]
    OR?: DomainPatternScalarWhereInput[]
    NOT?: DomainPatternScalarWhereInput | DomainPatternScalarWhereInput[]
    id?: StringFilter<"DomainPattern"> | string
    domainKnowledgeId?: StringFilter<"DomainPattern"> | string
    name?: StringFilter<"DomainPattern"> | string
    description?: StringFilter<"DomainPattern"> | string
    context?: StringFilter<"DomainPattern"> | string
    solution?: StringFilter<"DomainPattern"> | string
    consequences?: StringFilter<"DomainPattern"> | string
    examples?: StringNullableListFilter<"DomainPattern">
    createdAt?: DateTimeFilter<"DomainPattern"> | Date | string
    updatedAt?: DateTimeFilter<"DomainPattern"> | Date | string
  }

  export type DomainBestPracticeUpsertWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainBestPracticeWhereUniqueInput
    update: XOR<DomainBestPracticeUpdateWithoutDomainKnowledgeInput, DomainBestPracticeUncheckedUpdateWithoutDomainKnowledgeInput>
    create: XOR<DomainBestPracticeCreateWithoutDomainKnowledgeInput, DomainBestPracticeUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainBestPracticeUpdateWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainBestPracticeWhereUniqueInput
    data: XOR<DomainBestPracticeUpdateWithoutDomainKnowledgeInput, DomainBestPracticeUncheckedUpdateWithoutDomainKnowledgeInput>
  }

  export type DomainBestPracticeUpdateManyWithWhereWithoutDomainKnowledgeInput = {
    where: DomainBestPracticeScalarWhereInput
    data: XOR<DomainBestPracticeUpdateManyMutationInput, DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeInput>
  }

  export type DomainBestPracticeScalarWhereInput = {
    AND?: DomainBestPracticeScalarWhereInput | DomainBestPracticeScalarWhereInput[]
    OR?: DomainBestPracticeScalarWhereInput[]
    NOT?: DomainBestPracticeScalarWhereInput | DomainBestPracticeScalarWhereInput[]
    id?: StringFilter<"DomainBestPractice"> | string
    domainKnowledgeId?: StringFilter<"DomainBestPractice"> | string
    title?: StringFilter<"DomainBestPractice"> | string
    description?: StringFilter<"DomainBestPractice"> | string
    rationale?: StringFilter<"DomainBestPractice"> | string
    implementation?: StringFilter<"DomainBestPractice"> | string
    benefits?: StringNullableListFilter<"DomainBestPractice">
    considerations?: StringNullableListFilter<"DomainBestPractice">
    createdAt?: DateTimeFilter<"DomainBestPractice"> | Date | string
    updatedAt?: DateTimeFilter<"DomainBestPractice"> | Date | string
  }

  export type DomainAntiPatternUpsertWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainAntiPatternWhereUniqueInput
    update: XOR<DomainAntiPatternUpdateWithoutDomainKnowledgeInput, DomainAntiPatternUncheckedUpdateWithoutDomainKnowledgeInput>
    create: XOR<DomainAntiPatternCreateWithoutDomainKnowledgeInput, DomainAntiPatternUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainAntiPatternUpdateWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainAntiPatternWhereUniqueInput
    data: XOR<DomainAntiPatternUpdateWithoutDomainKnowledgeInput, DomainAntiPatternUncheckedUpdateWithoutDomainKnowledgeInput>
  }

  export type DomainAntiPatternUpdateManyWithWhereWithoutDomainKnowledgeInput = {
    where: DomainAntiPatternScalarWhereInput
    data: XOR<DomainAntiPatternUpdateManyMutationInput, DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeInput>
  }

  export type DomainAntiPatternScalarWhereInput = {
    AND?: DomainAntiPatternScalarWhereInput | DomainAntiPatternScalarWhereInput[]
    OR?: DomainAntiPatternScalarWhereInput[]
    NOT?: DomainAntiPatternScalarWhereInput | DomainAntiPatternScalarWhereInput[]
    id?: StringFilter<"DomainAntiPattern"> | string
    domainKnowledgeId?: StringFilter<"DomainAntiPattern"> | string
    name?: StringFilter<"DomainAntiPattern"> | string
    description?: StringFilter<"DomainAntiPattern"> | string
    symptoms?: StringNullableListFilter<"DomainAntiPattern">
    causes?: StringNullableListFilter<"DomainAntiPattern">
    consequences?: StringNullableListFilter<"DomainAntiPattern">
    refactoring?: StringFilter<"DomainAntiPattern"> | string
    createdAt?: DateTimeFilter<"DomainAntiPattern"> | Date | string
    updatedAt?: DateTimeFilter<"DomainAntiPattern"> | Date | string
  }

  export type DomainReferenceUpsertWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainReferenceWhereUniqueInput
    update: XOR<DomainReferenceUpdateWithoutDomainKnowledgeInput, DomainReferenceUncheckedUpdateWithoutDomainKnowledgeInput>
    create: XOR<DomainReferenceCreateWithoutDomainKnowledgeInput, DomainReferenceUncheckedCreateWithoutDomainKnowledgeInput>
  }

  export type DomainReferenceUpdateWithWhereUniqueWithoutDomainKnowledgeInput = {
    where: DomainReferenceWhereUniqueInput
    data: XOR<DomainReferenceUpdateWithoutDomainKnowledgeInput, DomainReferenceUncheckedUpdateWithoutDomainKnowledgeInput>
  }

  export type DomainReferenceUpdateManyWithWhereWithoutDomainKnowledgeInput = {
    where: DomainReferenceScalarWhereInput
    data: XOR<DomainReferenceUpdateManyMutationInput, DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeInput>
  }

  export type DomainReferenceScalarWhereInput = {
    AND?: DomainReferenceScalarWhereInput | DomainReferenceScalarWhereInput[]
    OR?: DomainReferenceScalarWhereInput[]
    NOT?: DomainReferenceScalarWhereInput | DomainReferenceScalarWhereInput[]
    id?: StringFilter<"DomainReference"> | string
    domainKnowledgeId?: StringFilter<"DomainReference"> | string
    title?: StringFilter<"DomainReference"> | string
    type?: StringFilter<"DomainReference"> | string
    url?: StringNullableFilter<"DomainReference"> | string | null
    author?: StringNullableFilter<"DomainReference"> | string | null
    publishDate?: DateTimeNullableFilter<"DomainReference"> | Date | string | null
    summary?: StringNullableFilter<"DomainReference"> | string | null
    createdAt?: DateTimeFilter<"DomainReference"> | Date | string
  }

  export type UserUpsertWithoutDomainKnowledgeInput = {
    update: XOR<UserUpdateWithoutDomainKnowledgeInput, UserUncheckedUpdateWithoutDomainKnowledgeInput>
    create: XOR<UserCreateWithoutDomainKnowledgeInput, UserUncheckedCreateWithoutDomainKnowledgeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDomainKnowledgeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDomainKnowledgeInput, UserUncheckedUpdateWithoutDomainKnowledgeInput>
  }

  export type UserUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DomainKnowledgeCreateWithoutConceptsInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDomainKnowledgeInput
    patterns?: DomainPatternCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceCreateNestedManyWithoutDomainKnowledgeInput
    User?: UserCreateNestedOneWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeUncheckedCreateWithoutConceptsInput = {
    id?: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    patterns?: DomainPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceUncheckedCreateNestedManyWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeCreateOrConnectWithoutConceptsInput = {
    where: DomainKnowledgeWhereUniqueInput
    create: XOR<DomainKnowledgeCreateWithoutConceptsInput, DomainKnowledgeUncheckedCreateWithoutConceptsInput>
  }

  export type DomainKnowledgeUpsertWithoutConceptsInput = {
    update: XOR<DomainKnowledgeUpdateWithoutConceptsInput, DomainKnowledgeUncheckedUpdateWithoutConceptsInput>
    create: XOR<DomainKnowledgeCreateWithoutConceptsInput, DomainKnowledgeUncheckedCreateWithoutConceptsInput>
    where?: DomainKnowledgeWhereInput
  }

  export type DomainKnowledgeUpdateToOneWithWhereWithoutConceptsInput = {
    where?: DomainKnowledgeWhereInput
    data: XOR<DomainKnowledgeUpdateWithoutConceptsInput, DomainKnowledgeUncheckedUpdateWithoutConceptsInput>
  }

  export type DomainKnowledgeUpdateWithoutConceptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUpdateManyWithoutDomainKnowledgeNestedInput
    User?: UserUpdateOneWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateWithoutConceptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    patterns?: DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeCreateWithoutPatternsInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDomainKnowledgeInput
    concepts?: DomainConceptCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceCreateNestedManyWithoutDomainKnowledgeInput
    User?: UserCreateNestedOneWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeUncheckedCreateWithoutPatternsInput = {
    id?: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    concepts?: DomainConceptUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceUncheckedCreateNestedManyWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeCreateOrConnectWithoutPatternsInput = {
    where: DomainKnowledgeWhereUniqueInput
    create: XOR<DomainKnowledgeCreateWithoutPatternsInput, DomainKnowledgeUncheckedCreateWithoutPatternsInput>
  }

  export type DomainKnowledgeUpsertWithoutPatternsInput = {
    update: XOR<DomainKnowledgeUpdateWithoutPatternsInput, DomainKnowledgeUncheckedUpdateWithoutPatternsInput>
    create: XOR<DomainKnowledgeCreateWithoutPatternsInput, DomainKnowledgeUncheckedCreateWithoutPatternsInput>
    where?: DomainKnowledgeWhereInput
  }

  export type DomainKnowledgeUpdateToOneWithWhereWithoutPatternsInput = {
    where?: DomainKnowledgeWhereInput
    data: XOR<DomainKnowledgeUpdateWithoutPatternsInput, DomainKnowledgeUncheckedUpdateWithoutPatternsInput>
  }

  export type DomainKnowledgeUpdateWithoutPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDomainKnowledgeNestedInput
    concepts?: DomainConceptUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUpdateManyWithoutDomainKnowledgeNestedInput
    User?: UserUpdateOneWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateWithoutPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    concepts?: DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeCreateWithoutBestPracticesInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDomainKnowledgeInput
    concepts?: DomainConceptCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceCreateNestedManyWithoutDomainKnowledgeInput
    User?: UserCreateNestedOneWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeUncheckedCreateWithoutBestPracticesInput = {
    id?: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    concepts?: DomainConceptUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceUncheckedCreateNestedManyWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeCreateOrConnectWithoutBestPracticesInput = {
    where: DomainKnowledgeWhereUniqueInput
    create: XOR<DomainKnowledgeCreateWithoutBestPracticesInput, DomainKnowledgeUncheckedCreateWithoutBestPracticesInput>
  }

  export type DomainKnowledgeUpsertWithoutBestPracticesInput = {
    update: XOR<DomainKnowledgeUpdateWithoutBestPracticesInput, DomainKnowledgeUncheckedUpdateWithoutBestPracticesInput>
    create: XOR<DomainKnowledgeCreateWithoutBestPracticesInput, DomainKnowledgeUncheckedCreateWithoutBestPracticesInput>
    where?: DomainKnowledgeWhereInput
  }

  export type DomainKnowledgeUpdateToOneWithWhereWithoutBestPracticesInput = {
    where?: DomainKnowledgeWhereInput
    data: XOR<DomainKnowledgeUpdateWithoutBestPracticesInput, DomainKnowledgeUncheckedUpdateWithoutBestPracticesInput>
  }

  export type DomainKnowledgeUpdateWithoutBestPracticesInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDomainKnowledgeNestedInput
    concepts?: DomainConceptUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUpdateManyWithoutDomainKnowledgeNestedInput
    User?: UserUpdateOneWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateWithoutBestPracticesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    concepts?: DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeCreateWithoutAntiPatternsInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDomainKnowledgeInput
    concepts?: DomainConceptCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceCreateNestedManyWithoutDomainKnowledgeInput
    User?: UserCreateNestedOneWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeUncheckedCreateWithoutAntiPatternsInput = {
    id?: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    concepts?: DomainConceptUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceUncheckedCreateNestedManyWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeCreateOrConnectWithoutAntiPatternsInput = {
    where: DomainKnowledgeWhereUniqueInput
    create: XOR<DomainKnowledgeCreateWithoutAntiPatternsInput, DomainKnowledgeUncheckedCreateWithoutAntiPatternsInput>
  }

  export type DomainKnowledgeUpsertWithoutAntiPatternsInput = {
    update: XOR<DomainKnowledgeUpdateWithoutAntiPatternsInput, DomainKnowledgeUncheckedUpdateWithoutAntiPatternsInput>
    create: XOR<DomainKnowledgeCreateWithoutAntiPatternsInput, DomainKnowledgeUncheckedCreateWithoutAntiPatternsInput>
    where?: DomainKnowledgeWhereInput
  }

  export type DomainKnowledgeUpdateToOneWithWhereWithoutAntiPatternsInput = {
    where?: DomainKnowledgeWhereInput
    data: XOR<DomainKnowledgeUpdateWithoutAntiPatternsInput, DomainKnowledgeUncheckedUpdateWithoutAntiPatternsInput>
  }

  export type DomainKnowledgeUpdateWithoutAntiPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDomainKnowledgeNestedInput
    concepts?: DomainConceptUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUpdateManyWithoutDomainKnowledgeNestedInput
    User?: UserUpdateOneWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateWithoutAntiPatternsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    concepts?: DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeCreateWithoutReferencesInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDomainKnowledgeInput
    concepts?: DomainConceptCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternCreateNestedManyWithoutDomainKnowledgeInput
    User?: UserCreateNestedOneWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeUncheckedCreateWithoutReferencesInput = {
    id?: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    concepts?: DomainConceptUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeCreateOrConnectWithoutReferencesInput = {
    where: DomainKnowledgeWhereUniqueInput
    create: XOR<DomainKnowledgeCreateWithoutReferencesInput, DomainKnowledgeUncheckedCreateWithoutReferencesInput>
  }

  export type DomainKnowledgeUpsertWithoutReferencesInput = {
    update: XOR<DomainKnowledgeUpdateWithoutReferencesInput, DomainKnowledgeUncheckedUpdateWithoutReferencesInput>
    create: XOR<DomainKnowledgeCreateWithoutReferencesInput, DomainKnowledgeUncheckedCreateWithoutReferencesInput>
    where?: DomainKnowledgeWhereInput
  }

  export type DomainKnowledgeUpdateToOneWithWhereWithoutReferencesInput = {
    where?: DomainKnowledgeWhereInput
    data: XOR<DomainKnowledgeUpdateWithoutReferencesInput, DomainKnowledgeUncheckedUpdateWithoutReferencesInput>
  }

  export type DomainKnowledgeUpdateWithoutReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDomainKnowledgeNestedInput
    concepts?: DomainConceptUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUpdateManyWithoutDomainKnowledgeNestedInput
    User?: UserUpdateOneWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateWithoutReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    concepts?: DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    id?: string
    role?: $Enums.ProjectRole
    permissions?: ProjectMemberCreatepermissionsInput | string[]
    joinedAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    userId: string
    role?: $Enums.ProjectRole
    permissions?: ProjectMemberCreatepermissionsInput | string[]
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sprint: SprintCreateNestedOneWithoutTaskInput
    team: TeamCreateNestedOneWithoutTasksInput
    feature?: FeatureCreateNestedOneWithoutTasksInput
    AgentTask?: AgentTaskCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    sprintId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type DocumentationCreateWithoutProjectInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    tags?: DocumentTagCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentationInput
    User?: UserCreateNestedOneWithoutDocumentationInput
  }

  export type DocumentationUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    userId?: string | null
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentationInput
  }

  export type DocumentationCreateOrConnectWithoutProjectInput = {
    where: DocumentationWhereUniqueInput
    create: XOR<DocumentationCreateWithoutProjectInput, DocumentationUncheckedCreateWithoutProjectInput>
  }

  export type DocumentationCreateManyProjectInputEnvelope = {
    data: DocumentationCreateManyProjectInput | DocumentationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MindMapCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    overview: string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    rootNode?: MindMapNodeCreateNestedOneWithoutRootOfMapInput
    nodes?: MindMapNodeCreateNestedManyWithoutMindMapInput
    User?: UserCreateNestedOneWithoutMindMapInput
  }

  export type MindMapUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    overview: string
    nodeId?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    nodes?: MindMapNodeUncheckedCreateNestedManyWithoutMindMapInput
  }

  export type MindMapCreateOrConnectWithoutProjectInput = {
    where: MindMapWhereUniqueInput
    create: XOR<MindMapCreateWithoutProjectInput, MindMapUncheckedCreateWithoutProjectInput>
  }

  export type MindMapCreateManyProjectInputEnvelope = {
    data: MindMapCreateManyProjectInput | MindMapCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SprintCreateWithoutProjectInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    goal: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Task?: TaskCreateNestedManyWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    goal: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    Task?: TaskUncheckedCreateNestedManyWithoutSprintInput
  }

  export type SprintCreateOrConnectWithoutProjectInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput>
  }

  export type SprintCreateManyProjectInputEnvelope = {
    data: SprintCreateManyProjectInput | SprintCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type RequirementCreateWithoutProjectInput = {
    id?: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    parent?: RequirementCreateNestedOneWithoutChildrenInput
    children?: RequirementCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentCreateNestedManyWithoutRequirementInput
    User?: UserCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    children?: RequirementUncheckedCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionUncheckedCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutProjectInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutProjectInput, RequirementUncheckedCreateWithoutProjectInput>
  }

  export type RequirementCreateManyProjectInputEnvelope = {
    data: RequirementCreateManyProjectInput | RequirementCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type DomainKnowledgeCreateWithoutProjectInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    concepts?: DomainConceptCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceCreateNestedManyWithoutDomainKnowledgeInput
    User?: UserCreateNestedOneWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeUncheckedCreateWithoutProjectInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    concepts?: DomainConceptUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceUncheckedCreateNestedManyWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeCreateOrConnectWithoutProjectInput = {
    where: DomainKnowledgeWhereUniqueInput
    create: XOR<DomainKnowledgeCreateWithoutProjectInput, DomainKnowledgeUncheckedCreateWithoutProjectInput>
  }

  export type DomainKnowledgeCreateManyProjectInputEnvelope = {
    data: DomainKnowledgeCreateManyProjectInput | DomainKnowledgeCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SystemArchitectureCreateWithoutProjectInput = {
    id?: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    platformArchitectures?: PlatformArchitectureCreateNestedManyWithoutSystemArchitectureInput
    changeHistories?: ArchitectureChangeHistoryCreateNestedManyWithoutArchitectureInput
    previousVersion?: SystemArchitectureCreateNestedOneWithoutNextVersionsInput
    nextVersions?: SystemArchitectureCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    previousVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedCreateNestedManyWithoutSystemArchitectureInput
    changeHistories?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutArchitectureInput
    nextVersions?: SystemArchitectureUncheckedCreateNestedManyWithoutPreviousVersionInput
  }

  export type SystemArchitectureCreateOrConnectWithoutProjectInput = {
    where: SystemArchitectureWhereUniqueInput
    create: XOR<SystemArchitectureCreateWithoutProjectInput, SystemArchitectureUncheckedCreateWithoutProjectInput>
  }

  export type SystemArchitectureCreateManyProjectInputEnvelope = {
    data: SystemArchitectureCreateManyProjectInput | SystemArchitectureCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneCreateNestedManyWithoutRoadmapInput
    versions?: VersionCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneUncheckedCreateNestedManyWithoutRoadmapInput
    versions?: VersionUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutProjectInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutProjectInput, RoadmapUncheckedCreateWithoutProjectInput>
  }

  export type RoadmapCreateManyProjectInputEnvelope = {
    data: RoadmapCreateManyProjectInput | RoadmapCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ApiDesignCreateWithoutProjectInput = {
    id?: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    examples?: ApiExampleCreateNestedManyWithoutApiDesignInput
    errorCodes?: ApiErrorCodeCreateNestedManyWithoutApiDesignInput
  }

  export type ApiDesignUncheckedCreateWithoutProjectInput = {
    id?: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    examples?: ApiExampleUncheckedCreateNestedManyWithoutApiDesignInput
    errorCodes?: ApiErrorCodeUncheckedCreateNestedManyWithoutApiDesignInput
  }

  export type ApiDesignCreateOrConnectWithoutProjectInput = {
    where: ApiDesignWhereUniqueInput
    create: XOR<ApiDesignCreateWithoutProjectInput, ApiDesignUncheckedCreateWithoutProjectInput>
  }

  export type ApiDesignCreateManyProjectInputEnvelope = {
    data: ApiDesignCreateManyProjectInput | ApiDesignCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutTeamInput
    agents?: AgentCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutTeamInput
    agents?: AgentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutProjectInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutProjectInput, TeamUncheckedCreateWithoutProjectInput>
  }

  export type TeamCreateManyProjectInputEnvelope = {
    data: TeamCreateManyProjectInput | TeamCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    team: TeamCreateNestedOneWithoutAgentsInput
    AgentActivity?: AgentActivityCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutProjectInput = {
    id?: string
    teamId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    AgentActivity?: AgentActivityUncheckedCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutProjectInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutProjectInput, AgentUncheckedCreateWithoutProjectInput>
  }

  export type AgentCreateManyProjectInputEnvelope = {
    data: AgentCreateManyProjectInput | AgentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AgentWorklogCreateWithoutProjectInput = {
    id?: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutAgentWorklogInput
    task: TaskCreateNestedOneWithoutAgentWorklogInput
  }

  export type AgentWorklogUncheckedCreateWithoutProjectInput = {
    id?: string
    agentId: string
    taskId: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentWorklogCreateOrConnectWithoutProjectInput = {
    where: AgentWorklogWhereUniqueInput
    create: XOR<AgentWorklogCreateWithoutProjectInput, AgentWorklogUncheckedCreateWithoutProjectInput>
  }

  export type AgentWorklogCreateManyProjectInputEnvelope = {
    data: AgentWorklogCreateManyProjectInput | AgentWorklogCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type DatabaseSchemaCreateWithoutProjectInput = {
    id?: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tables?: DatabaseTableCreateNestedManyWithoutSchemaInput
    User?: UserCreateNestedOneWithoutDatabaseSchemaInput
  }

  export type DatabaseSchemaUncheckedCreateWithoutProjectInput = {
    id?: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    tables?: DatabaseTableUncheckedCreateNestedManyWithoutSchemaInput
  }

  export type DatabaseSchemaCreateOrConnectWithoutProjectInput = {
    where: DatabaseSchemaWhereUniqueInput
    create: XOR<DatabaseSchemaCreateWithoutProjectInput, DatabaseSchemaUncheckedCreateWithoutProjectInput>
  }

  export type DatabaseSchemaCreateManyProjectInputEnvelope = {
    data: DatabaseSchemaCreateManyProjectInput | DatabaseSchemaCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type RequirementQuestionCreateWithoutProjectInput = {
    id?: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
    requirement: RequirementCreateNestedOneWithoutQuestionsInput
    agent: AgentCreateNestedOneWithoutRequirementQuestionInput
  }

  export type RequirementQuestionUncheckedCreateWithoutProjectInput = {
    id?: string
    requirementId: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
  }

  export type RequirementQuestionCreateOrConnectWithoutProjectInput = {
    where: RequirementQuestionWhereUniqueInput
    create: XOR<RequirementQuestionCreateWithoutProjectInput, RequirementQuestionUncheckedCreateWithoutProjectInput>
  }

  export type RequirementQuestionCreateManyProjectInputEnvelope = {
    data: RequirementQuestionCreateManyProjectInput | RequirementQuestionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type RequirementAttachmentCreateWithoutProjectInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    requirement: RequirementCreateNestedOneWithoutAttachmentsInput
    User?: UserCreateNestedOneWithoutRequirementAttachmentInput
  }

  export type RequirementAttachmentUncheckedCreateWithoutProjectInput = {
    id?: string
    requirementId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type RequirementAttachmentCreateOrConnectWithoutProjectInput = {
    where: RequirementAttachmentWhereUniqueInput
    create: XOR<RequirementAttachmentCreateWithoutProjectInput, RequirementAttachmentUncheckedCreateWithoutProjectInput>
  }

  export type RequirementAttachmentCreateManyProjectInputEnvelope = {
    data: RequirementAttachmentCreateManyProjectInput | RequirementAttachmentCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    userId?: StringFilter<"ProjectMember"> | string
    role?: EnumProjectRoleFilter<"ProjectMember"> | $Enums.ProjectRole
    permissions?: StringNullableListFilter<"ProjectMember">
    joinedAt?: DateTimeFilter<"ProjectMember"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMember"> | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    projectId?: StringFilter<"Task"> | string
    sprintId?: StringFilter<"Task"> | string
    teamId?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    content?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    dueDate?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    featureId?: StringNullableFilter<"Task"> | string | null
  }

  export type DocumentationUpsertWithWhereUniqueWithoutProjectInput = {
    where: DocumentationWhereUniqueInput
    update: XOR<DocumentationUpdateWithoutProjectInput, DocumentationUncheckedUpdateWithoutProjectInput>
    create: XOR<DocumentationCreateWithoutProjectInput, DocumentationUncheckedCreateWithoutProjectInput>
  }

  export type DocumentationUpdateWithWhereUniqueWithoutProjectInput = {
    where: DocumentationWhereUniqueInput
    data: XOR<DocumentationUpdateWithoutProjectInput, DocumentationUncheckedUpdateWithoutProjectInput>
  }

  export type DocumentationUpdateManyWithWhereWithoutProjectInput = {
    where: DocumentationScalarWhereInput
    data: XOR<DocumentationUpdateManyMutationInput, DocumentationUncheckedUpdateManyWithoutProjectInput>
  }

  export type MindMapUpsertWithWhereUniqueWithoutProjectInput = {
    where: MindMapWhereUniqueInput
    update: XOR<MindMapUpdateWithoutProjectInput, MindMapUncheckedUpdateWithoutProjectInput>
    create: XOR<MindMapCreateWithoutProjectInput, MindMapUncheckedCreateWithoutProjectInput>
  }

  export type MindMapUpdateWithWhereUniqueWithoutProjectInput = {
    where: MindMapWhereUniqueInput
    data: XOR<MindMapUpdateWithoutProjectInput, MindMapUncheckedUpdateWithoutProjectInput>
  }

  export type MindMapUpdateManyWithWhereWithoutProjectInput = {
    where: MindMapScalarWhereInput
    data: XOR<MindMapUpdateManyMutationInput, MindMapUncheckedUpdateManyWithoutProjectInput>
  }

  export type MindMapScalarWhereInput = {
    AND?: MindMapScalarWhereInput | MindMapScalarWhereInput[]
    OR?: MindMapScalarWhereInput[]
    NOT?: MindMapScalarWhereInput | MindMapScalarWhereInput[]
    id?: StringFilter<"MindMap"> | string
    projectId?: StringFilter<"MindMap"> | string
    title?: StringFilter<"MindMap"> | string
    description?: StringNullableFilter<"MindMap"> | string | null
    overview?: StringFilter<"MindMap"> | string
    nodeId?: StringNullableFilter<"MindMap"> | string | null
    theme?: JsonNullableFilter<"MindMap">
    layout?: StringFilter<"MindMap"> | string
    version?: IntFilter<"MindMap"> | number
    createdAt?: DateTimeFilter<"MindMap"> | Date | string
    updatedAt?: DateTimeFilter<"MindMap"> | Date | string
    deletedAt?: DateTimeNullableFilter<"MindMap"> | Date | string | null
    userId?: StringNullableFilter<"MindMap"> | string | null
  }

  export type SprintUpsertWithWhereUniqueWithoutProjectInput = {
    where: SprintWhereUniqueInput
    update: XOR<SprintUpdateWithoutProjectInput, SprintUncheckedUpdateWithoutProjectInput>
    create: XOR<SprintCreateWithoutProjectInput, SprintUncheckedCreateWithoutProjectInput>
  }

  export type SprintUpdateWithWhereUniqueWithoutProjectInput = {
    where: SprintWhereUniqueInput
    data: XOR<SprintUpdateWithoutProjectInput, SprintUncheckedUpdateWithoutProjectInput>
  }

  export type SprintUpdateManyWithWhereWithoutProjectInput = {
    where: SprintScalarWhereInput
    data: XOR<SprintUpdateManyMutationInput, SprintUncheckedUpdateManyWithoutProjectInput>
  }

  export type SprintScalarWhereInput = {
    AND?: SprintScalarWhereInput | SprintScalarWhereInput[]
    OR?: SprintScalarWhereInput[]
    NOT?: SprintScalarWhereInput | SprintScalarWhereInput[]
    id?: StringFilter<"Sprint"> | string
    projectId?: StringFilter<"Sprint"> | string
    name?: StringFilter<"Sprint"> | string
    startDate?: DateTimeFilter<"Sprint"> | Date | string
    endDate?: DateTimeFilter<"Sprint"> | Date | string
    goal?: StringFilter<"Sprint"> | string
    status?: StringFilter<"Sprint"> | string
    createdAt?: DateTimeFilter<"Sprint"> | Date | string
    updatedAt?: DateTimeFilter<"Sprint"> | Date | string
  }

  export type RequirementUpsertWithWhereUniqueWithoutProjectInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutProjectInput, RequirementUncheckedUpdateWithoutProjectInput>
    create: XOR<RequirementCreateWithoutProjectInput, RequirementUncheckedCreateWithoutProjectInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutProjectInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutProjectInput, RequirementUncheckedUpdateWithoutProjectInput>
  }

  export type RequirementUpdateManyWithWhereWithoutProjectInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutProjectInput>
  }

  export type RequirementScalarWhereInput = {
    AND?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
    OR?: RequirementScalarWhereInput[]
    NOT?: RequirementScalarWhereInput | RequirementScalarWhereInput[]
    id?: StringFilter<"Requirement"> | string
    projectId?: StringFilter<"Requirement"> | string
    title?: StringFilter<"Requirement"> | string
    content?: StringFilter<"Requirement"> | string
    type?: EnumRequirementTypeFilter<"Requirement"> | $Enums.RequirementType
    priority?: EnumRequirementPriorityFilter<"Requirement"> | $Enums.RequirementPriority
    status?: EnumRequirementStatusFilter<"Requirement"> | $Enums.RequirementStatus
    source?: EnumRequirementSourceFilter<"Requirement"> | $Enums.RequirementSource
    parentId?: StringNullableFilter<"Requirement"> | string | null
    version?: IntFilter<"Requirement"> | number
    createdAt?: DateTimeFilter<"Requirement"> | Date | string
    updatedAt?: DateTimeFilter<"Requirement"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Requirement"> | Date | string | null
    userId?: StringNullableFilter<"Requirement"> | string | null
  }

  export type DomainKnowledgeUpsertWithWhereUniqueWithoutProjectInput = {
    where: DomainKnowledgeWhereUniqueInput
    update: XOR<DomainKnowledgeUpdateWithoutProjectInput, DomainKnowledgeUncheckedUpdateWithoutProjectInput>
    create: XOR<DomainKnowledgeCreateWithoutProjectInput, DomainKnowledgeUncheckedCreateWithoutProjectInput>
  }

  export type DomainKnowledgeUpdateWithWhereUniqueWithoutProjectInput = {
    where: DomainKnowledgeWhereUniqueInput
    data: XOR<DomainKnowledgeUpdateWithoutProjectInput, DomainKnowledgeUncheckedUpdateWithoutProjectInput>
  }

  export type DomainKnowledgeUpdateManyWithWhereWithoutProjectInput = {
    where: DomainKnowledgeScalarWhereInput
    data: XOR<DomainKnowledgeUpdateManyMutationInput, DomainKnowledgeUncheckedUpdateManyWithoutProjectInput>
  }

  export type DomainKnowledgeScalarWhereInput = {
    AND?: DomainKnowledgeScalarWhereInput | DomainKnowledgeScalarWhereInput[]
    OR?: DomainKnowledgeScalarWhereInput[]
    NOT?: DomainKnowledgeScalarWhereInput | DomainKnowledgeScalarWhereInput[]
    id?: StringFilter<"DomainKnowledge"> | string
    projectId?: StringFilter<"DomainKnowledge"> | string
    domain?: StringFilter<"DomainKnowledge"> | string
    description?: StringFilter<"DomainKnowledge"> | string
    category?: EnumKnowledgeCategoryFilter<"DomainKnowledge"> | $Enums.KnowledgeCategory
    tags?: StringNullableListFilter<"DomainKnowledge">
    version?: IntFilter<"DomainKnowledge"> | number
    createdAt?: DateTimeFilter<"DomainKnowledge"> | Date | string
    updatedAt?: DateTimeFilter<"DomainKnowledge"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DomainKnowledge"> | Date | string | null
    userId?: StringNullableFilter<"DomainKnowledge"> | string | null
  }

  export type SystemArchitectureUpsertWithWhereUniqueWithoutProjectInput = {
    where: SystemArchitectureWhereUniqueInput
    update: XOR<SystemArchitectureUpdateWithoutProjectInput, SystemArchitectureUncheckedUpdateWithoutProjectInput>
    create: XOR<SystemArchitectureCreateWithoutProjectInput, SystemArchitectureUncheckedCreateWithoutProjectInput>
  }

  export type SystemArchitectureUpdateWithWhereUniqueWithoutProjectInput = {
    where: SystemArchitectureWhereUniqueInput
    data: XOR<SystemArchitectureUpdateWithoutProjectInput, SystemArchitectureUncheckedUpdateWithoutProjectInput>
  }

  export type SystemArchitectureUpdateManyWithWhereWithoutProjectInput = {
    where: SystemArchitectureScalarWhereInput
    data: XOR<SystemArchitectureUpdateManyMutationInput, SystemArchitectureUncheckedUpdateManyWithoutProjectInput>
  }

  export type RoadmapUpsertWithWhereUniqueWithoutProjectInput = {
    where: RoadmapWhereUniqueInput
    update: XOR<RoadmapUpdateWithoutProjectInput, RoadmapUncheckedUpdateWithoutProjectInput>
    create: XOR<RoadmapCreateWithoutProjectInput, RoadmapUncheckedCreateWithoutProjectInput>
  }

  export type RoadmapUpdateWithWhereUniqueWithoutProjectInput = {
    where: RoadmapWhereUniqueInput
    data: XOR<RoadmapUpdateWithoutProjectInput, RoadmapUncheckedUpdateWithoutProjectInput>
  }

  export type RoadmapUpdateManyWithWhereWithoutProjectInput = {
    where: RoadmapScalarWhereInput
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyWithoutProjectInput>
  }

  export type RoadmapScalarWhereInput = {
    AND?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
    OR?: RoadmapScalarWhereInput[]
    NOT?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
    id?: StringFilter<"Roadmap"> | string
    projectId?: StringFilter<"Roadmap"> | string
    name?: StringFilter<"Roadmap"> | string
    description?: StringNullableFilter<"Roadmap"> | string | null
    startDate?: DateTimeFilter<"Roadmap"> | Date | string
    endDate?: DateTimeFilter<"Roadmap"> | Date | string
    status?: StringFilter<"Roadmap"> | string
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
  }

  export type ApiDesignUpsertWithWhereUniqueWithoutProjectInput = {
    where: ApiDesignWhereUniqueInput
    update: XOR<ApiDesignUpdateWithoutProjectInput, ApiDesignUncheckedUpdateWithoutProjectInput>
    create: XOR<ApiDesignCreateWithoutProjectInput, ApiDesignUncheckedCreateWithoutProjectInput>
  }

  export type ApiDesignUpdateWithWhereUniqueWithoutProjectInput = {
    where: ApiDesignWhereUniqueInput
    data: XOR<ApiDesignUpdateWithoutProjectInput, ApiDesignUncheckedUpdateWithoutProjectInput>
  }

  export type ApiDesignUpdateManyWithWhereWithoutProjectInput = {
    where: ApiDesignScalarWhereInput
    data: XOR<ApiDesignUpdateManyMutationInput, ApiDesignUncheckedUpdateManyWithoutProjectInput>
  }

  export type ApiDesignScalarWhereInput = {
    AND?: ApiDesignScalarWhereInput | ApiDesignScalarWhereInput[]
    OR?: ApiDesignScalarWhereInput[]
    NOT?: ApiDesignScalarWhereInput | ApiDesignScalarWhereInput[]
    id?: StringFilter<"ApiDesign"> | string
    projectId?: StringFilter<"ApiDesign"> | string
    apiName?: StringFilter<"ApiDesign"> | string
    apiPath?: StringFilter<"ApiDesign"> | string
    apiMethod?: EnumApiMethodFilter<"ApiDesign"> | $Enums.ApiMethod
    apiVersion?: StringFilter<"ApiDesign"> | string
    platform?: StringFilter<"ApiDesign"> | string
    module?: StringNullableFilter<"ApiDesign"> | string | null
    apiDescription?: StringFilter<"ApiDesign"> | string
    businessLogic?: StringNullableFilter<"ApiDesign"> | string | null
    apiContentType?: EnumApiContentTypeFilter<"ApiDesign"> | $Enums.ApiContentType
    requestHeaders?: JsonNullableFilter<"ApiDesign">
    requestParams?: JsonNullableFilter<"ApiDesign">
    requestBody?: JsonNullableFilter<"ApiDesign">
    responseHeaders?: JsonNullableFilter<"ApiDesign">
    responseBody?: JsonNullableFilter<"ApiDesign">
    authentication?: EnumApiAuthTypeFilter<"ApiDesign"> | $Enums.ApiAuthType
    authDetails?: JsonNullableFilter<"ApiDesign">
    permissions?: StringNullableListFilter<"ApiDesign">
    rateLimit?: IntNullableFilter<"ApiDesign"> | number | null
    timeout?: IntNullableFilter<"ApiDesign"> | number | null
    maxPayloadSize?: IntNullableFilter<"ApiDesign"> | number | null
    status?: EnumApiStatusFilter<"ApiDesign"> | $Enums.ApiStatus
    deprecated?: BoolFilter<"ApiDesign"> | boolean
    deprecationDate?: DateTimeNullableFilter<"ApiDesign"> | Date | string | null
    sunsetDate?: DateTimeNullableFilter<"ApiDesign"> | Date | string | null
    version?: IntFilter<"ApiDesign"> | number
    createdAt?: DateTimeFilter<"ApiDesign"> | Date | string
    updatedAt?: DateTimeFilter<"ApiDesign"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ApiDesign"> | Date | string | null
  }

  export type TeamUpsertWithWhereUniqueWithoutProjectInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutProjectInput, TeamUncheckedUpdateWithoutProjectInput>
    create: XOR<TeamCreateWithoutProjectInput, TeamUncheckedCreateWithoutProjectInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutProjectInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutProjectInput, TeamUncheckedUpdateWithoutProjectInput>
  }

  export type TeamUpdateManyWithWhereWithoutProjectInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutProjectInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    projectId?: StringFilter<"Team"> | string
  }

  export type AgentUpsertWithWhereUniqueWithoutProjectInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutProjectInput, AgentUncheckedUpdateWithoutProjectInput>
    create: XOR<AgentCreateWithoutProjectInput, AgentUncheckedCreateWithoutProjectInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutProjectInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutProjectInput, AgentUncheckedUpdateWithoutProjectInput>
  }

  export type AgentUpdateManyWithWhereWithoutProjectInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutProjectInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: StringFilter<"Agent"> | string
    projectId?: StringFilter<"Agent"> | string
    teamId?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    workPrompt?: StringNullableFilter<"Agent"> | string | null
    responsibilities?: StringNullableListFilter<"Agent">
    skills?: StringNullableListFilter<"Agent">
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
  }

  export type AgentWorklogUpsertWithWhereUniqueWithoutProjectInput = {
    where: AgentWorklogWhereUniqueInput
    update: XOR<AgentWorklogUpdateWithoutProjectInput, AgentWorklogUncheckedUpdateWithoutProjectInput>
    create: XOR<AgentWorklogCreateWithoutProjectInput, AgentWorklogUncheckedCreateWithoutProjectInput>
  }

  export type AgentWorklogUpdateWithWhereUniqueWithoutProjectInput = {
    where: AgentWorklogWhereUniqueInput
    data: XOR<AgentWorklogUpdateWithoutProjectInput, AgentWorklogUncheckedUpdateWithoutProjectInput>
  }

  export type AgentWorklogUpdateManyWithWhereWithoutProjectInput = {
    where: AgentWorklogScalarWhereInput
    data: XOR<AgentWorklogUpdateManyMutationInput, AgentWorklogUncheckedUpdateManyWithoutProjectInput>
  }

  export type DatabaseSchemaUpsertWithWhereUniqueWithoutProjectInput = {
    where: DatabaseSchemaWhereUniqueInput
    update: XOR<DatabaseSchemaUpdateWithoutProjectInput, DatabaseSchemaUncheckedUpdateWithoutProjectInput>
    create: XOR<DatabaseSchemaCreateWithoutProjectInput, DatabaseSchemaUncheckedCreateWithoutProjectInput>
  }

  export type DatabaseSchemaUpdateWithWhereUniqueWithoutProjectInput = {
    where: DatabaseSchemaWhereUniqueInput
    data: XOR<DatabaseSchemaUpdateWithoutProjectInput, DatabaseSchemaUncheckedUpdateWithoutProjectInput>
  }

  export type DatabaseSchemaUpdateManyWithWhereWithoutProjectInput = {
    where: DatabaseSchemaScalarWhereInput
    data: XOR<DatabaseSchemaUpdateManyMutationInput, DatabaseSchemaUncheckedUpdateManyWithoutProjectInput>
  }

  export type DatabaseSchemaScalarWhereInput = {
    AND?: DatabaseSchemaScalarWhereInput | DatabaseSchemaScalarWhereInput[]
    OR?: DatabaseSchemaScalarWhereInput[]
    NOT?: DatabaseSchemaScalarWhereInput | DatabaseSchemaScalarWhereInput[]
    id?: StringFilter<"DatabaseSchema"> | string
    projectId?: StringFilter<"DatabaseSchema"> | string
    schemaName?: StringFilter<"DatabaseSchema"> | string
    engine?: EnumDatabaseEngineFilter<"DatabaseSchema"> | $Enums.DatabaseEngine
    charset?: StringFilter<"DatabaseSchema"> | string
    collation?: StringFilter<"DatabaseSchema"> | string
    description?: StringNullableFilter<"DatabaseSchema"> | string | null
    version?: IntFilter<"DatabaseSchema"> | number
    createdAt?: DateTimeFilter<"DatabaseSchema"> | Date | string
    updatedAt?: DateTimeFilter<"DatabaseSchema"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DatabaseSchema"> | Date | string | null
    userId?: StringNullableFilter<"DatabaseSchema"> | string | null
  }

  export type RequirementQuestionUpsertWithWhereUniqueWithoutProjectInput = {
    where: RequirementQuestionWhereUniqueInput
    update: XOR<RequirementQuestionUpdateWithoutProjectInput, RequirementQuestionUncheckedUpdateWithoutProjectInput>
    create: XOR<RequirementQuestionCreateWithoutProjectInput, RequirementQuestionUncheckedCreateWithoutProjectInput>
  }

  export type RequirementQuestionUpdateWithWhereUniqueWithoutProjectInput = {
    where: RequirementQuestionWhereUniqueInput
    data: XOR<RequirementQuestionUpdateWithoutProjectInput, RequirementQuestionUncheckedUpdateWithoutProjectInput>
  }

  export type RequirementQuestionUpdateManyWithWhereWithoutProjectInput = {
    where: RequirementQuestionScalarWhereInput
    data: XOR<RequirementQuestionUpdateManyMutationInput, RequirementQuestionUncheckedUpdateManyWithoutProjectInput>
  }

  export type RequirementAttachmentUpsertWithWhereUniqueWithoutProjectInput = {
    where: RequirementAttachmentWhereUniqueInput
    update: XOR<RequirementAttachmentUpdateWithoutProjectInput, RequirementAttachmentUncheckedUpdateWithoutProjectInput>
    create: XOR<RequirementAttachmentCreateWithoutProjectInput, RequirementAttachmentUncheckedCreateWithoutProjectInput>
  }

  export type RequirementAttachmentUpdateWithWhereUniqueWithoutProjectInput = {
    where: RequirementAttachmentWhereUniqueInput
    data: XOR<RequirementAttachmentUpdateWithoutProjectInput, RequirementAttachmentUncheckedUpdateWithoutProjectInput>
  }

  export type RequirementAttachmentUpdateManyWithWhereWithoutProjectInput = {
    where: RequirementAttachmentScalarWhereInput
    data: XOR<RequirementAttachmentUpdateManyMutationInput, RequirementAttachmentUncheckedUpdateManyWithoutProjectInput>
  }

  export type RequirementAttachmentScalarWhereInput = {
    AND?: RequirementAttachmentScalarWhereInput | RequirementAttachmentScalarWhereInput[]
    OR?: RequirementAttachmentScalarWhereInput[]
    NOT?: RequirementAttachmentScalarWhereInput | RequirementAttachmentScalarWhereInput[]
    id?: StringFilter<"RequirementAttachment"> | string
    projectId?: StringFilter<"RequirementAttachment"> | string
    requirementId?: StringFilter<"RequirementAttachment"> | string
    fileName?: StringFilter<"RequirementAttachment"> | string
    fileUrl?: StringFilter<"RequirementAttachment"> | string
    fileSize?: IntFilter<"RequirementAttachment"> | number
    mimeType?: StringFilter<"RequirementAttachment"> | string
    createdAt?: DateTimeFilter<"RequirementAttachment"> | Date | string
    userId?: StringNullableFilter<"RequirementAttachment"> | string | null
  }

  export type ProjectCreateWithoutRequirementInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRequirementInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRequirementInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRequirementInput, ProjectUncheckedCreateWithoutRequirementInput>
  }

  export type RequirementCreateWithoutChildrenInput = {
    id?: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutRequirementInput
    parent?: RequirementCreateNestedOneWithoutChildrenInput
    questions?: RequirementQuestionCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentCreateNestedManyWithoutRequirementInput
    User?: UserCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutChildrenInput = {
    id?: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    questions?: RequirementQuestionUncheckedCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutChildrenInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutChildrenInput, RequirementUncheckedCreateWithoutChildrenInput>
  }

  export type RequirementCreateWithoutParentInput = {
    id?: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutRequirementInput
    children?: RequirementCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentCreateNestedManyWithoutRequirementInput
    User?: UserCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutParentInput = {
    id?: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    children?: RequirementUncheckedCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionUncheckedCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutParentInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutParentInput, RequirementUncheckedCreateWithoutParentInput>
  }

  export type RequirementCreateManyParentInputEnvelope = {
    data: RequirementCreateManyParentInput | RequirementCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type RequirementQuestionCreateWithoutRequirementInput = {
    id?: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutRequirementQuestionInput
    agent: AgentCreateNestedOneWithoutRequirementQuestionInput
  }

  export type RequirementQuestionUncheckedCreateWithoutRequirementInput = {
    id?: string
    projectId: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
  }

  export type RequirementQuestionCreateOrConnectWithoutRequirementInput = {
    where: RequirementQuestionWhereUniqueInput
    create: XOR<RequirementQuestionCreateWithoutRequirementInput, RequirementQuestionUncheckedCreateWithoutRequirementInput>
  }

  export type RequirementQuestionCreateManyRequirementInputEnvelope = {
    data: RequirementQuestionCreateManyRequirementInput | RequirementQuestionCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type RequirementAttachmentCreateWithoutRequirementInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutRequirementAttachmentInput
    User?: UserCreateNestedOneWithoutRequirementAttachmentInput
  }

  export type RequirementAttachmentUncheckedCreateWithoutRequirementInput = {
    id?: string
    projectId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type RequirementAttachmentCreateOrConnectWithoutRequirementInput = {
    where: RequirementAttachmentWhereUniqueInput
    create: XOR<RequirementAttachmentCreateWithoutRequirementInput, RequirementAttachmentUncheckedCreateWithoutRequirementInput>
  }

  export type RequirementAttachmentCreateManyRequirementInputEnvelope = {
    data: RequirementAttachmentCreateManyRequirementInput | RequirementAttachmentCreateManyRequirementInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRequirementInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRequirementInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRequirementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequirementInput, UserUncheckedCreateWithoutRequirementInput>
  }

  export type ProjectUpsertWithoutRequirementInput = {
    update: XOR<ProjectUpdateWithoutRequirementInput, ProjectUncheckedUpdateWithoutRequirementInput>
    create: XOR<ProjectCreateWithoutRequirementInput, ProjectUncheckedCreateWithoutRequirementInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRequirementInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRequirementInput, ProjectUncheckedUpdateWithoutRequirementInput>
  }

  export type ProjectUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type RequirementUpsertWithoutChildrenInput = {
    update: XOR<RequirementUpdateWithoutChildrenInput, RequirementUncheckedUpdateWithoutChildrenInput>
    create: XOR<RequirementCreateWithoutChildrenInput, RequirementUncheckedCreateWithoutChildrenInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutChildrenInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutChildrenInput, RequirementUncheckedUpdateWithoutChildrenInput>
  }

  export type RequirementUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutRequirementNestedInput
    parent?: RequirementUpdateOneWithoutChildrenNestedInput
    questions?: RequirementQuestionUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUpdateManyWithoutRequirementNestedInput
    User?: UserUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    questions?: RequirementQuestionUncheckedUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUpsertWithWhereUniqueWithoutParentInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutParentInput, RequirementUncheckedUpdateWithoutParentInput>
    create: XOR<RequirementCreateWithoutParentInput, RequirementUncheckedCreateWithoutParentInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutParentInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutParentInput, RequirementUncheckedUpdateWithoutParentInput>
  }

  export type RequirementUpdateManyWithWhereWithoutParentInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutParentInput>
  }

  export type RequirementQuestionUpsertWithWhereUniqueWithoutRequirementInput = {
    where: RequirementQuestionWhereUniqueInput
    update: XOR<RequirementQuestionUpdateWithoutRequirementInput, RequirementQuestionUncheckedUpdateWithoutRequirementInput>
    create: XOR<RequirementQuestionCreateWithoutRequirementInput, RequirementQuestionUncheckedCreateWithoutRequirementInput>
  }

  export type RequirementQuestionUpdateWithWhereUniqueWithoutRequirementInput = {
    where: RequirementQuestionWhereUniqueInput
    data: XOR<RequirementQuestionUpdateWithoutRequirementInput, RequirementQuestionUncheckedUpdateWithoutRequirementInput>
  }

  export type RequirementQuestionUpdateManyWithWhereWithoutRequirementInput = {
    where: RequirementQuestionScalarWhereInput
    data: XOR<RequirementQuestionUpdateManyMutationInput, RequirementQuestionUncheckedUpdateManyWithoutRequirementInput>
  }

  export type RequirementAttachmentUpsertWithWhereUniqueWithoutRequirementInput = {
    where: RequirementAttachmentWhereUniqueInput
    update: XOR<RequirementAttachmentUpdateWithoutRequirementInput, RequirementAttachmentUncheckedUpdateWithoutRequirementInput>
    create: XOR<RequirementAttachmentCreateWithoutRequirementInput, RequirementAttachmentUncheckedCreateWithoutRequirementInput>
  }

  export type RequirementAttachmentUpdateWithWhereUniqueWithoutRequirementInput = {
    where: RequirementAttachmentWhereUniqueInput
    data: XOR<RequirementAttachmentUpdateWithoutRequirementInput, RequirementAttachmentUncheckedUpdateWithoutRequirementInput>
  }

  export type RequirementAttachmentUpdateManyWithWhereWithoutRequirementInput = {
    where: RequirementAttachmentScalarWhereInput
    data: XOR<RequirementAttachmentUpdateManyMutationInput, RequirementAttachmentUncheckedUpdateManyWithoutRequirementInput>
  }

  export type UserUpsertWithoutRequirementInput = {
    update: XOR<UserUpdateWithoutRequirementInput, UserUncheckedUpdateWithoutRequirementInput>
    create: XOR<UserCreateWithoutRequirementInput, UserUncheckedCreateWithoutRequirementInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequirementInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequirementInput, UserUncheckedUpdateWithoutRequirementInput>
  }

  export type UserUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutRequirementQuestionInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRequirementQuestionInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRequirementQuestionInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRequirementQuestionInput, ProjectUncheckedCreateWithoutRequirementQuestionInput>
  }

  export type RequirementCreateWithoutQuestionsInput = {
    id?: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutRequirementInput
    parent?: RequirementCreateNestedOneWithoutChildrenInput
    children?: RequirementCreateNestedManyWithoutParentInput
    attachments?: RequirementAttachmentCreateNestedManyWithoutRequirementInput
    User?: UserCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutQuestionsInput = {
    id?: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    children?: RequirementUncheckedCreateNestedManyWithoutParentInput
    attachments?: RequirementAttachmentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutQuestionsInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutQuestionsInput, RequirementUncheckedCreateWithoutQuestionsInput>
  }

  export type AgentCreateWithoutRequirementQuestionInput = {
    id?: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgentInput
    team: TeamCreateNestedOneWithoutAgentsInput
    AgentActivity?: AgentActivityCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutRequirementQuestionInput = {
    id?: string
    projectId: string
    teamId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    AgentActivity?: AgentActivityUncheckedCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutRequirementQuestionInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutRequirementQuestionInput, AgentUncheckedCreateWithoutRequirementQuestionInput>
  }

  export type ProjectUpsertWithoutRequirementQuestionInput = {
    update: XOR<ProjectUpdateWithoutRequirementQuestionInput, ProjectUncheckedUpdateWithoutRequirementQuestionInput>
    create: XOR<ProjectCreateWithoutRequirementQuestionInput, ProjectUncheckedCreateWithoutRequirementQuestionInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRequirementQuestionInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRequirementQuestionInput, ProjectUncheckedUpdateWithoutRequirementQuestionInput>
  }

  export type ProjectUpdateWithoutRequirementQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRequirementQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type RequirementUpsertWithoutQuestionsInput = {
    update: XOR<RequirementUpdateWithoutQuestionsInput, RequirementUncheckedUpdateWithoutQuestionsInput>
    create: XOR<RequirementCreateWithoutQuestionsInput, RequirementUncheckedCreateWithoutQuestionsInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutQuestionsInput, RequirementUncheckedUpdateWithoutQuestionsInput>
  }

  export type RequirementUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutRequirementNestedInput
    parent?: RequirementUpdateOneWithoutChildrenNestedInput
    children?: RequirementUpdateManyWithoutParentNestedInput
    attachments?: RequirementAttachmentUpdateManyWithoutRequirementNestedInput
    User?: UserUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RequirementUncheckedUpdateManyWithoutParentNestedInput
    attachments?: RequirementAttachmentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type AgentUpsertWithoutRequirementQuestionInput = {
    update: XOR<AgentUpdateWithoutRequirementQuestionInput, AgentUncheckedUpdateWithoutRequirementQuestionInput>
    create: XOR<AgentCreateWithoutRequirementQuestionInput, AgentUncheckedCreateWithoutRequirementQuestionInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutRequirementQuestionInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutRequirementQuestionInput, AgentUncheckedUpdateWithoutRequirementQuestionInput>
  }

  export type AgentUpdateWithoutRequirementQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgentNestedInput
    team?: TeamUpdateOneRequiredWithoutAgentsNestedInput
    AgentActivity?: AgentActivityUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutRequirementQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentActivity?: AgentActivityUncheckedUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ProjectCreateWithoutRequirementAttachmentInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRequirementAttachmentInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRequirementAttachmentInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRequirementAttachmentInput, ProjectUncheckedCreateWithoutRequirementAttachmentInput>
  }

  export type RequirementCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutRequirementInput
    parent?: RequirementCreateNestedOneWithoutChildrenInput
    children?: RequirementCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionCreateNestedManyWithoutRequirementInput
    User?: UserCreateNestedOneWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
    children?: RequirementUncheckedCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutAttachmentsInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutAttachmentsInput, RequirementUncheckedCreateWithoutAttachmentsInput>
  }

  export type UserCreateWithoutRequirementAttachmentInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRequirementAttachmentInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRequirementAttachmentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequirementAttachmentInput, UserUncheckedCreateWithoutRequirementAttachmentInput>
  }

  export type ProjectUpsertWithoutRequirementAttachmentInput = {
    update: XOR<ProjectUpdateWithoutRequirementAttachmentInput, ProjectUncheckedUpdateWithoutRequirementAttachmentInput>
    create: XOR<ProjectCreateWithoutRequirementAttachmentInput, ProjectUncheckedCreateWithoutRequirementAttachmentInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRequirementAttachmentInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRequirementAttachmentInput, ProjectUncheckedUpdateWithoutRequirementAttachmentInput>
  }

  export type ProjectUpdateWithoutRequirementAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRequirementAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type RequirementUpsertWithoutAttachmentsInput = {
    update: XOR<RequirementUpdateWithoutAttachmentsInput, RequirementUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<RequirementCreateWithoutAttachmentsInput, RequirementUncheckedCreateWithoutAttachmentsInput>
    where?: RequirementWhereInput
  }

  export type RequirementUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: RequirementWhereInput
    data: XOR<RequirementUpdateWithoutAttachmentsInput, RequirementUncheckedUpdateWithoutAttachmentsInput>
  }

  export type RequirementUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutRequirementNestedInput
    parent?: RequirementUpdateOneWithoutChildrenNestedInput
    children?: RequirementUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUpdateManyWithoutRequirementNestedInput
    User?: UserUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RequirementUncheckedUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type UserUpsertWithoutRequirementAttachmentInput = {
    update: XOR<UserUpdateWithoutRequirementAttachmentInput, UserUncheckedUpdateWithoutRequirementAttachmentInput>
    create: XOR<UserCreateWithoutRequirementAttachmentInput, UserUncheckedCreateWithoutRequirementAttachmentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequirementAttachmentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequirementAttachmentInput, UserUncheckedUpdateWithoutRequirementAttachmentInput>
  }

  export type UserUpdateWithoutRequirementAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRequirementAttachmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutRoadmapsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutRoadmapsInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutRoadmapsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutRoadmapsInput, ProjectUncheckedCreateWithoutRoadmapsInput>
  }

  export type MilestoneCreateWithoutRoadmapInput = {
    id?: string
    name: string
    description?: string | null
    targetDate: Date | string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: FeatureCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneUncheckedCreateWithoutRoadmapInput = {
    id?: string
    name: string
    description?: string | null
    targetDate: Date | string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: FeatureUncheckedCreateNestedManyWithoutMilestoneInput
  }

  export type MilestoneCreateOrConnectWithoutRoadmapInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutRoadmapInput, MilestoneUncheckedCreateWithoutRoadmapInput>
  }

  export type MilestoneCreateManyRoadmapInputEnvelope = {
    data: MilestoneCreateManyRoadmapInput | MilestoneCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type VersionCreateWithoutRoadmapInput = {
    id?: string
    name: string
    description?: string | null
    releaseDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: FeatureCreateNestedManyWithoutVersionInput
  }

  export type VersionUncheckedCreateWithoutRoadmapInput = {
    id?: string
    name: string
    description?: string | null
    releaseDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: FeatureUncheckedCreateNestedManyWithoutVersionInput
  }

  export type VersionCreateOrConnectWithoutRoadmapInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutRoadmapInput, VersionUncheckedCreateWithoutRoadmapInput>
  }

  export type VersionCreateManyRoadmapInputEnvelope = {
    data: VersionCreateManyRoadmapInput | VersionCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutRoadmapsInput = {
    update: XOR<ProjectUpdateWithoutRoadmapsInput, ProjectUncheckedUpdateWithoutRoadmapsInput>
    create: XOR<ProjectCreateWithoutRoadmapsInput, ProjectUncheckedCreateWithoutRoadmapsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutRoadmapsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutRoadmapsInput, ProjectUncheckedUpdateWithoutRoadmapsInput>
  }

  export type ProjectUpdateWithoutRoadmapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutRoadmapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type MilestoneUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: MilestoneWhereUniqueInput
    update: XOR<MilestoneUpdateWithoutRoadmapInput, MilestoneUncheckedUpdateWithoutRoadmapInput>
    create: XOR<MilestoneCreateWithoutRoadmapInput, MilestoneUncheckedCreateWithoutRoadmapInput>
  }

  export type MilestoneUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: MilestoneWhereUniqueInput
    data: XOR<MilestoneUpdateWithoutRoadmapInput, MilestoneUncheckedUpdateWithoutRoadmapInput>
  }

  export type MilestoneUpdateManyWithWhereWithoutRoadmapInput = {
    where: MilestoneScalarWhereInput
    data: XOR<MilestoneUpdateManyMutationInput, MilestoneUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type MilestoneScalarWhereInput = {
    AND?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    OR?: MilestoneScalarWhereInput[]
    NOT?: MilestoneScalarWhereInput | MilestoneScalarWhereInput[]
    id?: StringFilter<"Milestone"> | string
    roadmapId?: StringFilter<"Milestone"> | string
    name?: StringFilter<"Milestone"> | string
    description?: StringNullableFilter<"Milestone"> | string | null
    targetDate?: DateTimeFilter<"Milestone"> | Date | string
    status?: StringFilter<"Milestone"> | string
    priority?: StringFilter<"Milestone"> | string
    createdAt?: DateTimeFilter<"Milestone"> | Date | string
    updatedAt?: DateTimeFilter<"Milestone"> | Date | string
  }

  export type VersionUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: VersionWhereUniqueInput
    update: XOR<VersionUpdateWithoutRoadmapInput, VersionUncheckedUpdateWithoutRoadmapInput>
    create: XOR<VersionCreateWithoutRoadmapInput, VersionUncheckedCreateWithoutRoadmapInput>
  }

  export type VersionUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: VersionWhereUniqueInput
    data: XOR<VersionUpdateWithoutRoadmapInput, VersionUncheckedUpdateWithoutRoadmapInput>
  }

  export type VersionUpdateManyWithWhereWithoutRoadmapInput = {
    where: VersionScalarWhereInput
    data: XOR<VersionUpdateManyMutationInput, VersionUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type VersionScalarWhereInput = {
    AND?: VersionScalarWhereInput | VersionScalarWhereInput[]
    OR?: VersionScalarWhereInput[]
    NOT?: VersionScalarWhereInput | VersionScalarWhereInput[]
    id?: StringFilter<"Version"> | string
    roadmapId?: StringFilter<"Version"> | string
    name?: StringFilter<"Version"> | string
    description?: StringNullableFilter<"Version"> | string | null
    releaseDate?: DateTimeNullableFilter<"Version"> | Date | string | null
    status?: StringFilter<"Version"> | string
    createdAt?: DateTimeFilter<"Version"> | Date | string
    updatedAt?: DateTimeFilter<"Version"> | Date | string
  }

  export type RoadmapCreateWithoutMilestonesInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutRoadmapsInput
    versions?: VersionCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutMilestonesInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    versions?: VersionUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutMilestonesInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutMilestonesInput, RoadmapUncheckedCreateWithoutMilestonesInput>
  }

  export type FeatureCreateWithoutMilestoneInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    version?: VersionCreateNestedOneWithoutFeaturesInput
    tasks?: TaskCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutMilestoneInput = {
    id?: string
    versionId?: string | null
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutMilestoneInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutMilestoneInput, FeatureUncheckedCreateWithoutMilestoneInput>
  }

  export type FeatureCreateManyMilestoneInputEnvelope = {
    data: FeatureCreateManyMilestoneInput | FeatureCreateManyMilestoneInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapUpsertWithoutMilestonesInput = {
    update: XOR<RoadmapUpdateWithoutMilestonesInput, RoadmapUncheckedUpdateWithoutMilestonesInput>
    create: XOR<RoadmapCreateWithoutMilestonesInput, RoadmapUncheckedCreateWithoutMilestonesInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutMilestonesInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutMilestonesInput, RoadmapUncheckedUpdateWithoutMilestonesInput>
  }

  export type RoadmapUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutRoadmapsNestedInput
    versions?: VersionUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutMilestonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    versions?: VersionUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type FeatureUpsertWithWhereUniqueWithoutMilestoneInput = {
    where: FeatureWhereUniqueInput
    update: XOR<FeatureUpdateWithoutMilestoneInput, FeatureUncheckedUpdateWithoutMilestoneInput>
    create: XOR<FeatureCreateWithoutMilestoneInput, FeatureUncheckedCreateWithoutMilestoneInput>
  }

  export type FeatureUpdateWithWhereUniqueWithoutMilestoneInput = {
    where: FeatureWhereUniqueInput
    data: XOR<FeatureUpdateWithoutMilestoneInput, FeatureUncheckedUpdateWithoutMilestoneInput>
  }

  export type FeatureUpdateManyWithWhereWithoutMilestoneInput = {
    where: FeatureScalarWhereInput
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyWithoutMilestoneInput>
  }

  export type FeatureScalarWhereInput = {
    AND?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
    OR?: FeatureScalarWhereInput[]
    NOT?: FeatureScalarWhereInput | FeatureScalarWhereInput[]
    id?: StringFilter<"Feature"> | string
    milestoneId?: StringNullableFilter<"Feature"> | string | null
    versionId?: StringNullableFilter<"Feature"> | string | null
    name?: StringFilter<"Feature"> | string
    description?: StringNullableFilter<"Feature"> | string | null
    status?: StringFilter<"Feature"> | string
    priority?: StringFilter<"Feature"> | string
    effort?: StringNullableFilter<"Feature"> | string | null
    createdAt?: DateTimeFilter<"Feature"> | Date | string
    updatedAt?: DateTimeFilter<"Feature"> | Date | string
  }

  export type RoadmapCreateWithoutVersionsInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutRoadmapsInput
    milestones?: MilestoneCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutVersionsInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    milestones?: MilestoneUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutVersionsInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutVersionsInput, RoadmapUncheckedCreateWithoutVersionsInput>
  }

  export type FeatureCreateWithoutVersionInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    milestone?: MilestoneCreateNestedOneWithoutFeaturesInput
    tasks?: TaskCreateNestedManyWithoutFeatureInput
  }

  export type FeatureUncheckedCreateWithoutVersionInput = {
    id?: string
    milestoneId?: string | null
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutFeatureInput
  }

  export type FeatureCreateOrConnectWithoutVersionInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutVersionInput, FeatureUncheckedCreateWithoutVersionInput>
  }

  export type FeatureCreateManyVersionInputEnvelope = {
    data: FeatureCreateManyVersionInput | FeatureCreateManyVersionInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapUpsertWithoutVersionsInput = {
    update: XOR<RoadmapUpdateWithoutVersionsInput, RoadmapUncheckedUpdateWithoutVersionsInput>
    create: XOR<RoadmapCreateWithoutVersionsInput, RoadmapUncheckedCreateWithoutVersionsInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutVersionsInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutVersionsInput, RoadmapUncheckedUpdateWithoutVersionsInput>
  }

  export type RoadmapUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutRoadmapsNestedInput
    milestones?: MilestoneUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type FeatureUpsertWithWhereUniqueWithoutVersionInput = {
    where: FeatureWhereUniqueInput
    update: XOR<FeatureUpdateWithoutVersionInput, FeatureUncheckedUpdateWithoutVersionInput>
    create: XOR<FeatureCreateWithoutVersionInput, FeatureUncheckedCreateWithoutVersionInput>
  }

  export type FeatureUpdateWithWhereUniqueWithoutVersionInput = {
    where: FeatureWhereUniqueInput
    data: XOR<FeatureUpdateWithoutVersionInput, FeatureUncheckedUpdateWithoutVersionInput>
  }

  export type FeatureUpdateManyWithWhereWithoutVersionInput = {
    where: FeatureScalarWhereInput
    data: XOR<FeatureUpdateManyMutationInput, FeatureUncheckedUpdateManyWithoutVersionInput>
  }

  export type MilestoneCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description?: string | null
    targetDate: Date | string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmap: RoadmapCreateNestedOneWithoutMilestonesInput
  }

  export type MilestoneUncheckedCreateWithoutFeaturesInput = {
    id?: string
    roadmapId: string
    name: string
    description?: string | null
    targetDate: Date | string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneCreateOrConnectWithoutFeaturesInput = {
    where: MilestoneWhereUniqueInput
    create: XOR<MilestoneCreateWithoutFeaturesInput, MilestoneUncheckedCreateWithoutFeaturesInput>
  }

  export type VersionCreateWithoutFeaturesInput = {
    id?: string
    name: string
    description?: string | null
    releaseDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmap: RoadmapCreateNestedOneWithoutVersionsInput
  }

  export type VersionUncheckedCreateWithoutFeaturesInput = {
    id?: string
    roadmapId: string
    name: string
    description?: string | null
    releaseDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VersionCreateOrConnectWithoutFeaturesInput = {
    where: VersionWhereUniqueInput
    create: XOR<VersionCreateWithoutFeaturesInput, VersionUncheckedCreateWithoutFeaturesInput>
  }

  export type TaskCreateWithoutFeatureInput = {
    id?: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    sprint: SprintCreateNestedOneWithoutTaskInput
    team: TeamCreateNestedOneWithoutTasksInput
    AgentTask?: AgentTaskCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutFeatureInput = {
    id?: string
    projectId: string
    sprintId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutFeatureInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutFeatureInput, TaskUncheckedCreateWithoutFeatureInput>
  }

  export type TaskCreateManyFeatureInputEnvelope = {
    data: TaskCreateManyFeatureInput | TaskCreateManyFeatureInput[]
    skipDuplicates?: boolean
  }

  export type MilestoneUpsertWithoutFeaturesInput = {
    update: XOR<MilestoneUpdateWithoutFeaturesInput, MilestoneUncheckedUpdateWithoutFeaturesInput>
    create: XOR<MilestoneCreateWithoutFeaturesInput, MilestoneUncheckedCreateWithoutFeaturesInput>
    where?: MilestoneWhereInput
  }

  export type MilestoneUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: MilestoneWhereInput
    data: XOR<MilestoneUpdateWithoutFeaturesInput, MilestoneUncheckedUpdateWithoutFeaturesInput>
  }

  export type MilestoneUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmap?: RoadmapUpdateOneRequiredWithoutMilestonesNestedInput
  }

  export type MilestoneUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VersionUpsertWithoutFeaturesInput = {
    update: XOR<VersionUpdateWithoutFeaturesInput, VersionUncheckedUpdateWithoutFeaturesInput>
    create: XOR<VersionCreateWithoutFeaturesInput, VersionUncheckedCreateWithoutFeaturesInput>
    where?: VersionWhereInput
  }

  export type VersionUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: VersionWhereInput
    data: XOR<VersionUpdateWithoutFeaturesInput, VersionUncheckedUpdateWithoutFeaturesInput>
  }

  export type VersionUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmap?: RoadmapUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type VersionUncheckedUpdateWithoutFeaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutFeatureInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutFeatureInput, TaskUncheckedUpdateWithoutFeatureInput>
    create: XOR<TaskCreateWithoutFeatureInput, TaskUncheckedCreateWithoutFeatureInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutFeatureInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutFeatureInput, TaskUncheckedUpdateWithoutFeatureInput>
  }

  export type TaskUpdateManyWithWhereWithoutFeatureInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutFeatureInput>
  }

  export type ProjectCreateWithoutSprintInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSprintInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSprintInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSprintInput, ProjectUncheckedCreateWithoutSprintInput>
  }

  export type TaskCreateWithoutSprintInput = {
    id?: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    team: TeamCreateNestedOneWithoutTasksInput
    feature?: FeatureCreateNestedOneWithoutTasksInput
    AgentTask?: AgentTaskCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutSprintInput = {
    id?: string
    projectId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutSprintInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput>
  }

  export type TaskCreateManySprintInputEnvelope = {
    data: TaskCreateManySprintInput | TaskCreateManySprintInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSprintInput = {
    update: XOR<ProjectUpdateWithoutSprintInput, ProjectUncheckedUpdateWithoutSprintInput>
    create: XOR<ProjectCreateWithoutSprintInput, ProjectUncheckedCreateWithoutSprintInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSprintInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSprintInput, ProjectUncheckedUpdateWithoutSprintInput>
  }

  export type ProjectUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutSprintInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutSprintInput, TaskUncheckedUpdateWithoutSprintInput>
    create: XOR<TaskCreateWithoutSprintInput, TaskUncheckedCreateWithoutSprintInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutSprintInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutSprintInput, TaskUncheckedUpdateWithoutSprintInput>
  }

  export type TaskUpdateManyWithWhereWithoutSprintInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutSprintInput>
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type SprintCreateWithoutTaskInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    goal: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSprintInput
  }

  export type SprintUncheckedCreateWithoutTaskInput = {
    id?: string
    projectId: string
    name: string
    startDate: Date | string
    endDate: Date | string
    goal: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SprintCreateOrConnectWithoutTaskInput = {
    where: SprintWhereUniqueInput
    create: XOR<SprintCreateWithoutTaskInput, SprintUncheckedCreateWithoutTaskInput>
  }

  export type TeamCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project?: ProjectCreateNestedOneWithoutTeamInput
    agents?: AgentCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId?: string
    agents?: AgentUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTasksInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
  }

  export type FeatureCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    milestone?: MilestoneCreateNestedOneWithoutFeaturesInput
    version?: VersionCreateNestedOneWithoutFeaturesInput
  }

  export type FeatureUncheckedCreateWithoutTasksInput = {
    id?: string
    milestoneId?: string | null
    versionId?: string | null
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureCreateOrConnectWithoutTasksInput = {
    where: FeatureWhereUniqueInput
    create: XOR<FeatureCreateWithoutTasksInput, FeatureUncheckedCreateWithoutTasksInput>
  }

  export type AgentTaskCreateWithoutTaskInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutAgentTaskInput
  }

  export type AgentTaskUncheckedCreateWithoutTaskInput = {
    id?: string
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTaskCreateOrConnectWithoutTaskInput = {
    where: AgentTaskWhereUniqueInput
    create: XOR<AgentTaskCreateWithoutTaskInput, AgentTaskUncheckedCreateWithoutTaskInput>
  }

  export type AgentTaskCreateManyTaskInputEnvelope = {
    data: AgentTaskCreateManyTaskInput | AgentTaskCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type AgentWorklogCreateWithoutTaskInput = {
    id?: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgentWorklogInput
    agent: AgentCreateNestedOneWithoutAgentWorklogInput
  }

  export type AgentWorklogUncheckedCreateWithoutTaskInput = {
    id?: string
    projectId: string
    agentId: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentWorklogCreateOrConnectWithoutTaskInput = {
    where: AgentWorklogWhereUniqueInput
    create: XOR<AgentWorklogCreateWithoutTaskInput, AgentWorklogUncheckedCreateWithoutTaskInput>
  }

  export type AgentWorklogCreateManyTaskInputEnvelope = {
    data: AgentWorklogCreateManyTaskInput | AgentWorklogCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type SprintUpsertWithoutTaskInput = {
    update: XOR<SprintUpdateWithoutTaskInput, SprintUncheckedUpdateWithoutTaskInput>
    create: XOR<SprintCreateWithoutTaskInput, SprintUncheckedCreateWithoutTaskInput>
    where?: SprintWhereInput
  }

  export type SprintUpdateToOneWithWhereWithoutTaskInput = {
    where?: SprintWhereInput
    data: XOR<SprintUpdateWithoutTaskInput, SprintUncheckedUpdateWithoutTaskInput>
  }

  export type SprintUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpsertWithoutTasksInput = {
    update: XOR<TeamUpdateWithoutTasksInput, TeamUncheckedUpdateWithoutTasksInput>
    create: XOR<TeamCreateWithoutTasksInput, TeamUncheckedCreateWithoutTasksInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTasksInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTasksInput, TeamUncheckedUpdateWithoutTasksInput>
  }

  export type TeamUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTeamNestedInput
    agents?: AgentUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    agents?: AgentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type FeatureUpsertWithoutTasksInput = {
    update: XOR<FeatureUpdateWithoutTasksInput, FeatureUncheckedUpdateWithoutTasksInput>
    create: XOR<FeatureCreateWithoutTasksInput, FeatureUncheckedCreateWithoutTasksInput>
    where?: FeatureWhereInput
  }

  export type FeatureUpdateToOneWithWhereWithoutTasksInput = {
    where?: FeatureWhereInput
    data: XOR<FeatureUpdateWithoutTasksInput, FeatureUncheckedUpdateWithoutTasksInput>
  }

  export type FeatureUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestone?: MilestoneUpdateOneWithoutFeaturesNestedInput
    version?: VersionUpdateOneWithoutFeaturesNestedInput
  }

  export type FeatureUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTaskUpsertWithWhereUniqueWithoutTaskInput = {
    where: AgentTaskWhereUniqueInput
    update: XOR<AgentTaskUpdateWithoutTaskInput, AgentTaskUncheckedUpdateWithoutTaskInput>
    create: XOR<AgentTaskCreateWithoutTaskInput, AgentTaskUncheckedCreateWithoutTaskInput>
  }

  export type AgentTaskUpdateWithWhereUniqueWithoutTaskInput = {
    where: AgentTaskWhereUniqueInput
    data: XOR<AgentTaskUpdateWithoutTaskInput, AgentTaskUncheckedUpdateWithoutTaskInput>
  }

  export type AgentTaskUpdateManyWithWhereWithoutTaskInput = {
    where: AgentTaskScalarWhereInput
    data: XOR<AgentTaskUpdateManyMutationInput, AgentTaskUncheckedUpdateManyWithoutTaskInput>
  }

  export type AgentWorklogUpsertWithWhereUniqueWithoutTaskInput = {
    where: AgentWorklogWhereUniqueInput
    update: XOR<AgentWorklogUpdateWithoutTaskInput, AgentWorklogUncheckedUpdateWithoutTaskInput>
    create: XOR<AgentWorklogCreateWithoutTaskInput, AgentWorklogUncheckedCreateWithoutTaskInput>
  }

  export type AgentWorklogUpdateWithWhereUniqueWithoutTaskInput = {
    where: AgentWorklogWhereUniqueInput
    data: XOR<AgentWorklogUpdateWithoutTaskInput, AgentWorklogUncheckedUpdateWithoutTaskInput>
  }

  export type AgentWorklogUpdateManyWithWhereWithoutTaskInput = {
    where: AgentWorklogScalarWhereInput
    data: XOR<AgentWorklogUpdateManyMutationInput, AgentWorklogUncheckedUpdateManyWithoutTaskInput>
  }

  export type ProjectCreateWithoutTeamInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTeamInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTeamInput, ProjectUncheckedCreateWithoutTeamInput>
  }

  export type TaskCreateWithoutTeamInput = {
    id?: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    sprint: SprintCreateNestedOneWithoutTaskInput
    feature?: FeatureCreateNestedOneWithoutTasksInput
    AgentTask?: AgentTaskCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutTeamInput = {
    id?: string
    projectId: string
    sprintId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutTaskInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutTeamInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput>
  }

  export type TaskCreateManyTeamInputEnvelope = {
    data: TaskCreateManyTeamInput | TaskCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type AgentCreateWithoutTeamInput = {
    id?: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutAgentInput
    AgentActivity?: AgentActivityCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutTeamInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    AgentActivity?: AgentActivityUncheckedCreateNestedManyWithoutAgentInput
    AgentTask?: AgentTaskUncheckedCreateNestedManyWithoutAgentInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutAgentInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutTeamInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutTeamInput, AgentUncheckedCreateWithoutTeamInput>
  }

  export type AgentCreateManyTeamInputEnvelope = {
    data: AgentCreateManyTeamInput | AgentCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutTeamInput = {
    update: XOR<ProjectUpdateWithoutTeamInput, ProjectUncheckedUpdateWithoutTeamInput>
    create: XOR<ProjectCreateWithoutTeamInput, ProjectUncheckedCreateWithoutTeamInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTeamInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTeamInput, ProjectUncheckedUpdateWithoutTeamInput>
  }

  export type ProjectUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TaskUpsertWithWhereUniqueWithoutTeamInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutTeamInput, TaskUncheckedUpdateWithoutTeamInput>
    create: XOR<TaskCreateWithoutTeamInput, TaskUncheckedCreateWithoutTeamInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutTeamInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutTeamInput, TaskUncheckedUpdateWithoutTeamInput>
  }

  export type TaskUpdateManyWithWhereWithoutTeamInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutTeamInput>
  }

  export type AgentUpsertWithWhereUniqueWithoutTeamInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutTeamInput, AgentUncheckedUpdateWithoutTeamInput>
    create: XOR<AgentCreateWithoutTeamInput, AgentUncheckedCreateWithoutTeamInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutTeamInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutTeamInput, AgentUncheckedUpdateWithoutTeamInput>
  }

  export type AgentUpdateManyWithWhereWithoutTeamInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutTeamInput>
  }

  export type ProjectCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectCreateManyCreatorInputEnvelope = {
    data: ProjectCreateManyCreatorInput | ProjectCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.ProjectRole
    permissions?: ProjectMemberCreatepermissionsInput | string[]
    joinedAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    role?: $Enums.ProjectRole
    permissions?: ProjectMemberCreatepermissionsInput | string[]
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateOrConnectWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberCreateManyUserInputEnvelope = {
    data: ProjectMemberCreateManyUserInput | ProjectMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DomainKnowledgeCreateWithoutUserInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDomainKnowledgeInput
    concepts?: DomainConceptCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceCreateNestedManyWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    concepts?: DomainConceptUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    patterns?: DomainPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    bestPractices?: DomainBestPracticeUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    antiPatterns?: DomainAntiPatternUncheckedCreateNestedManyWithoutDomainKnowledgeInput
    references?: DomainReferenceUncheckedCreateNestedManyWithoutDomainKnowledgeInput
  }

  export type DomainKnowledgeCreateOrConnectWithoutUserInput = {
    where: DomainKnowledgeWhereUniqueInput
    create: XOR<DomainKnowledgeCreateWithoutUserInput, DomainKnowledgeUncheckedCreateWithoutUserInput>
  }

  export type DomainKnowledgeCreateManyUserInputEnvelope = {
    data: DomainKnowledgeCreateManyUserInput | DomainKnowledgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DatabaseSchemaCreateWithoutUserInput = {
    id?: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDatabaseSchemaInput
    tables?: DatabaseTableCreateNestedManyWithoutSchemaInput
  }

  export type DatabaseSchemaUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tables?: DatabaseTableUncheckedCreateNestedManyWithoutSchemaInput
  }

  export type DatabaseSchemaCreateOrConnectWithoutUserInput = {
    where: DatabaseSchemaWhereUniqueInput
    create: XOR<DatabaseSchemaCreateWithoutUserInput, DatabaseSchemaUncheckedCreateWithoutUserInput>
  }

  export type DatabaseSchemaCreateManyUserInputEnvelope = {
    data: DatabaseSchemaCreateManyUserInput | DatabaseSchemaCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RequirementCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutRequirementInput
    parent?: RequirementCreateNestedOneWithoutChildrenInput
    children?: RequirementCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentCreateNestedManyWithoutRequirementInput
  }

  export type RequirementUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    children?: RequirementUncheckedCreateNestedManyWithoutParentInput
    questions?: RequirementQuestionUncheckedCreateNestedManyWithoutRequirementInput
    attachments?: RequirementAttachmentUncheckedCreateNestedManyWithoutRequirementInput
  }

  export type RequirementCreateOrConnectWithoutUserInput = {
    where: RequirementWhereUniqueInput
    create: XOR<RequirementCreateWithoutUserInput, RequirementUncheckedCreateWithoutUserInput>
  }

  export type RequirementCreateManyUserInputEnvelope = {
    data: RequirementCreateManyUserInput | RequirementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RequirementAttachmentCreateWithoutUserInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutRequirementAttachmentInput
    requirement: RequirementCreateNestedOneWithoutAttachmentsInput
  }

  export type RequirementAttachmentUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    requirementId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type RequirementAttachmentCreateOrConnectWithoutUserInput = {
    where: RequirementAttachmentWhereUniqueInput
    create: XOR<RequirementAttachmentCreateWithoutUserInput, RequirementAttachmentUncheckedCreateWithoutUserInput>
  }

  export type RequirementAttachmentCreateManyUserInputEnvelope = {
    data: RequirementAttachmentCreateManyUserInput | RequirementAttachmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentationCreateWithoutUserInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutDocumentationInput
    tags?: DocumentTagCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentCreateNestedManyWithoutDocumentationInput
  }

  export type DocumentationUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    tags?: DocumentTagUncheckedCreateNestedManyWithoutDocumentationsInput
    versions?: DocumentVersionUncheckedCreateNestedManyWithoutDocumentationInput
    comments?: DocumentCommentUncheckedCreateNestedManyWithoutDocumentationInput
    attachments?: DocumentAttachmentUncheckedCreateNestedManyWithoutDocumentationInput
  }

  export type DocumentationCreateOrConnectWithoutUserInput = {
    where: DocumentationWhereUniqueInput
    create: XOR<DocumentationCreateWithoutUserInput, DocumentationUncheckedCreateWithoutUserInput>
  }

  export type DocumentationCreateManyUserInputEnvelope = {
    data: DocumentationCreateManyUserInput | DocumentationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentVersionCreateWithoutUserInput = {
    id?: string
    version: string
    content: string
    changeLog: string
    createdAt?: Date | string
    documentation: DocumentationCreateNestedOneWithoutVersionsInput
  }

  export type DocumentVersionUncheckedCreateWithoutUserInput = {
    id?: string
    documentationId: string
    version: string
    content: string
    changeLog: string
    createdAt?: Date | string
  }

  export type DocumentVersionCreateOrConnectWithoutUserInput = {
    where: DocumentVersionWhereUniqueInput
    create: XOR<DocumentVersionCreateWithoutUserInput, DocumentVersionUncheckedCreateWithoutUserInput>
  }

  export type DocumentVersionCreateManyUserInputEnvelope = {
    data: DocumentVersionCreateManyUserInput | DocumentVersionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCommentCreateWithoutUserInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    documentation: DocumentationCreateNestedOneWithoutCommentsInput
    parent?: DocumentCommentCreateNestedOneWithoutRepliesInput
    replies?: DocumentCommentCreateNestedManyWithoutParentInput
  }

  export type DocumentCommentUncheckedCreateWithoutUserInput = {
    id?: string
    documentationId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: DocumentCommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DocumentCommentCreateOrConnectWithoutUserInput = {
    where: DocumentCommentWhereUniqueInput
    create: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCommentCreateManyUserInputEnvelope = {
    data: DocumentCommentCreateManyUserInput | DocumentCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DocumentAttachmentCreateWithoutUserInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    documentation: DocumentationCreateNestedOneWithoutAttachmentsInput
  }

  export type DocumentAttachmentUncheckedCreateWithoutUserInput = {
    id?: string
    documentationId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type DocumentAttachmentCreateOrConnectWithoutUserInput = {
    where: DocumentAttachmentWhereUniqueInput
    create: XOR<DocumentAttachmentCreateWithoutUserInput, DocumentAttachmentUncheckedCreateWithoutUserInput>
  }

  export type DocumentAttachmentCreateManyUserInputEnvelope = {
    data: DocumentAttachmentCreateManyUserInput | DocumentAttachmentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MindMapCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    overview: string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    project: ProjectCreateNestedOneWithoutMindMapInput
    rootNode?: MindMapNodeCreateNestedOneWithoutRootOfMapInput
    nodes?: MindMapNodeCreateNestedManyWithoutMindMapInput
  }

  export type MindMapUncheckedCreateWithoutUserInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    overview: string
    nodeId?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    nodes?: MindMapNodeUncheckedCreateNestedManyWithoutMindMapInput
  }

  export type MindMapCreateOrConnectWithoutUserInput = {
    where: MindMapWhereUniqueInput
    create: XOR<MindMapCreateWithoutUserInput, MindMapUncheckedCreateWithoutUserInput>
  }

  export type MindMapCreateManyUserInputEnvelope = {
    data: MindMapCreateManyUserInput | MindMapCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ArchitectureChangeHistoryCreateWithoutUserInput = {
    id?: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact?: string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    architecture: SystemArchitectureCreateNestedOneWithoutChangeHistoriesInput
  }

  export type ArchitectureChangeHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    architectureId: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact?: string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: Date | string
  }

  export type ArchitectureChangeHistoryCreateOrConnectWithoutUserInput = {
    where: ArchitectureChangeHistoryWhereUniqueInput
    create: XOR<ArchitectureChangeHistoryCreateWithoutUserInput, ArchitectureChangeHistoryUncheckedCreateWithoutUserInput>
  }

  export type ArchitectureChangeHistoryCreateManyUserInputEnvelope = {
    data: ArchitectureChangeHistoryCreateManyUserInput | ArchitectureChangeHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
    create: XOR<ProjectCreateWithoutCreatorInput, ProjectUncheckedCreateWithoutCreatorInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutCreatorInput, ProjectUncheckedUpdateWithoutCreatorInput>
  }

  export type ProjectUpdateManyWithWhereWithoutCreatorInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    createdBy?: StringNullableFilter<"Project"> | string | null
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
    create: XOR<ProjectMemberCreateWithoutUserInput, ProjectMemberUncheckedCreateWithoutUserInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutUserInput, ProjectMemberUncheckedUpdateWithoutUserInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutUserInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    token?: StringFilter<"Session"> | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type DomainKnowledgeUpsertWithWhereUniqueWithoutUserInput = {
    where: DomainKnowledgeWhereUniqueInput
    update: XOR<DomainKnowledgeUpdateWithoutUserInput, DomainKnowledgeUncheckedUpdateWithoutUserInput>
    create: XOR<DomainKnowledgeCreateWithoutUserInput, DomainKnowledgeUncheckedCreateWithoutUserInput>
  }

  export type DomainKnowledgeUpdateWithWhereUniqueWithoutUserInput = {
    where: DomainKnowledgeWhereUniqueInput
    data: XOR<DomainKnowledgeUpdateWithoutUserInput, DomainKnowledgeUncheckedUpdateWithoutUserInput>
  }

  export type DomainKnowledgeUpdateManyWithWhereWithoutUserInput = {
    where: DomainKnowledgeScalarWhereInput
    data: XOR<DomainKnowledgeUpdateManyMutationInput, DomainKnowledgeUncheckedUpdateManyWithoutUserInput>
  }

  export type DatabaseSchemaUpsertWithWhereUniqueWithoutUserInput = {
    where: DatabaseSchemaWhereUniqueInput
    update: XOR<DatabaseSchemaUpdateWithoutUserInput, DatabaseSchemaUncheckedUpdateWithoutUserInput>
    create: XOR<DatabaseSchemaCreateWithoutUserInput, DatabaseSchemaUncheckedCreateWithoutUserInput>
  }

  export type DatabaseSchemaUpdateWithWhereUniqueWithoutUserInput = {
    where: DatabaseSchemaWhereUniqueInput
    data: XOR<DatabaseSchemaUpdateWithoutUserInput, DatabaseSchemaUncheckedUpdateWithoutUserInput>
  }

  export type DatabaseSchemaUpdateManyWithWhereWithoutUserInput = {
    where: DatabaseSchemaScalarWhereInput
    data: XOR<DatabaseSchemaUpdateManyMutationInput, DatabaseSchemaUncheckedUpdateManyWithoutUserInput>
  }

  export type RequirementUpsertWithWhereUniqueWithoutUserInput = {
    where: RequirementWhereUniqueInput
    update: XOR<RequirementUpdateWithoutUserInput, RequirementUncheckedUpdateWithoutUserInput>
    create: XOR<RequirementCreateWithoutUserInput, RequirementUncheckedCreateWithoutUserInput>
  }

  export type RequirementUpdateWithWhereUniqueWithoutUserInput = {
    where: RequirementWhereUniqueInput
    data: XOR<RequirementUpdateWithoutUserInput, RequirementUncheckedUpdateWithoutUserInput>
  }

  export type RequirementUpdateManyWithWhereWithoutUserInput = {
    where: RequirementScalarWhereInput
    data: XOR<RequirementUpdateManyMutationInput, RequirementUncheckedUpdateManyWithoutUserInput>
  }

  export type RequirementAttachmentUpsertWithWhereUniqueWithoutUserInput = {
    where: RequirementAttachmentWhereUniqueInput
    update: XOR<RequirementAttachmentUpdateWithoutUserInput, RequirementAttachmentUncheckedUpdateWithoutUserInput>
    create: XOR<RequirementAttachmentCreateWithoutUserInput, RequirementAttachmentUncheckedCreateWithoutUserInput>
  }

  export type RequirementAttachmentUpdateWithWhereUniqueWithoutUserInput = {
    where: RequirementAttachmentWhereUniqueInput
    data: XOR<RequirementAttachmentUpdateWithoutUserInput, RequirementAttachmentUncheckedUpdateWithoutUserInput>
  }

  export type RequirementAttachmentUpdateManyWithWhereWithoutUserInput = {
    where: RequirementAttachmentScalarWhereInput
    data: XOR<RequirementAttachmentUpdateManyMutationInput, RequirementAttachmentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentationUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentationWhereUniqueInput
    update: XOR<DocumentationUpdateWithoutUserInput, DocumentationUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentationCreateWithoutUserInput, DocumentationUncheckedCreateWithoutUserInput>
  }

  export type DocumentationUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentationWhereUniqueInput
    data: XOR<DocumentationUpdateWithoutUserInput, DocumentationUncheckedUpdateWithoutUserInput>
  }

  export type DocumentationUpdateManyWithWhereWithoutUserInput = {
    where: DocumentationScalarWhereInput
    data: XOR<DocumentationUpdateManyMutationInput, DocumentationUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentVersionUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentVersionWhereUniqueInput
    update: XOR<DocumentVersionUpdateWithoutUserInput, DocumentVersionUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentVersionCreateWithoutUserInput, DocumentVersionUncheckedCreateWithoutUserInput>
  }

  export type DocumentVersionUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentVersionWhereUniqueInput
    data: XOR<DocumentVersionUpdateWithoutUserInput, DocumentVersionUncheckedUpdateWithoutUserInput>
  }

  export type DocumentVersionUpdateManyWithWhereWithoutUserInput = {
    where: DocumentVersionScalarWhereInput
    data: XOR<DocumentVersionUpdateManyMutationInput, DocumentVersionUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentCommentWhereUniqueInput
    update: XOR<DocumentCommentUpdateWithoutUserInput, DocumentCommentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCommentCreateWithoutUserInput, DocumentCommentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentCommentWhereUniqueInput
    data: XOR<DocumentCommentUpdateWithoutUserInput, DocumentCommentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentCommentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentCommentScalarWhereInput
    data: XOR<DocumentCommentUpdateManyMutationInput, DocumentCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentAttachmentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentAttachmentWhereUniqueInput
    update: XOR<DocumentAttachmentUpdateWithoutUserInput, DocumentAttachmentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentAttachmentCreateWithoutUserInput, DocumentAttachmentUncheckedCreateWithoutUserInput>
  }

  export type DocumentAttachmentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentAttachmentWhereUniqueInput
    data: XOR<DocumentAttachmentUpdateWithoutUserInput, DocumentAttachmentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentAttachmentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentAttachmentScalarWhereInput
    data: XOR<DocumentAttachmentUpdateManyMutationInput, DocumentAttachmentUncheckedUpdateManyWithoutUserInput>
  }

  export type MindMapUpsertWithWhereUniqueWithoutUserInput = {
    where: MindMapWhereUniqueInput
    update: XOR<MindMapUpdateWithoutUserInput, MindMapUncheckedUpdateWithoutUserInput>
    create: XOR<MindMapCreateWithoutUserInput, MindMapUncheckedCreateWithoutUserInput>
  }

  export type MindMapUpdateWithWhereUniqueWithoutUserInput = {
    where: MindMapWhereUniqueInput
    data: XOR<MindMapUpdateWithoutUserInput, MindMapUncheckedUpdateWithoutUserInput>
  }

  export type MindMapUpdateManyWithWhereWithoutUserInput = {
    where: MindMapScalarWhereInput
    data: XOR<MindMapUpdateManyMutationInput, MindMapUncheckedUpdateManyWithoutUserInput>
  }

  export type ArchitectureChangeHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: ArchitectureChangeHistoryWhereUniqueInput
    update: XOR<ArchitectureChangeHistoryUpdateWithoutUserInput, ArchitectureChangeHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<ArchitectureChangeHistoryCreateWithoutUserInput, ArchitectureChangeHistoryUncheckedCreateWithoutUserInput>
  }

  export type ArchitectureChangeHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: ArchitectureChangeHistoryWhereUniqueInput
    data: XOR<ArchitectureChangeHistoryUpdateWithoutUserInput, ArchitectureChangeHistoryUncheckedUpdateWithoutUserInput>
  }

  export type ArchitectureChangeHistoryUpdateManyWithWhereWithoutUserInput = {
    where: ArchitectureChangeHistoryScalarWhereInput
    data: XOR<ArchitectureChangeHistoryUpdateManyMutationInput, ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutProjectsInput
    tasks?: TaskCreateNestedManyWithoutProjectInput
    documentation?: DocumentationCreateNestedManyWithoutProjectInput
    MindMap?: MindMapCreateNestedManyWithoutProjectInput
    Sprint?: SprintCreateNestedManyWithoutProjectInput
    Requirement?: RequirementCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignCreateNestedManyWithoutProjectInput
    team?: TeamCreateNestedManyWithoutProjectInput
    Agent?: AgentCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
    documentation?: DocumentationUncheckedCreateNestedManyWithoutProjectInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutProjectInput
    Sprint?: SprintUncheckedCreateNestedManyWithoutProjectInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutProjectInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutProjectInput
    SystemArchitecture?: SystemArchitectureUncheckedCreateNestedManyWithoutProjectInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutProjectInput
    ApiDesign?: ApiDesignUncheckedCreateNestedManyWithoutProjectInput
    team?: TeamUncheckedCreateNestedManyWithoutProjectInput
    Agent?: AgentUncheckedCreateNestedManyWithoutProjectInput
    AgentWorklog?: AgentWorklogUncheckedCreateNestedManyWithoutProjectInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutProjectInput
    RequirementQuestion?: RequirementQuestionUncheckedCreateNestedManyWithoutProjectInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutProjectMembersInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProjectMembersInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProjectMembersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutProjectsNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProjectMembersInput = {
    update: XOR<UserUpdateWithoutProjectMembersInput, UserUncheckedUpdateWithoutProjectMembersInput>
    create: XOR<UserCreateWithoutProjectMembersInput, UserUncheckedCreateWithoutProjectMembersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectMembersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectMembersInput, UserUncheckedUpdateWithoutProjectMembersInput>
  }

  export type UserUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaCreateNestedManyWithoutUserInput
    Requirement?: RequirementCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentCreateNestedManyWithoutUserInput
    Documentation?: DocumentationCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentCreateNestedManyWithoutUserInput
    MindMap?: MindMapCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    username: string
    password: string
    name?: string | null
    avatar?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutCreatorInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    DomainKnowledge?: DomainKnowledgeUncheckedCreateNestedManyWithoutUserInput
    DatabaseSchema?: DatabaseSchemaUncheckedCreateNestedManyWithoutUserInput
    Requirement?: RequirementUncheckedCreateNestedManyWithoutUserInput
    RequirementAttachment?: RequirementAttachmentUncheckedCreateNestedManyWithoutUserInput
    Documentation?: DocumentationUncheckedCreateNestedManyWithoutUserInput
    DocumentVersion?: DocumentVersionUncheckedCreateNestedManyWithoutUserInput
    DocumentComment?: DocumentCommentUncheckedCreateNestedManyWithoutUserInput
    DocumentAttachment?: DocumentAttachmentUncheckedCreateNestedManyWithoutUserInput
    MindMap?: MindMapUncheckedCreateNestedManyWithoutUserInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutCreatorNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutUserNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutUserNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutUserNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutUserNestedInput
    Documentation?: DocumentationUncheckedUpdateManyWithoutUserNestedInput
    DocumentVersion?: DocumentVersionUncheckedUpdateManyWithoutUserNestedInput
    DocumentComment?: DocumentCommentUncheckedUpdateManyWithoutUserNestedInput
    DocumentAttachment?: DocumentAttachmentUncheckedUpdateManyWithoutUserNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutUserNestedInput
    ArchitectureChangeHistory?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgentActivityCreateManyAgentInput = {
    id?: string
    body: string
    action?: string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTaskCreateManyAgentInput = {
    id?: string
    taskId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentWorklogCreateManyAgentInput = {
    id?: string
    projectId: string
    taskId: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementQuestionCreateManyAgentInput = {
    id?: string
    projectId: string
    requirementId: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
  }

  export type AgentActivityUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentActivityUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentActivityUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTaskUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutAgentTaskNestedInput
  }

  export type AgentTaskUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTaskUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWorklogUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgentWorklogNestedInput
    task?: TaskUpdateOneRequiredWithoutAgentWorklogNestedInput
  }

  export type AgentWorklogUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWorklogUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementQuestionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutRequirementQuestionNestedInput
    requirement?: RequirementUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type RequirementQuestionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementQuestionUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ApiExampleCreateManyApiDesignInput = {
    id?: string
    name: string
    description: string
    requestUrl: string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus: number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    isSuccess?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiErrorCodeCreateManyApiDesignInput = {
    id?: string
    code: string
    httpStatus: number
    message: string
    description: string
    solution?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiExampleUpdateWithoutApiDesignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestUrl?: StringFieldUpdateOperationsInput | string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus?: IntFieldUpdateOperationsInput | number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiExampleUncheckedUpdateWithoutApiDesignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestUrl?: StringFieldUpdateOperationsInput | string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus?: IntFieldUpdateOperationsInput | number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiExampleUncheckedUpdateManyWithoutApiDesignInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    requestUrl?: StringFieldUpdateOperationsInput | string
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseStatus?: IntFieldUpdateOperationsInput | number
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isSuccess?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorCodeUpdateWithoutApiDesignInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    httpStatus?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorCodeUncheckedUpdateWithoutApiDesignInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    httpStatus?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiErrorCodeUncheckedUpdateManyWithoutApiDesignInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    httpStatus?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    solution?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformArchitectureCreateManySystemArchitectureInput = {
    id?: string
    platform: string
    displayName: string
    description: string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureCreatetechnologiesInput | string[]
    components?: PlatformArchitectureCreatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: string | null
    scalingStrategy?: string | null
    diagrams?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArchitectureChangeHistoryCreateManyArchitectureInput = {
    id?: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact?: string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: Date | string
    userId?: string | null
  }

  export type SystemArchitectureCreateManyPreviousVersionInput = {
    id?: string
    projectId: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PlatformArchitectureUpdateWithoutSystemArchitectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureUpdatetechnologiesInput | string[]
    components?: PlatformArchitectureUpdatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    scalingStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformArchitectureUncheckedUpdateWithoutSystemArchitectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureUpdatetechnologiesInput | string[]
    components?: PlatformArchitectureUpdatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    scalingStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformArchitectureUncheckedUpdateManyWithoutSystemArchitectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    frontend?: NullableJsonNullValueInput | InputJsonValue
    backend?: NullableJsonNullValueInput | InputJsonValue
    infrastructure?: NullableJsonNullValueInput | InputJsonValue
    technologies?: PlatformArchitectureUpdatetechnologiesInput | string[]
    components?: PlatformArchitectureUpdatecomponentsInput | string[]
    dependencies?: NullableJsonNullValueInput | InputJsonValue
    deploymentStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    scalingStrategy?: NullableStringFieldUpdateOperationsInput | string | null
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArchitectureChangeHistoryUpdateWithoutArchitectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutArchitectureChangeHistoryNestedInput
  }

  export type ArchitectureChangeHistoryUncheckedUpdateWithoutArchitectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ArchitectureChangeHistoryUncheckedUpdateManyWithoutArchitectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemArchitectureUpdateWithoutPreviousVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutSystemArchitectureNestedInput
    platformArchitectures?: PlatformArchitectureUpdateManyWithoutSystemArchitectureNestedInput
    changeHistories?: ArchitectureChangeHistoryUpdateManyWithoutArchitectureNestedInput
    nextVersions?: SystemArchitectureUpdateManyWithoutPreviousVersionNestedInput
  }

  export type SystemArchitectureUncheckedUpdateWithoutPreviousVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedUpdateManyWithoutSystemArchitectureNestedInput
    changeHistories?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutArchitectureNestedInput
    nextVersions?: SystemArchitectureUncheckedUpdateManyWithoutPreviousVersionNestedInput
  }

  export type SystemArchitectureUncheckedUpdateManyWithoutPreviousVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DatabaseTableCreateManySchemaInput = {
    id?: string
    tableName: string
    displayName: string
    description?: string | null
    engine?: string | null
    charset?: string | null
    collation?: string | null
    autoIncrement?: number | null
    comment?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseTableUpdateWithoutSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columns?: TableColumnUpdateManyWithoutTableNestedInput
    indexes?: DatabaseIndexUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUpdateManyWithoutSourceTableNestedInput
    targetRelations?: DatabaseRelationUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableUncheckedUpdateWithoutSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    columns?: TableColumnUncheckedUpdateManyWithoutTableNestedInput
    indexes?: DatabaseIndexUncheckedUpdateManyWithoutTableNestedInput
    sourceRelations?: DatabaseRelationUncheckedUpdateManyWithoutSourceTableNestedInput
    targetRelations?: DatabaseRelationUncheckedUpdateManyWithoutTargetTableNestedInput
  }

  export type DatabaseTableUncheckedUpdateManyWithoutSchemaInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    engine?: NullableStringFieldUpdateOperationsInput | string | null
    charset?: NullableStringFieldUpdateOperationsInput | string | null
    collation?: NullableStringFieldUpdateOperationsInput | string | null
    autoIncrement?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableColumnCreateManyTableInput = {
    id?: string
    columnName: string
    displayName: string
    columnType: $Enums.ColumnType
    length?: number | null
    precision?: number | null
    scale?: number | null
    isPrimaryKey?: boolean
    isNullable?: boolean
    isUnique?: boolean
    isAutoIncrement?: boolean
    defaultValue?: string | null
    comment?: string | null
    enumValues?: TableColumnCreateenumValuesInput | string[]
    isForeignKey?: boolean
    referencedTable?: string | null
    referencedColumn?: string | null
    onDelete?: string | null
    onUpdate?: string | null
    position: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseIndexCreateManyTableInput = {
    id?: string
    indexName: string
    indexType: $Enums.IndexType
    columns?: DatabaseIndexCreatecolumnsInput | string[]
    isUnique?: boolean
    comment?: string | null
    algorithm?: string | null
    lockOption?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseRelationCreateManySourceTableInput = {
    id?: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceColumns?: DatabaseRelationCreatesourceColumnsInput | string[]
    targetTableId: string
    targetColumns?: DatabaseRelationCreatetargetColumnsInput | string[]
    onDelete?: string | null
    onUpdate?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseRelationCreateManyTargetTableInput = {
    id?: string
    schemaId: string
    relationName: string
    relationType: $Enums.RelationType
    sourceTableId: string
    sourceColumns?: DatabaseRelationCreatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationCreatetargetColumnsInput | string[]
    onDelete?: string | null
    onUpdate?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TableColumnUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    columnType?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    precision?: NullableIntFieldUpdateOperationsInput | number | null
    scale?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryKey?: BoolFieldUpdateOperationsInput | boolean
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    isAutoIncrement?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    enumValues?: TableColumnUpdateenumValuesInput | string[]
    isForeignKey?: BoolFieldUpdateOperationsInput | boolean
    referencedTable?: NullableStringFieldUpdateOperationsInput | string | null
    referencedColumn?: NullableStringFieldUpdateOperationsInput | string | null
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableColumnUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    columnType?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    precision?: NullableIntFieldUpdateOperationsInput | number | null
    scale?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryKey?: BoolFieldUpdateOperationsInput | boolean
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    isAutoIncrement?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    enumValues?: TableColumnUpdateenumValuesInput | string[]
    isForeignKey?: BoolFieldUpdateOperationsInput | boolean
    referencedTable?: NullableStringFieldUpdateOperationsInput | string | null
    referencedColumn?: NullableStringFieldUpdateOperationsInput | string | null
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableColumnUncheckedUpdateManyWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    columnName?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    columnType?: EnumColumnTypeFieldUpdateOperationsInput | $Enums.ColumnType
    length?: NullableIntFieldUpdateOperationsInput | number | null
    precision?: NullableIntFieldUpdateOperationsInput | number | null
    scale?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryKey?: BoolFieldUpdateOperationsInput | boolean
    isNullable?: BoolFieldUpdateOperationsInput | boolean
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    isAutoIncrement?: BoolFieldUpdateOperationsInput | boolean
    defaultValue?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    enumValues?: TableColumnUpdateenumValuesInput | string[]
    isForeignKey?: BoolFieldUpdateOperationsInput | boolean
    referencedTable?: NullableStringFieldUpdateOperationsInput | string | null
    referencedColumn?: NullableStringFieldUpdateOperationsInput | string | null
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseIndexUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexName?: StringFieldUpdateOperationsInput | string
    indexType?: EnumIndexTypeFieldUpdateOperationsInput | $Enums.IndexType
    columns?: DatabaseIndexUpdatecolumnsInput | string[]
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    algorithm?: NullableStringFieldUpdateOperationsInput | string | null
    lockOption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseIndexUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexName?: StringFieldUpdateOperationsInput | string
    indexType?: EnumIndexTypeFieldUpdateOperationsInput | $Enums.IndexType
    columns?: DatabaseIndexUpdatecolumnsInput | string[]
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    algorithm?: NullableStringFieldUpdateOperationsInput | string | null
    lockOption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseIndexUncheckedUpdateManyWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    indexName?: StringFieldUpdateOperationsInput | string
    indexType?: EnumIndexTypeFieldUpdateOperationsInput | $Enums.IndexType
    columns?: DatabaseIndexUpdatecolumnsInput | string[]
    isUnique?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    algorithm?: NullableStringFieldUpdateOperationsInput | string | null
    lockOption?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseRelationUpdateWithoutSourceTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetTable?: DatabaseTableUpdateOneRequiredWithoutTargetRelationsNestedInput
  }

  export type DatabaseRelationUncheckedUpdateWithoutSourceTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetTableId?: StringFieldUpdateOperationsInput | string
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseRelationUncheckedUpdateManyWithoutSourceTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetTableId?: StringFieldUpdateOperationsInput | string
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseRelationUpdateWithoutTargetTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceTable?: DatabaseTableUpdateOneRequiredWithoutSourceRelationsNestedInput
  }

  export type DatabaseRelationUncheckedUpdateWithoutTargetTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceTableId?: StringFieldUpdateOperationsInput | string
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseRelationUncheckedUpdateManyWithoutTargetTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaId?: StringFieldUpdateOperationsInput | string
    relationName?: StringFieldUpdateOperationsInput | string
    relationType?: EnumRelationTypeFieldUpdateOperationsInput | $Enums.RelationType
    sourceTableId?: StringFieldUpdateOperationsInput | string
    sourceColumns?: DatabaseRelationUpdatesourceColumnsInput | string[]
    targetColumns?: DatabaseRelationUpdatetargetColumnsInput | string[]
    onDelete?: NullableStringFieldUpdateOperationsInput | string | null
    onUpdate?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionCreateManyDocumentationInput = {
    id?: string
    version: string
    content: string
    changeLog: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type DocumentCommentCreateManyDocumentationInput = {
    id?: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type DocumentAttachmentCreateManyDocumentationInput = {
    id?: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type DocumentTagUpdateWithoutDocumentationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagUncheckedUpdateWithoutDocumentationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentTagUncheckedUpdateManyWithoutDocumentationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutDocumentVersionNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentVersionUncheckedUpdateManyWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCommentUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: DocumentCommentUpdateOneWithoutRepliesNestedInput
    replies?: DocumentCommentUpdateManyWithoutParentNestedInput
    User?: UserUpdateOneWithoutDocumentCommentNestedInput
  }

  export type DocumentCommentUncheckedUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: DocumentCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DocumentCommentUncheckedUpdateManyWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentAttachmentUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutDocumentAttachmentNestedInput
  }

  export type DocumentAttachmentUncheckedUpdateWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutDocumentationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentationUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDocumentationNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentationNestedInput
    User?: UserUpdateOneWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCommentCreateManyParentInput = {
    id?: string
    documentationId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId?: string | null
  }

  export type DocumentCommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentation?: DocumentationUpdateOneRequiredWithoutCommentsNestedInput
    replies?: DocumentCommentUpdateManyWithoutParentNestedInput
    User?: UserUpdateOneWithoutDocumentCommentNestedInput
  }

  export type DocumentCommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replies?: DocumentCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DocumentCommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MindMapNodeCreateManyMindMapInput = {
    id?: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    parentId?: string | null
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MindMapNodeUpdateWithoutMindMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootOfMap?: MindMapUpdateOneWithoutRootNodeNestedInput
    parent?: MindMapNodeUpdateOneWithoutChildrenNestedInput
    children?: MindMapNodeUpdateManyWithoutParentNestedInput
  }

  export type MindMapNodeUncheckedUpdateWithoutMindMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootOfMap?: MindMapUncheckedUpdateOneWithoutRootNodeNestedInput
    children?: MindMapNodeUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MindMapNodeUncheckedUpdateManyWithoutMindMapInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MindMapNodeCreateManyParentInput = {
    id?: string
    mindMapId: string
    content: string
    note?: string | null
    nodeType?: $Enums.NodeType
    position: number
    expanded?: boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: string | null
    icon?: string | null
    priority?: number | null
    progress?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MindMapNodeUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mindMap?: MindMapUpdateOneRequiredWithoutNodesNestedInput
    rootOfMap?: MindMapUpdateOneWithoutRootNodeNestedInput
    children?: MindMapNodeUpdateManyWithoutParentNestedInput
  }

  export type MindMapNodeUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mindMapId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rootOfMap?: MindMapUncheckedUpdateOneWithoutRootNodeNestedInput
    children?: MindMapNodeUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MindMapNodeUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mindMapId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    nodeType?: EnumNodeTypeFieldUpdateOperationsInput | $Enums.NodeType
    position?: IntFieldUpdateOperationsInput | number
    expanded?: BoolFieldUpdateOperationsInput | boolean
    style?: NullableJsonNullValueInput | InputJsonValue
    link?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    progress?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainConceptCreateManyDomainKnowledgeInput = {
    id?: string
    name: string
    definition: string
    examples?: DomainConceptCreateexamplesInput | string[]
    relatedConcepts?: DomainConceptCreaterelatedConceptsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainPatternCreateManyDomainKnowledgeInput = {
    id?: string
    name: string
    description: string
    context: string
    solution: string
    consequences: string
    examples?: DomainPatternCreateexamplesInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainBestPracticeCreateManyDomainKnowledgeInput = {
    id?: string
    title: string
    description: string
    rationale: string
    implementation: string
    benefits?: DomainBestPracticeCreatebenefitsInput | string[]
    considerations?: DomainBestPracticeCreateconsiderationsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainAntiPatternCreateManyDomainKnowledgeInput = {
    id?: string
    name: string
    description: string
    symptoms?: DomainAntiPatternCreatesymptomsInput | string[]
    causes?: DomainAntiPatternCreatecausesInput | string[]
    consequences?: DomainAntiPatternCreateconsequencesInput | string[]
    refactoring: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DomainReferenceCreateManyDomainKnowledgeInput = {
    id?: string
    title: string
    type: string
    url?: string | null
    author?: string | null
    publishDate?: Date | string | null
    summary?: string | null
    createdAt?: Date | string
  }

  export type DomainConceptUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    examples?: DomainConceptUpdateexamplesInput | string[]
    relatedConcepts?: DomainConceptUpdaterelatedConceptsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainConceptUncheckedUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    examples?: DomainConceptUpdateexamplesInput | string[]
    relatedConcepts?: DomainConceptUpdaterelatedConceptsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    definition?: StringFieldUpdateOperationsInput | string
    examples?: DomainConceptUpdateexamplesInput | string[]
    relatedConcepts?: DomainConceptUpdaterelatedConceptsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainPatternUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    examples?: DomainPatternUpdateexamplesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainPatternUncheckedUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    examples?: DomainPatternUpdateexamplesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    context?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    consequences?: StringFieldUpdateOperationsInput | string
    examples?: DomainPatternUpdateexamplesInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainBestPracticeUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    implementation?: StringFieldUpdateOperationsInput | string
    benefits?: DomainBestPracticeUpdatebenefitsInput | string[]
    considerations?: DomainBestPracticeUpdateconsiderationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainBestPracticeUncheckedUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    implementation?: StringFieldUpdateOperationsInput | string
    benefits?: DomainBestPracticeUpdatebenefitsInput | string[]
    considerations?: DomainBestPracticeUpdateconsiderationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    rationale?: StringFieldUpdateOperationsInput | string
    implementation?: StringFieldUpdateOperationsInput | string
    benefits?: DomainBestPracticeUpdatebenefitsInput | string[]
    considerations?: DomainBestPracticeUpdateconsiderationsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainAntiPatternUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    symptoms?: DomainAntiPatternUpdatesymptomsInput | string[]
    causes?: DomainAntiPatternUpdatecausesInput | string[]
    consequences?: DomainAntiPatternUpdateconsequencesInput | string[]
    refactoring?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainAntiPatternUncheckedUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    symptoms?: DomainAntiPatternUpdatesymptomsInput | string[]
    causes?: DomainAntiPatternUpdatecausesInput | string[]
    consequences?: DomainAntiPatternUpdateconsequencesInput | string[]
    refactoring?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    symptoms?: DomainAntiPatternUpdatesymptomsInput | string[]
    causes?: DomainAntiPatternUpdatecausesInput | string[]
    consequences?: DomainAntiPatternUpdateconsequencesInput | string[]
    refactoring?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainReferenceUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainReferenceUncheckedUpdateWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    url?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    publishDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: string
    userId: string
    role?: $Enums.ProjectRole
    permissions?: ProjectMemberCreatepermissionsInput | string[]
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    sprintId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
  }

  export type DocumentationCreateManyProjectInput = {
    id?: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type MindMapCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    overview: string
    nodeId?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type SprintCreateManyProjectInput = {
    id?: string
    name: string
    startDate: Date | string
    endDate: Date | string
    goal: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RequirementCreateManyProjectInput = {
    id?: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type DomainKnowledgeCreateManyProjectInput = {
    id?: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type SystemArchitectureCreateManyProjectInput = {
    id?: string
    name: string
    overview: string
    version: string
    status?: $Enums.ArchitectureStatus
    platforms?: SystemArchitectureCreateplatformsInput | string[]
    components?: SystemArchitectureCreatecomponentsInput | string[]
    technologies?: SystemArchitectureCreatetechnologiesInput | string[]
    diagrams?: string | null
    notes?: string | null
    versionNumber?: number
    previousVersionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RoadmapCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiDesignCreateManyProjectInput = {
    id?: string
    apiName: string
    apiPath: string
    apiMethod: $Enums.ApiMethod
    apiVersion?: string
    platform: string
    module?: string | null
    apiDescription: string
    businessLogic?: string | null
    apiContentType?: $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignCreatepermissionsInput | string[]
    rateLimit?: number | null
    timeout?: number | null
    maxPayloadSize?: number | null
    status?: $Enums.ApiStatus
    deprecated?: boolean
    deprecationDate?: Date | string | null
    sunsetDate?: Date | string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TeamCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentCreateManyProjectInput = {
    id?: string
    teamId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentWorklogCreateManyProjectInput = {
    id?: string
    agentId: string
    taskId: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DatabaseSchemaCreateManyProjectInput = {
    id?: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type RequirementQuestionCreateManyProjectInput = {
    id?: string
    requirementId: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
  }

  export type RequirementAttachmentCreateManyProjectInput = {
    id?: string
    requirementId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sprint?: SprintUpdateOneRequiredWithoutTaskNestedInput
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    feature?: FeatureUpdateOneWithoutTasksNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentTagUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentationNestedInput
    User?: UserUpdateOneWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MindMapUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rootNode?: MindMapNodeUpdateOneWithoutRootOfMapNestedInput
    nodes?: MindMapNodeUpdateManyWithoutMindMapNestedInput
    User?: UserUpdateOneWithoutMindMapNestedInput
  }

  export type MindMapUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nodes?: MindMapNodeUncheckedUpdateManyWithoutMindMapNestedInput
  }

  export type MindMapUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SprintUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Task?: TaskUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Task?: TaskUncheckedUpdateManyWithoutSprintNestedInput
  }

  export type SprintUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    goal?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: RequirementUpdateOneWithoutChildrenNestedInput
    children?: RequirementUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUpdateManyWithoutRequirementNestedInput
    User?: UserUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RequirementUncheckedUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUncheckedUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DomainKnowledgeUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concepts?: DomainConceptUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUpdateManyWithoutDomainKnowledgeNestedInput
    User?: UserUpdateOneWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    concepts?: DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SystemArchitectureUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformArchitectures?: PlatformArchitectureUpdateManyWithoutSystemArchitectureNestedInput
    changeHistories?: ArchitectureChangeHistoryUpdateManyWithoutArchitectureNestedInput
    previousVersion?: SystemArchitectureUpdateOneWithoutNextVersionsNestedInput
    nextVersions?: SystemArchitectureUpdateManyWithoutPreviousVersionNestedInput
  }

  export type SystemArchitectureUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    previousVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    platformArchitectures?: PlatformArchitectureUncheckedUpdateManyWithoutSystemArchitectureNestedInput
    changeHistories?: ArchitectureChangeHistoryUncheckedUpdateManyWithoutArchitectureNestedInput
    nextVersions?: SystemArchitectureUncheckedUpdateManyWithoutPreviousVersionNestedInput
  }

  export type SystemArchitectureUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    overview?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: EnumArchitectureStatusFieldUpdateOperationsInput | $Enums.ArchitectureStatus
    platforms?: SystemArchitectureUpdateplatformsInput | string[]
    components?: SystemArchitectureUpdatecomponentsInput | string[]
    technologies?: SystemArchitectureUpdatetechnologiesInput | string[]
    diagrams?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    versionNumber?: IntFieldUpdateOperationsInput | number
    previousVersionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoadmapUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUpdateManyWithoutRoadmapNestedInput
    versions?: VersionUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestones?: MilestoneUncheckedUpdateManyWithoutRoadmapNestedInput
    versions?: VersionUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiDesignUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examples?: ApiExampleUpdateManyWithoutApiDesignNestedInput
    errorCodes?: ApiErrorCodeUpdateManyWithoutApiDesignNestedInput
  }

  export type ApiDesignUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    examples?: ApiExampleUncheckedUpdateManyWithoutApiDesignNestedInput
    errorCodes?: ApiErrorCodeUncheckedUpdateManyWithoutApiDesignNestedInput
  }

  export type ApiDesignUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    apiName?: StringFieldUpdateOperationsInput | string
    apiPath?: StringFieldUpdateOperationsInput | string
    apiMethod?: EnumApiMethodFieldUpdateOperationsInput | $Enums.ApiMethod
    apiVersion?: StringFieldUpdateOperationsInput | string
    platform?: StringFieldUpdateOperationsInput | string
    module?: NullableStringFieldUpdateOperationsInput | string | null
    apiDescription?: StringFieldUpdateOperationsInput | string
    businessLogic?: NullableStringFieldUpdateOperationsInput | string | null
    apiContentType?: EnumApiContentTypeFieldUpdateOperationsInput | $Enums.ApiContentType
    requestHeaders?: NullableJsonNullValueInput | InputJsonValue
    requestParams?: NullableJsonNullValueInput | InputJsonValue
    requestBody?: NullableJsonNullValueInput | InputJsonValue
    responseHeaders?: NullableJsonNullValueInput | InputJsonValue
    responseBody?: NullableJsonNullValueInput | InputJsonValue
    authentication?: EnumApiAuthTypeFieldUpdateOperationsInput | $Enums.ApiAuthType
    authDetails?: NullableJsonNullValueInput | InputJsonValue
    permissions?: ApiDesignUpdatepermissionsInput | string[]
    rateLimit?: NullableIntFieldUpdateOperationsInput | number | null
    timeout?: NullableIntFieldUpdateOperationsInput | number | null
    maxPayloadSize?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumApiStatusFieldUpdateOperationsInput | $Enums.ApiStatus
    deprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sunsetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutTeamNestedInput
    agents?: AgentUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutTeamNestedInput
    agents?: AgentUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutAgentsNestedInput
    AgentActivity?: AgentActivityUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentActivity?: AgentActivityUncheckedUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWorklogUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutAgentWorklogNestedInput
    task?: TaskUpdateOneRequiredWithoutAgentWorklogNestedInput
  }

  export type AgentWorklogUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWorklogUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DatabaseSchemaUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables?: DatabaseTableUpdateManyWithoutSchemaNestedInput
    User?: UserUpdateOneWithoutDatabaseSchemaNestedInput
  }

  export type DatabaseSchemaUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tables?: DatabaseTableUncheckedUpdateManyWithoutSchemaNestedInput
  }

  export type DatabaseSchemaUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequirementQuestionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requirement?: RequirementUpdateOneRequiredWithoutQuestionsNestedInput
    agent?: AgentUpdateOneRequiredWithoutRequirementQuestionNestedInput
  }

  export type RequirementQuestionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementQuestionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementAttachmentUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requirement?: RequirementUpdateOneRequiredWithoutAttachmentsNestedInput
    User?: UserUpdateOneWithoutRequirementAttachmentNestedInput
  }

  export type RequirementAttachmentUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequirementAttachmentUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequirementCreateManyParentInput = {
    id?: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userId?: string | null
  }

  export type RequirementQuestionCreateManyRequirementInput = {
    id?: string
    projectId: string
    question: string
    answer?: string | null
    status?: $Enums.QuestionStatus
    priority?: $Enums.QuestionPriority
    clarified?: boolean
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    answeredAt?: Date | string | null
  }

  export type RequirementAttachmentCreateManyRequirementInput = {
    id?: string
    projectId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    userId?: string | null
  }

  export type RequirementUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutRequirementNestedInput
    children?: RequirementUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUpdateManyWithoutRequirementNestedInput
    User?: UserUpdateOneWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RequirementUncheckedUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUncheckedUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequirementQuestionUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutRequirementQuestionNestedInput
    agent?: AgentUpdateOneRequiredWithoutRequirementQuestionNestedInput
  }

  export type RequirementQuestionUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementQuestionUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumQuestionStatusFieldUpdateOperationsInput | $Enums.QuestionStatus
    priority?: EnumQuestionPriorityFieldUpdateOperationsInput | $Enums.QuestionPriority
    clarified?: BoolFieldUpdateOperationsInput | boolean
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answeredAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementAttachmentUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutRequirementAttachmentNestedInput
    User?: UserUpdateOneWithoutRequirementAttachmentNestedInput
  }

  export type RequirementAttachmentUncheckedUpdateWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RequirementAttachmentUncheckedUpdateManyWithoutRequirementInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MilestoneCreateManyRoadmapInput = {
    id?: string
    name: string
    description?: string | null
    targetDate: Date | string
    status?: string
    priority?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VersionCreateManyRoadmapInput = {
    id?: string
    name: string
    description?: string | null
    releaseDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MilestoneUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: FeatureUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: FeatureUncheckedUpdateManyWithoutMilestoneNestedInput
  }

  export type MilestoneUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VersionUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: FeatureUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: FeatureUncheckedUpdateManyWithoutVersionNestedInput
  }

  export type VersionUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    releaseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateManyMilestoneInput = {
    id?: string
    versionId?: string | null
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateWithoutMilestoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: VersionUpdateOneWithoutFeaturesNestedInput
    tasks?: TaskUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutMilestoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateManyWithoutMilestoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeatureCreateManyVersionInput = {
    id?: string
    milestoneId?: string | null
    name: string
    description?: string | null
    status?: string
    priority?: string
    effort?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeatureUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    milestone?: MilestoneUpdateOneWithoutFeaturesNestedInput
    tasks?: TaskUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutFeatureNestedInput
  }

  export type FeatureUncheckedUpdateManyWithoutVersionInput = {
    id?: StringFieldUpdateOperationsInput | string
    milestoneId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    effort?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyFeatureInput = {
    id?: string
    projectId: string
    sprintId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    sprint?: SprintUpdateOneRequiredWithoutTaskNestedInput
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutFeatureInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManySprintInput = {
    id?: string
    projectId: string
    teamId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
  }

  export type TaskUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    team?: TeamUpdateOneRequiredWithoutTasksNestedInput
    feature?: FeatureUpdateOneWithoutTasksNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutSprintInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentTaskCreateManyTaskInput = {
    id?: string
    agentId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentWorklogCreateManyTaskInput = {
    id?: string
    projectId: string
    agentId: string
    workType: string
    summarize?: string | null
    nextPlan?: string | null
    content?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentTaskUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutAgentTaskNestedInput
  }

  export type AgentTaskUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentTaskUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWorklogUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgentWorklogNestedInput
    agent?: AgentUpdateOneRequiredWithoutAgentWorklogNestedInput
  }

  export type AgentWorklogUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentWorklogUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    summarize?: NullableStringFieldUpdateOperationsInput | string | null
    nextPlan?: NullableStringFieldUpdateOperationsInput | string | null
    content?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyTeamInput = {
    id?: string
    projectId: string
    sprintId: string
    title: string
    content?: string | null
    status?: string
    dueDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    featureId?: string | null
  }

  export type AgentCreateManyTeamInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    workPrompt?: string | null
    responsibilities?: AgentCreateresponsibilitiesInput | string[]
    skills?: AgentCreateskillsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    sprint?: SprintUpdateOneRequiredWithoutTaskNestedInput
    feature?: FeatureUpdateOneWithoutTasksNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutTaskNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    sprintId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    featureId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AgentUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutAgentNestedInput
    AgentActivity?: AgentActivityUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AgentActivity?: AgentActivityUncheckedUpdateManyWithoutAgentNestedInput
    AgentTask?: AgentTaskUncheckedUpdateManyWithoutAgentNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutAgentNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    responsibilities?: AgentUpdateresponsibilitiesInput | string[]
    skills?: AgentUpdateskillsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateManyUserInput = {
    id?: string
    projectId: string
    role?: $Enums.ProjectRole
    permissions?: ProjectMemberCreatepermissionsInput | string[]
    joinedAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionCreateManyUserInput = {
    id?: string
    token: string
    ipAddress?: string | null
    userAgent?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type DomainKnowledgeCreateManyUserInput = {
    id?: string
    projectId: string
    domain: string
    description: string
    category: $Enums.KnowledgeCategory
    tags?: DomainKnowledgeCreatetagsInput | string[]
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DatabaseSchemaCreateManyUserInput = {
    id?: string
    projectId: string
    schemaName: string
    engine: $Enums.DatabaseEngine
    charset?: string
    collation?: string
    description?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RequirementCreateManyUserInput = {
    id?: string
    projectId: string
    title: string
    content: string
    type: $Enums.RequirementType
    priority: $Enums.RequirementPriority
    status?: $Enums.RequirementStatus
    source: $Enums.RequirementSource
    parentId?: string | null
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RequirementAttachmentCreateManyUserInput = {
    id?: string
    projectId: string
    requirementId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type DocumentationCreateManyUserInput = {
    id?: string
    projectId: string
    title: string
    content: string
    summary?: string | null
    type?: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    visibility?: $Enums.DocumentVisibility
    category?: string | null
    url?: string | null
    version?: string
    versionNumber?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    deletedAt?: Date | string | null
  }

  export type DocumentVersionCreateManyUserInput = {
    id?: string
    documentationId: string
    version: string
    content: string
    changeLog: string
    createdAt?: Date | string
  }

  export type DocumentCommentCreateManyUserInput = {
    id?: string
    documentationId: string
    content: string
    parentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentAttachmentCreateManyUserInput = {
    id?: string
    documentationId: string
    fileName: string
    fileUrl: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type MindMapCreateManyUserInput = {
    id?: string
    projectId: string
    title: string
    description?: string | null
    overview: string
    nodeId?: string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: string
    version?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ArchitectureChangeHistoryCreateManyUserInput = {
    id?: string
    architectureId: string
    changeType: string
    changeDescription: string
    changeReason: string
    impact?: string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: Date | string
  }

  export type ProjectUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
    tasks?: TaskUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUpdateManyWithoutProjectNestedInput
    team?: TeamUpdateManyWithoutProjectNestedInput
    Agent?: AgentUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
    documentation?: DocumentationUncheckedUpdateManyWithoutProjectNestedInput
    MindMap?: MindMapUncheckedUpdateManyWithoutProjectNestedInput
    Sprint?: SprintUncheckedUpdateManyWithoutProjectNestedInput
    Requirement?: RequirementUncheckedUpdateManyWithoutProjectNestedInput
    DomainKnowledge?: DomainKnowledgeUncheckedUpdateManyWithoutProjectNestedInput
    SystemArchitecture?: SystemArchitectureUncheckedUpdateManyWithoutProjectNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutProjectNestedInput
    ApiDesign?: ApiDesignUncheckedUpdateManyWithoutProjectNestedInput
    team?: TeamUncheckedUpdateManyWithoutProjectNestedInput
    Agent?: AgentUncheckedUpdateManyWithoutProjectNestedInput
    AgentWorklog?: AgentWorklogUncheckedUpdateManyWithoutProjectNestedInput
    DatabaseSchema?: DatabaseSchemaUncheckedUpdateManyWithoutProjectNestedInput
    RequirementQuestion?: RequirementQuestionUncheckedUpdateManyWithoutProjectNestedInput
    RequirementAttachment?: RequirementAttachmentUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    role?: EnumProjectRoleFieldUpdateOperationsInput | $Enums.ProjectRole
    permissions?: ProjectMemberUpdatepermissionsInput | string[]
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DomainKnowledgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDomainKnowledgeNestedInput
    concepts?: DomainConceptUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUpdateManyWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    concepts?: DomainConceptUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    patterns?: DomainPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    bestPractices?: DomainBestPracticeUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    antiPatterns?: DomainAntiPatternUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
    references?: DomainReferenceUncheckedUpdateManyWithoutDomainKnowledgeNestedInput
  }

  export type DomainKnowledgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumKnowledgeCategoryFieldUpdateOperationsInput | $Enums.KnowledgeCategory
    tags?: DomainKnowledgeUpdatetagsInput | string[]
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DatabaseSchemaUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDatabaseSchemaNestedInput
    tables?: DatabaseTableUpdateManyWithoutSchemaNestedInput
  }

  export type DatabaseSchemaUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tables?: DatabaseTableUncheckedUpdateManyWithoutSchemaNestedInput
  }

  export type DatabaseSchemaUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    schemaName?: StringFieldUpdateOperationsInput | string
    engine?: EnumDatabaseEngineFieldUpdateOperationsInput | $Enums.DatabaseEngine
    charset?: StringFieldUpdateOperationsInput | string
    collation?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutRequirementNestedInput
    parent?: RequirementUpdateOneWithoutChildrenNestedInput
    children?: RequirementUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: RequirementUncheckedUpdateManyWithoutParentNestedInput
    questions?: RequirementQuestionUncheckedUpdateManyWithoutRequirementNestedInput
    attachments?: RequirementAttachmentUncheckedUpdateManyWithoutRequirementNestedInput
  }

  export type RequirementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumRequirementTypeFieldUpdateOperationsInput | $Enums.RequirementType
    priority?: EnumRequirementPriorityFieldUpdateOperationsInput | $Enums.RequirementPriority
    status?: EnumRequirementStatusFieldUpdateOperationsInput | $Enums.RequirementStatus
    source?: EnumRequirementSourceFieldUpdateOperationsInput | $Enums.RequirementSource
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RequirementAttachmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutRequirementAttachmentNestedInput
    requirement?: RequirementUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type RequirementAttachmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RequirementAttachmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    requirementId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutDocumentationNestedInput
    tags?: DocumentTagUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUpdateManyWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tags?: DocumentTagUncheckedUpdateManyWithoutDocumentationsNestedInput
    versions?: DocumentVersionUncheckedUpdateManyWithoutDocumentationNestedInput
    comments?: DocumentCommentUncheckedUpdateManyWithoutDocumentationNestedInput
    attachments?: DocumentAttachmentUncheckedUpdateManyWithoutDocumentationNestedInput
  }

  export type DocumentationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    visibility?: EnumDocumentVisibilityFieldUpdateOperationsInput | $Enums.DocumentVisibility
    category?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentVersionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentation?: DocumentationUpdateOneRequiredWithoutVersionsNestedInput
  }

  export type DocumentVersionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentVersionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    changeLog?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentation?: DocumentationUpdateOneRequiredWithoutCommentsNestedInput
    parent?: DocumentCommentUpdateOneWithoutRepliesNestedInput
    replies?: DocumentCommentUpdateManyWithoutParentNestedInput
  }

  export type DocumentCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: DocumentCommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DocumentCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAttachmentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documentation?: DocumentationUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type DocumentAttachmentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentAttachmentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentationId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MindMapUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutMindMapNestedInput
    rootNode?: MindMapNodeUpdateOneWithoutRootOfMapNestedInput
    nodes?: MindMapNodeUpdateManyWithoutMindMapNestedInput
  }

  export type MindMapUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nodes?: MindMapNodeUncheckedUpdateManyWithoutMindMapNestedInput
  }

  export type MindMapUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: StringFieldUpdateOperationsInput | string
    nodeId?: NullableStringFieldUpdateOperationsInput | string | null
    theme?: NullableJsonNullValueInput | InputJsonValue
    layout?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ArchitectureChangeHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    architecture?: SystemArchitectureUpdateOneRequiredWithoutChangeHistoriesNestedInput
  }

  export type ArchitectureChangeHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    architectureId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArchitectureChangeHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    architectureId?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    changeDescription?: StringFieldUpdateOperationsInput | string
    changeReason?: StringFieldUpdateOperationsInput | string
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    beforeChange?: NullableJsonNullValueInput | InputJsonValue
    afterChange?: NullableJsonNullValueInput | InputJsonValue
    changedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}